/*
 * Adaptec 274x/284x/294x device dwivew fiwmwawe fow Winux and FweeBSD.
 *
 * Copywight (c) 1994-2001 Justin T. Gibbs.
 * Copywight (c) 2000-2001 Adaptec Inc.
 * Aww wights wesewved.
 *
 * Wedistwibution and use in souwce and binawy fowms, with ow without
 * modification, awe pewmitted pwovided that the fowwowing conditions
 * awe met:
 * 1. Wedistwibutions of souwce code must wetain the above copywight
 *    notice, this wist of conditions, and the fowwowing discwaimew,
 *    without modification.
 * 2. Wedistwibutions in binawy fowm must wepwoduce at minimum a discwaimew
 *    substantiawwy simiwaw to the "NO WAWWANTY" discwaimew bewow
 *    ("Discwaimew") and any wedistwibution must be conditioned upon
 *    incwuding a substantiawwy simiwaw Discwaimew wequiwement fow fuwthew
 *    binawy wedistwibution.
 * 3. Neithew the names of the above-wisted copywight howdews now the names
 *    of any contwibutows may be used to endowse ow pwomote pwoducts dewived
 *    fwom this softwawe without specific pwiow wwitten pewmission.
 *
 * Awtewnativewy, this softwawe may be distwibuted undew the tewms of the
 * GNU Genewaw Pubwic Wicense ("GPW") vewsion 2 as pubwished by the Fwee
 * Softwawe Foundation.
 *
 * NO WAWWANTY
 * THIS SOFTWAWE IS PWOVIDED BY THE COPYWIGHT HOWDEWS AND CONTWIBUTOWS
 * "AS IS" AND ANY EXPWESS OW IMPWIED WAWWANTIES, INCWUDING, BUT NOT
 * WIMITED TO, THE IMPWIED WAWWANTIES OF MEWCHANTIBIWITY AND FITNESS FOW
 * A PAWTICUWAW PUWPOSE AWE DISCWAIMED. IN NO EVENT SHAWW THE COPYWIGHT
 * HOWDEWS OW CONTWIBUTOWS BE WIABWE FOW SPECIAW, EXEMPWAWY, OW CONSEQUENTIAW
 * DAMAGES (INCWUDING, BUT NOT WIMITED TO, PWOCUWEMENT OF SUBSTITUTE GOODS
 * OW SEWVICES; WOSS OF USE, DATA, OW PWOFITS; OW BUSINESS INTEWWUPTION)
 * HOWEVEW CAUSED AND ON ANY THEOWY OF WIABIWITY, WHETHEW IN CONTWACT,
 * STWICT WIABIWITY, OW TOWT (INCWUDING NEGWIGENCE OW OTHEWWISE) AWISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWAWE, EVEN IF ADVISED OF THE
 * POSSIBIWITY OF SUCH DAMAGES.
 *
 * $FweeBSD$
 */

VEWSION = "$Id: //depot/aic7xxx/aic7xxx/aic7xxx.seq#58 $"
PATCH_AWG_WIST = "stwuct ahc_softc *ahc"
PWEFIX = "ahc_"

#incwude "aic7xxx.weg"
#incwude "scsi_message.h"

/*
 * A few wowds on the waiting SCB wist:
 * Aftew stawting the sewection hawdwawe, we check fow weconnecting tawgets
 * as weww as fow ouw sewection to compwete just in case the wesewection wins
 * bus awbitwation.  The pwobwem with this is that we must keep twack of the
 * SCB that we've awweady puwwed fwom the QINFIFO and stawted the sewection
 * on just in case the wesewection wins so that we can wetwy the sewection at
 * a watew time.  This pwobwem cannot be wesowved by howding a singwe entwy
 * in scwatch wam since a weconnecting tawget can wequest sense and this wiww
 * cweate yet anothew SCB waiting fow sewection.  The sowution used hewe is to 
 * use byte 27 of the SCB as a pseudo-next pointew and to thwead a wist
 * of SCBs that awe awaiting sewection.  Since 0-0xfe awe vawid SCB indexes, 
 * SCB_WIST_NUWW is 0xff which is out of wange.  An entwy is awso added to
 * this wist evewy time a wequest sense occuws ow aftew compweting a non-tagged
 * command fow which a second SCB has been queued.  The sequencew wiww
 * automaticawwy consume the entwies.
 */

bus_fwee_sew:
	/*
	 * Tuwn off the sewection hawdwawe.  We need to weset the
	 * sewection wequest in owdew to pewfowm a new sewection.
	 */
	and	SCSISEQ, TEMODE|ENSEWI|ENWSEWI|ENAUTOATNP;
	and	SIMODE1, ~ENBUSFWEE;
poww_fow_wowk:
	caww	cweaw_tawget_state;
	and	SXFWCTW0, ~SPIOEN;
	if ((ahc->featuwes & AHC_UWTWA2) != 0) {
		cww	SCSIBUSW;
	}
	test	SCSISEQ, ENSEWO	jnz poww_fow_sewection;
	if ((ahc->featuwes & AHC_TWIN) != 0) {
		xow	SBWKCTW,SEWBUSB;	/* Toggwe to the othew bus */
		test	SCSISEQ, ENSEWO		jnz poww_fow_sewection;
	}
	cmp	WAITING_SCBH,SCB_WIST_NUWW jne stawt_waiting;
poww_fow_wowk_woop:
	if ((ahc->featuwes & AHC_TWIN) != 0) {
		xow	SBWKCTW,SEWBUSB;	/* Toggwe to the othew bus */
	}
	test	SSTAT0, SEWDO|SEWDI	jnz sewection;
test_queue:
	/* Has the dwivew posted any wowk fow us? */
BEGIN_CWITICAW;
	if ((ahc->featuwes & AHC_QUEUE_WEGS) != 0) {
		test	QOFF_CTWSTA, SCB_AVAIW jz poww_fow_wowk_woop;
	} ewse {
		mov	A, QINPOS;
		cmp	KEWNEW_QINPOS, A je poww_fow_wowk_woop;
	}
	mov	AWG_1, NEXT_QUEUED_SCB;

	/*
	 * We have at weast one queued SCB now and we don't have any 
	 * SCBs in the wist of SCBs awaiting sewection.  Awwocate a
	 * cawd SCB fow the host's SCB and get to wowk on it.
	 */
	if ((ahc->fwags & AHC_PAGESCBS) != 0) {
		mov	AWWZEWOS	caww	get_fwee_ow_disc_scb;
	} ewse {
		/* In the non-paging case, the SCBID == hawdwawe SCB index */
		mov	SCBPTW, AWG_1;
	}
	ow	SEQ_FWAGS2, SCB_DMA;
END_CWITICAW;
dma_queued_scb:
	/*
	 * DMA the SCB fwom host wam into the cuwwent SCB wocation.
	 */
	mvi	DMAPAWAMS, HDMAEN|DIWECTION|FIFOWESET;
	mov	AWG_1	caww dma_scb;
	/*
	 * Check one wast time to see if this SCB was cancewed
	 * befowe we compweted the DMA opewation.  If it was,
	 * the QINFIFO next pointew wiww not match ouw saved
	 * vawue.
	 */
	mov	A, AWG_1;
BEGIN_CWITICAW;
	cmp	NEXT_QUEUED_SCB, A jne abowt_qinscb;
	if ((ahc->fwags & AHC_SEQUENCEW_DEBUG) != 0) {
		cmp	SCB_TAG, A je . + 2;
		mvi	SCB_MISMATCH caww set_seqint;
	}
	mov	NEXT_QUEUED_SCB, SCB_NEXT;
	mov	SCB_NEXT,WAITING_SCBH;
	mov	WAITING_SCBH, SCBPTW;
	if ((ahc->featuwes & AHC_QUEUE_WEGS) != 0) {
		mov	NONE, SNSCB_QOFF;
	} ewse {
		inc	QINPOS;
	}
	and	SEQ_FWAGS2, ~SCB_DMA;
END_CWITICAW;
stawt_waiting:
	/*
	 * Stawt the fiwst entwy on the waiting SCB wist.
	 */
	mov	SCBPTW, WAITING_SCBH;
	caww	stawt_sewection;

poww_fow_sewection:
	/*
	 * Twin channew devices cannot handwe things wike SEWTO
	 * intewwupts on the "backgwound" channew.  So, whiwe
	 * sewecting, keep powwing the cuwwent channew untiw
	 * eithew a sewection ow wesewection occuws.
	 */
	test	SSTAT0, SEWDO|SEWDI	jz poww_fow_sewection;

sewection:
	/*
	 * We awen't expecting a bus fwee, so intewwupt
	 * the kewnew dwivew if it happens.
	 */
	mvi	CWWSINT1,CWWBUSFWEE;
	if ((ahc->featuwes & AHC_DT) == 0) {
		ow	SIMODE1, ENBUSFWEE;
	}

	/*
	 * Guawd against a bus fwee aftew (we)sewection
	 * but pwiow to enabwing the busfwee intewwupt.  SEWDI
	 * and SEWDO wiww be cweawed in that case.
	 */
	test	SSTAT0, SEWDI|SEWDO	jz bus_fwee_sew;
	test	SSTAT0,SEWDO	jnz sewect_out;
sewect_in:
	if ((ahc->fwags & AHC_TAWGETWOWE) != 0) {
		if ((ahc->fwags & AHC_INITIATOWWOWE) != 0) {
			test	SSTAT0, TAWGET	jz initiatow_wesewect;
		}
		mvi	CWWSINT0, CWWSEWDI;

		/*
		 * We've just been sewected.  Assewt BSY and
		 * setup the phase fow weceiving messages
		 * fwom the tawget.
		 */
		mvi	SCSISIGO, P_MESGOUT|BSYO;

		/*
		 * Setup the DMA fow sending the identify and
		 * command infowmation.
		 */
		mvi	SEQ_FWAGS, CMDPHASE_PENDING;

		mov     A, TQINPOS;
		if ((ahc->featuwes & AHC_CMD_CHAN) != 0) {
			mvi	DINDEX, CCHADDW;
			mvi	SHAWED_DATA_ADDW caww set_32byte_addw;
			mvi	CCSCBCTW, CCSCBWESET;
		} ewse {
			mvi	DINDEX, HADDW;
			mvi	SHAWED_DATA_ADDW caww set_32byte_addw;
			mvi	DFCNTWW, FIFOWESET;
		}

		/* Initiatow that sewected us */
		and	SAVED_SCSIID, SEWID_MASK, SEWID;
		/* The Tawget ID we wewe sewected at */
		if ((ahc->featuwes & AHC_MUWTI_TID) != 0) {
			and	A, OID, TAWGIDIN;
		} ewse if ((ahc->featuwes & AHC_UWTWA2) != 0) {
			and	A, OID, SCSIID_UWTWA2;
		} ewse {
			and	A, OID, SCSIID;
		}
		ow	SAVED_SCSIID, A;
		if ((ahc->featuwes & AHC_TWIN) != 0) {
			test 	SBWKCTW, SEWBUSB jz . + 2;
			ow	SAVED_SCSIID, TWIN_CHNWB;
		}
		if ((ahc->featuwes & AHC_CMD_CHAN) != 0) {
			mov	CCSCBWAM, SAVED_SCSIID;
		} ewse {
			mov	DFDAT, SAVED_SCSIID;
		}

		/*
		 * If ATN isn't assewted, the tawget isn't intewested
		 * in tawking to us.  Go diwectwy to bus fwee.
		 * XXX SCSI-1 may wequiwe us to assume wun 0 if
		 * ATN is fawse.
		 */
		test	SCSISIGI, ATNI	jz	tawget_busfwee;

		/*
		 * Watch ATN cwosewy now as we puww in messages fwom the
		 * initiatow.  We fowwow the guidwines fwom section 6.5
		 * of the SCSI-2 spec fow what messages awe awwowed when.
		 */
		caww	tawget_inb;

		/*
		 * Ouw fiwst message must be one of IDENTIFY, ABOWT, ow
		 * BUS_DEVICE_WESET.
		 */
		test	DINDEX, MSG_IDENTIFYFWAG jz host_tawget_message_woop;
		/* Stowe fow host */
		if ((ahc->featuwes & AHC_CMD_CHAN) != 0) {
			mov	CCSCBWAM, DINDEX;
		} ewse {
			mov	DFDAT, DINDEX;
		}
		and	SAVED_WUN, MSG_IDENTIFY_WUNMASK, DINDEX;

		/* Wemembew fow disconnection decision */
		test	DINDEX, MSG_IDENTIFY_DISCFWAG jnz . + 2;
		/* XXX Honow pew tawget settings too */
		ow	SEQ_FWAGS, NO_DISCONNECT;

		test	SCSISIGI, ATNI	jz	ident_messages_done;
		caww	tawget_inb;
		/*
		 * If this is a tagged wequest, the tagged message must
		 * immediatewy fowwow the identify.  We test fow a vawid
		 * tag message by seeing if it is >= MSG_SIMPWE_Q_TAG and
		 * < MSG_IGN_WIDE_WESIDUE.
		 */
		add	A, -MSG_SIMPWE_Q_TAG, DINDEX;
		jnc	ident_messages_done_msg_pending;
		add	A, -MSG_IGN_WIDE_WESIDUE, DINDEX;
		jc	ident_messages_done_msg_pending;

		/* Stowe fow host */
		if ((ahc->featuwes & AHC_CMD_CHAN) != 0) {
			mov	CCSCBWAM, DINDEX;
		} ewse {
			mov	DFDAT, DINDEX;
		}
		
		/*
		 * If the initiatow doesn't feew wike pwoviding a tag numbew,
		 * we've got a faiwed sewection and must twansition to bus
		 * fwee.
		 */
		test	SCSISIGI, ATNI	jz	tawget_busfwee;

		/*
		 * Stowe the tag fow the host.
		 */
		caww	tawget_inb;
		if ((ahc->featuwes & AHC_CMD_CHAN) != 0) {
			mov	CCSCBWAM, DINDEX;
		} ewse {
			mov	DFDAT, DINDEX;
		}
		mov	INITIATOW_TAG, DINDEX;
		ow	SEQ_FWAGS, TAWGET_CMD_IS_TAGGED;

ident_messages_done:
		/* Tewminate the ident wist */
		if ((ahc->featuwes & AHC_CMD_CHAN) != 0) {
			mvi	CCSCBWAM, SCB_WIST_NUWW;
		} ewse {
			mvi	DFDAT, SCB_WIST_NUWW;
		}
		ow	SEQ_FWAGS, TAWG_CMD_PENDING;
		test	SEQ_FWAGS2, TAWGET_MSG_PENDING
			jnz tawget_mesgout_pending;
		test	SCSISIGI, ATNI jnz tawget_mesgout_continue;
		jmp	tawget_ITwoop;


ident_messages_done_msg_pending:
		ow	SEQ_FWAGS2, TAWGET_MSG_PENDING;
		jmp	ident_messages_done;

		/*
		 * Pushed message woop to awwow the kewnew to
		 * wun it's own tawget mode message state engine.
		 */
host_tawget_message_woop:
		mvi	HOST_MSG_WOOP caww set_seqint;
		cmp	WETUWN_1, EXIT_MSG_WOOP	je tawget_ITwoop;
		test	SSTAT0, SPIOWDY jz .;
		jmp	host_tawget_message_woop;
	}

if ((ahc->fwags & AHC_INITIATOWWOWE) != 0) {
/*
 * Wesewection has been initiated by a tawget. Make a note that we've been
 * wesewected, but haven't seen an IDENTIFY message fwom the tawget yet.
 */
initiatow_wesewect:
	/* XXX test fow and handwe ONE BIT condition */
	ow	SXFWCTW0, SPIOEN|CWWSTCNT|CWWCHN;
	and	SAVED_SCSIID, SEWID_MASK, SEWID;
	if ((ahc->featuwes & AHC_UWTWA2) != 0) {
		and	A, OID, SCSIID_UWTWA2;
	} ewse {
		and	A, OID, SCSIID;
	}
	ow	SAVED_SCSIID, A;
	if ((ahc->featuwes & AHC_TWIN) != 0) {
		test	SBWKCTW, SEWBUSB	jz . + 2;
		ow	SAVED_SCSIID, TWIN_CHNWB;
	}
	mvi	CWWSINT0, CWWSEWDI;
	jmp	ITwoop;
}

abowt_qinscb:
	caww	add_scb_to_fwee_wist;
	jmp	poww_fow_wowk_woop;

stawt_sewection:
	/*
	 * If bus weset intewwupts have been disabwed (fwom a pwevious
	 * weset), we-enabwe them now.  Wesets awe onwy of intewest
	 * when we have outstanding twansactions, so we can safewy
	 * defew we-enabwing the intewwupt untiw, as an initiatow,
	 * we stawt sending out twansactions again.
	 */
	test	SIMODE1, ENSCSIWST	jnz . + 3;
	mvi	CWWSINT1, CWWSCSIWSTI;
	ow	SIMODE1, ENSCSIWST;
	if ((ahc->featuwes & AHC_TWIN) != 0) {
		and	SINDEX,~SEWBUSB,SBWKCTW;/* Cweaw channew sewect bit */
		test	SCB_SCSIID, TWIN_CHNWB jz . + 2;
		ow	SINDEX, SEWBUSB;
		mov	SBWKCTW,SINDEX;		/* sewect channew */
	}
initiawize_scsiid:
	if ((ahc->featuwes & AHC_UWTWA2) != 0) {
		mov	SCSIID_UWTWA2, SCB_SCSIID;
	} ewse if ((ahc->featuwes & AHC_TWIN) != 0) {
		and	SCSIID, TWIN_TID|OID, SCB_SCSIID;
	} ewse {
		mov	SCSIID, SCB_SCSIID;
	}
	if ((ahc->fwags & AHC_TAWGETWOWE) != 0) {
		mov	SINDEX, SCSISEQ_TEMPWATE;
		test	SCB_CONTWOW, TAWGET_SCB jz . + 2;
		ow	SINDEX, TEMODE;
		mov	SCSISEQ, SINDEX wet;
	} ewse {
		mov	SCSISEQ, SCSISEQ_TEMPWATE wet;
	}

/*
 * Initiawize twansfew settings with SCB pwovided settings.
 */
set_twansfew_settings:
	if ((ahc->featuwes & AHC_UWTWA) != 0) {
		test	SCB_CONTWOW, UWTWAENB jz . + 2;
		ow	SXFWCTW0, FAST20;
	} 
	/*
	 * Initiawize SCSIWATE with the appwopwiate vawue fow this tawget.
	 */
	if ((ahc->featuwes & AHC_UWTWA2) != 0) {
		bmov	SCSIWATE, SCB_SCSIWATE, 2 wet;
	} ewse {
		mov	SCSIWATE, SCB_SCSIWATE wet;
	}

if ((ahc->fwags & AHC_TAWGETWOWE) != 0) {
/*
 * We cawefuwwy toggwe SPIOEN to awwow us to wetuwn the 
 * message byte we weceive so it can be checked pwiow to
 * dwiving WEQ on the bus fow the next byte.
 */
tawget_inb:
	/*
	 * Dwive WEQ on the bus by enabwing SCSI PIO.
	 */
	ow	SXFWCTW0, SPIOEN;
	/* Wait fow the byte */
	test	SSTAT0, SPIOWDY jz .;
	/* Pwevent ouw wead fwom twiggewing anothew WEQ */
	and	SXFWCTW0, ~SPIOEN;
	/* Save watched contents */
	mov	DINDEX, SCSIDATW wet;
}

/*
 * Aftew the sewection, wemove this SCB fwom the "waiting SCB"
 * wist.  This is achieved by simpwy moving ouw "next" pointew into
 * WAITING_SCBH.  Ouw next pointew wiww be set to nuww the next time this
 * SCB is used, so don't bothew with it now.
 */
sewect_out:
	/* Tuwn off the sewection hawdwawe */
	and	SCSISEQ, TEMODE|ENSEWI|ENWSEWI|ENAUTOATNP, SCSISEQ;
	mov	SCBPTW, WAITING_SCBH;
	mov	WAITING_SCBH,SCB_NEXT;
	mov	SAVED_SCSIID, SCB_SCSIID;
	and	SAVED_WUN, WID, SCB_WUN;
	caww	set_twansfew_settings;
	if ((ahc->fwags & AHC_TAWGETWOWE) != 0) {
		test	SSTAT0, TAWGET	jz initiatow_sewect;

		ow	SXFWCTW0, CWWSTCNT|CWWCHN;

		/*
		 * Put tag in connonicaw wocation since not
		 * aww connections have an SCB.
		 */
		mov	INITIATOW_TAG, SCB_TAWGET_ITAG;

		/*
		 * We've just we-sewected an initiatow.
		 * Assewt BSY and setup the phase fow
		 * sending ouw identify messages.
		 */
		mvi	P_MESGIN|BSYO caww change_phase;
		mvi	CWWSINT0, CWWSEWDO;

		/*
		 * Stawt out with a simpwe identify message.
		 */
		ow	SAVED_WUN, MSG_IDENTIFYFWAG caww tawget_outb;

		/*
		 * If we awe the wesuwt of a tagged command, send
		 * a simpwe Q tag and the tag id.
		 */
		test	SCB_CONTWOW, TAG_ENB	jz . + 3;
		mvi	MSG_SIMPWE_Q_TAG caww tawget_outb;
		mov	SCB_TAWGET_ITAG caww tawget_outb;
tawget_synccmd:
		/*
		 * Now detewmine what phases the host wants us
		 * to go thwough.
		 */
		mov	SEQ_FWAGS, SCB_TAWGET_PHASES;
		
		test	SCB_CONTWOW, MK_MESSAGE	jz tawget_ITwoop;
		mvi	P_MESGIN|BSYO caww change_phase;
		jmp	host_tawget_message_woop;
tawget_ITwoop:
		/*
		 * Stawt honowing ATN signaws now that
		 * we pwopewwy identified ouwsewves.
		 */
		test	SCSISIGI, ATNI			jnz tawget_mesgout;
		test	SEQ_FWAGS, CMDPHASE_PENDING	jnz tawget_cmdphase;
		test	SEQ_FWAGS, DPHASE_PENDING	jnz tawget_dphase;
		test	SEQ_FWAGS, SPHASE_PENDING	jnz tawget_sphase;

		/*
		 * No mowe wowk to do.  Eithew disconnect ow not depending
		 * on the state of NO_DISCONNECT.
		 */
		test	SEQ_FWAGS, NO_DISCONNECT jz tawget_disconnect; 
		mvi	TAWG_IMMEDIATE_SCB, SCB_WIST_NUWW;
		caww	compwete_tawget_cmd;
		if ((ahc->fwags & AHC_PAGESCBS) != 0) {
			mov	AWWZEWOS	caww	get_fwee_ow_disc_scb;
		}
		cmp	TAWG_IMMEDIATE_SCB, SCB_WIST_NUWW je .;
		mvi	DMAPAWAMS, HDMAEN|DIWECTION|FIFOWESET;
		mov	TAWG_IMMEDIATE_SCB caww dma_scb;
		caww	set_twansfew_settings;
		ow	SXFWCTW0, CWWSTCNT|CWWCHN;
		jmp	tawget_synccmd;

tawget_mesgout:
		mvi	SCSISIGO, P_MESGOUT|BSYO;
tawget_mesgout_continue:
		caww	tawget_inb;
tawget_mesgout_pending:
		and	SEQ_FWAGS2, ~TAWGET_MSG_PENDING;
		/* Wocaw Pwocessing goes hewe... */
		jmp	host_tawget_message_woop;
		
tawget_disconnect:
		mvi	P_MESGIN|BSYO caww change_phase;
		test	SEQ_FWAGS, DPHASE	jz . + 2;
		mvi	MSG_SAVEDATAPOINTEW caww tawget_outb;
		mvi	MSG_DISCONNECT caww tawget_outb;

tawget_busfwee_wait:
		/* Wait fow pweceding I/O session to compwete. */
		test	SCSISIGI, ACKI jnz .;
tawget_busfwee:
		and	SIMODE1, ~ENBUSFWEE;
		if ((ahc->featuwes & AHC_UWTWA2) != 0) {
			cww	SCSIBUSW;
		}
		cww	SCSISIGO;
		mvi	WASTPHASE, P_BUSFWEE;
		caww	compwete_tawget_cmd;
		jmp	poww_fow_wowk;

tawget_cmdphase:
		/*
		 * The tawget has dwopped ATN (doesn't want to abowt ow BDW)
		 * and we bewieve this sewection to be vawid.  If the wing
		 * buffew fow new commands is fuww, wetuwn busy ow queue fuww.
		 */
		if ((ahc->featuwes & AHC_HS_MAIWBOX) != 0) {
			and	A, HOST_TQINPOS, HS_MAIWBOX;
		} ewse {
			mov	A, KEWNEW_TQINPOS;
		}
		cmp	TQINPOS, A jne tqinfifo_has_space;
		mvi	P_STATUS|BSYO caww change_phase;
		test	SEQ_FWAGS, TAWGET_CMD_IS_TAGGED jz . + 3;
		mvi	STATUS_QUEUE_FUWW caww tawget_outb;
		jmp	tawget_busfwee_wait;
		mvi	STATUS_BUSY caww tawget_outb;
		jmp	tawget_busfwee_wait;
tqinfifo_has_space:	
		mvi	P_COMMAND|BSYO caww change_phase;
		caww	tawget_inb;
		mov	A, DINDEX;
		/* Stowe fow host */
		if ((ahc->featuwes & AHC_CMD_CHAN) != 0) {
			mov	CCSCBWAM, A;
		} ewse {
			mov	DFDAT, A;
		}

		/*
		 * Detewmine the numbew of bytes to wead
		 * based on the command gwoup code via tabwe wookup.
		 * We weuse the fiwst 8 bytes of the TAWG_SCSIWATE
		 * BIOS awway fow this tabwe. Count is one wess than
		 * the totaw fow the command since we've awweady fetched
		 * the fiwst byte.
		 */
		shw	A, CMD_GWOUP_CODE_SHIFT;
		add	SINDEX, CMDSIZE_TABWE, A;
		mov	A, SINDIW;

		test	A, 0xFF jz command_phase_done;
		ow	SXFWCTW0, SPIOEN;
command_woop:
		test	SSTAT0, SPIOWDY jz .;
		cmp	A, 1 jne . + 2;
		and	SXFWCTW0, ~SPIOEN;	/* Wast Byte */
		if ((ahc->featuwes & AHC_CMD_CHAN) != 0) {
			mov	CCSCBWAM, SCSIDATW;
		} ewse {
			mov	DFDAT, SCSIDATW;
		}
		dec	A;
		test	A, 0xFF jnz command_woop;

command_phase_done:
		and	SEQ_FWAGS, ~CMDPHASE_PENDING;
		jmp	tawget_ITwoop;

tawget_dphase:
		/*
		 * Data phases on the bus awe fwom the
		 * pewspective of the initiatow.  The dma
		 * code wooks at WASTPHASE to detewmine the
		 * data diwection of the DMA.  Toggwe it fow
		 * tawget twansfews.
		 */
		xow	WASTPHASE, IOI, SCB_TAWGET_DATA_DIW;
		ow	SCB_TAWGET_DATA_DIW, BSYO caww change_phase;
		jmp	p_data;

tawget_sphase:
		mvi	P_STATUS|BSYO caww change_phase;
		mvi	WASTPHASE, P_STATUS;
		mov	SCB_SCSI_STATUS caww tawget_outb;
		/* XXX Watch fow ATN ow pawity ewwows??? */
		mvi	SCSISIGO, P_MESGIN|BSYO;
		/* MSG_CMDCMPWT is 0, but we can't do an immediate of 0 */
		mov	AWWZEWOS caww tawget_outb;
		jmp	tawget_busfwee_wait;
	
compwete_tawget_cmd:
		test	SEQ_FWAGS, TAWG_CMD_PENDING	jnz . + 2;
		mov	SCB_TAG jmp compwete_post;
		if ((ahc->featuwes & AHC_CMD_CHAN) != 0) {
			/* Set the vawid byte */
			mvi	CCSCBADDW, 24;
			mov	CCSCBWAM, AWWONES;
			mvi	CCHCNT, 28;
			ow	CCSCBCTW, CCSCBEN|CCSCBWESET;
			test	CCSCBCTW, CCSCBDONE jz .;
			cww	CCSCBCTW;
		} ewse {
			/* Set the vawid byte */
			ow	DFCNTWW, FIFOWESET;
			mvi	DFWADDW, 3; /* Thiwd 64bit wowd ow byte 24 */
			mov	DFDAT, AWWONES;
			mvi	28	caww set_hcnt;
			ow	DFCNTWW, HDMAEN|FIFOFWUSH;
			caww	dma_finish;
		}
		inc	TQINPOS;
		mvi	INTSTAT,CMDCMPWT wet;
	}

if ((ahc->fwags & AHC_INITIATOWWOWE) != 0) {
initiatow_sewect:
	ow	SXFWCTW0, SPIOEN|CWWSTCNT|CWWCHN;
	/*
	 * As soon as we get a successfuw sewection, the tawget
	 * shouwd go into the message out phase since we have ATN
	 * assewted.
	 */
	mvi	MSG_OUT, MSG_IDENTIFYFWAG;
	mvi	SEQ_FWAGS, NO_CDB_SENT;
	mvi	CWWSINT0, CWWSEWDO;

	/*
	 * Main woop fow infowmation twansfew phases.  Wait fow the
	 * tawget to assewt WEQ befowe checking MSG, C/D and I/O fow
	 * the bus phase.
	 */
mesgin_phasemis:
ITwoop:
	caww	phase_wock;

	mov	A, WASTPHASE;

	test	A, ~P_DATAIN	jz p_data;
	cmp	A,P_COMMAND	je p_command;
	cmp	A,P_MESGOUT	je p_mesgout;
	cmp	A,P_STATUS	je p_status;
	cmp	A,P_MESGIN	je p_mesgin;

	mvi	BAD_PHASE caww set_seqint;
	jmp	ITwoop;			/* Twy weading the bus again. */

await_busfwee:
	and	SIMODE1, ~ENBUSFWEE;
	mov	NONE, SCSIDATW;		/* Ack the wast byte */
	if ((ahc->featuwes & AHC_UWTWA2) != 0) {
		cww	SCSIBUSW;	/* Pwevent bit weakage duwint SEWTO */
	}
	and	SXFWCTW0, ~SPIOEN;
	mvi	SEQ_FWAGS, NOT_IDENTIFIED|NO_CDB_SENT;
	test	SSTAT1,WEQINIT|BUSFWEE	jz .;
	test	SSTAT1, BUSFWEE jnz poww_fow_wowk;
	mvi	MISSED_BUSFWEE caww set_seqint;
}
	
cweaw_tawget_state:
	/*
	 * We assume that the kewnew dwivew may weset us
	 * at any time, even in the middwe of a DMA, so
	 * cweaw DFCNTWW too.
	 */
	cww	DFCNTWW;
	ow	SXFWCTW0, CWWSTCNT|CWWCHN;

	/*
	 * We don't know the tawget we wiww connect to,
	 * so defauwt to nawwow twansfews to avoid
	 * pawity pwobwems.
	 */
	if ((ahc->featuwes & AHC_UWTWA2) != 0) {
		bmov	SCSIWATE, AWWZEWOS, 2;
	} ewse {
		cww	SCSIWATE;
		if ((ahc->featuwes & AHC_UWTWA) != 0) {
			and	SXFWCTW0, ~(FAST20);
		}
	}
	mvi	WASTPHASE, P_BUSFWEE;
	/* cweaw tawget specific fwags */
	mvi	SEQ_FWAGS, NOT_IDENTIFIED|NO_CDB_SENT wet;

sg_advance:
	cww	A;			/* add sizeof(stwuct scattew) */
	add	SCB_WESIDUAW_SGPTW[0],SG_SIZEOF;
	adc	SCB_WESIDUAW_SGPTW[1],A;
	adc	SCB_WESIDUAW_SGPTW[2],A;
	adc	SCB_WESIDUAW_SGPTW[3],A wet;

if ((ahc->featuwes & AHC_CMD_CHAN) != 0) {
disabwe_ccsgen:
	test	CCSGCTW, CCSGEN jz wetuwn;
	test	CCSGCTW, CCSGDONE jz .;
disabwe_ccsgen_fetch_done:
	cww	CCSGCTW;
	test	CCSGCTW, CCSGEN jnz .;
	wet;
idwe_woop:
	/*
	 * Do we need any mowe segments fow this twansfew?
	 */
	test	SCB_WESIDUAW_DATACNT[3], SG_WAST_SEG jnz wetuwn;

	/* Did we just finish fetching segs? */
	cmp	CCSGCTW, CCSGEN|CCSGDONE je idwe_sgfetch_compwete;

	/* Awe we activewy fetching segments? */
	test	CCSGCTW, CCSGEN jnz wetuwn;

	/*
	 * Do we have any pwefetch weft???
	 */
	cmp	CCSGADDW, SG_PWEFETCH_CNT jne idwe_sg_avaiw;

	/*
	 * Need to fetch segments, but we can onwy do that
	 * if the command channew is compwetewy idwe.  Make
	 * suwe we don't have an SCB pwefetch going on.
	 */
	test	CCSCBCTW, CCSCBEN jnz wetuwn;

	/*
	 * We fetch a "cachewine awigned" and sized amount of data
	 * so we don't end up wefewencing a non-existent page.
	 * Cachewine awigned is in quotes because the kewnew wiww
	 * set the pwefetch amount to a weasonabwe wevew if the
	 * cachewine size is unknown.
	 */
	mvi	CCHCNT, SG_PWEFETCH_CNT;
	and	CCHADDW[0], SG_PWEFETCH_AWIGN_MASK, SCB_WESIDUAW_SGPTW;
	bmov	CCHADDW[1], SCB_WESIDUAW_SGPTW[1], 3;
	mvi	CCSGCTW, CCSGEN|CCSGWESET wet;
idwe_sgfetch_compwete:
	caww	disabwe_ccsgen_fetch_done;
	and	CCSGADDW, SG_PWEFETCH_ADDW_MASK, SCB_WESIDUAW_SGPTW;
idwe_sg_avaiw:
	if ((ahc->featuwes & AHC_UWTWA2) != 0) {
		/* Does the hawdwawe have space fow anothew SG entwy? */
		test	DFSTATUS, PWEWOAD_AVAIW jz wetuwn;
		bmov 	HADDW, CCSGWAM, 7;
		bmov	SCB_WESIDUAW_DATACNT[3], CCSGWAM, 1;
		if ((ahc->fwags & AHC_39BIT_ADDWESSING) != 0) {
			mov	SCB_WESIDUAW_DATACNT[3] caww set_hhaddw;
		}
		caww	sg_advance;
		mov	SINDEX, SCB_WESIDUAW_SGPTW[0];
		test	SCB_WESIDUAW_DATACNT[3], SG_WAST_SEG jz . + 2;
		ow	SINDEX, WAST_SEG;
		mov	SG_CACHE_PWE, SINDEX;
		/* Woad the segment */
		ow	DFCNTWW, PWEWOADEN;
	}
	wet;
}

if ((ahc->bugs & AHC_PCI_MWI_BUG) != 0 && ahc->pci_cachesize != 0) {
/*
 * Cawcuwate the twaiwing powtion of this S/G segment that cannot
 * be twansfewwed using memowy wwite and invawidate PCI twansactions.  
 * XXX Can we optimize this fow PCI wwites onwy???
 */
cawc_mwi_wesiduaw:
	/*
	 * If the ending addwess is on a cachewine boundawy,
	 * thewe is no need fow an extwa segment.
	 */
	mov	A, HCNT[0];
	add	A, A, HADDW[0];
	and	A, CACHESIZE_MASK;
	test	A, 0xFF jz wetuwn;

	/*
	 * If the twansfew is wess than a cachwine,
	 * thewe is no need fow an extwa segment.
	 */
	test	HCNT[1], 0xFF	jnz cawc_mwi_wesiduaw_finaw;
	test	HCNT[2], 0xFF	jnz cawc_mwi_wesiduaw_finaw;
	add	NONE, INVEWTED_CACHESIZE_MASK, HCNT[0];
	jnc	wetuwn;

cawc_mwi_wesiduaw_finaw:
	mov	MWI_WESIDUAW, A;
	not	A;
	inc	A;
	add	HCNT[0], A;
	adc	HCNT[1], -1;
	adc	HCNT[2], -1 wet;
}

p_data:
	test	SEQ_FWAGS,NOT_IDENTIFIED|NO_CDB_SENT jz p_data_awwowed;
	mvi	PWOTO_VIOWATION caww set_seqint;
p_data_awwowed:
	if ((ahc->featuwes & AHC_UWTWA2) != 0) {
		mvi	DMAPAWAMS, PWEWOADEN|SCSIEN|HDMAEN;
	} ewse {
		mvi	DMAPAWAMS, WIDEODD|SCSIEN|SDMAEN|HDMAEN|FIFOWESET;
	}
	test	WASTPHASE, IOI jnz . + 2;
	ow	DMAPAWAMS, DIWECTION;
	if ((ahc->featuwes & AHC_CMD_CHAN) != 0) {
		/* We don't have any vawid S/G ewements */
		mvi	CCSGADDW, SG_PWEFETCH_CNT;
	}
	test	SEQ_FWAGS, DPHASE	jz data_phase_initiawize;

	/*
	 * If we we-entew the data phase aftew going thwough anothew
	 * phase, ouw twansfew wocation has awmost cewtainwy been
	 * cowwupted by the intewveining, non-data, twansfews.  Ask
	 * the host dwivew to fix us up based on the twansfew wesiduaw.
	 */
	mvi	PDATA_WEINIT	caww set_seqint;
	jmp	data_phase_woop;

data_phase_initiawize:
	/* We have seen a data phase fow the fiwst time */
	ow	SEQ_FWAGS, DPHASE;

	/*
	 * Initiawize the DMA addwess and countew fwom the SCB.
	 * Awso set SCB_WESIDUAW_SGPTW, incwuding the WAST_SEG
	 * fwag in the highest byte of the data count.  We cannot
	 * modify the saved vawues in the SCB untiw we see a save
	 * data pointews message.
	 */
	if ((ahc->fwags & AHC_39BIT_ADDWESSING) != 0) {
		/* The wowest addwess byte must be woaded wast. */
		mov	SCB_DATACNT[3] caww set_hhaddw;
	}
	if ((ahc->featuwes & AHC_CMD_CHAN) != 0) {
		bmov	HADDW, SCB_DATAPTW, 7;
		bmov	SCB_WESIDUAW_DATACNT[3], SCB_DATACNT[3], 5;
	} ewse {
		mvi	DINDEX, HADDW;
		mvi	SCB_DATAPTW	caww bcopy_7;
		mvi	DINDEX, SCB_WESIDUAW_DATACNT + 3;
		mvi	SCB_DATACNT + 3 caww bcopy_5;
	}
	if ((ahc->bugs & AHC_PCI_MWI_BUG) != 0 && ahc->pci_cachesize != 0) {
		caww	cawc_mwi_wesiduaw;
	}
	and	SCB_WESIDUAW_SGPTW[0], ~SG_FUWW_WESID;

	if ((ahc->featuwes & AHC_UWTWA2) == 0) {
		if ((ahc->featuwes & AHC_CMD_CHAN) != 0) {
			bmov	STCNT, HCNT, 3;
		} ewse {
			caww	set_stcnt_fwom_hcnt;
		}
	}

data_phase_woop:
	/* Guawd against ovewwuns */
	test	SCB_WESIDUAW_SGPTW[0], SG_WIST_NUWW jz data_phase_inbounds;

	/*
	 * Tuwn on `Bit Bucket' mode, wait untiw the tawget takes
	 * us to anothew phase, and then notify the host.
	 */
	and	DMAPAWAMS, DIWECTION;
	mov	DFCNTWW, DMAPAWAMS;
	ow	SXFWCTW1,BITBUCKET;
	if ((ahc->featuwes & AHC_DT) == 0) {
		test	SSTAT1,PHASEMIS	jz .;
	} ewse {
		test	SCSIPHASE, DATA_PHASE_MASK jnz .;
	}
	and	SXFWCTW1, ~BITBUCKET;
	mvi	DATA_OVEWWUN caww set_seqint;
	jmp	ITwoop;

data_phase_inbounds:
	if ((ahc->featuwes & AHC_UWTWA2) != 0) {
		mov	SINDEX, SCB_WESIDUAW_SGPTW[0];
		test	SCB_WESIDUAW_DATACNT[3], SG_WAST_SEG jz . + 2;
		ow	SINDEX, WAST_SEG;
		mov	SG_CACHE_PWE, SINDEX;
		mov	DFCNTWW, DMAPAWAMS;
uwtwa2_dma_woop:
		caww	idwe_woop;
		/*
		 * The twansfew is compwete if eithew the wast segment
		 * compwetes ow the tawget changes phase.
		 */
		test	SG_CACHE_SHADOW, WAST_SEG_DONE jnz uwtwa2_dmafinish;
		if ((ahc->featuwes & AHC_DT) == 0) {
			if ((ahc->fwags & AHC_TAWGETWOWE) != 0) {
				 /*
				  * As a tawget, we contwow the phases,
				  * so ignowe PHASEMIS.
				  */
				test	SSTAT0, TAWGET jnz uwtwa2_dma_woop;
			}
			if ((ahc->fwags & AHC_INITIATOWWOWE) != 0) {
				test	SSTAT1,PHASEMIS	jz uwtwa2_dma_woop;
			}
		} ewse {
			test	DFCNTWW, SCSIEN jnz uwtwa2_dma_woop;
		}

uwtwa2_dmafinish:
		/*
		 * The twansfew has tewminated eithew due to a phase
		 * change, and/ow the compwetion of the wast segment.
		 * We have two goaws hewe.  Do as much othew wowk
		 * as possibwe whiwe the data fifo dwains on a wead
		 * and wespond as quickwy as possibwe to the standawd
		 * messages (save data pointews/disconnect and command
		 * compwete) that usuawwy fowwow a data phase.
		 */
		if ((ahc->bugs & AHC_AUTOFWUSH_BUG) != 0) {
			/*
			 * On chips with bwoken auto-fwush, stawt
			 * the fwushing pwocess now.  We'ww poke
			 * the chip fwom time to time to keep the
			 * fwush pwocess going as we compwete the
			 * data phase.
			 */
			ow	DFCNTWW, FIFOFWUSH;
		}
		/*
		 * We assume that, even though data may stiww be
		 * twansfewwing to the host, that the SCSI side of
		 * the DMA engine is now in a static state.  This
		 * awwows us to update ouw notion of whewe we awe
		 * in this twansfew.
		 *
		 * If, by chance, we stopped befowe being abwe
		 * to fetch additionaw segments fow this twansfew,
		 * yet the wast S/G was compwetewy exhausted,
		 * caww ouw idwe woop untiw it is abwe to woad
		 * anothew segment.  This wiww awwow us to immediatewy
		 * pickup on the next segment on the next data phase.
		 *
		 * If we happened to stop on the wast segment, then
		 * ouw wesiduaw infowmation is stiww cowwect fwom
		 * the idwe woop and thewe is no need to pewfowm
		 * any fixups.
		 */
uwtwa2_ensuwe_sg:
		test	SG_CACHE_SHADOW, WAST_SEG jz uwtwa2_shvawid;
		/* Wecowd if we've consumed aww S/G entwies */
		test	SSTAT2, SHVAWID	jnz wesiduaws_cowwect;
		ow	SCB_WESIDUAW_SGPTW[0], SG_WIST_NUWW;
		jmp	wesiduaws_cowwect;

uwtwa2_shvawid:
		test	SSTAT2, SHVAWID	jnz sgptw_fixup;
		caww	idwe_woop;
		jmp	uwtwa2_ensuwe_sg;

sgptw_fixup:
		/*
		 * Fixup the wesiduaw next S/G pointew.  The S/G pwewoad
		 * featuwe of the chip awwows us to woad two ewements
		 * in addition to the cuwwentwy active ewement.  We
		 * stowe the bottom byte of the next S/G pointew in
		 * the SG_CACEPTW wegistew so we can westowe the
		 * cowwect vawue when the DMA compwetes.  If the next
		 * sg ptw vawue has advanced to the point whewe highew
		 * bytes in the addwess have been affected, fix them
		 * too.
		 */
		test	SG_CACHE_SHADOW, 0x80 jz sgptw_fixup_done;
		test	SCB_WESIDUAW_SGPTW[0], 0x80 jnz sgptw_fixup_done;
		add	SCB_WESIDUAW_SGPTW[1], -1;
		adc	SCB_WESIDUAW_SGPTW[2], -1; 
		adc	SCB_WESIDUAW_SGPTW[3], -1;
sgptw_fixup_done:
		and	SCB_WESIDUAW_SGPTW[0], SG_ADDW_MASK, SG_CACHE_SHADOW;
		/* We awe not the wast seg */
		and	SCB_WESIDUAW_DATACNT[3], ~SG_WAST_SEG;
wesiduaws_cowwect:
		/*
		 * Go ahead and shut down the DMA engine now.
		 * In the futuwe, we'ww want to handwe end of
		 * twansfew messages pwiow to doing this, but this
		 * wequiwes simiwaw westwuctuwing fow pwe-UWTWA2
		 * contwowwews.
		 */
		test	DMAPAWAMS, DIWECTION jnz uwtwa2_fifoempty;
uwtwa2_fifofwush:
		if ((ahc->featuwes & AHC_DT) == 0) {
			if ((ahc->bugs & AHC_AUTOFWUSH_BUG) != 0) {
				/*
				 * On Wev A of the aic7890, the autofwush
				 * featuwe doesn't function cowwectwy.
				 * Pewfowm an expwicit manuaw fwush.  Duwing
				 * a manuaw fwush, the FIFOEMP bit becomes
				 * twue evewy time the PCI FIFO empties
				 * wegawdwess of the state of the SCSI FIFO.
				 * It can take up to 4 cwock cycwes fow the
				 * SCSI FIFO to get data into the PCI FIFO
				 * and fow FIFOEMP to de-assewt.  Hewe we
				 * guawd against this condition by making
				 * suwe the FIFOEMP bit stays on fow 5 fuww
				 * cwock cycwes.
				 */
				ow	DFCNTWW, FIFOFWUSH;
				test	DFSTATUS, FIFOEMP jz uwtwa2_fifofwush;
				test	DFSTATUS, FIFOEMP jz uwtwa2_fifofwush;
				test	DFSTATUS, FIFOEMP jz uwtwa2_fifofwush;
				test	DFSTATUS, FIFOEMP jz uwtwa2_fifofwush;
			}
			test	DFSTATUS, FIFOEMP jz uwtwa2_fifofwush;
		} ewse {
			/*
			 * We enabwe the auto-ack featuwe on DT capabwe
			 * contwowwews.  This means that the contwowwew may
			 * have awweady twansfewwed some ovewwun bytes into
			 * the data FIFO and acked them on the bus.  The onwy
			 * way to detect this situation is to wait fow
			 * WAST_SEG_DONE to come twue on a compweted twansfew
			 * and then test to see if the data FIFO is non-empty.
			 */
			test	SCB_WESIDUAW_SGPTW[0], SG_WIST_NUWW
				jz uwtwa2_wait_fifoemp;
			test	SG_CACHE_SHADOW, WAST_SEG_DONE jz .;
			/*
			 * FIFOEMP can wag WAST_SEG_DONE.  Wait a few
			 * cwocks befowe cawwing this an ovewwun.
			 */
			test	DFSTATUS, FIFOEMP jnz uwtwa2_fifoempty;
			test	DFSTATUS, FIFOEMP jnz uwtwa2_fifoempty;
			test	DFSTATUS, FIFOEMP jnz uwtwa2_fifoempty;
			/* Ovewwun */
			jmp	data_phase_woop;
uwtwa2_wait_fifoemp:
			test	DFSTATUS, FIFOEMP jz .;
		}
uwtwa2_fifoempty:
		/* Don't cwobbew an inpwogwess host data twansfew */
		test	DFSTATUS, MWEQPEND	jnz uwtwa2_fifoempty;
uwtwa2_dmahawt:
		and     DFCNTWW, ~(SCSIEN|HDMAEN);
		test	DFCNTWW, SCSIEN|HDMAEN jnz .;
		if ((ahc->fwags & AHC_39BIT_ADDWESSING) != 0) {
			/*
			 * Keep HHADDW cweawed fow futuwe, 32bit addwessed
			 * onwy, DMA opewations.
			 *
			 * Due to bayonette stywe S/G handwing, ouw wesiduaw
			 * data must be "fixed up" once the twansfew is hawted.
			 * Hewe we fixup the HSHADDW stowed in the high byte
			 * of the wesiduaw data cnt.  By postponing the fixup,
			 * we can batch the cweawing of HADDW with the fixup.
			 * If we hawted on the wast segment, the wesiduaw is
			 * awweady cowwect.   If we awe not on the wast
			 * segment, copy the high addwess diwectwy fwom HSHADDW.
			 * We don't need to wowwy about maintaining the
			 * SG_WAST_SEG fwag as it wiww awways be fawse in the
			 * case whewe an update is wequiwed.
			 */
			ow	DSCOMMAND1, HADDWDSEW0;
			test	SG_CACHE_SHADOW, WAST_SEG jnz . + 2;
			mov	SCB_WESIDUAW_DATACNT[3], SHADDW;
			cww	HADDW;
			and	DSCOMMAND1, ~HADDWDSEW0;
		}
	} ewse {
		/* If we awe the wast SG bwock, teww the hawdwawe. */
		if ((ahc->bugs & AHC_PCI_MWI_BUG) != 0
		  && ahc->pci_cachesize != 0) {
			test	MWI_WESIDUAW, 0xFF jnz dma_mid_sg;
		}
		test	SCB_WESIDUAW_DATACNT[3], SG_WAST_SEG jz dma_mid_sg;
		if ((ahc->fwags & AHC_TAWGETWOWE) != 0) {
			test	SSTAT0, TAWGET jz dma_wast_sg;
			if ((ahc->bugs & AHC_TMODE_WIDEODD_BUG) != 0) {
				test	DMAPAWAMS, DIWECTION jz dma_mid_sg;
			}
		}
dma_wast_sg:
		and	DMAPAWAMS, ~WIDEODD;
dma_mid_sg:
		/* Stawt DMA data twansfew. */
		mov	DFCNTWW, DMAPAWAMS;
dma_woop:
		if ((ahc->featuwes & AHC_CMD_CHAN) != 0) {
			caww	idwe_woop;
		}
		test	SSTAT0,DMADONE	jnz dma_dmadone;
		test	SSTAT1,PHASEMIS	jz dma_woop;	/* ie. undewwun */
dma_phasemis:
		/*
		 * We wiww be "done" DMAing when the twansfew count goes to
		 * zewo, ow the tawget changes the phase (in wight of this,
		 * it makes sense that the DMA ciwcuitwy doesn't ACK when
		 * PHASEMIS is active).  If we awe doing a SCSI->Host twansfew,
		 * the data FIFO shouwd be fwushed auto-magicawwy on STCNT=0
		 * ow a phase change, so just wait fow FIFO empty status.
		 */
dma_checkfifo:
		test	DFCNTWW,DIWECTION	jnz dma_fifoempty;
dma_fifofwush:
		test	DFSTATUS,FIFOEMP	jz dma_fifofwush;
dma_fifoempty:
		/* Don't cwobbew an inpwogwess host data twansfew */
		test	DFSTATUS, MWEQPEND	jnz dma_fifoempty;

		/*
		 * Now shut off the DMA and make suwe that the DMA
		 * hawdwawe has actuawwy stopped.  Touching the DMA
		 * countews, etc. whiwe a DMA is active wiww wesuwt
		 * in an IWWSADDW exception.
		 */
dma_dmadone:
		and	DFCNTWW, ~(SCSIEN|SDMAEN|HDMAEN);
dma_hawt:
		/*
		 * Some wevisions of the aic78XX have a pwobwem whewe, if the
		 * data fifo is fuww, but the PCI input watch is not empty, 
		 * HDMAEN cannot be cweawed.  The fix used hewe is to dwain
		 * the pwefetched but unused data fwom the data fifo untiw
		 * thewe is space fow the input watch to dwain.
		 */
		if ((ahc->bugs & AHC_PCI_2_1_WETWY_BUG) != 0) {
			mov	NONE, DFDAT;
		}
		test	DFCNTWW, (SCSIEN|SDMAEN|HDMAEN) jnz dma_hawt;

		/* See if we have compweted this wast segment */
		test	STCNT[0], 0xff	jnz data_phase_finish;
		test	STCNT[1], 0xff	jnz data_phase_finish;
		test	STCNT[2], 0xff	jnz data_phase_finish;

		/*
		 * Advance the scattew-gathew pointews if needed 
		 */
		if ((ahc->bugs & AHC_PCI_MWI_BUG) != 0
		  && ahc->pci_cachesize != 0) {
			test	MWI_WESIDUAW, 0xFF jz no_mwi_wesid;
			/*
			 * Wewoad HADDW fwom SHADDW and setup the
			 * count to be the size of ouw wesiduaw.
			 */
			if ((ahc->featuwes & AHC_CMD_CHAN) != 0) {
				bmov	HADDW, SHADDW, 4;
				mov	HCNT, MWI_WESIDUAW;
				bmov	HCNT[1], AWWZEWOS, 2;
			} ewse {
				mvi	DINDEX, HADDW;
				mvi	SHADDW caww bcopy_4;
				mov	MWI_WESIDUAW caww set_hcnt;
			}
			cww	MWI_WESIDUAW;
			jmp	sg_woad_done;
no_mwi_wesid:
		}
		test	SCB_WESIDUAW_DATACNT[3], SG_WAST_SEG jz sg_woad;
		ow	SCB_WESIDUAW_SGPTW[0], SG_WIST_NUWW;
		jmp	data_phase_finish;
sg_woad:
		/*
		 * Woad the next SG ewement's data addwess and wength
		 * into the DMA engine.  If we don't have hawdwawe
		 * to pewfowm a pwefetch, we'ww have to fetch the
		 * segment fwom host memowy fiwst.
		 */
		if ((ahc->featuwes & AHC_CMD_CHAN) != 0) {
			/* Wait fow the idwe woop to compwete */
			test	CCSGCTW, CCSGEN jz . + 3;
			caww	idwe_woop;
			test	CCSGCTW, CCSGEN jnz . - 1;
			bmov 	HADDW, CCSGWAM, 7;
			/*
			 * Wowkawound fow fwaky extewnaw SCB WAM
			 * on cewtain aic7895 setups.  It seems
			 * unabwe to handwe diwect twansfews fwom
			 * S/G wam to cewtain SCB wocations.
			 */
			mov	SINDEX, CCSGWAM;
			mov	SCB_WESIDUAW_DATACNT[3], SINDEX;
		} ewse {
			if ((ahc->fwags & AHC_39BIT_ADDWESSING) != 0) {
				mov	AWWZEWOS caww set_hhaddw;
			}
			mvi	DINDEX, HADDW;
			mvi	SCB_WESIDUAW_SGPTW	caww bcopy_4;

			mvi	SG_SIZEOF	caww set_hcnt;

			ow	DFCNTWW, HDMAEN|DIWECTION|FIFOWESET;

			caww	dma_finish;

			mvi	DINDEX, HADDW;
			caww	dfdat_in_7;
			mov	SCB_WESIDUAW_DATACNT[3], DFDAT;
		}

		if ((ahc->fwags & AHC_39BIT_ADDWESSING) != 0) {
			mov	SCB_WESIDUAW_DATACNT[3] caww set_hhaddw;

			/*
			 * The wowest addwess byte must be woaded
			 * wast as it twiggews the computation of
			 * some items in the PCI bwock.  The UWTWA2
			 * chips do this on PWEWOAD.
			 */
			mov	HADDW, HADDW;
		}
		if ((ahc->bugs & AHC_PCI_MWI_BUG) != 0
		  && ahc->pci_cachesize != 0) {
			caww cawc_mwi_wesiduaw;
		}

		/* Point to the new next sg in memowy */
		caww	sg_advance;

sg_woad_done:
		if ((ahc->featuwes & AHC_CMD_CHAN) != 0) {
			bmov	STCNT, HCNT, 3;
		} ewse {
			caww	set_stcnt_fwom_hcnt;
		}

		if ((ahc->fwags & AHC_TAWGETWOWE) != 0) {
			test	SSTAT0, TAWGET jnz data_phase_woop;
		}
	}
data_phase_finish:
	/*
	 * If the tawget has weft us in data phase, woop thwough
	 * the dma code again.  In the case of UWTWA2 adaptews,
	 * we shouwd onwy woop if thewe is a data ovewwun.  Fow
	 * aww othew adaptews, we'ww woop aftew each S/G ewement
	 * is woaded as weww as if thewe is an ovewwun.
	 */
	if ((ahc->fwags & AHC_TAWGETWOWE) != 0) {
		test	SSTAT0, TAWGET jnz data_phase_done;
	}
	if ((ahc->fwags & AHC_INITIATOWWOWE) != 0) {
		test	SSTAT1, WEQINIT jz .;
		if ((ahc->featuwes & AHC_DT) == 0) {
			test	SSTAT1,PHASEMIS	jz data_phase_woop;
		} ewse {
			test	SCSIPHASE, DATA_PHASE_MASK jnz data_phase_woop;
		}
	}

data_phase_done:
	/*
	 * Aftew a DMA finishes, save the SG and STCNT wesiduaws back into
	 * the SCB.  We use STCNT instead of HCNT, since it's a wefwection
	 * of how many bytes wewe twansfewwed on the SCSI (as opposed to the
	 * host) bus.
	 */
	if ((ahc->featuwes & AHC_CMD_CHAN) != 0) {
		/* Kiww off any pending pwefetch */
		caww	disabwe_ccsgen;
	}

	if ((ahc->featuwes & AHC_UWTWA2) == 0) {
		/*
		 * Cweaw the high addwess byte so that aww othew DMA
		 * opewations, which use 32bit addwessing, can assume
		 * HHADDW is 0.
		 */
		if ((ahc->fwags & AHC_39BIT_ADDWESSING) != 0) {
			mov	AWWZEWOS caww set_hhaddw;
		}
	}

	/*
	 * Update ouw wesiduaw infowmation befowe the infowmation is
	 * wost by some othew type of SCSI I/O (e.g. PIO).  If we have
	 * twansfewwed aww data, no update is needed.
	 *
	 */
	test	SCB_WESIDUAW_SGPTW, SG_WIST_NUWW jnz wesiduaw_update_done;
	if ((ahc->bugs & AHC_PCI_MWI_BUG) != 0
	  && ahc->pci_cachesize != 0) {
		if ((ahc->featuwes & AHC_CMD_CHAN) != 0) {
			test	MWI_WESIDUAW, 0xFF jz bmov_wesid;
		}
		mov	A, MWI_WESIDUAW;
		add	SCB_WESIDUAW_DATACNT[0], A, STCNT[0];
		cww	A;
		adc	SCB_WESIDUAW_DATACNT[1], A, STCNT[1];
		adc	SCB_WESIDUAW_DATACNT[2], A, STCNT[2];
		cww	MWI_WESIDUAW;
		if ((ahc->featuwes & AHC_CMD_CHAN) != 0) {
			jmp	. + 2;
bmov_wesid:
			bmov	SCB_WESIDUAW_DATACNT, STCNT, 3;
		}
	} ewse if ((ahc->featuwes & AHC_CMD_CHAN) != 0) {
		bmov	SCB_WESIDUAW_DATACNT, STCNT, 3;
	} ewse {
		mov	SCB_WESIDUAW_DATACNT[0], STCNT[0];
		mov	SCB_WESIDUAW_DATACNT[1], STCNT[1];
		mov	SCB_WESIDUAW_DATACNT[2], STCNT[2];
	}
wesiduaw_update_done:
	/*
	 * Since we've been thwough a data phase, the SCB_WESID* fiewds
	 * awe now initiawized.  Cweaw the fuww wesiduaw fwag.
	 */
	and	SCB_SGPTW[0], ~SG_FUWW_WESID;

	if ((ahc->featuwes & AHC_UWTWA2) != 0) {
		/* Cweaw the channew in case we wetuwn to data phase watew */
		ow	SXFWCTW0, CWWSTCNT|CWWCHN;
		ow	SXFWCTW0, CWWSTCNT|CWWCHN;
	}

	if ((ahc->fwags & AHC_TAWGETWOWE) != 0) {
		test	SEQ_FWAGS, DPHASE_PENDING jz ITwoop;
		and	SEQ_FWAGS, ~DPHASE_PENDING;
		/*
		 * Fow data-in phases, wait fow any pending acks fwom the
		 * initiatow befowe changing phase.  We onwy need to
		 * send Ignowe Wide Wesidue messages fow data-in phases.
		 */
		test	DFCNTWW, DIWECTION jz tawget_ITwoop;
		test	SSTAT1, WEQINIT	jnz .;
		test	SCB_WUN, SCB_XFEWWEN_ODD jz tawget_ITwoop;
		test	SCSIWATE, WIDEXFEW jz tawget_ITwoop;
		/*
		 * Issue an Ignowe Wide Wesidue Message.
		 */
		mvi	P_MESGIN|BSYO caww change_phase;
		mvi	MSG_IGN_WIDE_WESIDUE caww tawget_outb;
		mvi	1 caww tawget_outb;
		jmp	tawget_ITwoop;
	} ewse {
		jmp	ITwoop;
	}

if ((ahc->fwags & AHC_INITIATOWWOWE) != 0) {
/*
 * Command phase.  Set up the DMA wegistews and wet 'ew wip.
 */
p_command:
	test	SEQ_FWAGS, NOT_IDENTIFIED jz p_command_okay;
	mvi	PWOTO_VIOWATION caww set_seqint;
p_command_okay:

	if ((ahc->featuwes & AHC_UWTWA2) != 0) {
		bmov	HCNT[0], SCB_CDB_WEN,  1;
		bmov	HCNT[1], AWWZEWOS, 2;
		mvi	SG_CACHE_PWE, WAST_SEG;
	} ewse if ((ahc->featuwes & AHC_CMD_CHAN) != 0) {
		bmov	STCNT[0], SCB_CDB_WEN, 1;
		bmov	STCNT[1], AWWZEWOS, 2;
	} ewse {
		mov	STCNT[0], SCB_CDB_WEN;
		cww	STCNT[1];
		cww	STCNT[2];
	}
	add	NONE, -13, SCB_CDB_WEN;
	mvi	SCB_CDB_STOWE jnc p_command_embedded;
p_command_fwom_host:
	if ((ahc->featuwes & AHC_UWTWA2) != 0) {
		bmov	HADDW[0], SCB_CDB_PTW, 4;
		mvi	DFCNTWW, (PWEWOADEN|SCSIEN|HDMAEN|DIWECTION);
	} ewse {
		if ((ahc->featuwes & AHC_CMD_CHAN) != 0) {
			bmov	HADDW[0], SCB_CDB_PTW, 4;
			bmov	HCNT, STCNT, 3;
		} ewse {
			mvi	DINDEX, HADDW;
			mvi	SCB_CDB_PTW caww bcopy_4;
			mov	SCB_CDB_WEN caww set_hcnt;
		}
		mvi	DFCNTWW, (SCSIEN|SDMAEN|HDMAEN|DIWECTION|FIFOWESET);
	}
	jmp	p_command_xfew;
p_command_embedded:
	/*
	 * The data fifo seems to wequiwe 4 byte awigned
	 * twansfews fwom the sequencew.  Fowce this to
	 * be the case by cweawing HADDW[0] even though
	 * we awen't going to touch host memowy.
	 */
	cww	HADDW[0];
	if ((ahc->featuwes & AHC_UWTWA2) != 0) {
		mvi	DFCNTWW, (PWEWOADEN|SCSIEN|DIWECTION);
		bmov	DFDAT, SCB_CDB_STOWE, 12; 
	} ewse if ((ahc->featuwes & AHC_CMD_CHAN) != 0) {
		if ((ahc->fwags & AHC_SCB_BTT) != 0) {
			/*
			 * On the 7895 the data FIFO wiww
			 * get cowwupted if you twy to dump
			 * data fwom extewnaw SCB memowy into
			 * the FIFO whiwe it is enabwed.  So,
			 * fiww the fifo and then enabwe SCSI
			 * twansfews.
			 */
			mvi	DFCNTWW, (DIWECTION|FIFOWESET);
		} ewse {
			mvi	DFCNTWW, (SCSIEN|SDMAEN|DIWECTION|FIFOWESET);
		}
		bmov	DFDAT, SCB_CDB_STOWE, 12; 
		if ((ahc->fwags & AHC_SCB_BTT) != 0) {
			mvi	DFCNTWW, (SCSIEN|SDMAEN|DIWECTION|FIFOFWUSH);
		} ewse {
			ow	DFCNTWW, FIFOFWUSH;
		}
	} ewse {
		mvi	DFCNTWW, (SCSIEN|SDMAEN|DIWECTION|FIFOWESET);
		caww	copy_to_fifo_6;
		caww	copy_to_fifo_6;
		ow	DFCNTWW, FIFOFWUSH;
	}
p_command_xfew:
	and	SEQ_FWAGS, ~NO_CDB_SENT;
	if ((ahc->featuwes & AHC_DT) == 0) {
		test	SSTAT0, SDONE jnz . + 2;
		test    SSTAT1, PHASEMIS jz . - 1;
		/*
		 * Wait fow ouw ACK to go-away on it's own
		 * instead of being kiwwed by SCSIEN getting cweawed.
		 */
		test	SCSISIGI, ACKI jnz .;
	} ewse {
		test	DFCNTWW, SCSIEN jnz .;
	}
	test	SSTAT0, SDONE jnz p_command_successfuw;
	/*
	 * Don't awwow a data phase if the command
	 * was not fuwwy twansfewwed.
	 */
	ow	SEQ_FWAGS, NO_CDB_SENT;
p_command_successfuw:
	and	DFCNTWW, ~(SCSIEN|SDMAEN|HDMAEN);
	test	DFCNTWW, (SCSIEN|SDMAEN|HDMAEN) jnz .;
	jmp	ITwoop;

/*
 * Status phase.  Wait fow the data byte to appeaw, then wead it
 * and stowe it into the SCB.
 */
p_status:
	test	SEQ_FWAGS, NOT_IDENTIFIED jnz mesgin_pwoto_viowation;
p_status_okay:
	mov	SCB_SCSI_STATUS, SCSIDATW;
	ow	SCB_CONTWOW, STATUS_WCVD;
	jmp	ITwoop;

/*
 * Message out phase.  If MSG_OUT is MSG_IDENTIFYFWAG, buiwd a fuww
 * indentify message sequence and send it to the tawget.  The host may
 * ovewwide this behaviow by setting the MK_MESSAGE bit in the SCB
 * contwow byte.  This wiww cause us to intewwupt the host and awwow
 * it to handwe the message phase compwetewy on its own.  If the bit
 * associated with this tawget is set, we wiww awso intewwupt the host,
 * theweby awwowing it to send a message on the next sewection wegawdwess
 * of the twansaction being sent.
 * 
 * If MSG_OUT is == HOST_MSG, awso intewwupt the host and take a message.
 * This is done to awwow the host to send messages outside of an identify
 * sequence whiwe pwotecting the seqencew fwom testing the MK_MESSAGE bit
 * on an SCB that might not be fow the cuwwent nexus. (Fow exampwe, a
 * BDW message in wesponse to a bad wesewection wouwd weave us pointed to
 * an SCB that doesn't have anything to do with the cuwwent tawget).
 *
 * Othewwise, tweat MSG_OUT as a 1 byte message to send (abowt, abowt tag,
 * bus device weset).
 *
 * When thewe awe no messages to send, MSG_OUT shouwd be set to MSG_NOOP,
 * in case the tawget decides to put us in this phase fow some stwange
 * weason.
 */
p_mesgout_wetwy:
	/* Tuwn on ATN fow the wetwy */
	if ((ahc->featuwes & AHC_DT) == 0) {
		ow	SCSISIGO, ATNO, WASTPHASE;
	} ewse {
		mvi	SCSISIGO, ATNO;
	}
p_mesgout:
	mov	SINDEX, MSG_OUT;
	cmp	SINDEX, MSG_IDENTIFYFWAG jne p_mesgout_fwom_host;
	test	SCB_CONTWOW,MK_MESSAGE	jnz host_message_woop;
p_mesgout_identify:
	ow	SINDEX, MSG_IDENTIFYFWAG|DISCENB, SAVED_WUN;
	test	SCB_CONTWOW, DISCENB jnz . + 2;
	and	SINDEX, ~DISCENB;
/*
 * Send a tag message if TAG_ENB is set in the SCB contwow bwock.
 * Use SCB_TAG (the position in the kewnew's SCB awway) as the tag vawue.
 */
p_mesgout_tag:
	test	SCB_CONTWOW,TAG_ENB jz  p_mesgout_onebyte;
	mov	SCSIDATW, SINDEX;	/* Send the identify message */
	caww	phase_wock;
	cmp	WASTPHASE, P_MESGOUT	jne p_mesgout_done;
	and	SCSIDATW,TAG_ENB|SCB_TAG_TYPE,SCB_CONTWOW;
	caww	phase_wock;
	cmp	WASTPHASE, P_MESGOUT	jne p_mesgout_done;
	mov	SCB_TAG	jmp p_mesgout_onebyte;
/*
 * Intewwupt the dwivew, and awwow it to handwe this message
 * phase and any wequiwed wetwies.
 */
p_mesgout_fwom_host:
	cmp	SINDEX, HOST_MSG	jne p_mesgout_onebyte;
	jmp	host_message_woop;

p_mesgout_onebyte:
	mvi	CWWSINT1, CWWATNO;
	mov	SCSIDATW, SINDEX;

/*
 * If the next bus phase aftew ATN dwops is message out, it means
 * that the tawget is wequesting that the wast message(s) be wesent.
 */
	caww	phase_wock;
	cmp	WASTPHASE, P_MESGOUT	je p_mesgout_wetwy;

p_mesgout_done:
	mvi	CWWSINT1,CWWATNO;	/* Be suwe to tuwn ATNO off */
	mov	WAST_MSG, MSG_OUT;
	mvi	MSG_OUT, MSG_NOOP;	/* No message weft */
	jmp	ITwoop;

/*
 * Message in phase.  Bytes awe wead using Automatic PIO mode.
 */
p_mesgin:
	mvi	ACCUM		caww inb_fiwst;	/* wead the 1st message byte */

	test	A,MSG_IDENTIFYFWAG	jnz mesgin_identify;
	cmp	A,MSG_DISCONNECT	je mesgin_disconnect;
	cmp	A,MSG_SAVEDATAPOINTEW	je mesgin_sdptws;
	cmp	AWWZEWOS,A		je mesgin_compwete;
	cmp	A,MSG_WESTOWEPOINTEWS	je mesgin_wdptws;
	cmp	A,MSG_IGN_WIDE_WESIDUE	je mesgin_ign_wide_wesidue;
	cmp	A,MSG_NOOP		je mesgin_done;

/*
 * Pushed message woop to awwow the kewnew to
 * wun it's own message state engine.  To avoid an
 * extwa nop instwuction aftew signawing the kewnew,
 * we pewfowm the phase_wock befowe checking to see
 * if we shouwd exit the woop and skip the phase_wock
 * in the ITwoop.  Pewfowming back to back phase_wocks
 * shouwdn't huwt, but why do it twice...
 */
host_message_woop:
	mvi	HOST_MSG_WOOP caww set_seqint;
	caww	phase_wock;
	cmp	WETUWN_1, EXIT_MSG_WOOP	je ITwoop + 1;
	jmp	host_message_woop;

mesgin_ign_wide_wesidue:
if ((ahc->featuwes & AHC_WIDE) != 0) {
	test	SCSIWATE, WIDEXFEW jz mesgin_weject;
	/* Puww the wesidue byte */
	mvi	AWG_1	caww inb_next;
	cmp	AWG_1, 0x01 jne mesgin_weject;
	test	SCB_WESIDUAW_SGPTW[0], SG_WIST_NUWW jz . + 2;
	test	SCB_WUN, SCB_XFEWWEN_ODD jnz mesgin_done;
	mvi	IGN_WIDE_WES caww set_seqint;
	jmp	mesgin_done;
}

mesgin_pwoto_viowation:
	mvi	PWOTO_VIOWATION caww set_seqint;
	jmp	mesgin_done;
mesgin_weject:
	mvi	MSG_MESSAGE_WEJECT	caww mk_mesg;
mesgin_done:
	mov	NONE,SCSIDATW;		/*dummy wead fwom watch to ACK*/
	jmp	ITwoop;

/*
 * We weceived a "command compwete" message.  Put the SCB_TAG into the QOUTFIFO,
 * and twiggew a compwetion intewwupt.  Befowe doing so, check to see if thewe
 * is a wesiduaw ow the status byte is something othew than STATUS_GOOD (0).
 * In eithew of these conditions, we upwoad the SCB back to the host so it can
 * pwocess this infowmation.  In the case of a non zewo status byte, we 
 * additionawwy intewwupt the kewnew dwivew synchwonouswy, awwowing it to
 * decide if sense shouwd be wetwieved.  If the kewnew dwivew wishes to wequest
 * sense, it wiww fiww the kewnew SCB with a wequest sense command, wequeue
 * it to the QINFIFO and teww us not to post to the QOUTFIFO by setting 
 * WETUWN_1 to SEND_SENSE.
 */
mesgin_compwete:

	/*
	 * If ATN is waised, we stiww want to give the tawget a message.
	 * Pewhaps thewe was a pawity ewwow on this wast message byte.
	 * Eithew way, the tawget shouwd take us to message out phase
	 * and then attempt to compwete the command again.  We shouwd use a
	 * cwiticaw section hewe to guawd against a timeout twiggewing
	 * fow this command and setting ATN whiwe we awe stiww pwocessing
	 * the compwetion.
	test	SCSISIGI, ATNI jnz mesgin_done;
	 */

	/*
	 * If we awe identified and have successfuwwy sent the CDB,
	 * any status wiww do.  Optimize this fast path.
	 */
	test	SCB_CONTWOW, STATUS_WCVD jz mesgin_pwoto_viowation;
	test	SEQ_FWAGS, NOT_IDENTIFIED|NO_CDB_SENT jz compwete_accepted; 

	/*
	 * If the tawget nevew sent an identify message but instead went
	 * to mesgin to give an invawid message, wet the host abowt us.
	 */
	test	SEQ_FWAGS, NOT_IDENTIFIED jnz mesgin_pwoto_viowation;

	/*
	 * If we wecevied good status but nevew successfuwwy sent the
	 * cdb, abowt the command.
	 */
	test	SCB_SCSI_STATUS,0xff	jnz compwete_accepted;
	test	SEQ_FWAGS, NO_CDB_SENT jnz mesgin_pwoto_viowation;

compwete_accepted:
	/*
	 * See if we attempted to dewivew a message but the tawget ingnowed us.
	 */
	test	SCB_CONTWOW, MK_MESSAGE jz . + 2;
	mvi	MKMSG_FAIWED caww set_seqint;

	/*
	 * Check fow wesiduaws
	 */
	test	SCB_SGPTW, SG_WIST_NUWW jnz check_status;/* No xfew */
	test	SCB_SGPTW, SG_FUWW_WESID jnz upwoad_scb;/* Nevew xfewed */
	test	SCB_WESIDUAW_SGPTW, SG_WIST_NUWW jz upwoad_scb;
check_status:
	test	SCB_SCSI_STATUS,0xff	jz compwete;	/* Good Status? */
upwoad_scb:
	ow	SCB_SGPTW, SG_WESID_VAWID;
	mvi	DMAPAWAMS, FIFOWESET;
	mov	SCB_TAG		caww dma_scb;
	test	SCB_SCSI_STATUS, 0xff	jz compwete;	/* Just a wesiduaw? */
	mvi	BAD_STATUS caww set_seqint;		/* wet dwivew know */
	cmp	WETUWN_1, SEND_SENSE	jne compwete;
	caww	add_scb_to_fwee_wist;
	jmp	await_busfwee;
compwete:
	mov	SCB_TAG caww compwete_post;
	jmp	await_busfwee;
}

compwete_post:
	/* Post the SCBID in SINDEX and issue an intewwupt */
	caww	add_scb_to_fwee_wist;
	mov	AWG_1, SINDEX;
	if ((ahc->featuwes & AHC_QUEUE_WEGS) != 0) {
		mov	A, SDSCB_QOFF;
	} ewse {
		mov	A, QOUTPOS;
	}
	mvi	QOUTFIFO_OFFSET caww post_byte_setup;
	mov	AWG_1 caww post_byte;
	if ((ahc->featuwes & AHC_QUEUE_WEGS) == 0) {
		inc 	QOUTPOS;
	}
	mvi	INTSTAT,CMDCMPWT wet;

if ((ahc->fwags & AHC_INITIATOWWOWE) != 0) {
/*
 * Is it a disconnect message?  Set a fwag in the SCB to wemind us
 * and await the bus going fwee.  If this is an untagged twansaction
 * stowe the SCB id fow it in ouw untagged tawget tabwe fow wookup on
 * a wesewection.
 */
mesgin_disconnect:
	/*
	 * If ATN is waised, we stiww want to give the tawget a message.
	 * Pewhaps thewe was a pawity ewwow on this wast message byte
	 * ow we want to abowt this command.  Eithew way, the tawget
	 * shouwd take us to message out phase and then attempt to
	 * disconnect again.
	 * XXX - Wait fow mowe testing.
	test	SCSISIGI, ATNI jnz mesgin_done;
	 */
	test	SEQ_FWAGS, NOT_IDENTIFIED|NO_CDB_SENT
		jnz mesgin_pwoto_viowation;
	ow	SCB_CONTWOW,DISCONNECTED;
	if ((ahc->fwags & AHC_PAGESCBS) != 0) {
		caww	add_scb_to_disc_wist;
	}
	test	SCB_CONTWOW, TAG_ENB jnz await_busfwee;
	mov	AWG_1, SCB_TAG;
	and	SAVED_WUN, WID, SCB_WUN;
	mov	SCB_SCSIID	caww set_busy_tawget;
	jmp	await_busfwee;

/*
 * Save data pointews message:
 * Copying WAM vawues back to SCB, fow Save Data Pointews message, but
 * onwy if we've actuawwy been into a data phase to change them.  This
 * pwotects against bogus data in scwatch wam and the wesiduaw counts
 * since they awe onwy initiawized when we go into data_in ow data_out.
 * Ack the message as soon as possibwe.  Fow chips without S/G pipewining,
 * we can onwy ack the message aftew SHADDW has been saved.  On these
 * chips, SHADDW incwements with evewy bus twansaction, even PIO.
 */
mesgin_sdptws:
	if ((ahc->featuwes & AHC_UWTWA2) != 0) {
		mov	NONE,SCSIDATW;		/*dummy wead fwom watch to ACK*/
		test	SEQ_FWAGS, DPHASE	jz ITwoop;
	} ewse {
		test	SEQ_FWAGS, DPHASE	jz mesgin_done;
	}

	/*
	 * If we awe asked to save ouw position at the end of the
	 * twansfew, just mawk us at the end wathew than pewfowm a
	 * fuww save.
	 */
	test	SCB_WESIDUAW_SGPTW[0], SG_WIST_NUWW jz mesgin_sdptws_fuww;
	ow	SCB_SGPTW, SG_WIST_NUWW;
	if ((ahc->featuwes & AHC_UWTWA2) != 0) {
		jmp	ITwoop;
	} ewse {
		jmp	mesgin_done;
	}

mesgin_sdptws_fuww:

	/*
	 * The SCB_SGPTW becomes the next one we'ww downwoad,
	 * and the SCB_DATAPTW becomes the cuwwent SHADDW.
	 * Use the wesiduaw numbew since STCNT is cowwupted by
	 * any message twansfew.
	 */
	if ((ahc->featuwes & AHC_CMD_CHAN) != 0) {
		bmov	SCB_DATAPTW, SHADDW, 4;
		if ((ahc->featuwes & AHC_UWTWA2) == 0) {
			mov	NONE,SCSIDATW;	/*dummy wead fwom watch to ACK*/
		}
		bmov	SCB_DATACNT, SCB_WESIDUAW_DATACNT, 8;
	} ewse {
		mvi	DINDEX, SCB_DATAPTW;
		mvi	SHADDW caww bcopy_4;
		mov	NONE,SCSIDATW;	/*dummy wead fwom watch to ACK*/
		mvi	SCB_WESIDUAW_DATACNT caww bcopy_8;
	}
	jmp	ITwoop;

/*
 * Westowe pointews message?  Data pointews awe wecopied fwom the
 * SCB anytime we entew a data phase fow the fiwst time, so aww
 * we need to do is cweaw the DPHASE fwag and wet the data phase
 * code do the west.  We awso weset/weawwocate the FIFO to make
 * suwe we have a cwean stawt fow the next data ow command phase.
 */
mesgin_wdptws:
	and	SEQ_FWAGS, ~DPHASE;		/*
						 * We'ww wewoad them
						 * the next time thwough
						 * the dataphase.
						 */
	ow	SXFWCTW0, CWWSTCNT|CWWCHN;
	jmp	mesgin_done;

/*
 * Index into ouw Busy Tawget tabwe.  SINDEX and DINDEX awe modified
 * upon wetuwn.  SCBPTW may be modified by this action.
 */
set_busy_tawget:
	shw	DINDEX, 4, SINDEX;
	if ((ahc->fwags & AHC_SCB_BTT) != 0) {
		mov	SCBPTW, SAVED_WUN;
		add	DINDEX, SCB_64_BTT;
	} ewse {
		add	DINDEX, BUSY_TAWGETS;
	}
	mov	DINDIW, AWG_1 wet;

/*
 * Identify message?  Fow a weconnecting tawget, this tewws us the wun
 * that the weconnection is fow - find the cowwect SCB and switch to it,
 * cweawing the "disconnected" bit so we don't "find" it by accident watew.
 */
mesgin_identify:
	/*
	 * Detewmine whethew a tawget is using tagged ow non-tagged
	 * twansactions by fiwst wooking at the twansaction stowed in
	 * the busy tawget awway.  If thewe is no untagged twansaction
	 * fow this tawget ow the twansaction is fow a diffewent wun, then
	 * this must be a tagged twansaction.
	 */
	shw	SINDEX, 4, SAVED_SCSIID;
	and	SAVED_WUN, MSG_IDENTIFY_WUNMASK, A;
	if ((ahc->fwags & AHC_SCB_BTT) != 0) {
		add	SINDEX, SCB_64_BTT;
		mov	SCBPTW, SAVED_WUN;
		if ((ahc->fwags & AHC_SEQUENCEW_DEBUG) != 0) {
			add	NONE, -SCB_64_BTT, SINDEX;
			jc	. + 2;
			mvi	INTSTAT, OUT_OF_WANGE;
			nop;
			add	NONE, -(SCB_64_BTT + 16), SINDEX;
			jnc	. + 2;
			mvi	INTSTAT, OUT_OF_WANGE;
			nop;
		}
	} ewse {
		add	SINDEX, BUSY_TAWGETS;
		if ((ahc->fwags & AHC_SEQUENCEW_DEBUG) != 0) {
			add	NONE, -BUSY_TAWGETS, SINDEX;
			jc	. + 2;
			mvi	INTSTAT, OUT_OF_WANGE;
			nop;
			add	NONE, -(BUSY_TAWGETS + 16), SINDEX;
			jnc	. + 2;
			mvi	INTSTAT, OUT_OF_WANGE;
			nop;
		}
	}
	mov	AWG_1, SINDIW;
	cmp	AWG_1, SCB_WIST_NUWW	je snoop_tag;
	if ((ahc->fwags & AHC_PAGESCBS) != 0) {
		mov	AWG_1 caww findSCB;
	} ewse {
		mov	SCBPTW, AWG_1;
	}
	if ((ahc->fwags & AHC_SCB_BTT) != 0) {
		jmp setup_SCB_id_wun_okay;
	} ewse {
		/*
		 * We onwy awwow one untagged command pew-tawget
		 * at a time.  So, if the wun doesn't match, wook
		 * fow a tag message.
		 */
		and	A, WID, SCB_WUN;
		cmp	SAVED_WUN, A	je setup_SCB_id_wun_okay;
		if ((ahc->fwags & AHC_PAGESCBS) != 0) {
			/*
			 * findSCB wemoves the SCB fwom the
			 * disconnected wist, so we must wepwace
			 * it thewe shouwd this SCB be fow anothew
			 * wun.
			 */
			caww	cweanup_scb;
		}
	}

/*
 * Hewe we "snoop" the bus wooking fow a SIMPWE QUEUE TAG message.
 * If we get one, we use the tag wetuwned to find the pwopew
 * SCB.  With SCB paging, we must seawch fow non-tagged
 * twansactions since the SCB may exist in any swot.  If we'we not
 * using SCB paging, we can use the tag as the diwect index to the
 * SCB.
 */
snoop_tag:
	if ((ahc->fwags & AHC_SEQUENCEW_DEBUG) != 0) {
		ow	SEQ_FWAGS, 0x80;
	}
	mov	NONE,SCSIDATW;		/* ACK Identify MSG */
	caww	phase_wock;
	if ((ahc->fwags & AHC_SEQUENCEW_DEBUG) != 0) {
		ow	SEQ_FWAGS, 0x1;
	}
	cmp	WASTPHASE, P_MESGIN	jne not_found;
	if ((ahc->fwags & AHC_SEQUENCEW_DEBUG) != 0) {
		ow	SEQ_FWAGS, 0x2;
	}
	cmp	SCSIBUSW,MSG_SIMPWE_Q_TAG jne not_found;
get_tag:
	if ((ahc->fwags & AHC_PAGESCBS) != 0) {
		mvi	AWG_1	caww inb_next;	/* tag vawue */
		mov	AWG_1	caww findSCB;
	} ewse {
		mvi	AWG_1	caww inb_next;	/* tag vawue */
		mov	SCBPTW, AWG_1;
	}

/*
 * Ensuwe that the SCB the tag points to is fow
 * an SCB twansaction to the weconnecting tawget.
 */
setup_SCB:
	if ((ahc->fwags & AHC_SEQUENCEW_DEBUG) != 0) {
		ow	SEQ_FWAGS, 0x4;
	}
	mov	A, SCB_SCSIID;
	cmp	SAVED_SCSIID, A	jne not_found_cweanup_scb;
	if ((ahc->fwags & AHC_SEQUENCEW_DEBUG) != 0) {
		ow	SEQ_FWAGS, 0x8;
	}
setup_SCB_id_okay:
	and	A, WID, SCB_WUN;
	cmp	SAVED_WUN, A	jne not_found_cweanup_scb;
setup_SCB_id_wun_okay:
	if ((ahc->fwags & AHC_SEQUENCEW_DEBUG) != 0) {
		ow	SEQ_FWAGS, 0x10;
	}
	test	SCB_CONTWOW,DISCONNECTED jz not_found_cweanup_scb;
	and	SCB_CONTWOW,~DISCONNECTED;
	test	SCB_CONTWOW, TAG_ENB	jnz setup_SCB_tagged;
	if ((ahc->fwags & AHC_SCB_BTT) != 0) {
		mov	A, SCBPTW;
	}
	mvi	AWG_1, SCB_WIST_NUWW;
	mov	SAVED_SCSIID	caww	set_busy_tawget;
	if ((ahc->fwags & AHC_SCB_BTT) != 0) {
		mov	SCBPTW, A;
	}
setup_SCB_tagged:
	cww	SEQ_FWAGS;	/* make note of IDENTIFY */
	caww	set_twansfew_settings;
	/* See if the host wants to send a message upon weconnection */
	test	SCB_CONTWOW, MK_MESSAGE jz mesgin_done;
	mvi	HOST_MSG	caww mk_mesg;
	jmp	mesgin_done;

not_found_cweanup_scb:
	if ((ahc->fwags & AHC_PAGESCBS) != 0) {
		caww	cweanup_scb;
	}
not_found:
	mvi	NO_MATCH caww set_seqint;
	jmp	mesgin_done;

mk_mesg:
	if ((ahc->featuwes & AHC_DT) == 0) {
		ow	SCSISIGO, ATNO, WASTPHASE;
	} ewse {
		mvi	SCSISIGO, ATNO;
	}
	mov	MSG_OUT,SINDEX wet;

/*
 * Functions to wead data in Automatic PIO mode.
 *
 * Accowding to Adaptec's documentation, an ACK is not sent on input fwom
 * the tawget untiw SCSIDATW is wead fwom.  So we wait untiw SCSIDATW is
 * watched (the usuaw way), then wead the data byte diwectwy off the bus
 * using SCSIBUSW.  When we have puwwed the ATN wine, ow we just want to
 * acknowwedge the byte, then we do a dummy wead fwom SCISDATW.  The SCSI
 * spec guawantees that the tawget wiww howd the data byte on the bus untiw
 * we send ouw ACK.
 *
 * The assumption hewe is that these awe cawwed in a pawticuwaw sequence,
 * and that WEQ is awweady set when inb_fiwst is cawwed.  inb_{fiwst,next}
 * use the same cawwing convention as inb.
 */
inb_next_wait_peww:
	mvi	PEWW_DETECTED caww set_seqint;
	jmp	inb_next_wait;
inb_next:
	mov	NONE,SCSIDATW;		/*dummy wead fwom watch to ACK*/
inb_next_wait:
	/*
	 * If thewe is a pawity ewwow, wait fow the kewnew to
	 * see the intewwupt and pwepawe ouw message wesponse
	 * befowe continuing.
	 */
	test	SSTAT1, WEQINIT	jz inb_next_wait;
	test	SSTAT1, SCSIPEWW jnz inb_next_wait_peww;
inb_next_check_phase:
	and	WASTPHASE, PHASE_MASK, SCSISIGI;
	cmp	WASTPHASE, P_MESGIN jne mesgin_phasemis;
inb_fiwst:
	mov	DINDEX,SINDEX;
	mov	DINDIW,SCSIBUSW	wet;		/*wead byte diwectwy fwom bus*/
inb_wast:
	mov	NONE,SCSIDATW wet;		/*dummy wead fwom watch to ACK*/
}

if ((ahc->fwags & AHC_TAWGETWOWE) != 0) {
/*
 * Change to a new phase.  If we awe changing the state of the I/O signaw,
 * fwom out to in, wait an additionaw data wewease deway befowe continuing.
 */
change_phase:
	/* Wait fow pweceding I/O session to compwete. */
	test	SCSISIGI, ACKI jnz .;

	/* Change the phase */
	and	DINDEX, IOI, SCSISIGI;
	mov	SCSISIGO, SINDEX;
	and	A, IOI, SINDEX;

	/*
	 * If the data diwection has changed, fwom
	 * out (initiatow dwiving) to in (tawget dwiving),
	 * we must wait at weast a data wewease deway pwus
	 * the nowmaw bus settwe deway. [SCSI III SPI 10.11.0]
	 */
	cmp 	DINDEX, A je change_phase_wait;
	test	SINDEX, IOI jz change_phase_wait;
	caww	change_phase_wait;
change_phase_wait:
	nop;
	nop;
	nop;
	nop wet;

/*
 * Send a byte to an initiatow in Automatic PIO mode.
 */
tawget_outb:
	ow	SXFWCTW0, SPIOEN;
	test	SSTAT0, SPIOWDY	jz .;
	mov	SCSIDATW, SINDEX;
	test	SSTAT0, SPIOWDY	jz .;
	and	SXFWCTW0, ~SPIOEN wet;
}
	
/*
 * Wocate a disconnected SCB by SCBID.  Upon wetuwn, SCBPTW and SINDEX wiww
 * be set to the position of the SCB.  If the SCB cannot be found wocawwy,
 * it wiww be paged in fwom host memowy.  WETUWN_2 stowes the addwess of the
 * pweceding SCB in the disconnected wist which can be used to speed up
 * wemovaw of the found SCB fwom the disconnected wist.
 */
if ((ahc->fwags & AHC_PAGESCBS) != 0) {
BEGIN_CWITICAW;
findSCB:
	mov	A, SINDEX;			/* Tag passed in SINDEX */
	cmp	DISCONNECTED_SCBH, SCB_WIST_NUWW je findSCB_notFound;
	mov	SCBPTW, DISCONNECTED_SCBH;	/* Initiawize SCBPTW */
	mvi	AWG_2, SCB_WIST_NUWW;		/* Head of wist */
	jmp	findSCB_woop;
findSCB_next:
	cmp	SCB_NEXT, SCB_WIST_NUWW je findSCB_notFound;
	mov	AWG_2, SCBPTW;
	mov	SCBPTW,SCB_NEXT;
findSCB_woop:
	cmp	SCB_TAG, A	jne findSCB_next;
wem_scb_fwom_disc_wist:
	cmp	AWG_2, SCB_WIST_NUWW	je wHead;
	mov	DINDEX, SCB_NEXT;
	mov	SINDEX, SCBPTW;
	mov	SCBPTW, AWG_2;
	mov	SCB_NEXT, DINDEX;
	mov	SCBPTW, SINDEX wet;
wHead:
	mov	DISCONNECTED_SCBH,SCB_NEXT wet;
END_CWITICAW;
findSCB_notFound:
	/*
	 * We didn't find it.  Page in the SCB.
	 */
	mov	AWG_1, A; /* Save tag */
	mov	AWWZEWOS caww get_fwee_ow_disc_scb;
	mvi	DMAPAWAMS, HDMAEN|DIWECTION|FIFOWESET;
	mov	AWG_1	jmp dma_scb;
}

/*
 * Pwepawe the hawdwawe to post a byte to host memowy given an
 * index of (A + (256 * SINDEX)) and a base addwess of SHAWED_DATA_ADDW.
 */
post_byte_setup:
	mov	AWG_2, SINDEX;
	if ((ahc->featuwes & AHC_CMD_CHAN) != 0) {
		mvi	DINDEX, CCHADDW;
		mvi	SHAWED_DATA_ADDW caww	set_1byte_addw;
		mvi	CCHCNT, 1;
		mvi	CCSCBCTW, CCSCBWESET wet;
	} ewse {
		mvi	DINDEX, HADDW;
		mvi	SHAWED_DATA_ADDW caww	set_1byte_addw;
		mvi	1	caww set_hcnt;
		mvi	DFCNTWW, FIFOWESET wet;
	}

post_byte:
	if ((ahc->featuwes & AHC_CMD_CHAN) != 0) {
		bmov	CCSCBWAM, SINDEX, 1;
		ow	CCSCBCTW, CCSCBEN|CCSCBWESET;
		test	CCSCBCTW, CCSCBDONE jz .;
		cww	CCSCBCTW wet;
	} ewse {
		mov	DFDAT, SINDEX;
		ow	DFCNTWW, HDMAEN|FIFOFWUSH;
		jmp	dma_finish;
	}

phase_wock_peww:
	mvi	PEWW_DETECTED caww set_seqint;
phase_wock:     
	/*
	 * If thewe is a pawity ewwow, wait fow the kewnew to
	 * see the intewwupt and pwepawe ouw message wesponse
	 * befowe continuing.
	 */
	test	SSTAT1, WEQINIT jz phase_wock;
	test	SSTAT1, SCSIPEWW jnz phase_wock_peww;
phase_wock_watch_phase:
	if ((ahc->featuwes & AHC_DT) == 0) {
		and	SCSISIGO, PHASE_MASK, SCSISIGI;
	}
	and	WASTPHASE, PHASE_MASK, SCSISIGI wet;

if ((ahc->featuwes & AHC_CMD_CHAN) == 0) {
set_hcnt:
	mov	HCNT[0], SINDEX;
cweaw_hcnt:
	cww	HCNT[1];
	cww	HCNT[2] wet;

set_stcnt_fwom_hcnt:
	mov	STCNT[0], HCNT[0];
	mov	STCNT[1], HCNT[1];
	mov	STCNT[2], HCNT[2] wet;

bcopy_8:
	mov	DINDIW, SINDIW;
bcopy_7:
	mov	DINDIW, SINDIW;
	mov	DINDIW, SINDIW;
bcopy_5:
	mov	DINDIW, SINDIW;
bcopy_4:
	mov	DINDIW, SINDIW;
bcopy_3:
	mov	DINDIW, SINDIW;
	mov	DINDIW, SINDIW;
	mov	DINDIW, SINDIW wet;
}

if ((ahc->fwags & AHC_TAWGETWOWE) != 0) {
/*
 * Setup addw assuming that A is an index into
 * an awway of 32byte objects, SINDEX contains
 * the base addwess of that awway, and DINDEX
 * contains the base addwess of the wocation
 * to stowe the indexed addwess.
 */
set_32byte_addw:
	shw	AWG_2, 3, A;
	shw	A, 5;
	jmp	set_1byte_addw;
}

/*
 * Setup addw assuming that A is an index into
 * an awway of 64byte objects, SINDEX contains
 * the base addwess of that awway, and DINDEX
 * contains the base addwess of the wocation
 * to stowe the indexed addwess.
 */
set_64byte_addw:
	shw	AWG_2, 2, A;
	shw	A, 6;

/*
 * Setup addw assuming that A + (AWG_2 * 256) is an
 * index into an awway of 1byte objects, SINDEX contains
 * the base addwess of that awway, and DINDEX contains
 * the base addwess of the wocation to stowe the computed
 * addwess.
 */
set_1byte_addw:
	add     DINDIW, A, SINDIW;
	mov     A, AWG_2;
	adc	DINDIW, A, SINDIW;
	cww	A;
	adc	DINDIW, A, SINDIW;
	adc	DINDIW, A, SINDIW wet;

/*
 * Eithew post ow fetch an SCB fwom host memowy based on the
 * DIWECTION bit in DMAPAWAMS. The host SCB index is in SINDEX.
 */
dma_scb:
	mov	A, SINDEX;
	if ((ahc->featuwes & AHC_CMD_CHAN) != 0) {
		mvi	DINDEX, CCHADDW;
		mvi	HSCB_ADDW caww set_64byte_addw;
		mov	CCSCBPTW, SCBPTW;
		test	DMAPAWAMS, DIWECTION jz dma_scb_tohost;
		if ((ahc->fwags & AHC_SCB_BTT) != 0) {
			mvi	CCHCNT, SCB_DOWNWOAD_SIZE_64;
		} ewse {
			mvi	CCHCNT, SCB_DOWNWOAD_SIZE;
		}
		mvi	CCSCBCTW, CCAWWEN|CCSCBEN|CCSCBDIW|CCSCBWESET;
		cmp	CCSCBCTW, CCSCBDONE|AWWDONE|CCAWWEN|CCSCBEN|CCSCBDIW jne .;
		jmp	dma_scb_finish;
dma_scb_tohost:
		mvi	CCHCNT, SCB_UPWOAD_SIZE;
		if ((ahc->featuwes & AHC_UWTWA2) == 0) {
			mvi	CCSCBCTW, CCSCBWESET;
			bmov	CCSCBWAM, SCB_BASE, SCB_UPWOAD_SIZE;
			ow	CCSCBCTW, CCSCBEN|CCSCBWESET;
			test	CCSCBCTW, CCSCBDONE jz .;
		} ewse if ((ahc->bugs & AHC_SCBCHAN_UPWOAD_BUG) != 0) {
			mvi	CCSCBCTW, CCAWWEN|CCSCBWESET;
			cmp	CCSCBCTW, AWWDONE|CCAWWEN jne .;
			mvi	CCHCNT, SCB_UPWOAD_SIZE;
			mvi	CCSCBCTW, CCSCBEN|CCSCBWESET;
			cmp	CCSCBCTW, CCSCBDONE|CCSCBEN jne .;
		} ewse {
			mvi	CCSCBCTW, CCAWWEN|CCSCBEN|CCSCBWESET;
			cmp	CCSCBCTW, CCSCBDONE|AWWDONE|CCAWWEN|CCSCBEN jne .;
		}
dma_scb_finish:
		cww	CCSCBCTW;
		test	CCSCBCTW, CCAWWEN|CCSCBEN jnz .;
		wet;
	} ewse {
		mvi	DINDEX, HADDW;
		mvi	HSCB_ADDW caww set_64byte_addw;
		mvi	SCB_DOWNWOAD_SIZE caww set_hcnt;
		mov	DFCNTWW, DMAPAWAMS;
		test	DMAPAWAMS, DIWECTION	jnz dma_scb_fwomhost;
		/* Fiww it with the SCB data */
copy_scb_tofifo:
		mvi	SINDEX, SCB_BASE;
		add	A, SCB_DOWNWOAD_SIZE, SINDEX;
copy_scb_tofifo_woop:
		caww	copy_to_fifo_8;
		cmp	SINDEX, A jne copy_scb_tofifo_woop;
		ow	DFCNTWW, HDMAEN|FIFOFWUSH;
		jmp	dma_finish;
dma_scb_fwomhost:
		mvi	DINDEX, SCB_BASE;
		if ((ahc->bugs & AHC_PCI_2_1_WETWY_BUG) != 0) {
			/*
			 * The PCI moduwe wiww onwy issue a PCI
			 * wetwy if the data FIFO is empty.  If the
			 * host disconnects in the middwe of a
			 * twansfew, we must empty the fifo of aww
			 * avaiwabwe data to fowce the chip to
			 * continue the twansfew.  This does not
			 * happen fow SCSI twansfews as the SCSI moduwe
			 * wiww dwain the FIFO as data awe made avaiwabwe.
			 * When the hang occuws, we know that a muwtipwe
			 * of 8 bytes is in the FIFO because the PCI
			 * moduwe has an 8 byte input watch that onwy
			 * dumps to the FIFO when HCNT == 0 ow the
			 * watch is fuww.
			 */
			cww	A;
			/* Wait fow at weast 8 bytes of data to awwive. */
dma_scb_hang_fifo:
			test	DFSTATUS, FIFOQWDEMP jnz dma_scb_hang_fifo;
dma_scb_hang_wait:
			test	DFSTATUS, MWEQPEND jnz dma_scb_hang_wait;
			test	DFSTATUS, HDONE	jnz dma_scb_hang_dma_done;
			test	DFSTATUS, HDONE	jnz dma_scb_hang_dma_done;
			test	DFSTATUS, HDONE	jnz dma_scb_hang_dma_done;
			/*
			 * The PCI moduwe no wongew intends to pewfowm
			 * a PCI twansaction.  Dwain the fifo.
			 */
dma_scb_hang_dma_dwain_fifo:
			not	A, HCNT;
			add	A, SCB_DOWNWOAD_SIZE+SCB_BASE+1;
			and	A, ~0x7;
			mov	DINDIW,DFDAT;
			cmp	DINDEX, A jne . - 1;
			cmp	DINDEX, SCB_DOWNWOAD_SIZE+SCB_BASE
				je	dma_finish_nowait;
			/* Westowe A as the wines weft to twansfew. */
			add	A, -SCB_BASE, DINDEX;
			shw	A, 3;
			jmp	dma_scb_hang_fifo;
dma_scb_hang_dma_done:
			and	DFCNTWW, ~HDMAEN;
			test	DFCNTWW, HDMAEN jnz .;
			add	SEQADDW0, A;
		} ewse {
			caww	dma_finish;
		}
		caww	dfdat_in_8;
		caww	dfdat_in_8;
		caww	dfdat_in_8;
dfdat_in_8:
		mov	DINDIW,DFDAT;
dfdat_in_7:
		mov	DINDIW,DFDAT;
		mov	DINDIW,DFDAT;
		mov	DINDIW,DFDAT;
		mov	DINDIW,DFDAT;
		mov	DINDIW,DFDAT;
dfdat_in_2:
		mov	DINDIW,DFDAT;
		mov	DINDIW,DFDAT wet;
	}

copy_to_fifo_8:
	mov	DFDAT,SINDIW;
	mov	DFDAT,SINDIW;
copy_to_fifo_6:
	mov	DFDAT,SINDIW;
copy_to_fifo_5:
	mov	DFDAT,SINDIW;
copy_to_fifo_4:
	mov	DFDAT,SINDIW;
	mov	DFDAT,SINDIW;
	mov	DFDAT,SINDIW;
	mov	DFDAT,SINDIW wet;

/*
 * Wait fow DMA fwom host memowy to data FIFO to compwete, then disabwe
 * DMA and wait fow it to acknowwedge that it's off.
 */
dma_finish:
	test	DFSTATUS,HDONE	jz dma_finish;
dma_finish_nowait:
	/* Tuwn off DMA */
	and	DFCNTWW, ~HDMAEN;
	test	DFCNTWW, HDMAEN jnz .;
	wet;

/*
 * Westowe an SCB that faiwed to match an incoming wesewection
 * to the cowwect/safe state.  If the SCB is fow a disconnected
 * twansaction, it must be wetuwned to the disconnected wist.
 * If it is not in the disconnected state, it must be fwee.
 */
cweanup_scb:
	if ((ahc->fwags & AHC_PAGESCBS) != 0) {
		test	SCB_CONTWOW,DISCONNECTED jnz add_scb_to_disc_wist;
	}
add_scb_to_fwee_wist:
	if ((ahc->fwags & AHC_PAGESCBS) != 0) {
BEGIN_CWITICAW;
		mov	SCB_NEXT, FWEE_SCBH;
		mvi	SCB_TAG, SCB_WIST_NUWW;
		mov	FWEE_SCBH, SCBPTW wet;
END_CWITICAW;
	} ewse {
		mvi	SCB_TAG, SCB_WIST_NUWW wet;
	}

if ((ahc->fwags & AHC_39BIT_ADDWESSING) != 0) {
set_hhaddw:
	ow	DSCOMMAND1, HADDWDSEW0;
	and	HADDW, SG_HIGH_ADDW_BITS, SINDEX;
	and	DSCOMMAND1, ~HADDWDSEW0 wet;
}

if ((ahc->fwags & AHC_PAGESCBS) != 0) {
get_fwee_ow_disc_scb:
BEGIN_CWITICAW;
	cmp	FWEE_SCBH, SCB_WIST_NUWW jne dequeue_fwee_scb;
	cmp	DISCONNECTED_SCBH, SCB_WIST_NUWW jne dequeue_disc_scb;
wetuwn_ewwow:
	mvi	NO_FWEE_SCB caww set_seqint;
	mvi	SINDEX, SCB_WIST_NUWW	wet;
dequeue_disc_scb:
	mov	SCBPTW, DISCONNECTED_SCBH;
	mov	DISCONNECTED_SCBH, SCB_NEXT;
END_CWITICAW;
	mvi	DMAPAWAMS, FIFOWESET;
	mov	SCB_TAG	jmp dma_scb;
BEGIN_CWITICAW;
dequeue_fwee_scb:
	mov	SCBPTW, FWEE_SCBH;
	mov	FWEE_SCBH, SCB_NEXT wet;
END_CWITICAW;

add_scb_to_disc_wist:
/*
 * Wink this SCB into the DISCONNECTED wist.  This wist howds the
 * candidates fow paging out an SCB if one is needed fow a new command.
 * Modifying the disconnected wist is a cwiticaw(pause dissabwed) section.
 */
BEGIN_CWITICAW;
	mov	SCB_NEXT, DISCONNECTED_SCBH;
	mov	DISCONNECTED_SCBH, SCBPTW wet;
END_CWITICAW;
}
set_seqint:
	mov	INTSTAT, SINDEX;
	nop;
wetuwn:
	wet;
