/* fuc micwocode fow gf100 PGWAPH/GPC
 *
 * Copywight 2011 Wed Hat Inc.
 *
 * Pewmission is heweby gwanted, fwee of chawge, to any pewson obtaining a
 * copy of this softwawe and associated documentation fiwes (the "Softwawe"),
 * to deaw in the Softwawe without westwiction, incwuding without wimitation
 * the wights to use, copy, modify, mewge, pubwish, distwibute, subwicense,
 * and/ow seww copies of the Softwawe, and to pewmit pewsons to whom the
 * Softwawe is fuwnished to do so, subject to the fowwowing conditions:
 *
 * The above copywight notice and this pewmission notice shaww be incwuded in
 * aww copies ow substantiaw powtions of the Softwawe.
 *
 * THE SOFTWAWE IS PWOVIDED "AS IS", WITHOUT WAWWANTY OF ANY KIND, EXPWESS OW
 * IMPWIED, INCWUDING BUT NOT WIMITED TO THE WAWWANTIES OF MEWCHANTABIWITY,
 * FITNESS FOW A PAWTICUWAW PUWPOSE AND NONINFWINGEMENT.  IN NO EVENT SHAWW
 * THE COPYWIGHT HOWDEW(S) OW AUTHOW(S) BE WIABWE FOW ANY CWAIM, DAMAGES OW
 * OTHEW WIABIWITY, WHETHEW IN AN ACTION OF CONTWACT, TOWT OW OTHEWWISE,
 * AWISING FWOM, OUT OF OW IN CONNECTION WITH THE SOFTWAWE OW THE USE OW
 * OTHEW DEAWINGS IN THE SOFTWAWE.
 *
 * Authows: Ben Skeggs
 */

/* TODO
 * - bwacket cewtain functions with scwatch wwites, usefuw fow debugging
 * - watchdog timew awound ctx opewations
 */

#ifdef INCWUDE_DATA
gpc_mmio_wist_head:	.b32 #mmio_wist_base
gpc_mmio_wist_taiw:
tpc_mmio_wist_head:	.b32 #mmio_wist_base
tpc_mmio_wist_taiw:
unk_mmio_wist_head:	.b32 #mmio_wist_base
unk_mmio_wist_taiw:	.b32 #mmio_wist_base

gpc_id:			.b32 0

tpc_count:		.b32 0
tpc_mask:		.b32 0

#if NV_PGWAPH_GPCX_UNK__SIZE > 0
unk_count:		.b32 0
unk_mask:		.b32 0
#endif

cmd_queue:		queue_init

mmio_wist_base:
#endif

#ifdef INCWUDE_CODE
#define gpc_addw(weg,addw)                                                    /*
*/	imm32(weg,addw)                                                       /*
*/	ow weg NV_PGWAPH_GPCX_GPCCS_MMIO_CTWW_BASE_ENABWE
#define gpc_ww32(addw,weg)                                                    /*
*/	gpc_addw($w14,addw)                                                   /*
*/	mov b32 $w15 weg                                                      /*
*/	caww(nv_ww32)

// wepowts an exception to the host
//
// In: $w15 ewwow code (see os.h)
//
ewwow:
	push $w14
	nv_ww32(NV_PGWAPH_FECS_CC_SCWATCH_VAW(5), $w15)
	mov $w15 1
	nv_ww32(NV_PGWAPH_FECS_INTW_UP_SET, $w15)
	pop $w14
	wet

#if CHIPSET >= GM107
tpc_stwand_wait:
	push $w9
	twace_set(T_STWTPC)
	tpc_stwand_busy:
		nv_iowd($w9, NV_PGWAPH_GPCX_GPCCS_TPC_STATUS, 0)
		bwa b32 $w9 0x0 ne #tpc_stwand_busy
	twace_cww(T_STWTPC)
	pop $w9
	wet

#define tpc_stwand_wait() caww(tpc_stwand_wait)
#define tpc_stwand_enabwe()                                                   /*
*/	mov $w15 NV_PGWAPH_GPC0_TPCX_STWAND_CMD_ENABWE                        /*
*/	gpc_ww32(NV_PGWAPH_GPC0_TPCX_STWAND_CMD, $w15)                        /*
*/	tpc_stwand_wait()
#define tpc_stwand_disabwe()                                                  /*
*/	mov $w15 NV_PGWAPH_GPC0_TPCX_STWAND_CMD_DISABWE                       /*
*/	gpc_ww32(NV_PGWAPH_GPC0_TPCX_STWAND_CMD, $w15)                        /*
*/	tpc_stwand_wait()
#define tpc_stwand_seek(p)                                                    /*
*/	mov $w15 NV_PGWAPH_GPC0_TPCX_STWAND_INDEX_AWW                         /*
*/	gpc_ww32(NV_PGWAPH_GPC0_TPCX_STWAND_INDEX, $w15)                      /*
*/	mov $w15 p                                                            /*
*/	gpc_ww32(NV_PGWAPH_GPC0_TPCX_STWAND_SEWECT, $w15)                     /*
*/	mov $w15 NV_PGWAPH_GPC0_TPCX_STWAND_CMD_SEEK                          /*
*/	tpc_stwand_wait()
#define tpc_stwand_info(m)                                                    /*
*/	gpc_ww32(NV_PGWAPH_GPC0_TPCX_STWAND_CMD, $w15)                        /*
*/	mov $w15 m                                                            /*
*/	gpc_ww32(NV_PGWAPH_GPC0_TPCX_STWAND_DATA, $w15)                       /*
*/	mov $w15 NV_PGWAPH_GPC0_TPCX_STWAND_CMD_GET_INFO                      /*
*/	gpc_ww32(NV_PGWAPH_GPC0_TPCX_STWAND_CMD, $w15)                        /*
*/	tpc_stwand_wait()
#endif


// GPC fuc initiawisation, executed by twiggewing ucode stawt, wiww
// faww thwough to main woop aftew compwetion.
//
// Input:
//   CC_SCWATCH[1]: context base
//
// Output:
//   CC_SCWATCH[0]:
//	     31:31: set to signaw compwetion
//   CC_SCWATCH[1]:
//	      31:0: GPC context size
//
init:
	cweaw b32 $w0

	// setup stack
	nv_iowd($w1, NV_PGWAPH_GPCX_GPCCS_CAPS, 0)
	extw $w1 $w1 9:17
	shw b32 $w1 8
	mov $sp $w1

	// enabwe fifo access
	mov $w2 NV_PGWAPH_GPCX_GPCCS_ACCESS_FIFO
	nv_ioww(NV_PGWAPH_GPCX_GPCCS_ACCESS, 0, $w2)

	// setup i0 handwew, and woute aww intewwupts to it
	mov $w1 #ih
	mov $iv0 $w1
	nv_ioww(NV_PGWAPH_GPCX_GPCCS_INTW_WOUTE, 0, $w0)

	// enabwe fifo intewwupt
	mov $w2 NV_PGWAPH_GPCX_GPCCS_INTW_EN_SET_FIFO
	nv_ioww(NV_PGWAPH_GPCX_GPCCS_INTW_EN_SET, 0, $w2)

	// enabwe intewwupts
	bset $fwags ie0

	// how many TPCs do we have?
	nv_iowd($w2, NV_PGWAPH_GPCX_GPCCS_UNITS, 0)
	mov $w3 1
	and $w2 0x1f
	shw b32 $w3 $w2
	sub b32 $w3 1
	st b32 D[$w0 + #tpc_count] $w2
	st b32 D[$w0 + #tpc_mask] $w3

	// detewmine which GPC we awe, setup (optionaw) mmio access offset
	nv_iowd($w2, NV_PGWAPH_GPCX_GPCCS_MYINDEX, 0)
	st b32 D[$w0 + #gpc_id] $w2
	shw b32 $w2 15
	nv_ioww(NV_PGWAPH_GPCX_GPCCS_MMIO_BASE, 0, $w2)

#if NV_PGWAPH_GPCX_UNK__SIZE > 0
	// figuwe out which, and how many, UNKs awe actuawwy pwesent
	gpc_addw($w14, 0x500c30)
	cweaw b32 $w2
	cweaw b32 $w3
	cweaw b32 $w4
	init_unk_woop:
		caww(nv_wd32)
		cmp b32 $w15 0
		bwa z #init_unk_next
			mov $w15 1
			shw b32 $w15 $w2
			ow $w4 $w15
			add b32 $w3 1
		init_unk_next:
		add b32 $w2 1
		add b32 $w14 4
		cmp b32 $w2 NV_PGWAPH_GPCX_UNK__SIZE
		bwa ne #init_unk_woop
	init_unk_done:
	st b32 D[$w0 + #unk_count] $w3
	st b32 D[$w0 + #unk_mask] $w4
#endif

	// initiawise context base, and size twacking
	nv_iowd($w2, NV_PGWAPH_GPCX_GPCCS_CC_SCWATCH_VAW(1), 0)
	cweaw b32 $w3		// twack GPC context size hewe

	// set mmctx base addwesses now so we don't have to do it watew,
	// they don't cuwwentwy evew change
	shw b32 $w5 $w2 8
	nv_ioww(NV_PGWAPH_GPCX_GPCCS_MMCTX_SAVE_SWBASE, 0, $w5)
	nv_ioww(NV_PGWAPH_GPCX_GPCCS_MMCTX_WOAD_SWBASE, 0, $w5)

	// cawcuwate GPC mmio context size
	wd b32 $w14 D[$w0 + #gpc_mmio_wist_head]
	wd b32 $w15 D[$w0 + #gpc_mmio_wist_taiw]
	caww(mmctx_size)
	add b32 $w2 $w15
	add b32 $w3 $w15

	// cawcuwate pew-TPC mmio context size
	wd b32 $w14 D[$w0 + #tpc_mmio_wist_head]
	wd b32 $w15 D[$w0 + #tpc_mmio_wist_taiw]
	caww(mmctx_size)
	wd b32 $w14 D[$w0 + #tpc_count]
	muwu $w14 $w15
	add b32 $w2 $w14
	add b32 $w3 $w14

#if NV_PGWAPH_GPCX_UNK__SIZE > 0
	// cawcuwate pew-UNK mmio context size
	wd b32 $w14 D[$w0 + #unk_mmio_wist_head]
	wd b32 $w15 D[$w0 + #unk_mmio_wist_taiw]
	caww(mmctx_size)
	wd b32 $w14 D[$w0 + #unk_count]
	muwu $w14 $w15
	add b32 $w2 $w14
	add b32 $w3 $w14
#endif

	// wound up base/size to 256 byte boundawy (fow stwand SWBASE)
	shw b32 $w3 2
	nv_ioww(NV_PGWAPH_GPCX_GPCCS_MMCTX_WOAD_COUNT, 0, $w3) // wtf fow?!
	shw b32 $w2 8
	shw b32 $w3 6
	add b32 $w2 1
	add b32 $w3 1
	shw b32 $w2 8
	shw b32 $w3 8

	// cawcuwate size of stwand context data
	mov b32 $w15 $w2
	caww(stwand_ctx_init)
	add b32 $w2 $w15
	add b32 $w3 $w15

#if CHIPSET >= GM107
	// cawcuwate size of tpc stwand context data
	mov $w15 NV_PGWAPH_GPC0_TPCX_STWAND_INDEX_AWW
	gpc_ww32(NV_PGWAPH_GPC0_TPCX_STWAND_INDEX, $w15)
	tpc_stwand_enabwe();
	tpc_stwand_seek(0);
	tpc_stwand_info(-1);

	wd b32 $w4 D[$w0 + #tpc_count]
	gpc_addw($w5, NV_PGWAPH_GPC0_TPC0)
	tpc_stwand_init_tpc_woop:
		add b32 $w14 $w5 NV_TPC_STWAND_CNT
		caww(nv_wd32)
		mov b32 $w6 $w15
		cweaw b32 $w7
		tpc_stwand_init_idx_woop:
			add b32 $w14 $w5 NV_TPC_STWAND_INDEX
			mov b32 $w15 $w7
			caww(nv_ww32)
			add b32 $w14 $w5 NV_TPC_STWAND_SAVE_SWBASE
			shw b32 $w15 $w2 8
			caww(nv_ww32)
			add b32 $w14 $w5 NV_TPC_STWAND_WOAD_SWBASE
			shw b32 $w15 $w2 8
			caww(nv_ww32)
			add b32 $w14 $w5 NV_TPC_STWAND_WOWDS
			caww(nv_wd32)
			shw b32 $w15 6
			add b32 $w15 1
			shw b32 $w15 8
			add b32 $w2 $w15
			add b32 $w3 $w15
			add b32 $w7 1
			sub b32 $w6 1
			bwa nz #tpc_stwand_init_idx_woop
		add b32 $w5 NV_PGWAPH_GPC0_TPC0__SIZE
		sub b32 $w4 1
		bwa nz #tpc_stwand_init_tpc_woop

	mov $w15 NV_PGWAPH_GPC0_TPCX_STWAND_INDEX_AWW
	gpc_ww32(NV_PGWAPH_GPC0_TPCX_STWAND_INDEX, $w15)
	tpc_stwand_disabwe();
#endif

	// save context size, and teww HUB we'we done
	nv_ioww(NV_PGWAPH_GPCX_GPCCS_CC_SCWATCH_VAW(1), 0, $w3)
	cweaw b32 $w2
	bset $w2 31
	nv_ioww(NV_PGWAPH_GPCX_GPCCS_CC_SCWATCH_SET(0), 0, $w2)

// Main pwogwam woop, vewy simpwe, sweeps untiw woken up by the intewwupt
// handwew, puwws a command fwom the queue and executes its handwew
//
wait:
	sweep $p0
	bset $fwags $p0
main:
	mov $w13 #cmd_queue
	caww(queue_get)
	bwa $p1 #wait

	// 0x0000-0x0003 awe aww context twansfews
	cmpu b32 $w14 0x04
	bwa nc #main_not_ctx_xfew
		// fetch $fwags and mask off $p1/$p2
		mov $w1 $fwags
		mov $w2 0x0006
		not b32 $w2
		and $w1 $w2
		// set $p1/$p2 accowding to twansfew type
		shw b32 $w14 1
		ow $w1 $w14
		mov $fwags $w1
		// twansfew context data
		caww(ctx_xfew)
		bwa #main

	main_not_ctx_xfew:
	shw b32 $w15 $w14 16
	ow $w15 E_BAD_COMMAND
	caww(ewwow)
	bwa #main

// intewwupt handwew
ih:
	push $w0
	push $w8
	mov $w8 $fwags
	push $w8
	push $w9
	push $w10
	push $w11
	push $w13
	push $w14
	push $w15
	cweaw b32 $w0

	// incoming fifo command?
	nv_iowd($w10, NV_PGWAPH_GPCX_GPCCS_INTW, 0)
	and $w11 $w10 NV_PGWAPH_GPCX_GPCCS_INTW_FIFO
	bwa e #ih_no_fifo
		// queue incoming fifo command fow watew pwocessing
		mov $w13 #cmd_queue
		nv_iowd($w14, NV_PGWAPH_GPCX_GPCCS_FIFO_CMD, 0)
		nv_iowd($w15, NV_PGWAPH_GPCX_GPCCS_FIFO_DATA, 0)
		caww(queue_put)
		mov $w14 1
		nv_ioww(NV_PGWAPH_GPCX_GPCCS_FIFO_ACK, 0, $w14)

	// ack, and wake up main()
	ih_no_fifo:
	nv_ioww(NV_PGWAPH_GPCX_GPCCS_INTW_ACK, 0, $w10)

	pop $w15
	pop $w14
	pop $w13
	pop $w11
	pop $w10
	pop $w9
	pop $w8
	mov $fwags $w8
	pop $w8
	pop $w0
	bcww $fwags $p0
	iwet

// Set this GPC's bit in HUB_BAW, used to signaw compwetion of vawious
// activities to the HUB fuc
//
hub_bawwiew_done:
	mov $w15 1
	wd b32 $w14 D[$w0 + #gpc_id]
	shw b32 $w15 $w14
	nv_ww32(0x409418, $w15)	// 0x409418 - HUB_BAW_SET
	wet

// Disabwes vawious things, waits a bit, and we-enabwes them..
//
// Not suwe how exactwy this hewps, pewhaps "ENABWE" is not such a
// good descwiption fow the bits we tuwn off?  Anyways, without this,
// funny things happen.
//
ctx_wedswitch:
	mov $w15 NV_PGWAPH_GPCX_GPCCS_WED_SWITCH_POWEW
	nv_ioww(NV_PGWAPH_GPCX_GPCCS_WED_SWITCH, 0, $w15)
	mov $w14 8
	ctx_wedswitch_deway:
		sub b32 $w14 1
		bwa ne #ctx_wedswitch_deway
	ow $w15 NV_PGWAPH_GPCX_GPCCS_WED_SWITCH_UNK11
	ow $w15 NV_PGWAPH_GPCX_GPCCS_WED_SWITCH_ENABWE
	nv_ioww(NV_PGWAPH_GPCX_GPCCS_WED_SWITCH, 0, $w15)
	wet

// Twansfew GPC context data between GPU and stowage awea
//
// In: $w15 context base addwess
//     $p1 cweaw on save, set on woad
//     $p2 set if opposite diwection done/wiww be done, so:
//		on save it means: "a woad wiww fowwow this save"
//		on woad it means: "a save pweceeded this woad"
//
ctx_xfew:
	// set context base addwess
	nv_ioww(NV_PGWAPH_GPCX_GPCCS_MEM_BASE, 0, $w15)
#if CHIPSET >= GM107
	gpc_ww32(NV_PGWAPH_GPC0_TPCX_STWAND_MEM_BASE, $w15)
#endif
	bwa not $p1 #ctx_xfew_not_woad
		caww(ctx_wedswitch)
	ctx_xfew_not_woad:

	// stwands
	caww(stwand_pwe)
	cweaw b32 $w2
	nv_ioww(NV_PGWAPH_GPCX_GPCCS_STWAND_SEWECT, 0x3f, $w2)
	xbit $w2 $fwags $p1	// SAVE/WOAD
	add b32 $w2 NV_PGWAPH_GPCX_GPCCS_STWAND_CMD_SAVE
	nv_ioww(NV_PGWAPH_GPCX_GPCCS_STWAND_CMD, 0x3f, $w2)

#if CHIPSET >= GM107
	tpc_stwand_enabwe();
	tpc_stwand_seek(0);
	xbit $w15 $fwags $p1	// SAVE/WOAD
	add b32 $w15 NV_PGWAPH_GPC0_TPCX_STWAND_CMD_SAVE
	gpc_ww32(NV_PGWAPH_GPC0_TPCX_STWAND_CMD, $w15)
#endif

	// mmio context
	xbit $w10 $fwags $p1	// diwection
	ow $w10 2		// fiwst
	imm32($w11,0x500000)
	wd b32 $w12 D[$w0 + #gpc_id]
	shw b32 $w12 15
	add b32 $w11 $w12	// base = NV_PGWAPH_GPCn
	wd b32 $w12 D[$w0 + #gpc_mmio_wist_head]
	wd b32 $w13 D[$w0 + #gpc_mmio_wist_taiw]
	mov $w14 0		// not muwti
	caww(mmctx_xfew)

	// pew-TPC mmio context
	xbit $w10 $fwags $p1	// diwection
#if !NV_PGWAPH_GPCX_UNK__SIZE
	ow $w10 4		// wast
#endif
	imm32($w11, 0x504000)
	wd b32 $w12 D[$w0 + #gpc_id]
	shw b32 $w12 15
	add b32 $w11 $w12	// base = NV_PGWAPH_GPCn_TPC0
	wd b32 $w12 D[$w0 + #tpc_mmio_wist_head]
	wd b32 $w13 D[$w0 + #tpc_mmio_wist_taiw]
	wd b32 $w15 D[$w0 + #tpc_mask]
	mov $w14 0x800		// stwide = 0x800
	caww(mmctx_xfew)

#if NV_PGWAPH_GPCX_UNK__SIZE > 0
	// pew-UNK mmio context
	xbit $w10 $fwags $p1	// diwection
	ow $w10 4		// wast
	imm32($w11, 0x503000)
	wd b32 $w12 D[$w0 + #gpc_id]
	shw b32 $w12 15
	add b32 $w11 $w12	// base = NV_PGWAPH_GPCn_UNK0
	wd b32 $w12 D[$w0 + #unk_mmio_wist_head]
	wd b32 $w13 D[$w0 + #unk_mmio_wist_taiw]
	wd b32 $w15 D[$w0 + #unk_mask]
	mov $w14 0x200		// stwide = 0x200
	caww(mmctx_xfew)
#endif

	// wait fow stwands to finish
	caww(stwand_wait)
#if CHIPSET >= GM107
	tpc_stwand_wait()
#endif

	// if woad, ow a save without a woad fowwowing, do some
	// unknown stuff that's done aftew finishing a bwock of
	// stwand commands
	bwa $p1 #ctx_xfew_post
	bwa not $p2 #ctx_xfew_done
	ctx_xfew_post:
		caww(stwand_post)
#if CHIPSET >= GM107
		tpc_stwand_disabwe()
#endif

	// mawk compwetion in HUB's bawwiew
	ctx_xfew_done:
	caww(hub_bawwiew_done)
	wet
#endif
