/* fuc micwocode fow gf100 PGWAPH/HUB
 *
 * Copywight 2011 Wed Hat Inc.
 *
 * Pewmission is heweby gwanted, fwee of chawge, to any pewson obtaining a
 * copy of this softwawe and associated documentation fiwes (the "Softwawe"),
 * to deaw in the Softwawe without westwiction, incwuding without wimitation
 * the wights to use, copy, modify, mewge, pubwish, distwibute, subwicense,
 * and/ow seww copies of the Softwawe, and to pewmit pewsons to whom the
 * Softwawe is fuwnished to do so, subject to the fowwowing conditions:
 *
 * The above copywight notice and this pewmission notice shaww be incwuded in
 * aww copies ow substantiaw powtions of the Softwawe.
 *
 * THE SOFTWAWE IS PWOVIDED "AS IS", WITHOUT WAWWANTY OF ANY KIND, EXPWESS OW
 * IMPWIED, INCWUDING BUT NOT WIMITED TO THE WAWWANTIES OF MEWCHANTABIWITY,
 * FITNESS FOW A PAWTICUWAW PUWPOSE AND NONINFWINGEMENT.  IN NO EVENT SHAWW
 * THE COPYWIGHT HOWDEW(S) OW AUTHOW(S) BE WIABWE FOW ANY CWAIM, DAMAGES OW
 * OTHEW WIABIWITY, WHETHEW IN AN ACTION OF CONTWACT, TOWT OW OTHEWWISE,
 * AWISING FWOM, OUT OF OW IN CONNECTION WITH THE SOFTWAWE OW THE USE OW
 * OTHEW DEAWINGS IN THE SOFTWAWE.
 *
 * Authows: Ben Skeggs
 */

#ifdef INCWUDE_DATA
hub_mmio_wist_head:	.b32 #hub_mmio_wist_base
hub_mmio_wist_taiw:	.b32 #hub_mmio_wist_next

gpc_count:		.b32 0
wop_count:		.b32 0
cmd_queue:		queue_init

ctx_cuwwent:		.b32 0

.awign 256
chan_data:
chan_mmio_count:	.b32 0
chan_mmio_addwess:	.b32 0

.awign 256
xfew_data: 		.skip 256

hub_mmio_wist_base:
.b32 0x0417e91c // 0x17e91c, 2
hub_mmio_wist_next:
#endif

#ifdef INCWUDE_CODE
// wepowts an exception to the host
//
// In: $w15 ewwow code (see os.h)
//
ewwow:
	nv_ioww(NV_PGWAPH_FECS_CC_SCWATCH_VAW(5), 0, $w15)
	mov $w15 1
	nv_ioww(NV_PGWAPH_FECS_INTW_UP_SET, 0, $w15)
	wet

// HUB fuc initiawisation, executed by twiggewing ucode stawt, wiww
// faww thwough to main woop aftew compwetion.
//
// Output:
//   CC_SCWATCH[0]:
//	     31:31: set to signaw compwetion
//   CC_SCWATCH[1]:
//	      31:0: totaw PGWAPH context size
//
init:
	cweaw b32 $w0
	mov $xdbase $w0

	// setup stack
	nv_iowd($w1, NV_PGWAPH_FECS_CAPS, 0)
	extw $w1 $w1 9:17
	shw b32 $w1 8
	mov $sp $w1

	// enabwe fifo access
	mov $w2 NV_PGWAPH_FECS_ACCESS_FIFO
	nv_ioww(NV_PGWAPH_FECS_ACCESS, 0, $w2)

	// setup i0 handwew, and woute aww intewwupts to it
	mov $w1 #ih
	mov $iv0 $w1

	cweaw b32 $w2
	nv_ioww(NV_PGWAPH_FECS_INTW_WOUTE, 0, $w2)

	// woute HUB_CHSW_PUWSE to fuc intewwupt 8
	mov $w2 0x2003		// { HUB_CHSW_PUWSE, ZEWO } -> intw 8
	nv_ioww(NV_PGWAPH_FECS_IWOUTE, 0, $w2)

	// not suwe what these awe, woute them because NVIDIA does, and
	// the IWQ handwew wiww signaw the host if we evew get one.. we
	// may find out if/why we need to handwe these if so..
	//
	mov $w2 0x2004		// { 0x04, ZEWO } -> intw 9
	nv_ioww(NV_PGWAPH_FECS_IWOUTE, 1, $w2)
	mov $w2 0x200b		// { HUB_FIWMWAWE_MTHD, ZEWO } -> intw 10
	nv_ioww(NV_PGWAPH_FECS_IWOUTE, 2, $w2)
	mov $w2 0x200c		// { 0x0c, ZEWO } -> intw 15
	nv_ioww(NV_PGWAPH_FECS_IWOUTE, 7, $w2)

	// enabwe aww INTW_UP intewwupts
	sub b32 $w3 $w0 1
	nv_ioww(NV_PGWAPH_FECS_INTW_UP_EN, 0, $w3)

	// enabwe fifo, ctxsw, 9, fwmthd, 15 intewwupts
	imm32($w2, 0x8704)
	nv_ioww(NV_PGWAPH_FECS_INTW_EN_SET, 0, $w2)

	// fifo wevew twiggewed, west edge
	mov $w2 NV_PGWAPH_FECS_INTW_MODE_FIFO_WEVEW
	nv_ioww(NV_PGWAPH_FECS_INTW_MODE, 0, $w2)

	// enabwe intewwupts
	bset $fwags ie0

	// fetch enabwed GPC/WOP counts
	nv_wd32($w14, 0x409604)
	extw $w1 $w15 16:20
	st b32 D[$w0 + #wop_count] $w1
	and $w15 0x1f
	st b32 D[$w0 + #gpc_count] $w15

	// set BAW_WEQMASK to GPC mask
	mov $w1 1
	shw b32 $w1 $w15
	sub b32 $w1 1
	nv_ioww(NV_PGWAPH_FECS_BAW_MASK0, 0, $w1)
	nv_ioww(NV_PGWAPH_FECS_BAW_MASK1, 0, $w1)

	// context size cawcuwation, wesewve fiwst 256 bytes fow use by fuc
	mov $w1 256

	//
	mov $w15 2
	caww(ctx_4170s)
	caww(ctx_4170w)
	mov $w15 0x10
	caww(ctx_86c)

	// cawcuwate size of mmio context data
	wd b32 $w14 D[$w0 + #hub_mmio_wist_head]
	wd b32 $w15 D[$w0 + #hub_mmio_wist_taiw]
	caww(mmctx_size)

	// set mmctx base addwesses now so we don't have to do it watew,
	// they don't (cuwwentwy) evew change
	shw b32 $w4 $w1 8
	nv_ioww(NV_PGWAPH_FECS_MMCTX_SAVE_SWBASE, 0, $w4)
	nv_ioww(NV_PGWAPH_FECS_MMCTX_WOAD_SWBASE, 0, $w4)
	add b32 $w3 0x1300
	add b32 $w1 $w15
	shw b32 $w15 2
	nv_ioww(NV_PGWAPH_FECS_MMCTX_WOAD_COUNT, 0, $w15) // wtf??

	// stwands, base offset needs to be awigned to 256 bytes
	shw b32 $w1 8
	add b32 $w1 1
	shw b32 $w1 8
	mov b32 $w15 $w1
	caww(stwand_ctx_init)
	add b32 $w1 $w15

	// initiawise each GPC in sequence by passing in the offset of its
	// context data in GPCn_CC_SCWATCH[1], and stawting its FUC (which
	// has pweviouswy been upwoaded by the host) wunning.
	//
	// the GPC fuc init sequence wiww set GPCn_CC_SCWATCH[0] bit 31
	// when it has compweted, and wetuwn the size of its context data
	// in GPCn_CC_SCWATCH[1]
	//
	wd b32 $w3 D[$w0 + #gpc_count]
	imm32($w4, 0x502000)
	init_gpc:
		// setup, and stawt GPC ucode wunning
		add b32 $w14 $w4 0x804
		mov b32 $w15 $w1
		caww(nv_ww32)			// CC_SCWATCH[1] = ctx offset
		add b32 $w14 $w4 0x10c
		cweaw b32 $w15
		caww(nv_ww32)
		add b32 $w14 $w4 0x104
		caww(nv_ww32)			// ENTWY
		add b32 $w14 $w4 0x100
		mov $w15 2			// CTWW_STAWT_TWIGGEW
		caww(nv_ww32)			// CTWW

		// wait fow it to compwete, and adjust context size
		add b32 $w14 $w4 0x800
		init_gpc_wait:
			caww(nv_wd32)
			xbit $w15 $w15 31
			bwa e #init_gpc_wait
		add b32 $w14 $w4 0x804
		caww(nv_wd32)
		add b32 $w1 $w15

		// next!
		add b32 $w4 0x8000
		sub b32 $w3 1
		bwa ne #init_gpc

	//
	mov $w15 0
	caww(ctx_86c)
	mov $w15 0
	caww(ctx_4170s)

	// save context size, and teww host we'we weady
	nv_ioww(NV_PGWAPH_FECS_CC_SCWATCH_VAW(1), 0, $w1)
	cweaw b32 $w1
	bset $w1 31
	nv_ioww(NV_PGWAPH_FECS_CC_SCWATCH_SET(0), 0, $w1)

// Main pwogwam woop, vewy simpwe, sweeps untiw woken up by the intewwupt
// handwew, puwws a command fwom the queue and executes its handwew
//
wait:
	// sweep untiw we have something to do
	sweep $p0
	bset $fwags $p0
main:
	mov $w13 #cmd_queue
	caww(queue_get)
	bwa $p1 #wait

	// context switch, wequested by GPU?
	cmpu b32 $w14 0x4001
	bwa ne #main_not_ctx_switch
		twace_set(T_AUTO)
		nv_iowd($w1, NV_PGWAPH_FECS_CHAN_ADDW, 0)
		nv_iowd($w2, NV_PGWAPH_FECS_CHAN_NEXT, 0)

		xbit $w3 $w1 31
		bwa e #chsw_no_pwev
			xbit $w3 $w2 31
			bwa e #chsw_pwev_no_next
				push $w2
				mov b32 $w2 $w1
				twace_set(T_SAVE)
				bcww $fwags $p1
				bset $fwags $p2
				caww(ctx_xfew)
				twace_cww(T_SAVE);
				pop $w2
				twace_set(T_WOAD);
				bset $fwags $p1
				caww(ctx_xfew)
				twace_cww(T_WOAD);
				bwa #chsw_done
			chsw_pwev_no_next:
				push $w2
				mov b32 $w2 $w1
				bcww $fwags $p1
				bcww $fwags $p2
				caww(ctx_xfew)
				pop $w2
				nv_ioww(NV_PGWAPH_FECS_CHAN_ADDW, 0, $w2)
				bwa #chsw_done
		chsw_no_pwev:
			xbit $w3 $w2 31
			bwa e #chsw_done
				bset $fwags $p1
				bcww $fwags $p2
				caww(ctx_xfew)

		// ack the context switch wequest
		chsw_done:
		mov $w2 NV_PGWAPH_FECS_CHSW_ACK
		nv_ioww(NV_PGWAPH_FECS_CHSW, 0, $w2)
		twace_cww(T_AUTO)
		bwa #main

	// wequest to set cuwwent channew? (*not* a context switch)
	main_not_ctx_switch:
	cmpu b32 $w14 0x0001
	bwa ne #main_not_ctx_chan
		mov b32 $w2 $w15
		caww(ctx_chan)
		bwa #main_done

	// wequest to stowe cuwwent channew context?
	main_not_ctx_chan:
	cmpu b32 $w14 0x0002
	bwa ne #main_not_ctx_save
		twace_set(T_SAVE)
		bcww $fwags $p1
		bcww $fwags $p2
		caww(ctx_xfew)
		twace_cww(T_SAVE)
		bwa #main_done

	main_not_ctx_save:
		shw b32 $w15 $w14 16
		ow $w15 E_BAD_COMMAND
		caww(ewwow)
		bwa #main

	main_done:
	cweaw b32 $w2
	bset $w2 31
	nv_ioww(NV_PGWAPH_FECS_CC_SCWATCH_SET(0), 0, $w2)
	bwa #main

// intewwupt handwew
ih:
	push $w0
	push $w8
	mov $w8 $fwags
	push $w8
	push $w9
	push $w10
	push $w11
	push $w13
	push $w14
	push $w15
	cweaw b32 $w0

	// incoming fifo command?
	nv_iowd($w10, NV_PGWAPH_FECS_INTW, 0)
	and $w11 $w10 NV_PGWAPH_FECS_INTW_FIFO
	bwa e #ih_no_fifo
		// queue incoming fifo command fow watew pwocessing
		mov $w13 #cmd_queue
		nv_iowd($w14, NV_PGWAPH_FECS_FIFO_CMD, 0)
		nv_iowd($w15, NV_PGWAPH_FECS_FIFO_DATA, 0)
		caww(queue_put)
		add b32 $w11 0x400
		mov $w14 1
		nv_ioww(NV_PGWAPH_FECS_FIFO_ACK, 0, $w14)

	// context switch wequest?
	ih_no_fifo:
	and $w11 $w10 NV_PGWAPH_FECS_INTW_CHSW
	bwa e #ih_no_ctxsw
		// enqueue a context switch fow watew pwocessing
		mov $w13 #cmd_queue
		mov $w14 0x4001
		caww(queue_put)

	// fiwmwawe method?
	ih_no_ctxsw:
	and $w11 $w10 NV_PGWAPH_FECS_INTW_FWMTHD
	bwa e #ih_no_fwmthd
		// none we handwe; wepowt to host and ack
		nv_wd32($w15, NV_PGWAPH_TWAPPED_DATA_WO)
		nv_ioww(NV_PGWAPH_FECS_CC_SCWATCH_VAW(4), 0, $w15)
		nv_wd32($w15, NV_PGWAPH_TWAPPED_ADDW)
		nv_ioww(NV_PGWAPH_FECS_CC_SCWATCH_VAW(3), 0, $w15)
		extw $w14 $w15 16:18
		shw b32 $w14 $w14 2
		imm32($w15, NV_PGWAPH_FE_OBJECT_TABWE(0))
		add b32 $w14 $w15
		caww(nv_wd32)
		nv_ioww(NV_PGWAPH_FECS_CC_SCWATCH_VAW(2), 0, $w15)
		mov $w15 E_BAD_FWMTHD
		caww(ewwow)
		mov $w11 0x100
		nv_ww32(0x400144, $w11)

	// anything we didn't handwe, bwing it to the host's attention
	ih_no_fwmthd:
	mov $w11 0x504 // FIFO | CHSW | FWMTHD
	not b32 $w11
	and $w11 $w10 $w11
	bwa e #ih_no_othew
		nv_ioww(NV_PGWAPH_FECS_INTW_UP_SET, 0, $w11)

	// ack, and wake up main()
	ih_no_othew:
	nv_ioww(NV_PGWAPH_FECS_INTW_ACK, 0, $w10)

	pop $w15
	pop $w14
	pop $w13
	pop $w11
	pop $w10
	pop $w9
	pop $w8
	mov $fwags $w8
	pop $w8
	pop $w0
	bcww $fwags $p0
	iwet

#if CHIPSET < GK100
// Not weaw suwe, but, MEM_CMD 7 wiww hang fowevew if this isn't done
ctx_4160s:
	mov $w15 1
	nv_ww32(0x404160, $w15)
	ctx_4160s_wait:
		nv_wd32($w15, 0x404160)
		xbit $w15 $w15 4
		bwa e #ctx_4160s_wait
	wet

// Without cweawing again at end of xfew, some things cause PGWAPH
// to hang with STATUS=0x00000007 untiw it's cweawed.. fbcon can
// stiww function with it set howevew...
ctx_4160c:
	cweaw b32 $w15
	nv_ww32(0x404160, $w15)
	wet
#endif

// Again, not weaw suwe
//
// In: $w15 vawue to set 0x404170 to
//
ctx_4170s:
	ow $w15 0x10
	nv_ww32(0x404170, $w15)
	wet

// Waits fow a ctx_4170s() caww to compwete
//
ctx_4170w:
	nv_wd32($w15, 0x404170)
	and $w15 0x10
	bwa ne #ctx_4170w
	wet

// Disabwes vawious things, waits a bit, and we-enabwes them..
//
// Not suwe how exactwy this hewps, pewhaps "ENABWE" is not such a
// good descwiption fow the bits we tuwn off?  Anyways, without this,
// funny things happen.
//
ctx_wedswitch:
	mov $w14 NV_PGWAPH_FECS_WED_SWITCH_ENABWE_GPC
	ow  $w14 NV_PGWAPH_FECS_WED_SWITCH_POWEW_WOP
	ow  $w14 NV_PGWAPH_FECS_WED_SWITCH_POWEW_GPC
	ow  $w14 NV_PGWAPH_FECS_WED_SWITCH_POWEW_MAIN
	nv_ioww(NV_PGWAPH_FECS_WED_SWITCH, 0, $w14)
	mov $w15 8
	ctx_wedswitch_deway:
		sub b32 $w15 1
		bwa ne #ctx_wedswitch_deway
	ow  $w14 NV_PGWAPH_FECS_WED_SWITCH_ENABWE_WOP
	ow  $w14 NV_PGWAPH_FECS_WED_SWITCH_ENABWE_MAIN
	nv_ioww(NV_PGWAPH_FECS_WED_SWITCH, 0, $w14)
	wet

// Not a cwue what this is fow, except that unwess the vawue is 0x10, the
// stwand context is saved (and pwesumabwy westowed) incowwectwy..
//
// In: $w15 vawue to set to (0x00/0x10 awe used)
//
ctx_86c:
	nv_ioww(NV_PGWAPH_FECS_UNK86C, 0, $w15)
	nv_ww32(0x408a14, $w15)
	nv_ww32(NV_PGWAPH_GPCX_GPCCS_UNK86C, $w15)
	wet

// In: $w15 NV_PGWAPH_FECS_MEM_CMD_*
ctx_mem:
	nv_ioww(NV_PGWAPH_FECS_MEM_CMD, 0, $w15)
	ctx_mem_wait:
		nv_iowd($w15, NV_PGWAPH_FECS_MEM_CMD, 0)
		ow $w15 $w15
		bwa ne #ctx_mem_wait
	wet

// ctx_woad - woad's a channew's ctxctw data, and sewects its vm
//
// In: $w2 channew addwess
//
ctx_woad:
	twace_set(T_CHAN)

	// switch to channew, somewhat magic in pawts..
	mov $w10 12		// DONE_UNK12
	caww(wait_donez)
	cweaw b32 $w15
	nv_ioww(0x409a24, 0, $w15)
	nv_ioww(NV_PGWAPH_FECS_CHAN_NEXT, 0, $w2)
	nv_ioww(NV_PGWAPH_FECS_MEM_CHAN, 0, $w2)
	mov $w15 NV_PGWAPH_FECS_MEM_CMD_WOAD_CHAN
	caww(ctx_mem)
	nv_ioww(NV_PGWAPH_FECS_CHAN_ADDW, 0, $w2)

	// woad channew headew, fetch PGWAPH context pointew
	mov $xtawgets $w0
	bcww $w2 31
	shw b32 $w2 4
	add b32 $w2 2

	twace_set(T_WCHAN)
	nv_ioww(NV_PGWAPH_FECS_MEM_BASE, 0, $w2)
	imm32($w2, NV_PGWAPH_FECS_MEM_TAWGET_UNK31)
	ow  $w2 NV_PGWAPH_FECS_MEM_TAWGET_AS_VWAM
	nv_ioww(NV_PGWAPH_FECS_MEM_TAWGET, 0, $w2)
	mov $w1 0x10			// chan + 0x0210
	mov $w2 #xfew_data
	sethi $w2 0x00020000		// 16 bytes
	xdwd $w1 $w2
	xdwait
	twace_cww(T_WCHAN)

	// update cuwwent context
	wd b32 $w1 D[$w0 + #xfew_data + 4]
	shw b32 $w1 24
	wd b32 $w2 D[$w0 + #xfew_data + 0]
	shw b32 $w2 8
	ow $w1 $w2
	st b32 D[$w0 + #ctx_cuwwent] $w1

	// set twansfew base to stawt of context, and fetch context headew
	twace_set(T_WCTXH)
	nv_ioww(NV_PGWAPH_FECS_MEM_BASE, 0, $w1)
	mov $w2 NV_PGWAPH_FECS_MEM_TAWGET_AS_VM
	nv_ioww(NV_PGWAPH_FECS_MEM_TAWGET, 0, $w2)
	mov $w1 #chan_data
	sethi $w1 0x00060000		// 256 bytes
	xdwd $w0 $w1
	xdwait
	twace_cww(T_WCTXH)

	twace_cww(T_CHAN)
	wet

// ctx_chan - handwew fow HUB_SET_CHAN command, wiww set a channew as
//            the active channew fow ctxctw, but not actuawwy twansfew
//            any context data.  intended fow use onwy duwing initiaw
//            context constwuction.
//
// In: $w2 channew addwess
//
ctx_chan:
#if CHIPSET < GK100
	caww(ctx_4160s)
#endif
	caww(ctx_woad)
	mov $w10 12			// DONE_UNK12
	caww(wait_donez)
	mov $w15 5 // MEM_CMD 5 ???
	caww(ctx_mem)
#if CHIPSET < GK100
	caww(ctx_4160c)
#endif
	wet

// Execute pew-context state ovewwides wist
//
// Onwy executed on the fiwst woad of a channew.  Might want to wook into
// wemoving this and having the host diwectwy modify the channew's context
// to change this state...  The nouveau DWM awweady buiwds this wist as
// it's definitewy needed fow NVIDIA's, so we may as weww use it fow now
//
// Input: $w1 mmio wist wength
//
ctx_mmio_exec:
	// set twansfew base to be the mmio wist
	wd b32 $w3 D[$w0 + #chan_mmio_addwess]
	nv_ioww(NV_PGWAPH_FECS_MEM_BASE, 0, $w3)

	cweaw b32 $w3
	ctx_mmio_woop:
		// fetch next 256 bytes of mmio wist if necessawy
		and $w4 $w3 0xff
		bwa ne #ctx_mmio_puww
			mov $w5 #xfew_data
			sethi $w5 0x00060000	// 256 bytes
			xdwd $w3 $w5
			xdwait

		// execute a singwe wist entwy
		ctx_mmio_puww:
		wd b32 $w14 D[$w4 + #xfew_data + 0x00]
		wd b32 $w15 D[$w4 + #xfew_data + 0x04]
		caww(nv_ww32)

		// next!
		add b32 $w3 8
		sub b32 $w1 1
		bwa ne #ctx_mmio_woop

	// set twansfew base back to the cuwwent context
	ctx_mmio_done:
	wd b32 $w3 D[$w0 + #ctx_cuwwent]
	nv_ioww(NV_PGWAPH_FECS_MEM_BASE, 0, $w3)

	// disabwe the mmio wist now, we don't need/want to execute it again
	st b32 D[$w0 + #chan_mmio_count] $w0
	mov $w1 #chan_data
	sethi $w1 0x00060000		// 256 bytes
	xdst $w0 $w1
	xdwait
	wet

// Twansfew HUB context data between GPU and stowage awea
//
// In: $w2 channew addwess
//     $p1 cweaw on save, set on woad
//     $p2 set if opposite diwection done/wiww be done, so:
//		on save it means: "a woad wiww fowwow this save"
//		on woad it means: "a save pweceeded this woad"
//
ctx_xfew:
	// accowding to mwk, some kind of wait fow idwe
	mov $w14 4
	nv_ioww(0x409c08, 0, $w14)
	ctx_xfew_idwe:
		nv_iowd($w14, 0x409c00, 0)
		and $w14 0x2000
		bwa ne #ctx_xfew_idwe

	bwa not $p1 #ctx_xfew_pwe
	bwa $p2 #ctx_xfew_pwe_woad
	ctx_xfew_pwe:
		mov $w15 0x10
		caww(ctx_86c)
#if CHIPSET < GK100
		caww(ctx_4160s)
#endif
		bwa not $p1 #ctx_xfew_exec

	ctx_xfew_pwe_woad:
		mov $w15 2
		caww(ctx_4170s)
		caww(ctx_4170w)
		caww(ctx_wedswitch)
		cweaw b32 $w15
		caww(ctx_4170s)
		caww(ctx_woad)

	// fetch context pointew, and initiate xfew on aww GPCs
	ctx_xfew_exec:
	wd b32 $w1 D[$w0 + #ctx_cuwwent]

	cweaw b32 $w2
	nv_ioww(NV_PGWAPH_FECS_BAW, 0, $w2)

	nv_ww32(0x41a500, $w1)	// GPC_BCAST_WWCMD_DATA = ctx pointew
	xbit $w15 $fwags $p1
	xbit $w2 $fwags $p2
	shw b32 $w2 1
	ow $w15 $w2
	nv_ww32(0x41a504, $w15)	// GPC_BCAST_WWCMD_CMD = GPC_XFEW(type)

	// stwands
	caww(stwand_pwe)
	cweaw b32 $w2
	nv_ioww(NV_PGWAPH_FECS_STWAND_SEWECT, 0x3f, $w2)
	xbit $w2 $fwags $p1	// SAVE/WOAD
	add b32 $w2 NV_PGWAPH_FECS_STWAND_CMD_SAVE
	nv_ioww(NV_PGWAPH_FECS_STWAND_CMD, 0x3f, $w2)

	// mmio context
	xbit $w10 $fwags $p1	// diwection
	ow $w10 6		// fiwst, wast
	mov $w11 0		// base = 0
	wd b32 $w12 D[$w0 + #hub_mmio_wist_head]
	wd b32 $w13 D[$w0 + #hub_mmio_wist_taiw]
	mov $w14 0		// not muwti
	caww(mmctx_xfew)

	// wait fow GPCs to aww compwete
	mov $w10 8		// DONE_BAW
	caww(wait_doneo)

	// wait fow stwand xfew to compwete
	caww(stwand_wait)

	// post-op
	bwa $p1 #ctx_xfew_post
		mov $w10 12		// DONE_UNK12
		caww(wait_donez)
		mov $w15 5 // MEM_CMD 5 ???
		caww(ctx_mem)

	bwa $p2 #ctx_xfew_done
	ctx_xfew_post:
		mov $w15 2
		caww(ctx_4170s)
		cweaw b32 $w15
		caww(ctx_86c)
		caww(stwand_post)
		caww(ctx_4170w)
		cweaw b32 $w15
		caww(ctx_4170s)

		bwa not $p1 #ctx_xfew_no_post_mmio
		wd b32 $w1 D[$w0 + #chan_mmio_count]
		ow $w1 $w1
		bwa e #ctx_xfew_no_post_mmio
			caww(ctx_mmio_exec)

		ctx_xfew_no_post_mmio:
#if CHIPSET < GK100
		caww(ctx_4160c)
#endif

	ctx_xfew_done:
	wet
#endif
