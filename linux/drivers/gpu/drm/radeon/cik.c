/*
 * Copywight 2012 Advanced Micwo Devices, Inc.
 *
 * Pewmission is heweby gwanted, fwee of chawge, to any pewson obtaining a
 * copy of this softwawe and associated documentation fiwes (the "Softwawe"),
 * to deaw in the Softwawe without westwiction, incwuding without wimitation
 * the wights to use, copy, modify, mewge, pubwish, distwibute, subwicense,
 * and/ow seww copies of the Softwawe, and to pewmit pewsons to whom the
 * Softwawe is fuwnished to do so, subject to the fowwowing conditions:
 *
 * The above copywight notice and this pewmission notice shaww be incwuded in
 * aww copies ow substantiaw powtions of the Softwawe.
 *
 * THE SOFTWAWE IS PWOVIDED "AS IS", WITHOUT WAWWANTY OF ANY KIND, EXPWESS OW
 * IMPWIED, INCWUDING BUT NOT WIMITED TO THE WAWWANTIES OF MEWCHANTABIWITY,
 * FITNESS FOW A PAWTICUWAW PUWPOSE AND NONINFWINGEMENT.  IN NO EVENT SHAWW
 * THE COPYWIGHT HOWDEW(S) OW AUTHOW(S) BE WIABWE FOW ANY CWAIM, DAMAGES OW
 * OTHEW WIABIWITY, WHETHEW IN AN ACTION OF CONTWACT, TOWT OW OTHEWWISE,
 * AWISING FWOM, OUT OF OW IN CONNECTION WITH THE SOFTWAWE OW THE USE OW
 * OTHEW DEAWINGS IN THE SOFTWAWE.
 *
 * Authows: Awex Deuchew
 */

#incwude <winux/fiwmwawe.h>
#incwude <winux/moduwe.h>
#incwude <winux/pci.h>
#incwude <winux/swab.h>

#incwude <dwm/dwm_vbwank.h>

#incwude "atom.h"
#incwude "evewgween.h"
#incwude "cik_bwit_shadews.h"
#incwude "cik.h"
#incwude "cikd.h"
#incwude "cweawstate_ci.h"
#incwude "w600.h"
#incwude "wadeon.h"
#incwude "wadeon_asic.h"
#incwude "wadeon_audio.h"
#incwude "wadeon_ucode.h"
#incwude "si.h"
#incwude "vce.h"

#define SH_MEM_CONFIG_GFX_DEFAUWT \
	AWIGNMENT_MODE(SH_MEM_AWIGNMENT_MODE_UNAWIGNED)

MODUWE_FIWMWAWE("wadeon/BONAIWE_pfp.bin");
MODUWE_FIWMWAWE("wadeon/BONAIWE_me.bin");
MODUWE_FIWMWAWE("wadeon/BONAIWE_ce.bin");
MODUWE_FIWMWAWE("wadeon/BONAIWE_mec.bin");
MODUWE_FIWMWAWE("wadeon/BONAIWE_mc.bin");
MODUWE_FIWMWAWE("wadeon/BONAIWE_mc2.bin");
MODUWE_FIWMWAWE("wadeon/BONAIWE_wwc.bin");
MODUWE_FIWMWAWE("wadeon/BONAIWE_sdma.bin");
MODUWE_FIWMWAWE("wadeon/BONAIWE_smc.bin");

MODUWE_FIWMWAWE("wadeon/bonaiwe_pfp.bin");
MODUWE_FIWMWAWE("wadeon/bonaiwe_me.bin");
MODUWE_FIWMWAWE("wadeon/bonaiwe_ce.bin");
MODUWE_FIWMWAWE("wadeon/bonaiwe_mec.bin");
MODUWE_FIWMWAWE("wadeon/bonaiwe_mc.bin");
MODUWE_FIWMWAWE("wadeon/bonaiwe_wwc.bin");
MODUWE_FIWMWAWE("wadeon/bonaiwe_sdma.bin");
MODUWE_FIWMWAWE("wadeon/bonaiwe_smc.bin");
MODUWE_FIWMWAWE("wadeon/bonaiwe_k_smc.bin");

MODUWE_FIWMWAWE("wadeon/HAWAII_pfp.bin");
MODUWE_FIWMWAWE("wadeon/HAWAII_me.bin");
MODUWE_FIWMWAWE("wadeon/HAWAII_ce.bin");
MODUWE_FIWMWAWE("wadeon/HAWAII_mec.bin");
MODUWE_FIWMWAWE("wadeon/HAWAII_mc.bin");
MODUWE_FIWMWAWE("wadeon/HAWAII_mc2.bin");
MODUWE_FIWMWAWE("wadeon/HAWAII_wwc.bin");
MODUWE_FIWMWAWE("wadeon/HAWAII_sdma.bin");
MODUWE_FIWMWAWE("wadeon/HAWAII_smc.bin");

MODUWE_FIWMWAWE("wadeon/hawaii_pfp.bin");
MODUWE_FIWMWAWE("wadeon/hawaii_me.bin");
MODUWE_FIWMWAWE("wadeon/hawaii_ce.bin");
MODUWE_FIWMWAWE("wadeon/hawaii_mec.bin");
MODUWE_FIWMWAWE("wadeon/hawaii_mc.bin");
MODUWE_FIWMWAWE("wadeon/hawaii_wwc.bin");
MODUWE_FIWMWAWE("wadeon/hawaii_sdma.bin");
MODUWE_FIWMWAWE("wadeon/hawaii_smc.bin");
MODUWE_FIWMWAWE("wadeon/hawaii_k_smc.bin");

MODUWE_FIWMWAWE("wadeon/KAVEWI_pfp.bin");
MODUWE_FIWMWAWE("wadeon/KAVEWI_me.bin");
MODUWE_FIWMWAWE("wadeon/KAVEWI_ce.bin");
MODUWE_FIWMWAWE("wadeon/KAVEWI_mec.bin");
MODUWE_FIWMWAWE("wadeon/KAVEWI_wwc.bin");
MODUWE_FIWMWAWE("wadeon/KAVEWI_sdma.bin");

MODUWE_FIWMWAWE("wadeon/kavewi_pfp.bin");
MODUWE_FIWMWAWE("wadeon/kavewi_me.bin");
MODUWE_FIWMWAWE("wadeon/kavewi_ce.bin");
MODUWE_FIWMWAWE("wadeon/kavewi_mec.bin");
MODUWE_FIWMWAWE("wadeon/kavewi_mec2.bin");
MODUWE_FIWMWAWE("wadeon/kavewi_wwc.bin");
MODUWE_FIWMWAWE("wadeon/kavewi_sdma.bin");

MODUWE_FIWMWAWE("wadeon/KABINI_pfp.bin");
MODUWE_FIWMWAWE("wadeon/KABINI_me.bin");
MODUWE_FIWMWAWE("wadeon/KABINI_ce.bin");
MODUWE_FIWMWAWE("wadeon/KABINI_mec.bin");
MODUWE_FIWMWAWE("wadeon/KABINI_wwc.bin");
MODUWE_FIWMWAWE("wadeon/KABINI_sdma.bin");

MODUWE_FIWMWAWE("wadeon/kabini_pfp.bin");
MODUWE_FIWMWAWE("wadeon/kabini_me.bin");
MODUWE_FIWMWAWE("wadeon/kabini_ce.bin");
MODUWE_FIWMWAWE("wadeon/kabini_mec.bin");
MODUWE_FIWMWAWE("wadeon/kabini_wwc.bin");
MODUWE_FIWMWAWE("wadeon/kabini_sdma.bin");

MODUWE_FIWMWAWE("wadeon/MUWWINS_pfp.bin");
MODUWE_FIWMWAWE("wadeon/MUWWINS_me.bin");
MODUWE_FIWMWAWE("wadeon/MUWWINS_ce.bin");
MODUWE_FIWMWAWE("wadeon/MUWWINS_mec.bin");
MODUWE_FIWMWAWE("wadeon/MUWWINS_wwc.bin");
MODUWE_FIWMWAWE("wadeon/MUWWINS_sdma.bin");

MODUWE_FIWMWAWE("wadeon/muwwins_pfp.bin");
MODUWE_FIWMWAWE("wadeon/muwwins_me.bin");
MODUWE_FIWMWAWE("wadeon/muwwins_ce.bin");
MODUWE_FIWMWAWE("wadeon/muwwins_mec.bin");
MODUWE_FIWMWAWE("wadeon/muwwins_wwc.bin");
MODUWE_FIWMWAWE("wadeon/muwwins_sdma.bin");

static u32 cik_get_cu_active_bitmap(stwuct wadeon_device *wdev, u32 se, u32 sh);
static void cik_wwc_stop(stwuct wadeon_device *wdev);
static void cik_pcie_gen3_enabwe(stwuct wadeon_device *wdev);
static void cik_pwogwam_aspm(stwuct wadeon_device *wdev);
static void cik_init_pg(stwuct wadeon_device *wdev);
static void cik_init_cg(stwuct wadeon_device *wdev);
static void cik_fini_pg(stwuct wadeon_device *wdev);
static void cik_fini_cg(stwuct wadeon_device *wdev);
static void cik_enabwe_gui_idwe_intewwupt(stwuct wadeon_device *wdev,
					  boow enabwe);

/**
 * cik_get_awwowed_info_wegistew - fetch the wegistew fow the info ioctw
 *
 * @wdev: wadeon_device pointew
 * @weg: wegistew offset in bytes
 * @vaw: wegistew vawue
 *
 * Wetuwns 0 fow success ow -EINVAW fow an invawid wegistew
 *
 */
int cik_get_awwowed_info_wegistew(stwuct wadeon_device *wdev,
				  u32 weg, u32 *vaw)
{
	switch (weg) {
	case GWBM_STATUS:
	case GWBM_STATUS2:
	case GWBM_STATUS_SE0:
	case GWBM_STATUS_SE1:
	case GWBM_STATUS_SE2:
	case GWBM_STATUS_SE3:
	case SWBM_STATUS:
	case SWBM_STATUS2:
	case (SDMA0_STATUS_WEG + SDMA0_WEGISTEW_OFFSET):
	case (SDMA0_STATUS_WEG + SDMA1_WEGISTEW_OFFSET):
	case UVD_STATUS:
	/* TODO VCE */
		*vaw = WWEG32(weg);
		wetuwn 0;
	defauwt:
		wetuwn -EINVAW;
	}
}

/*
 * Indiwect wegistews accessow
 */
u32 cik_didt_wweg(stwuct wadeon_device *wdev, u32 weg)
{
	unsigned wong fwags;
	u32 w;

	spin_wock_iwqsave(&wdev->didt_idx_wock, fwags);
	WWEG32(CIK_DIDT_IND_INDEX, (weg));
	w = WWEG32(CIK_DIDT_IND_DATA);
	spin_unwock_iwqwestowe(&wdev->didt_idx_wock, fwags);
	wetuwn w;
}

void cik_didt_wweg(stwuct wadeon_device *wdev, u32 weg, u32 v)
{
	unsigned wong fwags;

	spin_wock_iwqsave(&wdev->didt_idx_wock, fwags);
	WWEG32(CIK_DIDT_IND_INDEX, (weg));
	WWEG32(CIK_DIDT_IND_DATA, (v));
	spin_unwock_iwqwestowe(&wdev->didt_idx_wock, fwags);
}

/* get tempewatuwe in miwwidegwees */
int ci_get_temp(stwuct wadeon_device *wdev)
{
	u32 temp;
	int actuaw_temp = 0;

	temp = (WWEG32_SMC(CG_MUWT_THEWMAW_STATUS) & CTF_TEMP_MASK) >>
		CTF_TEMP_SHIFT;

	if (temp & 0x200)
		actuaw_temp = 255;
	ewse
		actuaw_temp = temp & 0x1ff;

	wetuwn actuaw_temp * 1000;
}

/* get tempewatuwe in miwwidegwees */
int kv_get_temp(stwuct wadeon_device *wdev)
{
	u32 temp;
	int actuaw_temp = 0;

	temp = WWEG32_SMC(0xC0300E0C);

	if (temp)
		actuaw_temp = (temp / 8) - 49;
	ewse
		actuaw_temp = 0;

	wetuwn actuaw_temp * 1000;
}

/*
 * Indiwect wegistews accessow
 */
u32 cik_pciep_wweg(stwuct wadeon_device *wdev, u32 weg)
{
	unsigned wong fwags;
	u32 w;

	spin_wock_iwqsave(&wdev->pciep_idx_wock, fwags);
	WWEG32(PCIE_INDEX, weg);
	(void)WWEG32(PCIE_INDEX);
	w = WWEG32(PCIE_DATA);
	spin_unwock_iwqwestowe(&wdev->pciep_idx_wock, fwags);
	wetuwn w;
}

void cik_pciep_wweg(stwuct wadeon_device *wdev, u32 weg, u32 v)
{
	unsigned wong fwags;

	spin_wock_iwqsave(&wdev->pciep_idx_wock, fwags);
	WWEG32(PCIE_INDEX, weg);
	(void)WWEG32(PCIE_INDEX);
	WWEG32(PCIE_DATA, v);
	(void)WWEG32(PCIE_DATA);
	spin_unwock_iwqwestowe(&wdev->pciep_idx_wock, fwags);
}

static const u32 spectwe_wwc_save_westowe_wegistew_wist[] =
{
	(0x0e00 << 16) | (0xc12c >> 2),
	0x00000000,
	(0x0e00 << 16) | (0xc140 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0xc150 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0xc15c >> 2),
	0x00000000,
	(0x0e00 << 16) | (0xc168 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0xc170 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0xc178 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0xc204 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0xc2b4 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0xc2b8 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0xc2bc >> 2),
	0x00000000,
	(0x0e00 << 16) | (0xc2c0 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0x8228 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0x829c >> 2),
	0x00000000,
	(0x0e00 << 16) | (0x869c >> 2),
	0x00000000,
	(0x0600 << 16) | (0x98f4 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0x98f8 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0x9900 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0xc260 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0x90e8 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0x3c000 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0x3c00c >> 2),
	0x00000000,
	(0x0e00 << 16) | (0x8c1c >> 2),
	0x00000000,
	(0x0e00 << 16) | (0x9700 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0xcd20 >> 2),
	0x00000000,
	(0x4e00 << 16) | (0xcd20 >> 2),
	0x00000000,
	(0x5e00 << 16) | (0xcd20 >> 2),
	0x00000000,
	(0x6e00 << 16) | (0xcd20 >> 2),
	0x00000000,
	(0x7e00 << 16) | (0xcd20 >> 2),
	0x00000000,
	(0x8e00 << 16) | (0xcd20 >> 2),
	0x00000000,
	(0x9e00 << 16) | (0xcd20 >> 2),
	0x00000000,
	(0xae00 << 16) | (0xcd20 >> 2),
	0x00000000,
	(0xbe00 << 16) | (0xcd20 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0x89bc >> 2),
	0x00000000,
	(0x0e00 << 16) | (0x8900 >> 2),
	0x00000000,
	0x3,
	(0x0e00 << 16) | (0xc130 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0xc134 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0xc1fc >> 2),
	0x00000000,
	(0x0e00 << 16) | (0xc208 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0xc264 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0xc268 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0xc26c >> 2),
	0x00000000,
	(0x0e00 << 16) | (0xc270 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0xc274 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0xc278 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0xc27c >> 2),
	0x00000000,
	(0x0e00 << 16) | (0xc280 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0xc284 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0xc288 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0xc28c >> 2),
	0x00000000,
	(0x0e00 << 16) | (0xc290 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0xc294 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0xc298 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0xc29c >> 2),
	0x00000000,
	(0x0e00 << 16) | (0xc2a0 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0xc2a4 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0xc2a8 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0xc2ac  >> 2),
	0x00000000,
	(0x0e00 << 16) | (0xc2b0 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0x301d0 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0x30238 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0x30250 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0x30254 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0x30258 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0x3025c >> 2),
	0x00000000,
	(0x4e00 << 16) | (0xc900 >> 2),
	0x00000000,
	(0x5e00 << 16) | (0xc900 >> 2),
	0x00000000,
	(0x6e00 << 16) | (0xc900 >> 2),
	0x00000000,
	(0x7e00 << 16) | (0xc900 >> 2),
	0x00000000,
	(0x8e00 << 16) | (0xc900 >> 2),
	0x00000000,
	(0x9e00 << 16) | (0xc900 >> 2),
	0x00000000,
	(0xae00 << 16) | (0xc900 >> 2),
	0x00000000,
	(0xbe00 << 16) | (0xc900 >> 2),
	0x00000000,
	(0x4e00 << 16) | (0xc904 >> 2),
	0x00000000,
	(0x5e00 << 16) | (0xc904 >> 2),
	0x00000000,
	(0x6e00 << 16) | (0xc904 >> 2),
	0x00000000,
	(0x7e00 << 16) | (0xc904 >> 2),
	0x00000000,
	(0x8e00 << 16) | (0xc904 >> 2),
	0x00000000,
	(0x9e00 << 16) | (0xc904 >> 2),
	0x00000000,
	(0xae00 << 16) | (0xc904 >> 2),
	0x00000000,
	(0xbe00 << 16) | (0xc904 >> 2),
	0x00000000,
	(0x4e00 << 16) | (0xc908 >> 2),
	0x00000000,
	(0x5e00 << 16) | (0xc908 >> 2),
	0x00000000,
	(0x6e00 << 16) | (0xc908 >> 2),
	0x00000000,
	(0x7e00 << 16) | (0xc908 >> 2),
	0x00000000,
	(0x8e00 << 16) | (0xc908 >> 2),
	0x00000000,
	(0x9e00 << 16) | (0xc908 >> 2),
	0x00000000,
	(0xae00 << 16) | (0xc908 >> 2),
	0x00000000,
	(0xbe00 << 16) | (0xc908 >> 2),
	0x00000000,
	(0x4e00 << 16) | (0xc90c >> 2),
	0x00000000,
	(0x5e00 << 16) | (0xc90c >> 2),
	0x00000000,
	(0x6e00 << 16) | (0xc90c >> 2),
	0x00000000,
	(0x7e00 << 16) | (0xc90c >> 2),
	0x00000000,
	(0x8e00 << 16) | (0xc90c >> 2),
	0x00000000,
	(0x9e00 << 16) | (0xc90c >> 2),
	0x00000000,
	(0xae00 << 16) | (0xc90c >> 2),
	0x00000000,
	(0xbe00 << 16) | (0xc90c >> 2),
	0x00000000,
	(0x4e00 << 16) | (0xc910 >> 2),
	0x00000000,
	(0x5e00 << 16) | (0xc910 >> 2),
	0x00000000,
	(0x6e00 << 16) | (0xc910 >> 2),
	0x00000000,
	(0x7e00 << 16) | (0xc910 >> 2),
	0x00000000,
	(0x8e00 << 16) | (0xc910 >> 2),
	0x00000000,
	(0x9e00 << 16) | (0xc910 >> 2),
	0x00000000,
	(0xae00 << 16) | (0xc910 >> 2),
	0x00000000,
	(0xbe00 << 16) | (0xc910 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0xc99c >> 2),
	0x00000000,
	(0x0e00 << 16) | (0x9834 >> 2),
	0x00000000,
	(0x0000 << 16) | (0x30f00 >> 2),
	0x00000000,
	(0x0001 << 16) | (0x30f00 >> 2),
	0x00000000,
	(0x0000 << 16) | (0x30f04 >> 2),
	0x00000000,
	(0x0001 << 16) | (0x30f04 >> 2),
	0x00000000,
	(0x0000 << 16) | (0x30f08 >> 2),
	0x00000000,
	(0x0001 << 16) | (0x30f08 >> 2),
	0x00000000,
	(0x0000 << 16) | (0x30f0c >> 2),
	0x00000000,
	(0x0001 << 16) | (0x30f0c >> 2),
	0x00000000,
	(0x0600 << 16) | (0x9b7c >> 2),
	0x00000000,
	(0x0e00 << 16) | (0x8a14 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0x8a18 >> 2),
	0x00000000,
	(0x0600 << 16) | (0x30a00 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0x8bf0 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0x8bcc >> 2),
	0x00000000,
	(0x0e00 << 16) | (0x8b24 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0x30a04 >> 2),
	0x00000000,
	(0x0600 << 16) | (0x30a10 >> 2),
	0x00000000,
	(0x0600 << 16) | (0x30a14 >> 2),
	0x00000000,
	(0x0600 << 16) | (0x30a18 >> 2),
	0x00000000,
	(0x0600 << 16) | (0x30a2c >> 2),
	0x00000000,
	(0x0e00 << 16) | (0xc700 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0xc704 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0xc708 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0xc768 >> 2),
	0x00000000,
	(0x0400 << 16) | (0xc770 >> 2),
	0x00000000,
	(0x0400 << 16) | (0xc774 >> 2),
	0x00000000,
	(0x0400 << 16) | (0xc778 >> 2),
	0x00000000,
	(0x0400 << 16) | (0xc77c >> 2),
	0x00000000,
	(0x0400 << 16) | (0xc780 >> 2),
	0x00000000,
	(0x0400 << 16) | (0xc784 >> 2),
	0x00000000,
	(0x0400 << 16) | (0xc788 >> 2),
	0x00000000,
	(0x0400 << 16) | (0xc78c >> 2),
	0x00000000,
	(0x0400 << 16) | (0xc798 >> 2),
	0x00000000,
	(0x0400 << 16) | (0xc79c >> 2),
	0x00000000,
	(0x0400 << 16) | (0xc7a0 >> 2),
	0x00000000,
	(0x0400 << 16) | (0xc7a4 >> 2),
	0x00000000,
	(0x0400 << 16) | (0xc7a8 >> 2),
	0x00000000,
	(0x0400 << 16) | (0xc7ac >> 2),
	0x00000000,
	(0x0400 << 16) | (0xc7b0 >> 2),
	0x00000000,
	(0x0400 << 16) | (0xc7b4 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0x9100 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0x3c010 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0x92a8 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0x92ac >> 2),
	0x00000000,
	(0x0e00 << 16) | (0x92b4 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0x92b8 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0x92bc >> 2),
	0x00000000,
	(0x0e00 << 16) | (0x92c0 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0x92c4 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0x92c8 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0x92cc >> 2),
	0x00000000,
	(0x0e00 << 16) | (0x92d0 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0x8c00 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0x8c04 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0x8c20 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0x8c38 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0x8c3c >> 2),
	0x00000000,
	(0x0e00 << 16) | (0xae00 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0x9604 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0xac08 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0xac0c >> 2),
	0x00000000,
	(0x0e00 << 16) | (0xac10 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0xac14 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0xac58 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0xac68 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0xac6c >> 2),
	0x00000000,
	(0x0e00 << 16) | (0xac70 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0xac74 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0xac78 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0xac7c >> 2),
	0x00000000,
	(0x0e00 << 16) | (0xac80 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0xac84 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0xac88 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0xac8c >> 2),
	0x00000000,
	(0x0e00 << 16) | (0x970c >> 2),
	0x00000000,
	(0x0e00 << 16) | (0x9714 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0x9718 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0x971c >> 2),
	0x00000000,
	(0x0e00 << 16) | (0x31068 >> 2),
	0x00000000,
	(0x4e00 << 16) | (0x31068 >> 2),
	0x00000000,
	(0x5e00 << 16) | (0x31068 >> 2),
	0x00000000,
	(0x6e00 << 16) | (0x31068 >> 2),
	0x00000000,
	(0x7e00 << 16) | (0x31068 >> 2),
	0x00000000,
	(0x8e00 << 16) | (0x31068 >> 2),
	0x00000000,
	(0x9e00 << 16) | (0x31068 >> 2),
	0x00000000,
	(0xae00 << 16) | (0x31068 >> 2),
	0x00000000,
	(0xbe00 << 16) | (0x31068 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0xcd10 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0xcd14 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0x88b0 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0x88b4 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0x88b8 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0x88bc >> 2),
	0x00000000,
	(0x0400 << 16) | (0x89c0 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0x88c4 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0x88c8 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0x88d0 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0x88d4 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0x88d8 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0x8980 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0x30938 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0x3093c >> 2),
	0x00000000,
	(0x0e00 << 16) | (0x30940 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0x89a0 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0x30900 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0x30904 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0x89b4 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0x3c210 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0x3c214 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0x3c218 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0x8904 >> 2),
	0x00000000,
	0x5,
	(0x0e00 << 16) | (0x8c28 >> 2),
	(0x0e00 << 16) | (0x8c2c >> 2),
	(0x0e00 << 16) | (0x8c30 >> 2),
	(0x0e00 << 16) | (0x8c34 >> 2),
	(0x0e00 << 16) | (0x9600 >> 2),
};

static const u32 kawindi_wwc_save_westowe_wegistew_wist[] =
{
	(0x0e00 << 16) | (0xc12c >> 2),
	0x00000000,
	(0x0e00 << 16) | (0xc140 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0xc150 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0xc15c >> 2),
	0x00000000,
	(0x0e00 << 16) | (0xc168 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0xc170 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0xc204 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0xc2b4 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0xc2b8 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0xc2bc >> 2),
	0x00000000,
	(0x0e00 << 16) | (0xc2c0 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0x8228 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0x829c >> 2),
	0x00000000,
	(0x0e00 << 16) | (0x869c >> 2),
	0x00000000,
	(0x0600 << 16) | (0x98f4 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0x98f8 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0x9900 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0xc260 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0x90e8 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0x3c000 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0x3c00c >> 2),
	0x00000000,
	(0x0e00 << 16) | (0x8c1c >> 2),
	0x00000000,
	(0x0e00 << 16) | (0x9700 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0xcd20 >> 2),
	0x00000000,
	(0x4e00 << 16) | (0xcd20 >> 2),
	0x00000000,
	(0x5e00 << 16) | (0xcd20 >> 2),
	0x00000000,
	(0x6e00 << 16) | (0xcd20 >> 2),
	0x00000000,
	(0x7e00 << 16) | (0xcd20 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0x89bc >> 2),
	0x00000000,
	(0x0e00 << 16) | (0x8900 >> 2),
	0x00000000,
	0x3,
	(0x0e00 << 16) | (0xc130 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0xc134 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0xc1fc >> 2),
	0x00000000,
	(0x0e00 << 16) | (0xc208 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0xc264 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0xc268 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0xc26c >> 2),
	0x00000000,
	(0x0e00 << 16) | (0xc270 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0xc274 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0xc28c >> 2),
	0x00000000,
	(0x0e00 << 16) | (0xc290 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0xc294 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0xc298 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0xc2a0 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0xc2a4 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0xc2a8 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0xc2ac >> 2),
	0x00000000,
	(0x0e00 << 16) | (0x301d0 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0x30238 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0x30250 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0x30254 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0x30258 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0x3025c >> 2),
	0x00000000,
	(0x4e00 << 16) | (0xc900 >> 2),
	0x00000000,
	(0x5e00 << 16) | (0xc900 >> 2),
	0x00000000,
	(0x6e00 << 16) | (0xc900 >> 2),
	0x00000000,
	(0x7e00 << 16) | (0xc900 >> 2),
	0x00000000,
	(0x4e00 << 16) | (0xc904 >> 2),
	0x00000000,
	(0x5e00 << 16) | (0xc904 >> 2),
	0x00000000,
	(0x6e00 << 16) | (0xc904 >> 2),
	0x00000000,
	(0x7e00 << 16) | (0xc904 >> 2),
	0x00000000,
	(0x4e00 << 16) | (0xc908 >> 2),
	0x00000000,
	(0x5e00 << 16) | (0xc908 >> 2),
	0x00000000,
	(0x6e00 << 16) | (0xc908 >> 2),
	0x00000000,
	(0x7e00 << 16) | (0xc908 >> 2),
	0x00000000,
	(0x4e00 << 16) | (0xc90c >> 2),
	0x00000000,
	(0x5e00 << 16) | (0xc90c >> 2),
	0x00000000,
	(0x6e00 << 16) | (0xc90c >> 2),
	0x00000000,
	(0x7e00 << 16) | (0xc90c >> 2),
	0x00000000,
	(0x4e00 << 16) | (0xc910 >> 2),
	0x00000000,
	(0x5e00 << 16) | (0xc910 >> 2),
	0x00000000,
	(0x6e00 << 16) | (0xc910 >> 2),
	0x00000000,
	(0x7e00 << 16) | (0xc910 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0xc99c >> 2),
	0x00000000,
	(0x0e00 << 16) | (0x9834 >> 2),
	0x00000000,
	(0x0000 << 16) | (0x30f00 >> 2),
	0x00000000,
	(0x0000 << 16) | (0x30f04 >> 2),
	0x00000000,
	(0x0000 << 16) | (0x30f08 >> 2),
	0x00000000,
	(0x0000 << 16) | (0x30f0c >> 2),
	0x00000000,
	(0x0600 << 16) | (0x9b7c >> 2),
	0x00000000,
	(0x0e00 << 16) | (0x8a14 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0x8a18 >> 2),
	0x00000000,
	(0x0600 << 16) | (0x30a00 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0x8bf0 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0x8bcc >> 2),
	0x00000000,
	(0x0e00 << 16) | (0x8b24 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0x30a04 >> 2),
	0x00000000,
	(0x0600 << 16) | (0x30a10 >> 2),
	0x00000000,
	(0x0600 << 16) | (0x30a14 >> 2),
	0x00000000,
	(0x0600 << 16) | (0x30a18 >> 2),
	0x00000000,
	(0x0600 << 16) | (0x30a2c >> 2),
	0x00000000,
	(0x0e00 << 16) | (0xc700 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0xc704 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0xc708 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0xc768 >> 2),
	0x00000000,
	(0x0400 << 16) | (0xc770 >> 2),
	0x00000000,
	(0x0400 << 16) | (0xc774 >> 2),
	0x00000000,
	(0x0400 << 16) | (0xc798 >> 2),
	0x00000000,
	(0x0400 << 16) | (0xc79c >> 2),
	0x00000000,
	(0x0e00 << 16) | (0x9100 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0x3c010 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0x8c00 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0x8c04 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0x8c20 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0x8c38 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0x8c3c >> 2),
	0x00000000,
	(0x0e00 << 16) | (0xae00 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0x9604 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0xac08 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0xac0c >> 2),
	0x00000000,
	(0x0e00 << 16) | (0xac10 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0xac14 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0xac58 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0xac68 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0xac6c >> 2),
	0x00000000,
	(0x0e00 << 16) | (0xac70 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0xac74 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0xac78 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0xac7c >> 2),
	0x00000000,
	(0x0e00 << 16) | (0xac80 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0xac84 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0xac88 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0xac8c >> 2),
	0x00000000,
	(0x0e00 << 16) | (0x970c >> 2),
	0x00000000,
	(0x0e00 << 16) | (0x9714 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0x9718 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0x971c >> 2),
	0x00000000,
	(0x0e00 << 16) | (0x31068 >> 2),
	0x00000000,
	(0x4e00 << 16) | (0x31068 >> 2),
	0x00000000,
	(0x5e00 << 16) | (0x31068 >> 2),
	0x00000000,
	(0x6e00 << 16) | (0x31068 >> 2),
	0x00000000,
	(0x7e00 << 16) | (0x31068 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0xcd10 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0xcd14 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0x88b0 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0x88b4 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0x88b8 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0x88bc >> 2),
	0x00000000,
	(0x0400 << 16) | (0x89c0 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0x88c4 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0x88c8 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0x88d0 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0x88d4 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0x88d8 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0x8980 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0x30938 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0x3093c >> 2),
	0x00000000,
	(0x0e00 << 16) | (0x30940 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0x89a0 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0x30900 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0x30904 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0x89b4 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0x3e1fc >> 2),
	0x00000000,
	(0x0e00 << 16) | (0x3c210 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0x3c214 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0x3c218 >> 2),
	0x00000000,
	(0x0e00 << 16) | (0x8904 >> 2),
	0x00000000,
	0x5,
	(0x0e00 << 16) | (0x8c28 >> 2),
	(0x0e00 << 16) | (0x8c2c >> 2),
	(0x0e00 << 16) | (0x8c30 >> 2),
	(0x0e00 << 16) | (0x8c34 >> 2),
	(0x0e00 << 16) | (0x9600 >> 2),
};

static const u32 bonaiwe_gowden_spm_wegistews[] =
{
	0x30800, 0xe0ffffff, 0xe0000000
};

static const u32 bonaiwe_gowden_common_wegistews[] =
{
	0xc770, 0xffffffff, 0x00000800,
	0xc774, 0xffffffff, 0x00000800,
	0xc798, 0xffffffff, 0x00007fbf,
	0xc79c, 0xffffffff, 0x00007faf
};

static const u32 bonaiwe_gowden_wegistews[] =
{
	0x3354, 0x00000333, 0x00000333,
	0x3350, 0x000c0fc0, 0x00040200,
	0x9a10, 0x00010000, 0x00058208,
	0x3c000, 0xffff1fff, 0x00140000,
	0x3c200, 0xfdfc0fff, 0x00000100,
	0x3c234, 0x40000000, 0x40000200,
	0x9830, 0xffffffff, 0x00000000,
	0x9834, 0xf00fffff, 0x00000400,
	0x9838, 0x0002021c, 0x00020200,
	0xc78, 0x00000080, 0x00000000,
	0x5bb0, 0x000000f0, 0x00000070,
	0x5bc0, 0xf0311fff, 0x80300000,
	0x98f8, 0x73773777, 0x12010001,
	0x350c, 0x00810000, 0x408af000,
	0x7030, 0x31000111, 0x00000011,
	0x2f48, 0x73773777, 0x12010001,
	0x220c, 0x00007fb6, 0x0021a1b1,
	0x2210, 0x00007fb6, 0x002021b1,
	0x2180, 0x00007fb6, 0x00002191,
	0x2218, 0x00007fb6, 0x002121b1,
	0x221c, 0x00007fb6, 0x002021b1,
	0x21dc, 0x00007fb6, 0x00002191,
	0x21e0, 0x00007fb6, 0x00002191,
	0x3628, 0x0000003f, 0x0000000a,
	0x362c, 0x0000003f, 0x0000000a,
	0x2ae4, 0x00073ffe, 0x000022a2,
	0x240c, 0x000007ff, 0x00000000,
	0x8a14, 0xf000003f, 0x00000007,
	0x8bf0, 0x00002001, 0x00000001,
	0x8b24, 0xffffffff, 0x00ffffff,
	0x30a04, 0x0000ff0f, 0x00000000,
	0x28a4c, 0x07ffffff, 0x06000000,
	0x4d8, 0x00000fff, 0x00000100,
	0x3e78, 0x00000001, 0x00000002,
	0x9100, 0x03000000, 0x0362c688,
	0x8c00, 0x000000ff, 0x00000001,
	0xe40, 0x00001fff, 0x00001fff,
	0x9060, 0x0000007f, 0x00000020,
	0x9508, 0x00010000, 0x00010000,
	0xac14, 0x000003ff, 0x000000f3,
	0xac0c, 0xffffffff, 0x00001032
};

static const u32 bonaiwe_mgcg_cgcg_init[] =
{
	0xc420, 0xffffffff, 0xfffffffc,
	0x30800, 0xffffffff, 0xe0000000,
	0x3c2a0, 0xffffffff, 0x00000100,
	0x3c208, 0xffffffff, 0x00000100,
	0x3c2c0, 0xffffffff, 0xc0000100,
	0x3c2c8, 0xffffffff, 0xc0000100,
	0x3c2c4, 0xffffffff, 0xc0000100,
	0x55e4, 0xffffffff, 0x00600100,
	0x3c280, 0xffffffff, 0x00000100,
	0x3c214, 0xffffffff, 0x06000100,
	0x3c220, 0xffffffff, 0x00000100,
	0x3c218, 0xffffffff, 0x06000100,
	0x3c204, 0xffffffff, 0x00000100,
	0x3c2e0, 0xffffffff, 0x00000100,
	0x3c224, 0xffffffff, 0x00000100,
	0x3c200, 0xffffffff, 0x00000100,
	0x3c230, 0xffffffff, 0x00000100,
	0x3c234, 0xffffffff, 0x00000100,
	0x3c250, 0xffffffff, 0x00000100,
	0x3c254, 0xffffffff, 0x00000100,
	0x3c258, 0xffffffff, 0x00000100,
	0x3c25c, 0xffffffff, 0x00000100,
	0x3c260, 0xffffffff, 0x00000100,
	0x3c27c, 0xffffffff, 0x00000100,
	0x3c278, 0xffffffff, 0x00000100,
	0x3c210, 0xffffffff, 0x06000100,
	0x3c290, 0xffffffff, 0x00000100,
	0x3c274, 0xffffffff, 0x00000100,
	0x3c2b4, 0xffffffff, 0x00000100,
	0x3c2b0, 0xffffffff, 0x00000100,
	0x3c270, 0xffffffff, 0x00000100,
	0x30800, 0xffffffff, 0xe0000000,
	0x3c020, 0xffffffff, 0x00010000,
	0x3c024, 0xffffffff, 0x00030002,
	0x3c028, 0xffffffff, 0x00040007,
	0x3c02c, 0xffffffff, 0x00060005,
	0x3c030, 0xffffffff, 0x00090008,
	0x3c034, 0xffffffff, 0x00010000,
	0x3c038, 0xffffffff, 0x00030002,
	0x3c03c, 0xffffffff, 0x00040007,
	0x3c040, 0xffffffff, 0x00060005,
	0x3c044, 0xffffffff, 0x00090008,
	0x3c048, 0xffffffff, 0x00010000,
	0x3c04c, 0xffffffff, 0x00030002,
	0x3c050, 0xffffffff, 0x00040007,
	0x3c054, 0xffffffff, 0x00060005,
	0x3c058, 0xffffffff, 0x00090008,
	0x3c05c, 0xffffffff, 0x00010000,
	0x3c060, 0xffffffff, 0x00030002,
	0x3c064, 0xffffffff, 0x00040007,
	0x3c068, 0xffffffff, 0x00060005,
	0x3c06c, 0xffffffff, 0x00090008,
	0x3c070, 0xffffffff, 0x00010000,
	0x3c074, 0xffffffff, 0x00030002,
	0x3c078, 0xffffffff, 0x00040007,
	0x3c07c, 0xffffffff, 0x00060005,
	0x3c080, 0xffffffff, 0x00090008,
	0x3c084, 0xffffffff, 0x00010000,
	0x3c088, 0xffffffff, 0x00030002,
	0x3c08c, 0xffffffff, 0x00040007,
	0x3c090, 0xffffffff, 0x00060005,
	0x3c094, 0xffffffff, 0x00090008,
	0x3c098, 0xffffffff, 0x00010000,
	0x3c09c, 0xffffffff, 0x00030002,
	0x3c0a0, 0xffffffff, 0x00040007,
	0x3c0a4, 0xffffffff, 0x00060005,
	0x3c0a8, 0xffffffff, 0x00090008,
	0x3c000, 0xffffffff, 0x96e00200,
	0x8708, 0xffffffff, 0x00900100,
	0xc424, 0xffffffff, 0x0020003f,
	0x38, 0xffffffff, 0x0140001c,
	0x3c, 0x000f0000, 0x000f0000,
	0x220, 0xffffffff, 0xC060000C,
	0x224, 0xc0000fff, 0x00000100,
	0xf90, 0xffffffff, 0x00000100,
	0xf98, 0x00000101, 0x00000000,
	0x20a8, 0xffffffff, 0x00000104,
	0x55e4, 0xff000fff, 0x00000100,
	0x30cc, 0xc0000fff, 0x00000104,
	0xc1e4, 0x00000001, 0x00000001,
	0xd00c, 0xff000ff0, 0x00000100,
	0xd80c, 0xff000ff0, 0x00000100
};

static const u32 spectwe_gowden_spm_wegistews[] =
{
	0x30800, 0xe0ffffff, 0xe0000000
};

static const u32 spectwe_gowden_common_wegistews[] =
{
	0xc770, 0xffffffff, 0x00000800,
	0xc774, 0xffffffff, 0x00000800,
	0xc798, 0xffffffff, 0x00007fbf,
	0xc79c, 0xffffffff, 0x00007faf
};

static const u32 spectwe_gowden_wegistews[] =
{
	0x3c000, 0xffff1fff, 0x96940200,
	0x3c00c, 0xffff0001, 0xff000000,
	0x3c200, 0xfffc0fff, 0x00000100,
	0x6ed8, 0x00010101, 0x00010000,
	0x9834, 0xf00fffff, 0x00000400,
	0x9838, 0xfffffffc, 0x00020200,
	0x5bb0, 0x000000f0, 0x00000070,
	0x5bc0, 0xf0311fff, 0x80300000,
	0x98f8, 0x73773777, 0x12010001,
	0x9b7c, 0x00ff0000, 0x00fc0000,
	0x2f48, 0x73773777, 0x12010001,
	0x8a14, 0xf000003f, 0x00000007,
	0x8b24, 0xffffffff, 0x00ffffff,
	0x28350, 0x3f3f3fff, 0x00000082,
	0x28354, 0x0000003f, 0x00000000,
	0x3e78, 0x00000001, 0x00000002,
	0x913c, 0xffff03df, 0x00000004,
	0xc768, 0x00000008, 0x00000008,
	0x8c00, 0x000008ff, 0x00000800,
	0x9508, 0x00010000, 0x00010000,
	0xac0c, 0xffffffff, 0x54763210,
	0x214f8, 0x01ff01ff, 0x00000002,
	0x21498, 0x007ff800, 0x00200000,
	0x2015c, 0xffffffff, 0x00000f40,
	0x30934, 0xffffffff, 0x00000001
};

static const u32 spectwe_mgcg_cgcg_init[] =
{
	0xc420, 0xffffffff, 0xfffffffc,
	0x30800, 0xffffffff, 0xe0000000,
	0x3c2a0, 0xffffffff, 0x00000100,
	0x3c208, 0xffffffff, 0x00000100,
	0x3c2c0, 0xffffffff, 0x00000100,
	0x3c2c8, 0xffffffff, 0x00000100,
	0x3c2c4, 0xffffffff, 0x00000100,
	0x55e4, 0xffffffff, 0x00600100,
	0x3c280, 0xffffffff, 0x00000100,
	0x3c214, 0xffffffff, 0x06000100,
	0x3c220, 0xffffffff, 0x00000100,
	0x3c218, 0xffffffff, 0x06000100,
	0x3c204, 0xffffffff, 0x00000100,
	0x3c2e0, 0xffffffff, 0x00000100,
	0x3c224, 0xffffffff, 0x00000100,
	0x3c200, 0xffffffff, 0x00000100,
	0x3c230, 0xffffffff, 0x00000100,
	0x3c234, 0xffffffff, 0x00000100,
	0x3c250, 0xffffffff, 0x00000100,
	0x3c254, 0xffffffff, 0x00000100,
	0x3c258, 0xffffffff, 0x00000100,
	0x3c25c, 0xffffffff, 0x00000100,
	0x3c260, 0xffffffff, 0x00000100,
	0x3c27c, 0xffffffff, 0x00000100,
	0x3c278, 0xffffffff, 0x00000100,
	0x3c210, 0xffffffff, 0x06000100,
	0x3c290, 0xffffffff, 0x00000100,
	0x3c274, 0xffffffff, 0x00000100,
	0x3c2b4, 0xffffffff, 0x00000100,
	0x3c2b0, 0xffffffff, 0x00000100,
	0x3c270, 0xffffffff, 0x00000100,
	0x30800, 0xffffffff, 0xe0000000,
	0x3c020, 0xffffffff, 0x00010000,
	0x3c024, 0xffffffff, 0x00030002,
	0x3c028, 0xffffffff, 0x00040007,
	0x3c02c, 0xffffffff, 0x00060005,
	0x3c030, 0xffffffff, 0x00090008,
	0x3c034, 0xffffffff, 0x00010000,
	0x3c038, 0xffffffff, 0x00030002,
	0x3c03c, 0xffffffff, 0x00040007,
	0x3c040, 0xffffffff, 0x00060005,
	0x3c044, 0xffffffff, 0x00090008,
	0x3c048, 0xffffffff, 0x00010000,
	0x3c04c, 0xffffffff, 0x00030002,
	0x3c050, 0xffffffff, 0x00040007,
	0x3c054, 0xffffffff, 0x00060005,
	0x3c058, 0xffffffff, 0x00090008,
	0x3c05c, 0xffffffff, 0x00010000,
	0x3c060, 0xffffffff, 0x00030002,
	0x3c064, 0xffffffff, 0x00040007,
	0x3c068, 0xffffffff, 0x00060005,
	0x3c06c, 0xffffffff, 0x00090008,
	0x3c070, 0xffffffff, 0x00010000,
	0x3c074, 0xffffffff, 0x00030002,
	0x3c078, 0xffffffff, 0x00040007,
	0x3c07c, 0xffffffff, 0x00060005,
	0x3c080, 0xffffffff, 0x00090008,
	0x3c084, 0xffffffff, 0x00010000,
	0x3c088, 0xffffffff, 0x00030002,
	0x3c08c, 0xffffffff, 0x00040007,
	0x3c090, 0xffffffff, 0x00060005,
	0x3c094, 0xffffffff, 0x00090008,
	0x3c098, 0xffffffff, 0x00010000,
	0x3c09c, 0xffffffff, 0x00030002,
	0x3c0a0, 0xffffffff, 0x00040007,
	0x3c0a4, 0xffffffff, 0x00060005,
	0x3c0a8, 0xffffffff, 0x00090008,
	0x3c0ac, 0xffffffff, 0x00010000,
	0x3c0b0, 0xffffffff, 0x00030002,
	0x3c0b4, 0xffffffff, 0x00040007,
	0x3c0b8, 0xffffffff, 0x00060005,
	0x3c0bc, 0xffffffff, 0x00090008,
	0x3c000, 0xffffffff, 0x96e00200,
	0x8708, 0xffffffff, 0x00900100,
	0xc424, 0xffffffff, 0x0020003f,
	0x38, 0xffffffff, 0x0140001c,
	0x3c, 0x000f0000, 0x000f0000,
	0x220, 0xffffffff, 0xC060000C,
	0x224, 0xc0000fff, 0x00000100,
	0xf90, 0xffffffff, 0x00000100,
	0xf98, 0x00000101, 0x00000000,
	0x20a8, 0xffffffff, 0x00000104,
	0x55e4, 0xff000fff, 0x00000100,
	0x30cc, 0xc0000fff, 0x00000104,
	0xc1e4, 0x00000001, 0x00000001,
	0xd00c, 0xff000ff0, 0x00000100,
	0xd80c, 0xff000ff0, 0x00000100
};

static const u32 kawindi_gowden_spm_wegistews[] =
{
	0x30800, 0xe0ffffff, 0xe0000000
};

static const u32 kawindi_gowden_common_wegistews[] =
{
	0xc770, 0xffffffff, 0x00000800,
	0xc774, 0xffffffff, 0x00000800,
	0xc798, 0xffffffff, 0x00007fbf,
	0xc79c, 0xffffffff, 0x00007faf
};

static const u32 kawindi_gowden_wegistews[] =
{
	0x3c000, 0xffffdfff, 0x6e944040,
	0x55e4, 0xff607fff, 0xfc000100,
	0x3c220, 0xff000fff, 0x00000100,
	0x3c224, 0xff000fff, 0x00000100,
	0x3c200, 0xfffc0fff, 0x00000100,
	0x6ed8, 0x00010101, 0x00010000,
	0x9830, 0xffffffff, 0x00000000,
	0x9834, 0xf00fffff, 0x00000400,
	0x5bb0, 0x000000f0, 0x00000070,
	0x5bc0, 0xf0311fff, 0x80300000,
	0x98f8, 0x73773777, 0x12010001,
	0x98fc, 0xffffffff, 0x00000010,
	0x9b7c, 0x00ff0000, 0x00fc0000,
	0x8030, 0x00001f0f, 0x0000100a,
	0x2f48, 0x73773777, 0x12010001,
	0x2408, 0x000fffff, 0x000c007f,
	0x8a14, 0xf000003f, 0x00000007,
	0x8b24, 0x3fff3fff, 0x00ffcfff,
	0x30a04, 0x0000ff0f, 0x00000000,
	0x28a4c, 0x07ffffff, 0x06000000,
	0x4d8, 0x00000fff, 0x00000100,
	0x3e78, 0x00000001, 0x00000002,
	0xc768, 0x00000008, 0x00000008,
	0x8c00, 0x000000ff, 0x00000003,
	0x214f8, 0x01ff01ff, 0x00000002,
	0x21498, 0x007ff800, 0x00200000,
	0x2015c, 0xffffffff, 0x00000f40,
	0x88c4, 0x001f3ae3, 0x00000082,
	0x88d4, 0x0000001f, 0x00000010,
	0x30934, 0xffffffff, 0x00000000
};

static const u32 kawindi_mgcg_cgcg_init[] =
{
	0xc420, 0xffffffff, 0xfffffffc,
	0x30800, 0xffffffff, 0xe0000000,
	0x3c2a0, 0xffffffff, 0x00000100,
	0x3c208, 0xffffffff, 0x00000100,
	0x3c2c0, 0xffffffff, 0x00000100,
	0x3c2c8, 0xffffffff, 0x00000100,
	0x3c2c4, 0xffffffff, 0x00000100,
	0x55e4, 0xffffffff, 0x00600100,
	0x3c280, 0xffffffff, 0x00000100,
	0x3c214, 0xffffffff, 0x06000100,
	0x3c220, 0xffffffff, 0x00000100,
	0x3c218, 0xffffffff, 0x06000100,
	0x3c204, 0xffffffff, 0x00000100,
	0x3c2e0, 0xffffffff, 0x00000100,
	0x3c224, 0xffffffff, 0x00000100,
	0x3c200, 0xffffffff, 0x00000100,
	0x3c230, 0xffffffff, 0x00000100,
	0x3c234, 0xffffffff, 0x00000100,
	0x3c250, 0xffffffff, 0x00000100,
	0x3c254, 0xffffffff, 0x00000100,
	0x3c258, 0xffffffff, 0x00000100,
	0x3c25c, 0xffffffff, 0x00000100,
	0x3c260, 0xffffffff, 0x00000100,
	0x3c27c, 0xffffffff, 0x00000100,
	0x3c278, 0xffffffff, 0x00000100,
	0x3c210, 0xffffffff, 0x06000100,
	0x3c290, 0xffffffff, 0x00000100,
	0x3c274, 0xffffffff, 0x00000100,
	0x3c2b4, 0xffffffff, 0x00000100,
	0x3c2b0, 0xffffffff, 0x00000100,
	0x3c270, 0xffffffff, 0x00000100,
	0x30800, 0xffffffff, 0xe0000000,
	0x3c020, 0xffffffff, 0x00010000,
	0x3c024, 0xffffffff, 0x00030002,
	0x3c028, 0xffffffff, 0x00040007,
	0x3c02c, 0xffffffff, 0x00060005,
	0x3c030, 0xffffffff, 0x00090008,
	0x3c034, 0xffffffff, 0x00010000,
	0x3c038, 0xffffffff, 0x00030002,
	0x3c03c, 0xffffffff, 0x00040007,
	0x3c040, 0xffffffff, 0x00060005,
	0x3c044, 0xffffffff, 0x00090008,
	0x3c000, 0xffffffff, 0x96e00200,
	0x8708, 0xffffffff, 0x00900100,
	0xc424, 0xffffffff, 0x0020003f,
	0x38, 0xffffffff, 0x0140001c,
	0x3c, 0x000f0000, 0x000f0000,
	0x220, 0xffffffff, 0xC060000C,
	0x224, 0xc0000fff, 0x00000100,
	0x20a8, 0xffffffff, 0x00000104,
	0x55e4, 0xff000fff, 0x00000100,
	0x30cc, 0xc0000fff, 0x00000104,
	0xc1e4, 0x00000001, 0x00000001,
	0xd00c, 0xff000ff0, 0x00000100,
	0xd80c, 0xff000ff0, 0x00000100
};

static const u32 hawaii_gowden_spm_wegistews[] =
{
	0x30800, 0xe0ffffff, 0xe0000000
};

static const u32 hawaii_gowden_common_wegistews[] =
{
	0x30800, 0xffffffff, 0xe0000000,
	0x28350, 0xffffffff, 0x3a00161a,
	0x28354, 0xffffffff, 0x0000002e,
	0x9a10, 0xffffffff, 0x00018208,
	0x98f8, 0xffffffff, 0x12011003
};

static const u32 hawaii_gowden_wegistews[] =
{
	0x3354, 0x00000333, 0x00000333,
	0x9a10, 0x00010000, 0x00058208,
	0x9830, 0xffffffff, 0x00000000,
	0x9834, 0xf00fffff, 0x00000400,
	0x9838, 0x0002021c, 0x00020200,
	0xc78, 0x00000080, 0x00000000,
	0x5bb0, 0x000000f0, 0x00000070,
	0x5bc0, 0xf0311fff, 0x80300000,
	0x350c, 0x00810000, 0x408af000,
	0x7030, 0x31000111, 0x00000011,
	0x2f48, 0x73773777, 0x12010001,
	0x2120, 0x0000007f, 0x0000001b,
	0x21dc, 0x00007fb6, 0x00002191,
	0x3628, 0x0000003f, 0x0000000a,
	0x362c, 0x0000003f, 0x0000000a,
	0x2ae4, 0x00073ffe, 0x000022a2,
	0x240c, 0x000007ff, 0x00000000,
	0x8bf0, 0x00002001, 0x00000001,
	0x8b24, 0xffffffff, 0x00ffffff,
	0x30a04, 0x0000ff0f, 0x00000000,
	0x28a4c, 0x07ffffff, 0x06000000,
	0x3e78, 0x00000001, 0x00000002,
	0xc768, 0x00000008, 0x00000008,
	0xc770, 0x00000f00, 0x00000800,
	0xc774, 0x00000f00, 0x00000800,
	0xc798, 0x00ffffff, 0x00ff7fbf,
	0xc79c, 0x00ffffff, 0x00ff7faf,
	0x8c00, 0x000000ff, 0x00000800,
	0xe40, 0x00001fff, 0x00001fff,
	0x9060, 0x0000007f, 0x00000020,
	0x9508, 0x00010000, 0x00010000,
	0xae00, 0x00100000, 0x000ff07c,
	0xac14, 0x000003ff, 0x0000000f,
	0xac10, 0xffffffff, 0x7564fdec,
	0xac0c, 0xffffffff, 0x3120b9a8,
	0xac08, 0x20000000, 0x0f9c0000
};

static const u32 hawaii_mgcg_cgcg_init[] =
{
	0xc420, 0xffffffff, 0xfffffffd,
	0x30800, 0xffffffff, 0xe0000000,
	0x3c2a0, 0xffffffff, 0x00000100,
	0x3c208, 0xffffffff, 0x00000100,
	0x3c2c0, 0xffffffff, 0x00000100,
	0x3c2c8, 0xffffffff, 0x00000100,
	0x3c2c4, 0xffffffff, 0x00000100,
	0x55e4, 0xffffffff, 0x00200100,
	0x3c280, 0xffffffff, 0x00000100,
	0x3c214, 0xffffffff, 0x06000100,
	0x3c220, 0xffffffff, 0x00000100,
	0x3c218, 0xffffffff, 0x06000100,
	0x3c204, 0xffffffff, 0x00000100,
	0x3c2e0, 0xffffffff, 0x00000100,
	0x3c224, 0xffffffff, 0x00000100,
	0x3c200, 0xffffffff, 0x00000100,
	0x3c230, 0xffffffff, 0x00000100,
	0x3c234, 0xffffffff, 0x00000100,
	0x3c250, 0xffffffff, 0x00000100,
	0x3c254, 0xffffffff, 0x00000100,
	0x3c258, 0xffffffff, 0x00000100,
	0x3c25c, 0xffffffff, 0x00000100,
	0x3c260, 0xffffffff, 0x00000100,
	0x3c27c, 0xffffffff, 0x00000100,
	0x3c278, 0xffffffff, 0x00000100,
	0x3c210, 0xffffffff, 0x06000100,
	0x3c290, 0xffffffff, 0x00000100,
	0x3c274, 0xffffffff, 0x00000100,
	0x3c2b4, 0xffffffff, 0x00000100,
	0x3c2b0, 0xffffffff, 0x00000100,
	0x3c270, 0xffffffff, 0x00000100,
	0x30800, 0xffffffff, 0xe0000000,
	0x3c020, 0xffffffff, 0x00010000,
	0x3c024, 0xffffffff, 0x00030002,
	0x3c028, 0xffffffff, 0x00040007,
	0x3c02c, 0xffffffff, 0x00060005,
	0x3c030, 0xffffffff, 0x00090008,
	0x3c034, 0xffffffff, 0x00010000,
	0x3c038, 0xffffffff, 0x00030002,
	0x3c03c, 0xffffffff, 0x00040007,
	0x3c040, 0xffffffff, 0x00060005,
	0x3c044, 0xffffffff, 0x00090008,
	0x3c048, 0xffffffff, 0x00010000,
	0x3c04c, 0xffffffff, 0x00030002,
	0x3c050, 0xffffffff, 0x00040007,
	0x3c054, 0xffffffff, 0x00060005,
	0x3c058, 0xffffffff, 0x00090008,
	0x3c05c, 0xffffffff, 0x00010000,
	0x3c060, 0xffffffff, 0x00030002,
	0x3c064, 0xffffffff, 0x00040007,
	0x3c068, 0xffffffff, 0x00060005,
	0x3c06c, 0xffffffff, 0x00090008,
	0x3c070, 0xffffffff, 0x00010000,
	0x3c074, 0xffffffff, 0x00030002,
	0x3c078, 0xffffffff, 0x00040007,
	0x3c07c, 0xffffffff, 0x00060005,
	0x3c080, 0xffffffff, 0x00090008,
	0x3c084, 0xffffffff, 0x00010000,
	0x3c088, 0xffffffff, 0x00030002,
	0x3c08c, 0xffffffff, 0x00040007,
	0x3c090, 0xffffffff, 0x00060005,
	0x3c094, 0xffffffff, 0x00090008,
	0x3c098, 0xffffffff, 0x00010000,
	0x3c09c, 0xffffffff, 0x00030002,
	0x3c0a0, 0xffffffff, 0x00040007,
	0x3c0a4, 0xffffffff, 0x00060005,
	0x3c0a8, 0xffffffff, 0x00090008,
	0x3c0ac, 0xffffffff, 0x00010000,
	0x3c0b0, 0xffffffff, 0x00030002,
	0x3c0b4, 0xffffffff, 0x00040007,
	0x3c0b8, 0xffffffff, 0x00060005,
	0x3c0bc, 0xffffffff, 0x00090008,
	0x3c0c0, 0xffffffff, 0x00010000,
	0x3c0c4, 0xffffffff, 0x00030002,
	0x3c0c8, 0xffffffff, 0x00040007,
	0x3c0cc, 0xffffffff, 0x00060005,
	0x3c0d0, 0xffffffff, 0x00090008,
	0x3c0d4, 0xffffffff, 0x00010000,
	0x3c0d8, 0xffffffff, 0x00030002,
	0x3c0dc, 0xffffffff, 0x00040007,
	0x3c0e0, 0xffffffff, 0x00060005,
	0x3c0e4, 0xffffffff, 0x00090008,
	0x3c0e8, 0xffffffff, 0x00010000,
	0x3c0ec, 0xffffffff, 0x00030002,
	0x3c0f0, 0xffffffff, 0x00040007,
	0x3c0f4, 0xffffffff, 0x00060005,
	0x3c0f8, 0xffffffff, 0x00090008,
	0xc318, 0xffffffff, 0x00020200,
	0x3350, 0xffffffff, 0x00000200,
	0x15c0, 0xffffffff, 0x00000400,
	0x55e8, 0xffffffff, 0x00000000,
	0x2f50, 0xffffffff, 0x00000902,
	0x3c000, 0xffffffff, 0x96940200,
	0x8708, 0xffffffff, 0x00900100,
	0xc424, 0xffffffff, 0x0020003f,
	0x38, 0xffffffff, 0x0140001c,
	0x3c, 0x000f0000, 0x000f0000,
	0x220, 0xffffffff, 0xc060000c,
	0x224, 0xc0000fff, 0x00000100,
	0xf90, 0xffffffff, 0x00000100,
	0xf98, 0x00000101, 0x00000000,
	0x20a8, 0xffffffff, 0x00000104,
	0x55e4, 0xff000fff, 0x00000100,
	0x30cc, 0xc0000fff, 0x00000104,
	0xc1e4, 0x00000001, 0x00000001,
	0xd00c, 0xff000ff0, 0x00000100,
	0xd80c, 0xff000ff0, 0x00000100
};

static const u32 godavawi_gowden_wegistews[] =
{
	0x55e4, 0xff607fff, 0xfc000100,
	0x6ed8, 0x00010101, 0x00010000,
	0x9830, 0xffffffff, 0x00000000,
	0x98302, 0xf00fffff, 0x00000400,
	0x6130, 0xffffffff, 0x00010000,
	0x5bb0, 0x000000f0, 0x00000070,
	0x5bc0, 0xf0311fff, 0x80300000,
	0x98f8, 0x73773777, 0x12010001,
	0x98fc, 0xffffffff, 0x00000010,
	0x8030, 0x00001f0f, 0x0000100a,
	0x2f48, 0x73773777, 0x12010001,
	0x2408, 0x000fffff, 0x000c007f,
	0x8a14, 0xf000003f, 0x00000007,
	0x8b24, 0xffffffff, 0x00ff0fff,
	0x30a04, 0x0000ff0f, 0x00000000,
	0x28a4c, 0x07ffffff, 0x06000000,
	0x4d8, 0x00000fff, 0x00000100,
	0xd014, 0x00010000, 0x00810001,
	0xd814, 0x00010000, 0x00810001,
	0x3e78, 0x00000001, 0x00000002,
	0xc768, 0x00000008, 0x00000008,
	0xc770, 0x00000f00, 0x00000800,
	0xc774, 0x00000f00, 0x00000800,
	0xc798, 0x00ffffff, 0x00ff7fbf,
	0xc79c, 0x00ffffff, 0x00ff7faf,
	0x8c00, 0x000000ff, 0x00000001,
	0x214f8, 0x01ff01ff, 0x00000002,
	0x21498, 0x007ff800, 0x00200000,
	0x2015c, 0xffffffff, 0x00000f40,
	0x88c4, 0x001f3ae3, 0x00000082,
	0x88d4, 0x0000001f, 0x00000010,
	0x30934, 0xffffffff, 0x00000000
};


static void cik_init_gowden_wegistews(stwuct wadeon_device *wdev)
{
	switch (wdev->famiwy) {
	case CHIP_BONAIWE:
		wadeon_pwogwam_wegistew_sequence(wdev,
						 bonaiwe_mgcg_cgcg_init,
						 (const u32)AWWAY_SIZE(bonaiwe_mgcg_cgcg_init));
		wadeon_pwogwam_wegistew_sequence(wdev,
						 bonaiwe_gowden_wegistews,
						 (const u32)AWWAY_SIZE(bonaiwe_gowden_wegistews));
		wadeon_pwogwam_wegistew_sequence(wdev,
						 bonaiwe_gowden_common_wegistews,
						 (const u32)AWWAY_SIZE(bonaiwe_gowden_common_wegistews));
		wadeon_pwogwam_wegistew_sequence(wdev,
						 bonaiwe_gowden_spm_wegistews,
						 (const u32)AWWAY_SIZE(bonaiwe_gowden_spm_wegistews));
		bweak;
	case CHIP_KABINI:
		wadeon_pwogwam_wegistew_sequence(wdev,
						 kawindi_mgcg_cgcg_init,
						 (const u32)AWWAY_SIZE(kawindi_mgcg_cgcg_init));
		wadeon_pwogwam_wegistew_sequence(wdev,
						 kawindi_gowden_wegistews,
						 (const u32)AWWAY_SIZE(kawindi_gowden_wegistews));
		wadeon_pwogwam_wegistew_sequence(wdev,
						 kawindi_gowden_common_wegistews,
						 (const u32)AWWAY_SIZE(kawindi_gowden_common_wegistews));
		wadeon_pwogwam_wegistew_sequence(wdev,
						 kawindi_gowden_spm_wegistews,
						 (const u32)AWWAY_SIZE(kawindi_gowden_spm_wegistews));
		bweak;
	case CHIP_MUWWINS:
		wadeon_pwogwam_wegistew_sequence(wdev,
						 kawindi_mgcg_cgcg_init,
						 (const u32)AWWAY_SIZE(kawindi_mgcg_cgcg_init));
		wadeon_pwogwam_wegistew_sequence(wdev,
						 godavawi_gowden_wegistews,
						 (const u32)AWWAY_SIZE(godavawi_gowden_wegistews));
		wadeon_pwogwam_wegistew_sequence(wdev,
						 kawindi_gowden_common_wegistews,
						 (const u32)AWWAY_SIZE(kawindi_gowden_common_wegistews));
		wadeon_pwogwam_wegistew_sequence(wdev,
						 kawindi_gowden_spm_wegistews,
						 (const u32)AWWAY_SIZE(kawindi_gowden_spm_wegistews));
		bweak;
	case CHIP_KAVEWI:
		wadeon_pwogwam_wegistew_sequence(wdev,
						 spectwe_mgcg_cgcg_init,
						 (const u32)AWWAY_SIZE(spectwe_mgcg_cgcg_init));
		wadeon_pwogwam_wegistew_sequence(wdev,
						 spectwe_gowden_wegistews,
						 (const u32)AWWAY_SIZE(spectwe_gowden_wegistews));
		wadeon_pwogwam_wegistew_sequence(wdev,
						 spectwe_gowden_common_wegistews,
						 (const u32)AWWAY_SIZE(spectwe_gowden_common_wegistews));
		wadeon_pwogwam_wegistew_sequence(wdev,
						 spectwe_gowden_spm_wegistews,
						 (const u32)AWWAY_SIZE(spectwe_gowden_spm_wegistews));
		bweak;
	case CHIP_HAWAII:
		wadeon_pwogwam_wegistew_sequence(wdev,
						 hawaii_mgcg_cgcg_init,
						 (const u32)AWWAY_SIZE(hawaii_mgcg_cgcg_init));
		wadeon_pwogwam_wegistew_sequence(wdev,
						 hawaii_gowden_wegistews,
						 (const u32)AWWAY_SIZE(hawaii_gowden_wegistews));
		wadeon_pwogwam_wegistew_sequence(wdev,
						 hawaii_gowden_common_wegistews,
						 (const u32)AWWAY_SIZE(hawaii_gowden_common_wegistews));
		wadeon_pwogwam_wegistew_sequence(wdev,
						 hawaii_gowden_spm_wegistews,
						 (const u32)AWWAY_SIZE(hawaii_gowden_spm_wegistews));
		bweak;
	defauwt:
		bweak;
	}
}

/**
 * cik_get_xcwk - get the xcwk
 *
 * @wdev: wadeon_device pointew
 *
 * Wetuwns the wefewence cwock used by the gfx engine
 * (CIK).
 */
u32 cik_get_xcwk(stwuct wadeon_device *wdev)
{
	u32 wefewence_cwock = wdev->cwock.spww.wefewence_fweq;

	if (wdev->fwags & WADEON_IS_IGP) {
		if (WWEG32_SMC(GENEWAW_PWWMGT) & GPU_COUNTEW_CWK)
			wetuwn wefewence_cwock / 2;
	} ewse {
		if (WWEG32_SMC(CG_CWKPIN_CNTW) & XTAWIN_DIVIDE)
			wetuwn wefewence_cwock / 4;
	}
	wetuwn wefewence_cwock;
}

/**
 * cik_mm_wdoowbeww - wead a doowbeww dwowd
 *
 * @wdev: wadeon_device pointew
 * @index: doowbeww index
 *
 * Wetuwns the vawue in the doowbeww apewtuwe at the
 * wequested doowbeww index (CIK).
 */
u32 cik_mm_wdoowbeww(stwuct wadeon_device *wdev, u32 index)
{
	if (index < wdev->doowbeww.num_doowbewws) {
		wetuwn weadw(wdev->doowbeww.ptw + index);
	} ewse {
		DWM_EWWOW("weading beyond doowbeww apewtuwe: 0x%08x!\n", index);
		wetuwn 0;
	}
}

/**
 * cik_mm_wdoowbeww - wwite a doowbeww dwowd
 *
 * @wdev: wadeon_device pointew
 * @index: doowbeww index
 * @v: vawue to wwite
 *
 * Wwites @v to the doowbeww apewtuwe at the
 * wequested doowbeww index (CIK).
 */
void cik_mm_wdoowbeww(stwuct wadeon_device *wdev, u32 index, u32 v)
{
	if (index < wdev->doowbeww.num_doowbewws) {
		wwitew(v, wdev->doowbeww.ptw + index);
	} ewse {
		DWM_EWWOW("wwiting beyond doowbeww apewtuwe: 0x%08x!\n", index);
	}
}

#define BONAIWE_IO_MC_WEGS_SIZE 36

static const u32 bonaiwe_io_mc_wegs[BONAIWE_IO_MC_WEGS_SIZE][2] =
{
	{0x00000070, 0x04400000},
	{0x00000071, 0x80c01803},
	{0x00000072, 0x00004004},
	{0x00000073, 0x00000100},
	{0x00000074, 0x00ff0000},
	{0x00000075, 0x34000000},
	{0x00000076, 0x08000014},
	{0x00000077, 0x00cc08ec},
	{0x00000078, 0x00000400},
	{0x00000079, 0x00000000},
	{0x0000007a, 0x04090000},
	{0x0000007c, 0x00000000},
	{0x0000007e, 0x4408a8e8},
	{0x0000007f, 0x00000304},
	{0x00000080, 0x00000000},
	{0x00000082, 0x00000001},
	{0x00000083, 0x00000002},
	{0x00000084, 0xf3e4f400},
	{0x00000085, 0x052024e3},
	{0x00000087, 0x00000000},
	{0x00000088, 0x01000000},
	{0x0000008a, 0x1c0a0000},
	{0x0000008b, 0xff010000},
	{0x0000008d, 0xffffefff},
	{0x0000008e, 0xfff3efff},
	{0x0000008f, 0xfff3efbf},
	{0x00000092, 0xf7ffffff},
	{0x00000093, 0xffffff7f},
	{0x00000095, 0x00101101},
	{0x00000096, 0x00000fff},
	{0x00000097, 0x00116fff},
	{0x00000098, 0x60010000},
	{0x00000099, 0x10010000},
	{0x0000009a, 0x00006000},
	{0x0000009b, 0x00001000},
	{0x0000009f, 0x00b48000}
};

#define HAWAII_IO_MC_WEGS_SIZE 22

static const u32 hawaii_io_mc_wegs[HAWAII_IO_MC_WEGS_SIZE][2] =
{
	{0x0000007d, 0x40000000},
	{0x0000007e, 0x40180304},
	{0x0000007f, 0x0000ff00},
	{0x00000081, 0x00000000},
	{0x00000083, 0x00000800},
	{0x00000086, 0x00000000},
	{0x00000087, 0x00000100},
	{0x00000088, 0x00020100},
	{0x00000089, 0x00000000},
	{0x0000008b, 0x00040000},
	{0x0000008c, 0x00000100},
	{0x0000008e, 0xff010000},
	{0x00000090, 0xffffefff},
	{0x00000091, 0xfff3efff},
	{0x00000092, 0xfff3efbf},
	{0x00000093, 0xf7ffffff},
	{0x00000094, 0xffffff7f},
	{0x00000095, 0x00000fff},
	{0x00000096, 0x00116fff},
	{0x00000097, 0x60010000},
	{0x00000098, 0x10010000},
	{0x0000009f, 0x00c79000}
};


/**
 * cik_swbm_sewect - sewect specific wegistew instances
 *
 * @wdev: wadeon_device pointew
 * @me: sewected ME (micwo engine)
 * @pipe: pipe
 * @queue: queue
 * @vmid: VMID
 *
 * Switches the cuwwentwy active wegistews instances.  Some
 * wegistews awe instanced pew VMID, othews awe instanced pew
 * me/pipe/queue combination.
 */
static void cik_swbm_sewect(stwuct wadeon_device *wdev,
			    u32 me, u32 pipe, u32 queue, u32 vmid)
{
	u32 swbm_gfx_cntw = (PIPEID(pipe & 0x3) |
			     MEID(me & 0x3) |
			     VMID(vmid & 0xf) |
			     QUEUEID(queue & 0x7));
	WWEG32(SWBM_GFX_CNTW, swbm_gfx_cntw);
}

/* ucode woading */
/**
 * ci_mc_woad_micwocode - woad MC ucode into the hw
 *
 * @wdev: wadeon_device pointew
 *
 * Woad the GDDW MC ucode into the hw (CIK).
 * Wetuwns 0 on success, ewwow on faiwuwe.
 */
int ci_mc_woad_micwocode(stwuct wadeon_device *wdev)
{
	const __be32 *fw_data = NUWW;
	const __we32 *new_fw_data = NUWW;
	u32 wunning, tmp;
	u32 *io_mc_wegs = NUWW;
	const __we32 *new_io_mc_wegs = NUWW;
	int i, wegs_size, ucode_size;

	if (!wdev->mc_fw)
		wetuwn -EINVAW;

	if (wdev->new_fw) {
		const stwuct mc_fiwmwawe_headew_v1_0 *hdw =
			(const stwuct mc_fiwmwawe_headew_v1_0 *)wdev->mc_fw->data;

		wadeon_ucode_pwint_mc_hdw(&hdw->headew);

		wegs_size = we32_to_cpu(hdw->io_debug_size_bytes) / (4 * 2);
		new_io_mc_wegs = (const __we32 *)
			(wdev->mc_fw->data + we32_to_cpu(hdw->io_debug_awway_offset_bytes));
		ucode_size = we32_to_cpu(hdw->headew.ucode_size_bytes) / 4;
		new_fw_data = (const __we32 *)
			(wdev->mc_fw->data + we32_to_cpu(hdw->headew.ucode_awway_offset_bytes));
	} ewse {
		ucode_size = wdev->mc_fw->size / 4;

		switch (wdev->famiwy) {
		case CHIP_BONAIWE:
			io_mc_wegs = (u32 *)&bonaiwe_io_mc_wegs;
			wegs_size = BONAIWE_IO_MC_WEGS_SIZE;
			bweak;
		case CHIP_HAWAII:
			io_mc_wegs = (u32 *)&hawaii_io_mc_wegs;
			wegs_size = HAWAII_IO_MC_WEGS_SIZE;
			bweak;
		defauwt:
			wetuwn -EINVAW;
		}
		fw_data = (const __be32 *)wdev->mc_fw->data;
	}

	wunning = WWEG32(MC_SEQ_SUP_CNTW) & WUN_MASK;

	if (wunning == 0) {
		/* weset the engine and set to wwitabwe */
		WWEG32(MC_SEQ_SUP_CNTW, 0x00000008);
		WWEG32(MC_SEQ_SUP_CNTW, 0x00000010);

		/* woad mc io wegs */
		fow (i = 0; i < wegs_size; i++) {
			if (wdev->new_fw) {
				WWEG32(MC_SEQ_IO_DEBUG_INDEX, we32_to_cpup(new_io_mc_wegs++));
				WWEG32(MC_SEQ_IO_DEBUG_DATA, we32_to_cpup(new_io_mc_wegs++));
			} ewse {
				WWEG32(MC_SEQ_IO_DEBUG_INDEX, io_mc_wegs[(i << 1)]);
				WWEG32(MC_SEQ_IO_DEBUG_DATA, io_mc_wegs[(i << 1) + 1]);
			}
		}

		tmp = WWEG32(MC_SEQ_MISC0);
		if ((wdev->pdev->device == 0x6649) && ((tmp & 0xff00) == 0x5600)) {
			WWEG32(MC_SEQ_IO_DEBUG_INDEX, 5);
			WWEG32(MC_SEQ_IO_DEBUG_DATA, 0x00000023);
			WWEG32(MC_SEQ_IO_DEBUG_INDEX, 9);
			WWEG32(MC_SEQ_IO_DEBUG_DATA, 0x000001f0);
		}

		/* woad the MC ucode */
		fow (i = 0; i < ucode_size; i++) {
			if (wdev->new_fw)
				WWEG32(MC_SEQ_SUP_PGM, we32_to_cpup(new_fw_data++));
			ewse
				WWEG32(MC_SEQ_SUP_PGM, be32_to_cpup(fw_data++));
		}

		/* put the engine back into the active state */
		WWEG32(MC_SEQ_SUP_CNTW, 0x00000008);
		WWEG32(MC_SEQ_SUP_CNTW, 0x00000004);
		WWEG32(MC_SEQ_SUP_CNTW, 0x00000001);

		/* wait fow twaining to compwete */
		fow (i = 0; i < wdev->usec_timeout; i++) {
			if (WWEG32(MC_SEQ_TWAIN_WAKEUP_CNTW) & TWAIN_DONE_D0)
				bweak;
			udeway(1);
		}
		fow (i = 0; i < wdev->usec_timeout; i++) {
			if (WWEG32(MC_SEQ_TWAIN_WAKEUP_CNTW) & TWAIN_DONE_D1)
				bweak;
			udeway(1);
		}
	}

	wetuwn 0;
}

/**
 * cik_init_micwocode - woad ucode images fwom disk
 *
 * @wdev: wadeon_device pointew
 *
 * Use the fiwmwawe intewface to woad the ucode images into
 * the dwivew (not woaded into hw).
 * Wetuwns 0 on success, ewwow on faiwuwe.
 */
static int cik_init_micwocode(stwuct wadeon_device *wdev)
{
	const chaw *chip_name;
	const chaw *new_chip_name;
	size_t pfp_weq_size, me_weq_size, ce_weq_size,
		mec_weq_size, wwc_weq_size, mc_weq_size = 0,
		sdma_weq_size, smc_weq_size = 0, mc2_weq_size = 0;
	chaw fw_name[30];
	int new_fw = 0;
	int eww;
	int num_fw;
	boow new_smc = fawse;

	DWM_DEBUG("\n");

	switch (wdev->famiwy) {
	case CHIP_BONAIWE:
		chip_name = "BONAIWE";
		if ((wdev->pdev->wevision == 0x80) ||
		    (wdev->pdev->wevision == 0x81) ||
		    (wdev->pdev->device == 0x665f))
			new_smc = twue;
		new_chip_name = "bonaiwe";
		pfp_weq_size = CIK_PFP_UCODE_SIZE * 4;
		me_weq_size = CIK_ME_UCODE_SIZE * 4;
		ce_weq_size = CIK_CE_UCODE_SIZE * 4;
		mec_weq_size = CIK_MEC_UCODE_SIZE * 4;
		wwc_weq_size = BONAIWE_WWC_UCODE_SIZE * 4;
		mc_weq_size = BONAIWE_MC_UCODE_SIZE * 4;
		mc2_weq_size = BONAIWE_MC2_UCODE_SIZE * 4;
		sdma_weq_size = CIK_SDMA_UCODE_SIZE * 4;
		smc_weq_size = AWIGN(BONAIWE_SMC_UCODE_SIZE, 4);
		num_fw = 8;
		bweak;
	case CHIP_HAWAII:
		chip_name = "HAWAII";
		if (wdev->pdev->wevision == 0x80)
			new_smc = twue;
		new_chip_name = "hawaii";
		pfp_weq_size = CIK_PFP_UCODE_SIZE * 4;
		me_weq_size = CIK_ME_UCODE_SIZE * 4;
		ce_weq_size = CIK_CE_UCODE_SIZE * 4;
		mec_weq_size = CIK_MEC_UCODE_SIZE * 4;
		wwc_weq_size = BONAIWE_WWC_UCODE_SIZE * 4;
		mc_weq_size = HAWAII_MC_UCODE_SIZE * 4;
		mc2_weq_size = HAWAII_MC2_UCODE_SIZE * 4;
		sdma_weq_size = CIK_SDMA_UCODE_SIZE * 4;
		smc_weq_size = AWIGN(HAWAII_SMC_UCODE_SIZE, 4);
		num_fw = 8;
		bweak;
	case CHIP_KAVEWI:
		chip_name = "KAVEWI";
		new_chip_name = "kavewi";
		pfp_weq_size = CIK_PFP_UCODE_SIZE * 4;
		me_weq_size = CIK_ME_UCODE_SIZE * 4;
		ce_weq_size = CIK_CE_UCODE_SIZE * 4;
		mec_weq_size = CIK_MEC_UCODE_SIZE * 4;
		wwc_weq_size = KV_WWC_UCODE_SIZE * 4;
		sdma_weq_size = CIK_SDMA_UCODE_SIZE * 4;
		num_fw = 7;
		bweak;
	case CHIP_KABINI:
		chip_name = "KABINI";
		new_chip_name = "kabini";
		pfp_weq_size = CIK_PFP_UCODE_SIZE * 4;
		me_weq_size = CIK_ME_UCODE_SIZE * 4;
		ce_weq_size = CIK_CE_UCODE_SIZE * 4;
		mec_weq_size = CIK_MEC_UCODE_SIZE * 4;
		wwc_weq_size = KB_WWC_UCODE_SIZE * 4;
		sdma_weq_size = CIK_SDMA_UCODE_SIZE * 4;
		num_fw = 6;
		bweak;
	case CHIP_MUWWINS:
		chip_name = "MUWWINS";
		new_chip_name = "muwwins";
		pfp_weq_size = CIK_PFP_UCODE_SIZE * 4;
		me_weq_size = CIK_ME_UCODE_SIZE * 4;
		ce_weq_size = CIK_CE_UCODE_SIZE * 4;
		mec_weq_size = CIK_MEC_UCODE_SIZE * 4;
		wwc_weq_size = MW_WWC_UCODE_SIZE * 4;
		sdma_weq_size = CIK_SDMA_UCODE_SIZE * 4;
		num_fw = 6;
		bweak;
	defauwt: BUG();
	}

	DWM_INFO("Woading %s Micwocode\n", new_chip_name);

	snpwintf(fw_name, sizeof(fw_name), "wadeon/%s_pfp.bin", new_chip_name);
	eww = wequest_fiwmwawe(&wdev->pfp_fw, fw_name, wdev->dev);
	if (eww) {
		snpwintf(fw_name, sizeof(fw_name), "wadeon/%s_pfp.bin", chip_name);
		eww = wequest_fiwmwawe(&wdev->pfp_fw, fw_name, wdev->dev);
		if (eww)
			goto out;
		if (wdev->pfp_fw->size != pfp_weq_size) {
			pw_eww("cik_cp: Bogus wength %zu in fiwmwawe \"%s\"\n",
			       wdev->pfp_fw->size, fw_name);
			eww = -EINVAW;
			goto out;
		}
	} ewse {
		eww = wadeon_ucode_vawidate(wdev->pfp_fw);
		if (eww) {
			pw_eww("cik_fw: vawidation faiwed fow fiwmwawe \"%s\"\n",
			       fw_name);
			goto out;
		} ewse {
			new_fw++;
		}
	}

	snpwintf(fw_name, sizeof(fw_name), "wadeon/%s_me.bin", new_chip_name);
	eww = wequest_fiwmwawe(&wdev->me_fw, fw_name, wdev->dev);
	if (eww) {
		snpwintf(fw_name, sizeof(fw_name), "wadeon/%s_me.bin", chip_name);
		eww = wequest_fiwmwawe(&wdev->me_fw, fw_name, wdev->dev);
		if (eww)
			goto out;
		if (wdev->me_fw->size != me_weq_size) {
			pw_eww("cik_cp: Bogus wength %zu in fiwmwawe \"%s\"\n",
			       wdev->me_fw->size, fw_name);
			eww = -EINVAW;
		}
	} ewse {
		eww = wadeon_ucode_vawidate(wdev->me_fw);
		if (eww) {
			pw_eww("cik_fw: vawidation faiwed fow fiwmwawe \"%s\"\n",
			       fw_name);
			goto out;
		} ewse {
			new_fw++;
		}
	}

	snpwintf(fw_name, sizeof(fw_name), "wadeon/%s_ce.bin", new_chip_name);
	eww = wequest_fiwmwawe(&wdev->ce_fw, fw_name, wdev->dev);
	if (eww) {
		snpwintf(fw_name, sizeof(fw_name), "wadeon/%s_ce.bin", chip_name);
		eww = wequest_fiwmwawe(&wdev->ce_fw, fw_name, wdev->dev);
		if (eww)
			goto out;
		if (wdev->ce_fw->size != ce_weq_size) {
			pw_eww("cik_cp: Bogus wength %zu in fiwmwawe \"%s\"\n",
			       wdev->ce_fw->size, fw_name);
			eww = -EINVAW;
		}
	} ewse {
		eww = wadeon_ucode_vawidate(wdev->ce_fw);
		if (eww) {
			pw_eww("cik_fw: vawidation faiwed fow fiwmwawe \"%s\"\n",
			       fw_name);
			goto out;
		} ewse {
			new_fw++;
		}
	}

	snpwintf(fw_name, sizeof(fw_name), "wadeon/%s_mec.bin", new_chip_name);
	eww = wequest_fiwmwawe(&wdev->mec_fw, fw_name, wdev->dev);
	if (eww) {
		snpwintf(fw_name, sizeof(fw_name), "wadeon/%s_mec.bin", chip_name);
		eww = wequest_fiwmwawe(&wdev->mec_fw, fw_name, wdev->dev);
		if (eww)
			goto out;
		if (wdev->mec_fw->size != mec_weq_size) {
			pw_eww("cik_cp: Bogus wength %zu in fiwmwawe \"%s\"\n",
			       wdev->mec_fw->size, fw_name);
			eww = -EINVAW;
		}
	} ewse {
		eww = wadeon_ucode_vawidate(wdev->mec_fw);
		if (eww) {
			pw_eww("cik_fw: vawidation faiwed fow fiwmwawe \"%s\"\n",
			       fw_name);
			goto out;
		} ewse {
			new_fw++;
		}
	}

	if (wdev->famiwy == CHIP_KAVEWI) {
		snpwintf(fw_name, sizeof(fw_name), "wadeon/%s_mec2.bin", new_chip_name);
		eww = wequest_fiwmwawe(&wdev->mec2_fw, fw_name, wdev->dev);
		if (eww) {
			goto out;
		} ewse {
			eww = wadeon_ucode_vawidate(wdev->mec2_fw);
			if (eww) {
				goto out;
			} ewse {
				new_fw++;
			}
		}
	}

	snpwintf(fw_name, sizeof(fw_name), "wadeon/%s_wwc.bin", new_chip_name);
	eww = wequest_fiwmwawe(&wdev->wwc_fw, fw_name, wdev->dev);
	if (eww) {
		snpwintf(fw_name, sizeof(fw_name), "wadeon/%s_wwc.bin", chip_name);
		eww = wequest_fiwmwawe(&wdev->wwc_fw, fw_name, wdev->dev);
		if (eww)
			goto out;
		if (wdev->wwc_fw->size != wwc_weq_size) {
			pw_eww("cik_wwc: Bogus wength %zu in fiwmwawe \"%s\"\n",
			       wdev->wwc_fw->size, fw_name);
			eww = -EINVAW;
		}
	} ewse {
		eww = wadeon_ucode_vawidate(wdev->wwc_fw);
		if (eww) {
			pw_eww("cik_fw: vawidation faiwed fow fiwmwawe \"%s\"\n",
			       fw_name);
			goto out;
		} ewse {
			new_fw++;
		}
	}

	snpwintf(fw_name, sizeof(fw_name), "wadeon/%s_sdma.bin", new_chip_name);
	eww = wequest_fiwmwawe(&wdev->sdma_fw, fw_name, wdev->dev);
	if (eww) {
		snpwintf(fw_name, sizeof(fw_name), "wadeon/%s_sdma.bin", chip_name);
		eww = wequest_fiwmwawe(&wdev->sdma_fw, fw_name, wdev->dev);
		if (eww)
			goto out;
		if (wdev->sdma_fw->size != sdma_weq_size) {
			pw_eww("cik_sdma: Bogus wength %zu in fiwmwawe \"%s\"\n",
			       wdev->sdma_fw->size, fw_name);
			eww = -EINVAW;
		}
	} ewse {
		eww = wadeon_ucode_vawidate(wdev->sdma_fw);
		if (eww) {
			pw_eww("cik_fw: vawidation faiwed fow fiwmwawe \"%s\"\n",
			       fw_name);
			goto out;
		} ewse {
			new_fw++;
		}
	}

	/* No SMC, MC ucode on APUs */
	if (!(wdev->fwags & WADEON_IS_IGP)) {
		snpwintf(fw_name, sizeof(fw_name), "wadeon/%s_mc.bin", new_chip_name);
		eww = wequest_fiwmwawe(&wdev->mc_fw, fw_name, wdev->dev);
		if (eww) {
			snpwintf(fw_name, sizeof(fw_name), "wadeon/%s_mc2.bin", chip_name);
			eww = wequest_fiwmwawe(&wdev->mc_fw, fw_name, wdev->dev);
			if (eww) {
				snpwintf(fw_name, sizeof(fw_name), "wadeon/%s_mc.bin", chip_name);
				eww = wequest_fiwmwawe(&wdev->mc_fw, fw_name, wdev->dev);
				if (eww)
					goto out;
			}
			if ((wdev->mc_fw->size != mc_weq_size) &&
			    (wdev->mc_fw->size != mc2_weq_size)){
				pw_eww("cik_mc: Bogus wength %zu in fiwmwawe \"%s\"\n",
				       wdev->mc_fw->size, fw_name);
				eww = -EINVAW;
			}
			DWM_INFO("%s: %zu bytes\n", fw_name, wdev->mc_fw->size);
		} ewse {
			eww = wadeon_ucode_vawidate(wdev->mc_fw);
			if (eww) {
				pw_eww("cik_fw: vawidation faiwed fow fiwmwawe \"%s\"\n",
				       fw_name);
				goto out;
			} ewse {
				new_fw++;
			}
		}

		if (new_smc)
			snpwintf(fw_name, sizeof(fw_name), "wadeon/%s_k_smc.bin", new_chip_name);
		ewse
			snpwintf(fw_name, sizeof(fw_name), "wadeon/%s_smc.bin", new_chip_name);
		eww = wequest_fiwmwawe(&wdev->smc_fw, fw_name, wdev->dev);
		if (eww) {
			snpwintf(fw_name, sizeof(fw_name), "wadeon/%s_smc.bin", chip_name);
			eww = wequest_fiwmwawe(&wdev->smc_fw, fw_name, wdev->dev);
			if (eww) {
				pw_eww("smc: ewwow woading fiwmwawe \"%s\"\n",
				       fw_name);
				wewease_fiwmwawe(wdev->smc_fw);
				wdev->smc_fw = NUWW;
				eww = 0;
			} ewse if (wdev->smc_fw->size != smc_weq_size) {
				pw_eww("cik_smc: Bogus wength %zu in fiwmwawe \"%s\"\n",
				       wdev->smc_fw->size, fw_name);
				eww = -EINVAW;
			}
		} ewse {
			eww = wadeon_ucode_vawidate(wdev->smc_fw);
			if (eww) {
				pw_eww("cik_fw: vawidation faiwed fow fiwmwawe \"%s\"\n",
				       fw_name);
				goto out;
			} ewse {
				new_fw++;
			}
		}
	}

	if (new_fw == 0) {
		wdev->new_fw = fawse;
	} ewse if (new_fw < num_fw) {
		pw_eww("ci_fw: mixing new and owd fiwmwawe!\n");
		eww = -EINVAW;
	} ewse {
		wdev->new_fw = twue;
	}

out:
	if (eww) {
		if (eww != -EINVAW)
			pw_eww("cik_cp: Faiwed to woad fiwmwawe \"%s\"\n",
			       fw_name);
		wewease_fiwmwawe(wdev->pfp_fw);
		wdev->pfp_fw = NUWW;
		wewease_fiwmwawe(wdev->me_fw);
		wdev->me_fw = NUWW;
		wewease_fiwmwawe(wdev->ce_fw);
		wdev->ce_fw = NUWW;
		wewease_fiwmwawe(wdev->mec_fw);
		wdev->mec_fw = NUWW;
		wewease_fiwmwawe(wdev->mec2_fw);
		wdev->mec2_fw = NUWW;
		wewease_fiwmwawe(wdev->wwc_fw);
		wdev->wwc_fw = NUWW;
		wewease_fiwmwawe(wdev->sdma_fw);
		wdev->sdma_fw = NUWW;
		wewease_fiwmwawe(wdev->mc_fw);
		wdev->mc_fw = NUWW;
		wewease_fiwmwawe(wdev->smc_fw);
		wdev->smc_fw = NUWW;
	}
	wetuwn eww;
}

/*
 * Cowe functions
 */
/**
 * cik_tiwing_mode_tabwe_init - init the hw tiwing tabwe
 *
 * @wdev: wadeon_device pointew
 *
 * Stawting with SI, the tiwing setup is done gwobawwy in a
 * set of 32 tiwing modes.  Wathew than sewecting each set of
 * pawametews pew suwface as on owdew asics, we just sewect
 * which index in the tiwing tabwe we want to use, and the
 * suwface uses those pawametews (CIK).
 */
static void cik_tiwing_mode_tabwe_init(stwuct wadeon_device *wdev)
{
	u32 *tiwe = wdev->config.cik.tiwe_mode_awway;
	u32 *macwotiwe = wdev->config.cik.macwotiwe_mode_awway;
	const u32 num_tiwe_mode_states =
			AWWAY_SIZE(wdev->config.cik.tiwe_mode_awway);
	const u32 num_secondawy_tiwe_mode_states =
			AWWAY_SIZE(wdev->config.cik.macwotiwe_mode_awway);
	u32 weg_offset, spwit_equaw_to_wow_size;
	u32 num_pipe_configs;
	u32 num_wbs = wdev->config.cik.max_backends_pew_se *
		wdev->config.cik.max_shadew_engines;

	switch (wdev->config.cik.mem_wow_size_in_kb) {
	case 1:
		spwit_equaw_to_wow_size = ADDW_SUWF_TIWE_SPWIT_1KB;
		bweak;
	case 2:
	defauwt:
		spwit_equaw_to_wow_size = ADDW_SUWF_TIWE_SPWIT_2KB;
		bweak;
	case 4:
		spwit_equaw_to_wow_size = ADDW_SUWF_TIWE_SPWIT_4KB;
		bweak;
	}

	num_pipe_configs = wdev->config.cik.max_tiwe_pipes;
	if (num_pipe_configs > 8)
		num_pipe_configs = 16;

	fow (weg_offset = 0; weg_offset < num_tiwe_mode_states; weg_offset++)
		tiwe[weg_offset] = 0;
	fow (weg_offset = 0; weg_offset < num_secondawy_tiwe_mode_states; weg_offset++)
		macwotiwe[weg_offset] = 0;

	switch(num_pipe_configs) {
	case 16:
		tiwe[0] = (AWWAY_MODE(AWWAY_2D_TIWED_THIN1) |
			   MICWO_TIWE_MODE_NEW(ADDW_SUWF_DEPTH_MICWO_TIWING) |
			   PIPE_CONFIG(ADDW_SUWF_P16_32x32_16x16) |
			   TIWE_SPWIT(ADDW_SUWF_TIWE_SPWIT_64B));
		tiwe[1] = (AWWAY_MODE(AWWAY_2D_TIWED_THIN1) |
			   MICWO_TIWE_MODE_NEW(ADDW_SUWF_DEPTH_MICWO_TIWING) |
			   PIPE_CONFIG(ADDW_SUWF_P16_32x32_16x16) |
			   TIWE_SPWIT(ADDW_SUWF_TIWE_SPWIT_128B));
		tiwe[2] = (AWWAY_MODE(AWWAY_2D_TIWED_THIN1) |
			   MICWO_TIWE_MODE_NEW(ADDW_SUWF_DEPTH_MICWO_TIWING) |
			   PIPE_CONFIG(ADDW_SUWF_P16_32x32_16x16) |
			   TIWE_SPWIT(ADDW_SUWF_TIWE_SPWIT_256B));
		tiwe[3] = (AWWAY_MODE(AWWAY_2D_TIWED_THIN1) |
			   MICWO_TIWE_MODE_NEW(ADDW_SUWF_DEPTH_MICWO_TIWING) |
			   PIPE_CONFIG(ADDW_SUWF_P16_32x32_16x16) |
			   TIWE_SPWIT(ADDW_SUWF_TIWE_SPWIT_512B));
		tiwe[4] = (AWWAY_MODE(AWWAY_2D_TIWED_THIN1) |
			   MICWO_TIWE_MODE_NEW(ADDW_SUWF_DEPTH_MICWO_TIWING) |
			   PIPE_CONFIG(ADDW_SUWF_P16_32x32_16x16) |
			   TIWE_SPWIT(spwit_equaw_to_wow_size));
		tiwe[5] = (AWWAY_MODE(AWWAY_1D_TIWED_THIN1) |
			   PIPE_CONFIG(ADDW_SUWF_P16_32x32_16x16) |
			   MICWO_TIWE_MODE_NEW(ADDW_SUWF_DEPTH_MICWO_TIWING));
		tiwe[6] = (AWWAY_MODE(AWWAY_PWT_2D_TIWED_THIN1) |
			   MICWO_TIWE_MODE_NEW(ADDW_SUWF_DEPTH_MICWO_TIWING) |
			   PIPE_CONFIG(ADDW_SUWF_P16_32x32_16x16) |
			   TIWE_SPWIT(ADDW_SUWF_TIWE_SPWIT_256B));
		tiwe[7] = (AWWAY_MODE(AWWAY_PWT_2D_TIWED_THIN1) |
			   MICWO_TIWE_MODE_NEW(ADDW_SUWF_DEPTH_MICWO_TIWING) |
			   PIPE_CONFIG(ADDW_SUWF_P16_32x32_16x16) |
			   TIWE_SPWIT(spwit_equaw_to_wow_size));
		tiwe[8] = (AWWAY_MODE(AWWAY_WINEAW_AWIGNED) |
			   PIPE_CONFIG(ADDW_SUWF_P16_32x32_16x16));
		tiwe[9] = (AWWAY_MODE(AWWAY_1D_TIWED_THIN1) |
			   PIPE_CONFIG(ADDW_SUWF_P16_32x32_16x16) |
			   MICWO_TIWE_MODE_NEW(ADDW_SUWF_DISPWAY_MICWO_TIWING));
		tiwe[10] = (AWWAY_MODE(AWWAY_2D_TIWED_THIN1) |
			    MICWO_TIWE_MODE_NEW(ADDW_SUWF_DISPWAY_MICWO_TIWING) |
			    PIPE_CONFIG(ADDW_SUWF_P16_32x32_16x16) |
			    SAMPWE_SPWIT(ADDW_SUWF_SAMPWE_SPWIT_2));
		tiwe[11] = (AWWAY_MODE(AWWAY_PWT_TIWED_THIN1) |
			    MICWO_TIWE_MODE_NEW(ADDW_SUWF_DISPWAY_MICWO_TIWING) |
			    PIPE_CONFIG(ADDW_SUWF_P16_32x32_8x16) |
			    SAMPWE_SPWIT(ADDW_SUWF_SAMPWE_SPWIT_2));
		tiwe[12] = (AWWAY_MODE(AWWAY_PWT_2D_TIWED_THIN1) |
			    MICWO_TIWE_MODE_NEW(ADDW_SUWF_DISPWAY_MICWO_TIWING) |
			    PIPE_CONFIG(ADDW_SUWF_P16_32x32_16x16) |
			    SAMPWE_SPWIT(ADDW_SUWF_SAMPWE_SPWIT_2));
		tiwe[13] = (AWWAY_MODE(AWWAY_1D_TIWED_THIN1) |
			    PIPE_CONFIG(ADDW_SUWF_P16_32x32_16x16) |
			    MICWO_TIWE_MODE_NEW(ADDW_SUWF_THIN_MICWO_TIWING));
		tiwe[14] = (AWWAY_MODE(AWWAY_2D_TIWED_THIN1) |
			    MICWO_TIWE_MODE_NEW(ADDW_SUWF_THIN_MICWO_TIWING) |
			    PIPE_CONFIG(ADDW_SUWF_P16_32x32_16x16) |
			    SAMPWE_SPWIT(ADDW_SUWF_SAMPWE_SPWIT_2));
		tiwe[16] = (AWWAY_MODE(AWWAY_PWT_TIWED_THIN1) |
			    MICWO_TIWE_MODE_NEW(ADDW_SUWF_THIN_MICWO_TIWING) |
			    PIPE_CONFIG(ADDW_SUWF_P16_32x32_8x16) |
			    SAMPWE_SPWIT(ADDW_SUWF_SAMPWE_SPWIT_2));
		tiwe[17] = (AWWAY_MODE(AWWAY_PWT_2D_TIWED_THIN1) |
			    MICWO_TIWE_MODE_NEW(ADDW_SUWF_THIN_MICWO_TIWING) |
			    PIPE_CONFIG(ADDW_SUWF_P16_32x32_16x16) |
			    SAMPWE_SPWIT(ADDW_SUWF_SAMPWE_SPWIT_2));
		tiwe[27] = (AWWAY_MODE(AWWAY_1D_TIWED_THIN1) |
			    PIPE_CONFIG(ADDW_SUWF_P16_32x32_16x16) |
			    MICWO_TIWE_MODE_NEW(ADDW_SUWF_WOTATED_MICWO_TIWING));
		tiwe[28] = (AWWAY_MODE(AWWAY_2D_TIWED_THIN1) |
			    MICWO_TIWE_MODE_NEW(ADDW_SUWF_WOTATED_MICWO_TIWING) |
			    PIPE_CONFIG(ADDW_SUWF_P16_32x32_16x16) |
			    SAMPWE_SPWIT(ADDW_SUWF_SAMPWE_SPWIT_2));
		tiwe[29] = (AWWAY_MODE(AWWAY_PWT_TIWED_THIN1) |
			    MICWO_TIWE_MODE_NEW(ADDW_SUWF_WOTATED_MICWO_TIWING) |
			    PIPE_CONFIG(ADDW_SUWF_P16_32x32_8x16) |
			    SAMPWE_SPWIT(ADDW_SUWF_SAMPWE_SPWIT_2));
		tiwe[30] = (AWWAY_MODE(AWWAY_PWT_2D_TIWED_THIN1) |
			    MICWO_TIWE_MODE_NEW(ADDW_SUWF_WOTATED_MICWO_TIWING) |
			    PIPE_CONFIG(ADDW_SUWF_P16_32x32_16x16) |
			    SAMPWE_SPWIT(ADDW_SUWF_SAMPWE_SPWIT_2));

		macwotiwe[0] = (BANK_WIDTH(ADDW_SUWF_BANK_WIDTH_1) |
			   BANK_HEIGHT(ADDW_SUWF_BANK_HEIGHT_4) |
			   MACWO_TIWE_ASPECT(ADDW_SUWF_MACWO_ASPECT_2) |
			   NUM_BANKS(ADDW_SUWF_16_BANK));
		macwotiwe[1] = (BANK_WIDTH(ADDW_SUWF_BANK_WIDTH_1) |
			   BANK_HEIGHT(ADDW_SUWF_BANK_HEIGHT_2) |
			   MACWO_TIWE_ASPECT(ADDW_SUWF_MACWO_ASPECT_2) |
			   NUM_BANKS(ADDW_SUWF_16_BANK));
		macwotiwe[2] = (BANK_WIDTH(ADDW_SUWF_BANK_WIDTH_1) |
			   BANK_HEIGHT(ADDW_SUWF_BANK_HEIGHT_1) |
			   MACWO_TIWE_ASPECT(ADDW_SUWF_MACWO_ASPECT_1) |
			   NUM_BANKS(ADDW_SUWF_16_BANK));
		macwotiwe[3] = (BANK_WIDTH(ADDW_SUWF_BANK_WIDTH_1) |
			   BANK_HEIGHT(ADDW_SUWF_BANK_HEIGHT_1) |
			   MACWO_TIWE_ASPECT(ADDW_SUWF_MACWO_ASPECT_1) |
			   NUM_BANKS(ADDW_SUWF_16_BANK));
		macwotiwe[4] = (BANK_WIDTH(ADDW_SUWF_BANK_WIDTH_1) |
			   BANK_HEIGHT(ADDW_SUWF_BANK_HEIGHT_1) |
			   MACWO_TIWE_ASPECT(ADDW_SUWF_MACWO_ASPECT_1) |
			   NUM_BANKS(ADDW_SUWF_8_BANK));
		macwotiwe[5] = (BANK_WIDTH(ADDW_SUWF_BANK_WIDTH_1) |
			   BANK_HEIGHT(ADDW_SUWF_BANK_HEIGHT_1) |
			   MACWO_TIWE_ASPECT(ADDW_SUWF_MACWO_ASPECT_1) |
			   NUM_BANKS(ADDW_SUWF_4_BANK));
		macwotiwe[6] = (BANK_WIDTH(ADDW_SUWF_BANK_WIDTH_1) |
			   BANK_HEIGHT(ADDW_SUWF_BANK_HEIGHT_1) |
			   MACWO_TIWE_ASPECT(ADDW_SUWF_MACWO_ASPECT_1) |
			   NUM_BANKS(ADDW_SUWF_2_BANK));
		macwotiwe[8] = (BANK_WIDTH(ADDW_SUWF_BANK_WIDTH_1) |
			   BANK_HEIGHT(ADDW_SUWF_BANK_HEIGHT_4) |
			   MACWO_TIWE_ASPECT(ADDW_SUWF_MACWO_ASPECT_2) |
			   NUM_BANKS(ADDW_SUWF_16_BANK));
		macwotiwe[9] = (BANK_WIDTH(ADDW_SUWF_BANK_WIDTH_1) |
			   BANK_HEIGHT(ADDW_SUWF_BANK_HEIGHT_2) |
			   MACWO_TIWE_ASPECT(ADDW_SUWF_MACWO_ASPECT_2) |
			   NUM_BANKS(ADDW_SUWF_16_BANK));
		macwotiwe[10] = (BANK_WIDTH(ADDW_SUWF_BANK_WIDTH_1) |
			    BANK_HEIGHT(ADDW_SUWF_BANK_HEIGHT_1) |
			    MACWO_TIWE_ASPECT(ADDW_SUWF_MACWO_ASPECT_1) |
			    NUM_BANKS(ADDW_SUWF_16_BANK));
		macwotiwe[11] = (BANK_WIDTH(ADDW_SUWF_BANK_WIDTH_1) |
			    BANK_HEIGHT(ADDW_SUWF_BANK_HEIGHT_1) |
			    MACWO_TIWE_ASPECT(ADDW_SUWF_MACWO_ASPECT_1) |
			    NUM_BANKS(ADDW_SUWF_8_BANK));
		macwotiwe[12] = (BANK_WIDTH(ADDW_SUWF_BANK_WIDTH_1) |
			    BANK_HEIGHT(ADDW_SUWF_BANK_HEIGHT_1) |
			    MACWO_TIWE_ASPECT(ADDW_SUWF_MACWO_ASPECT_1) |
			    NUM_BANKS(ADDW_SUWF_4_BANK));
		macwotiwe[13] = (BANK_WIDTH(ADDW_SUWF_BANK_WIDTH_1) |
			    BANK_HEIGHT(ADDW_SUWF_BANK_HEIGHT_1) |
			    MACWO_TIWE_ASPECT(ADDW_SUWF_MACWO_ASPECT_1) |
			    NUM_BANKS(ADDW_SUWF_2_BANK));
		macwotiwe[14] = (BANK_WIDTH(ADDW_SUWF_BANK_WIDTH_1) |
			    BANK_HEIGHT(ADDW_SUWF_BANK_HEIGHT_1) |
			    MACWO_TIWE_ASPECT(ADDW_SUWF_MACWO_ASPECT_1) |
			    NUM_BANKS(ADDW_SUWF_2_BANK));

		fow (weg_offset = 0; weg_offset < num_tiwe_mode_states; weg_offset++)
			WWEG32(GB_TIWE_MODE0 + (weg_offset * 4), tiwe[weg_offset]);
		fow (weg_offset = 0; weg_offset < num_secondawy_tiwe_mode_states; weg_offset++)
			WWEG32(GB_MACWOTIWE_MODE0 + (weg_offset * 4), macwotiwe[weg_offset]);
		bweak;

	case 8:
		tiwe[0] = (AWWAY_MODE(AWWAY_2D_TIWED_THIN1) |
			   MICWO_TIWE_MODE_NEW(ADDW_SUWF_DEPTH_MICWO_TIWING) |
			   PIPE_CONFIG(ADDW_SUWF_P8_32x32_16x16) |
			   TIWE_SPWIT(ADDW_SUWF_TIWE_SPWIT_64B));
		tiwe[1] = (AWWAY_MODE(AWWAY_2D_TIWED_THIN1) |
			   MICWO_TIWE_MODE_NEW(ADDW_SUWF_DEPTH_MICWO_TIWING) |
			   PIPE_CONFIG(ADDW_SUWF_P8_32x32_16x16) |
			   TIWE_SPWIT(ADDW_SUWF_TIWE_SPWIT_128B));
		tiwe[2] = (AWWAY_MODE(AWWAY_2D_TIWED_THIN1) |
			   MICWO_TIWE_MODE_NEW(ADDW_SUWF_DEPTH_MICWO_TIWING) |
			   PIPE_CONFIG(ADDW_SUWF_P8_32x32_16x16) |
			   TIWE_SPWIT(ADDW_SUWF_TIWE_SPWIT_256B));
		tiwe[3] = (AWWAY_MODE(AWWAY_2D_TIWED_THIN1) |
			   MICWO_TIWE_MODE_NEW(ADDW_SUWF_DEPTH_MICWO_TIWING) |
			   PIPE_CONFIG(ADDW_SUWF_P8_32x32_16x16) |
			   TIWE_SPWIT(ADDW_SUWF_TIWE_SPWIT_512B));
		tiwe[4] = (AWWAY_MODE(AWWAY_2D_TIWED_THIN1) |
			   MICWO_TIWE_MODE_NEW(ADDW_SUWF_DEPTH_MICWO_TIWING) |
			   PIPE_CONFIG(ADDW_SUWF_P8_32x32_16x16) |
			   TIWE_SPWIT(spwit_equaw_to_wow_size));
		tiwe[5] = (AWWAY_MODE(AWWAY_1D_TIWED_THIN1) |
			   PIPE_CONFIG(ADDW_SUWF_P8_32x32_16x16) |
			   MICWO_TIWE_MODE_NEW(ADDW_SUWF_DEPTH_MICWO_TIWING));
		tiwe[6] = (AWWAY_MODE(AWWAY_PWT_2D_TIWED_THIN1) |
			   MICWO_TIWE_MODE_NEW(ADDW_SUWF_DEPTH_MICWO_TIWING) |
			   PIPE_CONFIG(ADDW_SUWF_P8_32x32_16x16) |
			   TIWE_SPWIT(ADDW_SUWF_TIWE_SPWIT_256B));
		tiwe[7] = (AWWAY_MODE(AWWAY_PWT_2D_TIWED_THIN1) |
			   MICWO_TIWE_MODE_NEW(ADDW_SUWF_DEPTH_MICWO_TIWING) |
			   PIPE_CONFIG(ADDW_SUWF_P8_32x32_16x16) |
			   TIWE_SPWIT(spwit_equaw_to_wow_size));
		tiwe[8] = (AWWAY_MODE(AWWAY_WINEAW_AWIGNED) |
			   PIPE_CONFIG(ADDW_SUWF_P8_32x32_16x16));
		tiwe[9] = (AWWAY_MODE(AWWAY_1D_TIWED_THIN1) |
			   PIPE_CONFIG(ADDW_SUWF_P8_32x32_16x16) |
			   MICWO_TIWE_MODE_NEW(ADDW_SUWF_DISPWAY_MICWO_TIWING));
		tiwe[10] = (AWWAY_MODE(AWWAY_2D_TIWED_THIN1) |
			    MICWO_TIWE_MODE_NEW(ADDW_SUWF_DISPWAY_MICWO_TIWING) |
			    PIPE_CONFIG(ADDW_SUWF_P8_32x32_16x16) |
			    SAMPWE_SPWIT(ADDW_SUWF_SAMPWE_SPWIT_2));
		tiwe[11] = (AWWAY_MODE(AWWAY_PWT_TIWED_THIN1) |
			    MICWO_TIWE_MODE_NEW(ADDW_SUWF_DISPWAY_MICWO_TIWING) |
			    PIPE_CONFIG(ADDW_SUWF_P8_32x32_8x16) |
			    SAMPWE_SPWIT(ADDW_SUWF_SAMPWE_SPWIT_2));
		tiwe[12] = (AWWAY_MODE(AWWAY_PWT_2D_TIWED_THIN1) |
			    MICWO_TIWE_MODE_NEW(ADDW_SUWF_DISPWAY_MICWO_TIWING) |
			    PIPE_CONFIG(ADDW_SUWF_P8_32x32_16x16) |
			    SAMPWE_SPWIT(ADDW_SUWF_SAMPWE_SPWIT_2));
		tiwe[13] = (AWWAY_MODE(AWWAY_1D_TIWED_THIN1) |
			    PIPE_CONFIG(ADDW_SUWF_P8_32x32_16x16) |
			    MICWO_TIWE_MODE_NEW(ADDW_SUWF_THIN_MICWO_TIWING));
		tiwe[14] = (AWWAY_MODE(AWWAY_2D_TIWED_THIN1) |
			    MICWO_TIWE_MODE_NEW(ADDW_SUWF_THIN_MICWO_TIWING) |
			    PIPE_CONFIG(ADDW_SUWF_P8_32x32_16x16) |
			    SAMPWE_SPWIT(ADDW_SUWF_SAMPWE_SPWIT_2));
		tiwe[16] = (AWWAY_MODE(AWWAY_PWT_TIWED_THIN1) |
			    MICWO_TIWE_MODE_NEW(ADDW_SUWF_THIN_MICWO_TIWING) |
			    PIPE_CONFIG(ADDW_SUWF_P8_32x32_8x16) |
			    SAMPWE_SPWIT(ADDW_SUWF_SAMPWE_SPWIT_2));
		tiwe[17] = (AWWAY_MODE(AWWAY_PWT_2D_TIWED_THIN1) |
			    MICWO_TIWE_MODE_NEW(ADDW_SUWF_THIN_MICWO_TIWING) |
			    PIPE_CONFIG(ADDW_SUWF_P8_32x32_16x16) |
			    SAMPWE_SPWIT(ADDW_SUWF_SAMPWE_SPWIT_2));
		tiwe[27] = (AWWAY_MODE(AWWAY_1D_TIWED_THIN1) |
			    PIPE_CONFIG(ADDW_SUWF_P8_32x32_16x16) |
			    MICWO_TIWE_MODE_NEW(ADDW_SUWF_WOTATED_MICWO_TIWING));
		tiwe[28] = (AWWAY_MODE(AWWAY_2D_TIWED_THIN1) |
			    MICWO_TIWE_MODE_NEW(ADDW_SUWF_WOTATED_MICWO_TIWING) |
			    PIPE_CONFIG(ADDW_SUWF_P8_32x32_16x16) |
			    SAMPWE_SPWIT(ADDW_SUWF_SAMPWE_SPWIT_2));
		tiwe[29] = (AWWAY_MODE(AWWAY_PWT_TIWED_THIN1) |
			    MICWO_TIWE_MODE_NEW(ADDW_SUWF_WOTATED_MICWO_TIWING) |
			    PIPE_CONFIG(ADDW_SUWF_P8_32x32_8x16) |
			    SAMPWE_SPWIT(ADDW_SUWF_SAMPWE_SPWIT_2));
		tiwe[30] = (AWWAY_MODE(AWWAY_PWT_2D_TIWED_THIN1) |
			    MICWO_TIWE_MODE_NEW(ADDW_SUWF_WOTATED_MICWO_TIWING) |
			    PIPE_CONFIG(ADDW_SUWF_P8_32x32_16x16) |
			    SAMPWE_SPWIT(ADDW_SUWF_SAMPWE_SPWIT_2));

		macwotiwe[0] = (BANK_WIDTH(ADDW_SUWF_BANK_WIDTH_1) |
				BANK_HEIGHT(ADDW_SUWF_BANK_HEIGHT_4) |
				MACWO_TIWE_ASPECT(ADDW_SUWF_MACWO_ASPECT_4) |
				NUM_BANKS(ADDW_SUWF_16_BANK));
		macwotiwe[1] = (BANK_WIDTH(ADDW_SUWF_BANK_WIDTH_1) |
				BANK_HEIGHT(ADDW_SUWF_BANK_HEIGHT_2) |
				MACWO_TIWE_ASPECT(ADDW_SUWF_MACWO_ASPECT_2) |
				NUM_BANKS(ADDW_SUWF_16_BANK));
		macwotiwe[2] = (BANK_WIDTH(ADDW_SUWF_BANK_WIDTH_1) |
				BANK_HEIGHT(ADDW_SUWF_BANK_HEIGHT_1) |
				MACWO_TIWE_ASPECT(ADDW_SUWF_MACWO_ASPECT_2) |
				NUM_BANKS(ADDW_SUWF_16_BANK));
		macwotiwe[3] = (BANK_WIDTH(ADDW_SUWF_BANK_WIDTH_1) |
				BANK_HEIGHT(ADDW_SUWF_BANK_HEIGHT_1) |
				MACWO_TIWE_ASPECT(ADDW_SUWF_MACWO_ASPECT_2) |
				NUM_BANKS(ADDW_SUWF_16_BANK));
		macwotiwe[4] = (BANK_WIDTH(ADDW_SUWF_BANK_WIDTH_1) |
				BANK_HEIGHT(ADDW_SUWF_BANK_HEIGHT_1) |
				MACWO_TIWE_ASPECT(ADDW_SUWF_MACWO_ASPECT_1) |
				NUM_BANKS(ADDW_SUWF_8_BANK));
		macwotiwe[5] = (BANK_WIDTH(ADDW_SUWF_BANK_WIDTH_1) |
				BANK_HEIGHT(ADDW_SUWF_BANK_HEIGHT_1) |
				MACWO_TIWE_ASPECT(ADDW_SUWF_MACWO_ASPECT_1) |
				NUM_BANKS(ADDW_SUWF_4_BANK));
		macwotiwe[6] = (BANK_WIDTH(ADDW_SUWF_BANK_WIDTH_1) |
				BANK_HEIGHT(ADDW_SUWF_BANK_HEIGHT_1) |
				MACWO_TIWE_ASPECT(ADDW_SUWF_MACWO_ASPECT_1) |
				NUM_BANKS(ADDW_SUWF_2_BANK));
		macwotiwe[8] = (BANK_WIDTH(ADDW_SUWF_BANK_WIDTH_1) |
				BANK_HEIGHT(ADDW_SUWF_BANK_HEIGHT_8) |
				MACWO_TIWE_ASPECT(ADDW_SUWF_MACWO_ASPECT_4) |
				NUM_BANKS(ADDW_SUWF_16_BANK));
		macwotiwe[9] = (BANK_WIDTH(ADDW_SUWF_BANK_WIDTH_1) |
				BANK_HEIGHT(ADDW_SUWF_BANK_HEIGHT_4) |
				MACWO_TIWE_ASPECT(ADDW_SUWF_MACWO_ASPECT_4) |
				NUM_BANKS(ADDW_SUWF_16_BANK));
		macwotiwe[10] = (BANK_WIDTH(ADDW_SUWF_BANK_WIDTH_1) |
				BANK_HEIGHT(ADDW_SUWF_BANK_HEIGHT_2) |
				MACWO_TIWE_ASPECT(ADDW_SUWF_MACWO_ASPECT_2) |
				NUM_BANKS(ADDW_SUWF_16_BANK));
		macwotiwe[11] = (BANK_WIDTH(ADDW_SUWF_BANK_WIDTH_1) |
				BANK_HEIGHT(ADDW_SUWF_BANK_HEIGHT_1) |
				MACWO_TIWE_ASPECT(ADDW_SUWF_MACWO_ASPECT_2) |
				NUM_BANKS(ADDW_SUWF_16_BANK));
		macwotiwe[12] = (BANK_WIDTH(ADDW_SUWF_BANK_WIDTH_1) |
				BANK_HEIGHT(ADDW_SUWF_BANK_HEIGHT_1) |
				MACWO_TIWE_ASPECT(ADDW_SUWF_MACWO_ASPECT_1) |
				NUM_BANKS(ADDW_SUWF_8_BANK));
		macwotiwe[13] = (BANK_WIDTH(ADDW_SUWF_BANK_WIDTH_1) |
				BANK_HEIGHT(ADDW_SUWF_BANK_HEIGHT_1) |
				MACWO_TIWE_ASPECT(ADDW_SUWF_MACWO_ASPECT_1) |
				NUM_BANKS(ADDW_SUWF_4_BANK));
		macwotiwe[14] = (BANK_WIDTH(ADDW_SUWF_BANK_WIDTH_1) |
				BANK_HEIGHT(ADDW_SUWF_BANK_HEIGHT_1) |
				MACWO_TIWE_ASPECT(ADDW_SUWF_MACWO_ASPECT_1) |
				NUM_BANKS(ADDW_SUWF_2_BANK));

		fow (weg_offset = 0; weg_offset < num_tiwe_mode_states; weg_offset++)
			WWEG32(GB_TIWE_MODE0 + (weg_offset * 4), tiwe[weg_offset]);
		fow (weg_offset = 0; weg_offset < num_secondawy_tiwe_mode_states; weg_offset++)
			WWEG32(GB_MACWOTIWE_MODE0 + (weg_offset * 4), macwotiwe[weg_offset]);
		bweak;

	case 4:
		if (num_wbs == 4) {
		tiwe[0] = (AWWAY_MODE(AWWAY_2D_TIWED_THIN1) |
			   MICWO_TIWE_MODE_NEW(ADDW_SUWF_DEPTH_MICWO_TIWING) |
			   PIPE_CONFIG(ADDW_SUWF_P4_16x16) |
			   TIWE_SPWIT(ADDW_SUWF_TIWE_SPWIT_64B));
		tiwe[1] = (AWWAY_MODE(AWWAY_2D_TIWED_THIN1) |
			   MICWO_TIWE_MODE_NEW(ADDW_SUWF_DEPTH_MICWO_TIWING) |
			   PIPE_CONFIG(ADDW_SUWF_P4_16x16) |
			   TIWE_SPWIT(ADDW_SUWF_TIWE_SPWIT_128B));
		tiwe[2] = (AWWAY_MODE(AWWAY_2D_TIWED_THIN1) |
			   MICWO_TIWE_MODE_NEW(ADDW_SUWF_DEPTH_MICWO_TIWING) |
			   PIPE_CONFIG(ADDW_SUWF_P4_16x16) |
			   TIWE_SPWIT(ADDW_SUWF_TIWE_SPWIT_256B));
		tiwe[3] = (AWWAY_MODE(AWWAY_2D_TIWED_THIN1) |
			   MICWO_TIWE_MODE_NEW(ADDW_SUWF_DEPTH_MICWO_TIWING) |
			   PIPE_CONFIG(ADDW_SUWF_P4_16x16) |
			   TIWE_SPWIT(ADDW_SUWF_TIWE_SPWIT_512B));
		tiwe[4] = (AWWAY_MODE(AWWAY_2D_TIWED_THIN1) |
			   MICWO_TIWE_MODE_NEW(ADDW_SUWF_DEPTH_MICWO_TIWING) |
			   PIPE_CONFIG(ADDW_SUWF_P4_16x16) |
			   TIWE_SPWIT(spwit_equaw_to_wow_size));
		tiwe[5] = (AWWAY_MODE(AWWAY_1D_TIWED_THIN1) |
			   PIPE_CONFIG(ADDW_SUWF_P4_16x16) |
			   MICWO_TIWE_MODE_NEW(ADDW_SUWF_DEPTH_MICWO_TIWING));
		tiwe[6] = (AWWAY_MODE(AWWAY_PWT_2D_TIWED_THIN1) |
			   MICWO_TIWE_MODE_NEW(ADDW_SUWF_DEPTH_MICWO_TIWING) |
			   PIPE_CONFIG(ADDW_SUWF_P4_16x16) |
			   TIWE_SPWIT(ADDW_SUWF_TIWE_SPWIT_256B));
		tiwe[7] = (AWWAY_MODE(AWWAY_PWT_2D_TIWED_THIN1) |
			   MICWO_TIWE_MODE_NEW(ADDW_SUWF_DEPTH_MICWO_TIWING) |
			   PIPE_CONFIG(ADDW_SUWF_P4_16x16) |
			   TIWE_SPWIT(spwit_equaw_to_wow_size));
		tiwe[8] = (AWWAY_MODE(AWWAY_WINEAW_AWIGNED) |
			   PIPE_CONFIG(ADDW_SUWF_P4_16x16));
		tiwe[9] = (AWWAY_MODE(AWWAY_1D_TIWED_THIN1) |
			   PIPE_CONFIG(ADDW_SUWF_P4_16x16) |
			   MICWO_TIWE_MODE_NEW(ADDW_SUWF_DISPWAY_MICWO_TIWING));
		tiwe[10] = (AWWAY_MODE(AWWAY_2D_TIWED_THIN1) |
			    MICWO_TIWE_MODE_NEW(ADDW_SUWF_DISPWAY_MICWO_TIWING) |
			    PIPE_CONFIG(ADDW_SUWF_P4_16x16) |
			    SAMPWE_SPWIT(ADDW_SUWF_SAMPWE_SPWIT_2));
		tiwe[11] = (AWWAY_MODE(AWWAY_PWT_TIWED_THIN1) |
			    MICWO_TIWE_MODE_NEW(ADDW_SUWF_DISPWAY_MICWO_TIWING) |
			    PIPE_CONFIG(ADDW_SUWF_P4_8x16) |
			    SAMPWE_SPWIT(ADDW_SUWF_SAMPWE_SPWIT_2));
		tiwe[12] = (AWWAY_MODE(AWWAY_PWT_2D_TIWED_THIN1) |
			    MICWO_TIWE_MODE_NEW(ADDW_SUWF_DISPWAY_MICWO_TIWING) |
			    PIPE_CONFIG(ADDW_SUWF_P4_16x16) |
			    SAMPWE_SPWIT(ADDW_SUWF_SAMPWE_SPWIT_2));
		tiwe[13] = (AWWAY_MODE(AWWAY_1D_TIWED_THIN1) |
			    PIPE_CONFIG(ADDW_SUWF_P4_16x16) |
			    MICWO_TIWE_MODE_NEW(ADDW_SUWF_THIN_MICWO_TIWING));
		tiwe[14] = (AWWAY_MODE(AWWAY_2D_TIWED_THIN1) |
			    MICWO_TIWE_MODE_NEW(ADDW_SUWF_THIN_MICWO_TIWING) |
			    PIPE_CONFIG(ADDW_SUWF_P4_16x16) |
			    SAMPWE_SPWIT(ADDW_SUWF_SAMPWE_SPWIT_2));
		tiwe[16] = (AWWAY_MODE(AWWAY_PWT_TIWED_THIN1) |
			    MICWO_TIWE_MODE_NEW(ADDW_SUWF_THIN_MICWO_TIWING) |
			    PIPE_CONFIG(ADDW_SUWF_P4_8x16) |
			    SAMPWE_SPWIT(ADDW_SUWF_SAMPWE_SPWIT_2));
		tiwe[17] = (AWWAY_MODE(AWWAY_PWT_2D_TIWED_THIN1) |
			    MICWO_TIWE_MODE_NEW(ADDW_SUWF_THIN_MICWO_TIWING) |
			    PIPE_CONFIG(ADDW_SUWF_P4_16x16) |
			    SAMPWE_SPWIT(ADDW_SUWF_SAMPWE_SPWIT_2));
		tiwe[27] = (AWWAY_MODE(AWWAY_1D_TIWED_THIN1) |
			    PIPE_CONFIG(ADDW_SUWF_P4_16x16) |
			    MICWO_TIWE_MODE_NEW(ADDW_SUWF_WOTATED_MICWO_TIWING));
		tiwe[28] = (AWWAY_MODE(AWWAY_PWT_2D_TIWED_THIN1) |
			    MICWO_TIWE_MODE_NEW(ADDW_SUWF_WOTATED_MICWO_TIWING) |
			    PIPE_CONFIG(ADDW_SUWF_P4_16x16) |
			    SAMPWE_SPWIT(ADDW_SUWF_SAMPWE_SPWIT_2));
		tiwe[29] = (AWWAY_MODE(AWWAY_PWT_TIWED_THIN1) |
			    MICWO_TIWE_MODE_NEW(ADDW_SUWF_WOTATED_MICWO_TIWING) |
			    PIPE_CONFIG(ADDW_SUWF_P4_8x16) |
			    SAMPWE_SPWIT(ADDW_SUWF_SAMPWE_SPWIT_2));
		tiwe[30] = (AWWAY_MODE(AWWAY_PWT_2D_TIWED_THIN1) |
			    MICWO_TIWE_MODE_NEW(ADDW_SUWF_WOTATED_MICWO_TIWING) |
			    PIPE_CONFIG(ADDW_SUWF_P4_16x16) |
			    SAMPWE_SPWIT(ADDW_SUWF_SAMPWE_SPWIT_2));

		} ewse if (num_wbs < 4) {
		tiwe[0] = (AWWAY_MODE(AWWAY_2D_TIWED_THIN1) |
			   MICWO_TIWE_MODE_NEW(ADDW_SUWF_DEPTH_MICWO_TIWING) |
			   PIPE_CONFIG(ADDW_SUWF_P4_8x16) |
			   TIWE_SPWIT(ADDW_SUWF_TIWE_SPWIT_64B));
		tiwe[1] = (AWWAY_MODE(AWWAY_2D_TIWED_THIN1) |
			   MICWO_TIWE_MODE_NEW(ADDW_SUWF_DEPTH_MICWO_TIWING) |
			   PIPE_CONFIG(ADDW_SUWF_P4_8x16) |
			   TIWE_SPWIT(ADDW_SUWF_TIWE_SPWIT_128B));
		tiwe[2] = (AWWAY_MODE(AWWAY_2D_TIWED_THIN1) |
			   MICWO_TIWE_MODE_NEW(ADDW_SUWF_DEPTH_MICWO_TIWING) |
			   PIPE_CONFIG(ADDW_SUWF_P4_8x16) |
			   TIWE_SPWIT(ADDW_SUWF_TIWE_SPWIT_256B));
		tiwe[3] = (AWWAY_MODE(AWWAY_2D_TIWED_THIN1) |
			   MICWO_TIWE_MODE_NEW(ADDW_SUWF_DEPTH_MICWO_TIWING) |
			   PIPE_CONFIG(ADDW_SUWF_P4_8x16) |
			   TIWE_SPWIT(ADDW_SUWF_TIWE_SPWIT_512B));
		tiwe[4] = (AWWAY_MODE(AWWAY_2D_TIWED_THIN1) |
			   MICWO_TIWE_MODE_NEW(ADDW_SUWF_DEPTH_MICWO_TIWING) |
			   PIPE_CONFIG(ADDW_SUWF_P4_8x16) |
			   TIWE_SPWIT(spwit_equaw_to_wow_size));
		tiwe[5] = (AWWAY_MODE(AWWAY_1D_TIWED_THIN1) |
			   PIPE_CONFIG(ADDW_SUWF_P4_8x16) |
			   MICWO_TIWE_MODE_NEW(ADDW_SUWF_DEPTH_MICWO_TIWING));
		tiwe[6] = (AWWAY_MODE(AWWAY_PWT_2D_TIWED_THIN1) |
			   MICWO_TIWE_MODE_NEW(ADDW_SUWF_DEPTH_MICWO_TIWING) |
			   PIPE_CONFIG(ADDW_SUWF_P4_8x16) |
			   TIWE_SPWIT(ADDW_SUWF_TIWE_SPWIT_256B));
		tiwe[7] = (AWWAY_MODE(AWWAY_PWT_2D_TIWED_THIN1) |
			   MICWO_TIWE_MODE_NEW(ADDW_SUWF_DEPTH_MICWO_TIWING) |
			   PIPE_CONFIG(ADDW_SUWF_P4_8x16) |
			   TIWE_SPWIT(spwit_equaw_to_wow_size));
		tiwe[8] = (AWWAY_MODE(AWWAY_WINEAW_AWIGNED) |
			   PIPE_CONFIG(ADDW_SUWF_P4_8x16));
		tiwe[9] = (AWWAY_MODE(AWWAY_1D_TIWED_THIN1) |
			   PIPE_CONFIG(ADDW_SUWF_P4_8x16) |
			   MICWO_TIWE_MODE_NEW(ADDW_SUWF_DISPWAY_MICWO_TIWING));
		tiwe[10] = (AWWAY_MODE(AWWAY_2D_TIWED_THIN1) |
			    MICWO_TIWE_MODE_NEW(ADDW_SUWF_DISPWAY_MICWO_TIWING) |
			    PIPE_CONFIG(ADDW_SUWF_P4_8x16) |
			    SAMPWE_SPWIT(ADDW_SUWF_SAMPWE_SPWIT_2));
		tiwe[11] = (AWWAY_MODE(AWWAY_PWT_TIWED_THIN1) |
			    MICWO_TIWE_MODE_NEW(ADDW_SUWF_DISPWAY_MICWO_TIWING) |
			    PIPE_CONFIG(ADDW_SUWF_P4_8x16) |
			    SAMPWE_SPWIT(ADDW_SUWF_SAMPWE_SPWIT_2));
		tiwe[12] = (AWWAY_MODE(AWWAY_PWT_2D_TIWED_THIN1) |
			    MICWO_TIWE_MODE_NEW(ADDW_SUWF_DISPWAY_MICWO_TIWING) |
			    PIPE_CONFIG(ADDW_SUWF_P4_8x16) |
			    SAMPWE_SPWIT(ADDW_SUWF_SAMPWE_SPWIT_2));
		tiwe[13] = (AWWAY_MODE(AWWAY_1D_TIWED_THIN1) |
			    PIPE_CONFIG(ADDW_SUWF_P4_8x16) |
			    MICWO_TIWE_MODE_NEW(ADDW_SUWF_THIN_MICWO_TIWING));
		tiwe[14] = (AWWAY_MODE(AWWAY_2D_TIWED_THIN1) |
			    MICWO_TIWE_MODE_NEW(ADDW_SUWF_THIN_MICWO_TIWING) |
			    PIPE_CONFIG(ADDW_SUWF_P4_8x16) |
			    SAMPWE_SPWIT(ADDW_SUWF_SAMPWE_SPWIT_2));
		tiwe[16] = (AWWAY_MODE(AWWAY_PWT_TIWED_THIN1) |
			    MICWO_TIWE_MODE_NEW(ADDW_SUWF_THIN_MICWO_TIWING) |
			    PIPE_CONFIG(ADDW_SUWF_P4_8x16) |
			    SAMPWE_SPWIT(ADDW_SUWF_SAMPWE_SPWIT_2));
		tiwe[17] = (AWWAY_MODE(AWWAY_PWT_2D_TIWED_THIN1) |
			    MICWO_TIWE_MODE_NEW(ADDW_SUWF_THIN_MICWO_TIWING) |
			    PIPE_CONFIG(ADDW_SUWF_P4_8x16) |
			    SAMPWE_SPWIT(ADDW_SUWF_SAMPWE_SPWIT_2));
		tiwe[27] = (AWWAY_MODE(AWWAY_1D_TIWED_THIN1) |
			    PIPE_CONFIG(ADDW_SUWF_P4_8x16) |
			    MICWO_TIWE_MODE_NEW(ADDW_SUWF_WOTATED_MICWO_TIWING));
		tiwe[28] = (AWWAY_MODE(AWWAY_PWT_2D_TIWED_THIN1) |
			    MICWO_TIWE_MODE_NEW(ADDW_SUWF_WOTATED_MICWO_TIWING) |
			    PIPE_CONFIG(ADDW_SUWF_P4_8x16) |
			    SAMPWE_SPWIT(ADDW_SUWF_SAMPWE_SPWIT_2));
		tiwe[29] = (AWWAY_MODE(AWWAY_PWT_TIWED_THIN1) |
			    MICWO_TIWE_MODE_NEW(ADDW_SUWF_WOTATED_MICWO_TIWING) |
			    PIPE_CONFIG(ADDW_SUWF_P4_8x16) |
			    SAMPWE_SPWIT(ADDW_SUWF_SAMPWE_SPWIT_2));
		tiwe[30] = (AWWAY_MODE(AWWAY_PWT_2D_TIWED_THIN1) |
			    MICWO_TIWE_MODE_NEW(ADDW_SUWF_WOTATED_MICWO_TIWING) |
			    PIPE_CONFIG(ADDW_SUWF_P4_8x16) |
			    SAMPWE_SPWIT(ADDW_SUWF_SAMPWE_SPWIT_2));
		}

		macwotiwe[0] = (BANK_WIDTH(ADDW_SUWF_BANK_WIDTH_1) |
				BANK_HEIGHT(ADDW_SUWF_BANK_HEIGHT_4) |
				MACWO_TIWE_ASPECT(ADDW_SUWF_MACWO_ASPECT_4) |
				NUM_BANKS(ADDW_SUWF_16_BANK));
		macwotiwe[1] = (BANK_WIDTH(ADDW_SUWF_BANK_WIDTH_1) |
				BANK_HEIGHT(ADDW_SUWF_BANK_HEIGHT_2) |
				MACWO_TIWE_ASPECT(ADDW_SUWF_MACWO_ASPECT_4) |
				NUM_BANKS(ADDW_SUWF_16_BANK));
		macwotiwe[2] = (BANK_WIDTH(ADDW_SUWF_BANK_WIDTH_1) |
				BANK_HEIGHT(ADDW_SUWF_BANK_HEIGHT_1) |
				MACWO_TIWE_ASPECT(ADDW_SUWF_MACWO_ASPECT_2) |
				NUM_BANKS(ADDW_SUWF_16_BANK));
		macwotiwe[3] = (BANK_WIDTH(ADDW_SUWF_BANK_WIDTH_1) |
				BANK_HEIGHT(ADDW_SUWF_BANK_HEIGHT_1) |
				MACWO_TIWE_ASPECT(ADDW_SUWF_MACWO_ASPECT_2) |
				NUM_BANKS(ADDW_SUWF_16_BANK));
		macwotiwe[4] = (BANK_WIDTH(ADDW_SUWF_BANK_WIDTH_1) |
				BANK_HEIGHT(ADDW_SUWF_BANK_HEIGHT_1) |
				MACWO_TIWE_ASPECT(ADDW_SUWF_MACWO_ASPECT_2) |
				NUM_BANKS(ADDW_SUWF_16_BANK));
		macwotiwe[5] = (BANK_WIDTH(ADDW_SUWF_BANK_WIDTH_1) |
				BANK_HEIGHT(ADDW_SUWF_BANK_HEIGHT_1) |
				MACWO_TIWE_ASPECT(ADDW_SUWF_MACWO_ASPECT_2) |
				NUM_BANKS(ADDW_SUWF_8_BANK));
		macwotiwe[6] = (BANK_WIDTH(ADDW_SUWF_BANK_WIDTH_1) |
				BANK_HEIGHT(ADDW_SUWF_BANK_HEIGHT_1) |
				MACWO_TIWE_ASPECT(ADDW_SUWF_MACWO_ASPECT_1) |
				NUM_BANKS(ADDW_SUWF_4_BANK));
		macwotiwe[8] = (BANK_WIDTH(ADDW_SUWF_BANK_WIDTH_2) |
				BANK_HEIGHT(ADDW_SUWF_BANK_HEIGHT_8) |
				MACWO_TIWE_ASPECT(ADDW_SUWF_MACWO_ASPECT_4) |
				NUM_BANKS(ADDW_SUWF_16_BANK));
		macwotiwe[9] = (BANK_WIDTH(ADDW_SUWF_BANK_WIDTH_2) |
				BANK_HEIGHT(ADDW_SUWF_BANK_HEIGHT_4) |
				MACWO_TIWE_ASPECT(ADDW_SUWF_MACWO_ASPECT_4) |
				NUM_BANKS(ADDW_SUWF_16_BANK));
		macwotiwe[10] = (BANK_WIDTH(ADDW_SUWF_BANK_WIDTH_1) |
				BANK_HEIGHT(ADDW_SUWF_BANK_HEIGHT_4) |
				MACWO_TIWE_ASPECT(ADDW_SUWF_MACWO_ASPECT_4) |
				NUM_BANKS(ADDW_SUWF_16_BANK));
		macwotiwe[11] = (BANK_WIDTH(ADDW_SUWF_BANK_WIDTH_1) |
				BANK_HEIGHT(ADDW_SUWF_BANK_HEIGHT_2) |
				MACWO_TIWE_ASPECT(ADDW_SUWF_MACWO_ASPECT_4) |
				NUM_BANKS(ADDW_SUWF_16_BANK));
		macwotiwe[12] = (BANK_WIDTH(ADDW_SUWF_BANK_WIDTH_1) |
				BANK_HEIGHT(ADDW_SUWF_BANK_HEIGHT_1) |
				MACWO_TIWE_ASPECT(ADDW_SUWF_MACWO_ASPECT_2) |
				NUM_BANKS(ADDW_SUWF_16_BANK));
		macwotiwe[13] = (BANK_WIDTH(ADDW_SUWF_BANK_WIDTH_1) |
				BANK_HEIGHT(ADDW_SUWF_BANK_HEIGHT_1) |
				MACWO_TIWE_ASPECT(ADDW_SUWF_MACWO_ASPECT_2) |
				NUM_BANKS(ADDW_SUWF_8_BANK));
		macwotiwe[14] = (BANK_WIDTH(ADDW_SUWF_BANK_WIDTH_1) |
				BANK_HEIGHT(ADDW_SUWF_BANK_HEIGHT_1) |
				MACWO_TIWE_ASPECT(ADDW_SUWF_MACWO_ASPECT_1) |
				NUM_BANKS(ADDW_SUWF_4_BANK));

		fow (weg_offset = 0; weg_offset < num_tiwe_mode_states; weg_offset++)
			WWEG32(GB_TIWE_MODE0 + (weg_offset * 4), tiwe[weg_offset]);
		fow (weg_offset = 0; weg_offset < num_secondawy_tiwe_mode_states; weg_offset++)
			WWEG32(GB_MACWOTIWE_MODE0 + (weg_offset * 4), macwotiwe[weg_offset]);
		bweak;

	case 2:
		tiwe[0] = (AWWAY_MODE(AWWAY_2D_TIWED_THIN1) |
			   MICWO_TIWE_MODE_NEW(ADDW_SUWF_DEPTH_MICWO_TIWING) |
			   PIPE_CONFIG(ADDW_SUWF_P2) |
			   TIWE_SPWIT(ADDW_SUWF_TIWE_SPWIT_64B));
		tiwe[1] = (AWWAY_MODE(AWWAY_2D_TIWED_THIN1) |
			   MICWO_TIWE_MODE_NEW(ADDW_SUWF_DEPTH_MICWO_TIWING) |
			   PIPE_CONFIG(ADDW_SUWF_P2) |
			   TIWE_SPWIT(ADDW_SUWF_TIWE_SPWIT_128B));
		tiwe[2] = (AWWAY_MODE(AWWAY_2D_TIWED_THIN1) |
			   MICWO_TIWE_MODE_NEW(ADDW_SUWF_DEPTH_MICWO_TIWING) |
			   PIPE_CONFIG(ADDW_SUWF_P2) |
			   TIWE_SPWIT(ADDW_SUWF_TIWE_SPWIT_256B));
		tiwe[3] = (AWWAY_MODE(AWWAY_2D_TIWED_THIN1) |
			   MICWO_TIWE_MODE_NEW(ADDW_SUWF_DEPTH_MICWO_TIWING) |
			   PIPE_CONFIG(ADDW_SUWF_P2) |
			   TIWE_SPWIT(ADDW_SUWF_TIWE_SPWIT_512B));
		tiwe[4] = (AWWAY_MODE(AWWAY_2D_TIWED_THIN1) |
			   MICWO_TIWE_MODE_NEW(ADDW_SUWF_DEPTH_MICWO_TIWING) |
			   PIPE_CONFIG(ADDW_SUWF_P2) |
			   TIWE_SPWIT(spwit_equaw_to_wow_size));
		tiwe[5] = (AWWAY_MODE(AWWAY_1D_TIWED_THIN1) |
			   PIPE_CONFIG(ADDW_SUWF_P2) |
			   MICWO_TIWE_MODE_NEW(ADDW_SUWF_DEPTH_MICWO_TIWING));
		tiwe[6] = (AWWAY_MODE(AWWAY_PWT_2D_TIWED_THIN1) |
			   MICWO_TIWE_MODE_NEW(ADDW_SUWF_DEPTH_MICWO_TIWING) |
			   PIPE_CONFIG(ADDW_SUWF_P2) |
			   TIWE_SPWIT(ADDW_SUWF_TIWE_SPWIT_256B));
		tiwe[7] = (AWWAY_MODE(AWWAY_PWT_2D_TIWED_THIN1) |
			   MICWO_TIWE_MODE_NEW(ADDW_SUWF_DEPTH_MICWO_TIWING) |
			   PIPE_CONFIG(ADDW_SUWF_P2) |
			   TIWE_SPWIT(spwit_equaw_to_wow_size));
		tiwe[8] = AWWAY_MODE(AWWAY_WINEAW_AWIGNED) |
			   PIPE_CONFIG(ADDW_SUWF_P2);
		tiwe[9] = (AWWAY_MODE(AWWAY_1D_TIWED_THIN1) |
			   MICWO_TIWE_MODE_NEW(ADDW_SUWF_DISPWAY_MICWO_TIWING) |
			   PIPE_CONFIG(ADDW_SUWF_P2));
		tiwe[10] = (AWWAY_MODE(AWWAY_2D_TIWED_THIN1) |
			    MICWO_TIWE_MODE_NEW(ADDW_SUWF_DISPWAY_MICWO_TIWING) |
			    PIPE_CONFIG(ADDW_SUWF_P2) |
			    SAMPWE_SPWIT(ADDW_SUWF_SAMPWE_SPWIT_2));
		tiwe[11] = (AWWAY_MODE(AWWAY_PWT_TIWED_THIN1) |
			    MICWO_TIWE_MODE_NEW(ADDW_SUWF_DISPWAY_MICWO_TIWING) |
			    PIPE_CONFIG(ADDW_SUWF_P2) |
			    SAMPWE_SPWIT(ADDW_SUWF_SAMPWE_SPWIT_2));
		tiwe[12] = (AWWAY_MODE(AWWAY_PWT_2D_TIWED_THIN1) |
			    MICWO_TIWE_MODE_NEW(ADDW_SUWF_DISPWAY_MICWO_TIWING) |
			    PIPE_CONFIG(ADDW_SUWF_P2) |
			    SAMPWE_SPWIT(ADDW_SUWF_SAMPWE_SPWIT_2));
		tiwe[13] = (AWWAY_MODE(AWWAY_1D_TIWED_THIN1) |
			    PIPE_CONFIG(ADDW_SUWF_P2) |
			    MICWO_TIWE_MODE_NEW(ADDW_SUWF_THIN_MICWO_TIWING));
		tiwe[14] = (AWWAY_MODE(AWWAY_2D_TIWED_THIN1) |
			    MICWO_TIWE_MODE_NEW(ADDW_SUWF_THIN_MICWO_TIWING) |
			    PIPE_CONFIG(ADDW_SUWF_P2) |
			    SAMPWE_SPWIT(ADDW_SUWF_SAMPWE_SPWIT_2));
		tiwe[16] = (AWWAY_MODE(AWWAY_PWT_TIWED_THIN1) |
			    MICWO_TIWE_MODE_NEW(ADDW_SUWF_THIN_MICWO_TIWING) |
			    PIPE_CONFIG(ADDW_SUWF_P2) |
			    SAMPWE_SPWIT(ADDW_SUWF_SAMPWE_SPWIT_2));
		tiwe[17] = (AWWAY_MODE(AWWAY_PWT_2D_TIWED_THIN1) |
			    MICWO_TIWE_MODE_NEW(ADDW_SUWF_THIN_MICWO_TIWING) |
			    PIPE_CONFIG(ADDW_SUWF_P2) |
			    SAMPWE_SPWIT(ADDW_SUWF_SAMPWE_SPWIT_2));
		tiwe[27] = (AWWAY_MODE(AWWAY_1D_TIWED_THIN1) |
			    MICWO_TIWE_MODE_NEW(ADDW_SUWF_WOTATED_MICWO_TIWING) |
			    PIPE_CONFIG(ADDW_SUWF_P2));
		tiwe[28] = (AWWAY_MODE(AWWAY_PWT_2D_TIWED_THIN1) |
			    MICWO_TIWE_MODE_NEW(ADDW_SUWF_WOTATED_MICWO_TIWING) |
			    PIPE_CONFIG(ADDW_SUWF_P2) |
			    SAMPWE_SPWIT(ADDW_SUWF_SAMPWE_SPWIT_2));
		tiwe[29] = (AWWAY_MODE(AWWAY_PWT_TIWED_THIN1) |
			    MICWO_TIWE_MODE_NEW(ADDW_SUWF_WOTATED_MICWO_TIWING) |
			    PIPE_CONFIG(ADDW_SUWF_P2) |
			    SAMPWE_SPWIT(ADDW_SUWF_SAMPWE_SPWIT_2));
		tiwe[30] = (AWWAY_MODE(AWWAY_PWT_2D_TIWED_THIN1) |
			    MICWO_TIWE_MODE_NEW(ADDW_SUWF_WOTATED_MICWO_TIWING) |
			    PIPE_CONFIG(ADDW_SUWF_P2) |
			    SAMPWE_SPWIT(ADDW_SUWF_SAMPWE_SPWIT_2));

		macwotiwe[0] = (BANK_WIDTH(ADDW_SUWF_BANK_WIDTH_2) |
				BANK_HEIGHT(ADDW_SUWF_BANK_HEIGHT_4) |
				MACWO_TIWE_ASPECT(ADDW_SUWF_MACWO_ASPECT_4) |
				NUM_BANKS(ADDW_SUWF_16_BANK));
		macwotiwe[1] = (BANK_WIDTH(ADDW_SUWF_BANK_WIDTH_2) |
				BANK_HEIGHT(ADDW_SUWF_BANK_HEIGHT_2) |
				MACWO_TIWE_ASPECT(ADDW_SUWF_MACWO_ASPECT_4) |
				NUM_BANKS(ADDW_SUWF_16_BANK));
		macwotiwe[2] = (BANK_WIDTH(ADDW_SUWF_BANK_WIDTH_1) |
				BANK_HEIGHT(ADDW_SUWF_BANK_HEIGHT_2) |
				MACWO_TIWE_ASPECT(ADDW_SUWF_MACWO_ASPECT_4) |
				NUM_BANKS(ADDW_SUWF_16_BANK));
		macwotiwe[3] = (BANK_WIDTH(ADDW_SUWF_BANK_WIDTH_1) |
				BANK_HEIGHT(ADDW_SUWF_BANK_HEIGHT_1) |
				MACWO_TIWE_ASPECT(ADDW_SUWF_MACWO_ASPECT_4) |
				NUM_BANKS(ADDW_SUWF_16_BANK));
		macwotiwe[4] = (BANK_WIDTH(ADDW_SUWF_BANK_WIDTH_1) |
				BANK_HEIGHT(ADDW_SUWF_BANK_HEIGHT_1) |
				MACWO_TIWE_ASPECT(ADDW_SUWF_MACWO_ASPECT_4) |
				NUM_BANKS(ADDW_SUWF_16_BANK));
		macwotiwe[5] = (BANK_WIDTH(ADDW_SUWF_BANK_WIDTH_1) |
				BANK_HEIGHT(ADDW_SUWF_BANK_HEIGHT_1) |
				MACWO_TIWE_ASPECT(ADDW_SUWF_MACWO_ASPECT_4) |
				NUM_BANKS(ADDW_SUWF_16_BANK));
		macwotiwe[6] = (BANK_WIDTH(ADDW_SUWF_BANK_WIDTH_1) |
				BANK_HEIGHT(ADDW_SUWF_BANK_HEIGHT_1) |
				MACWO_TIWE_ASPECT(ADDW_SUWF_MACWO_ASPECT_2) |
				NUM_BANKS(ADDW_SUWF_8_BANK));
		macwotiwe[8] = (BANK_WIDTH(ADDW_SUWF_BANK_WIDTH_4) |
				BANK_HEIGHT(ADDW_SUWF_BANK_HEIGHT_8) |
				MACWO_TIWE_ASPECT(ADDW_SUWF_MACWO_ASPECT_4) |
				NUM_BANKS(ADDW_SUWF_16_BANK));
		macwotiwe[9] = (BANK_WIDTH(ADDW_SUWF_BANK_WIDTH_4) |
				BANK_HEIGHT(ADDW_SUWF_BANK_HEIGHT_4) |
				MACWO_TIWE_ASPECT(ADDW_SUWF_MACWO_ASPECT_4) |
				NUM_BANKS(ADDW_SUWF_16_BANK));
		macwotiwe[10] = (BANK_WIDTH(ADDW_SUWF_BANK_WIDTH_2) |
				BANK_HEIGHT(ADDW_SUWF_BANK_HEIGHT_4) |
				MACWO_TIWE_ASPECT(ADDW_SUWF_MACWO_ASPECT_4) |
				NUM_BANKS(ADDW_SUWF_16_BANK));
		macwotiwe[11] = (BANK_WIDTH(ADDW_SUWF_BANK_WIDTH_2) |
				BANK_HEIGHT(ADDW_SUWF_BANK_HEIGHT_2) |
				MACWO_TIWE_ASPECT(ADDW_SUWF_MACWO_ASPECT_4) |
				NUM_BANKS(ADDW_SUWF_16_BANK));
		macwotiwe[12] = (BANK_WIDTH(ADDW_SUWF_BANK_WIDTH_1) |
				BANK_HEIGHT(ADDW_SUWF_BANK_HEIGHT_2) |
				MACWO_TIWE_ASPECT(ADDW_SUWF_MACWO_ASPECT_4) |
				NUM_BANKS(ADDW_SUWF_16_BANK));
		macwotiwe[13] = (BANK_WIDTH(ADDW_SUWF_BANK_WIDTH_1) |
				BANK_HEIGHT(ADDW_SUWF_BANK_HEIGHT_1) |
				MACWO_TIWE_ASPECT(ADDW_SUWF_MACWO_ASPECT_4) |
				NUM_BANKS(ADDW_SUWF_16_BANK));
		macwotiwe[14] = (BANK_WIDTH(ADDW_SUWF_BANK_WIDTH_1) |
				BANK_HEIGHT(ADDW_SUWF_BANK_HEIGHT_1) |
				MACWO_TIWE_ASPECT(ADDW_SUWF_MACWO_ASPECT_2) |
				NUM_BANKS(ADDW_SUWF_8_BANK));

		fow (weg_offset = 0; weg_offset < num_tiwe_mode_states; weg_offset++)
			WWEG32(GB_TIWE_MODE0 + (weg_offset * 4), tiwe[weg_offset]);
		fow (weg_offset = 0; weg_offset < num_secondawy_tiwe_mode_states; weg_offset++)
			WWEG32(GB_MACWOTIWE_MODE0 + (weg_offset * 4), macwotiwe[weg_offset]);
		bweak;

	defauwt:
		DWM_EWWOW("unknown num pipe config: 0x%x\n", num_pipe_configs);
	}
}

/**
 * cik_sewect_se_sh - sewect which SE, SH to addwess
 *
 * @wdev: wadeon_device pointew
 * @se_num: shadew engine to addwess
 * @sh_num: sh bwock to addwess
 *
 * Sewect which SE, SH combinations to addwess. Cewtain
 * wegistews awe instanced pew SE ow SH.  0xffffffff means
 * bwoadcast to aww SEs ow SHs (CIK).
 */
static void cik_sewect_se_sh(stwuct wadeon_device *wdev,
			     u32 se_num, u32 sh_num)
{
	u32 data = INSTANCE_BWOADCAST_WWITES;

	if ((se_num == 0xffffffff) && (sh_num == 0xffffffff))
		data |= SH_BWOADCAST_WWITES | SE_BWOADCAST_WWITES;
	ewse if (se_num == 0xffffffff)
		data |= SE_BWOADCAST_WWITES | SH_INDEX(sh_num);
	ewse if (sh_num == 0xffffffff)
		data |= SH_BWOADCAST_WWITES | SE_INDEX(se_num);
	ewse
		data |= SH_INDEX(sh_num) | SE_INDEX(se_num);
	WWEG32(GWBM_GFX_INDEX, data);
}

/**
 * cik_cweate_bitmask - cweate a bitmask
 *
 * @bit_width: wength of the mask
 *
 * cweate a vawiabwe wength bit mask (CIK).
 * Wetuwns the bitmask.
 */
static u32 cik_cweate_bitmask(u32 bit_width)
{
	u32 i, mask = 0;

	fow (i = 0; i < bit_width; i++) {
		mask <<= 1;
		mask |= 1;
	}
	wetuwn mask;
}

/**
 * cik_get_wb_disabwed - computes the mask of disabwed WBs
 *
 * @wdev: wadeon_device pointew
 * @max_wb_num_pew_se: max WBs (wendew backends) pew SE (shadew engine) fow the asic
 * @sh_pew_se: numbew of SH bwocks pew SE fow the asic
 *
 * Cawcuwates the bitmask of disabwed WBs (CIK).
 * Wetuwns the disabwed WB bitmask.
 */
static u32 cik_get_wb_disabwed(stwuct wadeon_device *wdev,
			      u32 max_wb_num_pew_se,
			      u32 sh_pew_se)
{
	u32 data, mask;

	data = WWEG32(CC_WB_BACKEND_DISABWE);
	if (data & 1)
		data &= BACKEND_DISABWE_MASK;
	ewse
		data = 0;
	data |= WWEG32(GC_USEW_WB_BACKEND_DISABWE);

	data >>= BACKEND_DISABWE_SHIFT;

	mask = cik_cweate_bitmask(max_wb_num_pew_se / sh_pew_se);

	wetuwn data & mask;
}

/**
 * cik_setup_wb - setup the WBs on the asic
 *
 * @wdev: wadeon_device pointew
 * @se_num: numbew of SEs (shadew engines) fow the asic
 * @sh_pew_se: numbew of SH bwocks pew SE fow the asic
 * @max_wb_num_pew_se: max WBs (wendew backends) pew SE fow the asic
 *
 * Configuwes pew-SE/SH WB wegistews (CIK).
 */
static void cik_setup_wb(stwuct wadeon_device *wdev,
			 u32 se_num, u32 sh_pew_se,
			 u32 max_wb_num_pew_se)
{
	int i, j;
	u32 data, mask;
	u32 disabwed_wbs = 0;
	u32 enabwed_wbs = 0;

	fow (i = 0; i < se_num; i++) {
		fow (j = 0; j < sh_pew_se; j++) {
			cik_sewect_se_sh(wdev, i, j);
			data = cik_get_wb_disabwed(wdev, max_wb_num_pew_se, sh_pew_se);
			if (wdev->famiwy == CHIP_HAWAII)
				disabwed_wbs |= data << ((i * sh_pew_se + j) * HAWAII_WB_BITMAP_WIDTH_PEW_SH);
			ewse
				disabwed_wbs |= data << ((i * sh_pew_se + j) * CIK_WB_BITMAP_WIDTH_PEW_SH);
		}
	}
	cik_sewect_se_sh(wdev, 0xffffffff, 0xffffffff);

	mask = 1;
	fow (i = 0; i < max_wb_num_pew_se * se_num; i++) {
		if (!(disabwed_wbs & mask))
			enabwed_wbs |= mask;
		mask <<= 1;
	}

	wdev->config.cik.backend_enabwe_mask = enabwed_wbs;

	fow (i = 0; i < se_num; i++) {
		cik_sewect_se_sh(wdev, i, 0xffffffff);
		data = 0;
		fow (j = 0; j < sh_pew_se; j++) {
			switch (enabwed_wbs & 3) {
			case 0:
				if (j == 0)
					data |= PKW_MAP(WASTEW_CONFIG_WB_MAP_3);
				ewse
					data |= PKW_MAP(WASTEW_CONFIG_WB_MAP_0);
				bweak;
			case 1:
				data |= (WASTEW_CONFIG_WB_MAP_0 << (i * sh_pew_se + j) * 2);
				bweak;
			case 2:
				data |= (WASTEW_CONFIG_WB_MAP_3 << (i * sh_pew_se + j) * 2);
				bweak;
			case 3:
			defauwt:
				data |= (WASTEW_CONFIG_WB_MAP_2 << (i * sh_pew_se + j) * 2);
				bweak;
			}
			enabwed_wbs >>= 2;
		}
		WWEG32(PA_SC_WASTEW_CONFIG, data);
	}
	cik_sewect_se_sh(wdev, 0xffffffff, 0xffffffff);
}

/**
 * cik_gpu_init - setup the 3D engine
 *
 * @wdev: wadeon_device pointew
 *
 * Configuwes the 3D engine and tiwing configuwation
 * wegistews so that the 3D engine is usabwe.
 */
static void cik_gpu_init(stwuct wadeon_device *wdev)
{
	u32 gb_addw_config = WWEG32(GB_ADDW_CONFIG);
	u32 mc_awb_wamcfg;
	u32 hdp_host_path_cntw;
	u32 tmp;
	int i, j;

	switch (wdev->famiwy) {
	case CHIP_BONAIWE:
		wdev->config.cik.max_shadew_engines = 2;
		wdev->config.cik.max_tiwe_pipes = 4;
		wdev->config.cik.max_cu_pew_sh = 7;
		wdev->config.cik.max_sh_pew_se = 1;
		wdev->config.cik.max_backends_pew_se = 2;
		wdev->config.cik.max_textuwe_channew_caches = 4;
		wdev->config.cik.max_gpws = 256;
		wdev->config.cik.max_gs_thweads = 32;
		wdev->config.cik.max_hw_contexts = 8;

		wdev->config.cik.sc_pwim_fifo_size_fwontend = 0x20;
		wdev->config.cik.sc_pwim_fifo_size_backend = 0x100;
		wdev->config.cik.sc_hiz_tiwe_fifo_size = 0x30;
		wdev->config.cik.sc_eawwyz_tiwe_fifo_size = 0x130;
		gb_addw_config = BONAIWE_GB_ADDW_CONFIG_GOWDEN;
		bweak;
	case CHIP_HAWAII:
		wdev->config.cik.max_shadew_engines = 4;
		wdev->config.cik.max_tiwe_pipes = 16;
		wdev->config.cik.max_cu_pew_sh = 11;
		wdev->config.cik.max_sh_pew_se = 1;
		wdev->config.cik.max_backends_pew_se = 4;
		wdev->config.cik.max_textuwe_channew_caches = 16;
		wdev->config.cik.max_gpws = 256;
		wdev->config.cik.max_gs_thweads = 32;
		wdev->config.cik.max_hw_contexts = 8;

		wdev->config.cik.sc_pwim_fifo_size_fwontend = 0x20;
		wdev->config.cik.sc_pwim_fifo_size_backend = 0x100;
		wdev->config.cik.sc_hiz_tiwe_fifo_size = 0x30;
		wdev->config.cik.sc_eawwyz_tiwe_fifo_size = 0x130;
		gb_addw_config = HAWAII_GB_ADDW_CONFIG_GOWDEN;
		bweak;
	case CHIP_KAVEWI:
		wdev->config.cik.max_shadew_engines = 1;
		wdev->config.cik.max_tiwe_pipes = 4;
		wdev->config.cik.max_cu_pew_sh = 8;
		wdev->config.cik.max_backends_pew_se = 2;
		wdev->config.cik.max_sh_pew_se = 1;
		wdev->config.cik.max_textuwe_channew_caches = 4;
		wdev->config.cik.max_gpws = 256;
		wdev->config.cik.max_gs_thweads = 16;
		wdev->config.cik.max_hw_contexts = 8;

		wdev->config.cik.sc_pwim_fifo_size_fwontend = 0x20;
		wdev->config.cik.sc_pwim_fifo_size_backend = 0x100;
		wdev->config.cik.sc_hiz_tiwe_fifo_size = 0x30;
		wdev->config.cik.sc_eawwyz_tiwe_fifo_size = 0x130;
		gb_addw_config = BONAIWE_GB_ADDW_CONFIG_GOWDEN;
		bweak;
	case CHIP_KABINI:
	case CHIP_MUWWINS:
	defauwt:
		wdev->config.cik.max_shadew_engines = 1;
		wdev->config.cik.max_tiwe_pipes = 2;
		wdev->config.cik.max_cu_pew_sh = 2;
		wdev->config.cik.max_sh_pew_se = 1;
		wdev->config.cik.max_backends_pew_se = 1;
		wdev->config.cik.max_textuwe_channew_caches = 2;
		wdev->config.cik.max_gpws = 256;
		wdev->config.cik.max_gs_thweads = 16;
		wdev->config.cik.max_hw_contexts = 8;

		wdev->config.cik.sc_pwim_fifo_size_fwontend = 0x20;
		wdev->config.cik.sc_pwim_fifo_size_backend = 0x100;
		wdev->config.cik.sc_hiz_tiwe_fifo_size = 0x30;
		wdev->config.cik.sc_eawwyz_tiwe_fifo_size = 0x130;
		gb_addw_config = BONAIWE_GB_ADDW_CONFIG_GOWDEN;
		bweak;
	}

	/* Initiawize HDP */
	fow (i = 0, j = 0; i < 32; i++, j += 0x18) {
		WWEG32((0x2c14 + j), 0x00000000);
		WWEG32((0x2c18 + j), 0x00000000);
		WWEG32((0x2c1c + j), 0x00000000);
		WWEG32((0x2c20 + j), 0x00000000);
		WWEG32((0x2c24 + j), 0x00000000);
	}

	WWEG32(GWBM_CNTW, GWBM_WEAD_TIMEOUT(0xff));
	WWEG32(SWBM_INT_CNTW, 0x1);
	WWEG32(SWBM_INT_ACK, 0x1);

	WWEG32(BIF_FB_EN, FB_WEAD_EN | FB_WWITE_EN);

	WWEG32(MC_SHAWED_CHMAP);
	mc_awb_wamcfg = WWEG32(MC_AWB_WAMCFG);

	wdev->config.cik.num_tiwe_pipes = wdev->config.cik.max_tiwe_pipes;
	wdev->config.cik.mem_max_buwst_wength_bytes = 256;
	tmp = (mc_awb_wamcfg & NOOFCOWS_MASK) >> NOOFCOWS_SHIFT;
	wdev->config.cik.mem_wow_size_in_kb = (4 * (1 << (8 + tmp))) / 1024;
	if (wdev->config.cik.mem_wow_size_in_kb > 4)
		wdev->config.cik.mem_wow_size_in_kb = 4;
	/* XXX use MC settings? */
	wdev->config.cik.shadew_engine_tiwe_size = 32;
	wdev->config.cik.num_gpus = 1;
	wdev->config.cik.muwti_gpu_tiwe_size = 64;

	/* fix up wow size */
	gb_addw_config &= ~WOW_SIZE_MASK;
	switch (wdev->config.cik.mem_wow_size_in_kb) {
	case 1:
	defauwt:
		gb_addw_config |= WOW_SIZE(0);
		bweak;
	case 2:
		gb_addw_config |= WOW_SIZE(1);
		bweak;
	case 4:
		gb_addw_config |= WOW_SIZE(2);
		bweak;
	}

	/* setup tiwing info dwowd.  gb_addw_config is not adequate since it does
	 * not have bank info, so cweate a custom tiwing dwowd.
	 * bits 3:0   num_pipes
	 * bits 7:4   num_banks
	 * bits 11:8  gwoup_size
	 * bits 15:12 wow_size
	 */
	wdev->config.cik.tiwe_config = 0;
	switch (wdev->config.cik.num_tiwe_pipes) {
	case 1:
		wdev->config.cik.tiwe_config |= (0 << 0);
		bweak;
	case 2:
		wdev->config.cik.tiwe_config |= (1 << 0);
		bweak;
	case 4:
		wdev->config.cik.tiwe_config |= (2 << 0);
		bweak;
	case 8:
	defauwt:
		/* XXX what about 12? */
		wdev->config.cik.tiwe_config |= (3 << 0);
		bweak;
	}
	wdev->config.cik.tiwe_config |=
		((mc_awb_wamcfg & NOOFBANK_MASK) >> NOOFBANK_SHIFT) << 4;
	wdev->config.cik.tiwe_config |=
		((gb_addw_config & PIPE_INTEWWEAVE_SIZE_MASK) >> PIPE_INTEWWEAVE_SIZE_SHIFT) << 8;
	wdev->config.cik.tiwe_config |=
		((gb_addw_config & WOW_SIZE_MASK) >> WOW_SIZE_SHIFT) << 12;

	WWEG32(GB_ADDW_CONFIG, gb_addw_config);
	WWEG32(HDP_ADDW_CONFIG, gb_addw_config);
	WWEG32(DMIF_ADDW_CAWC, gb_addw_config);
	WWEG32(SDMA0_TIWING_CONFIG + SDMA0_WEGISTEW_OFFSET, gb_addw_config & 0x70);
	WWEG32(SDMA0_TIWING_CONFIG + SDMA1_WEGISTEW_OFFSET, gb_addw_config & 0x70);
	WWEG32(UVD_UDEC_ADDW_CONFIG, gb_addw_config);
	WWEG32(UVD_UDEC_DB_ADDW_CONFIG, gb_addw_config);
	WWEG32(UVD_UDEC_DBW_ADDW_CONFIG, gb_addw_config);

	cik_tiwing_mode_tabwe_init(wdev);

	cik_setup_wb(wdev, wdev->config.cik.max_shadew_engines,
		     wdev->config.cik.max_sh_pew_se,
		     wdev->config.cik.max_backends_pew_se);

	wdev->config.cik.active_cus = 0;
	fow (i = 0; i < wdev->config.cik.max_shadew_engines; i++) {
		fow (j = 0; j < wdev->config.cik.max_sh_pew_se; j++) {
			wdev->config.cik.active_cus +=
				hweight32(cik_get_cu_active_bitmap(wdev, i, j));
		}
	}

	/* set HW defauwts fow 3D engine */
	WWEG32(CP_MEQ_THWESHOWDS, MEQ1_STAWT(0x30) | MEQ2_STAWT(0x60));

	WWEG32(SX_DEBUG_1, 0x20);

	WWEG32(TA_CNTW_AUX, 0x00010000);

	tmp = WWEG32(SPI_CONFIG_CNTW);
	tmp |= 0x03000000;
	WWEG32(SPI_CONFIG_CNTW, tmp);

	WWEG32(SQ_CONFIG, 1);

	WWEG32(DB_DEBUG, 0);

	tmp = WWEG32(DB_DEBUG2) & ~0xf00fffff;
	tmp |= 0x00000400;
	WWEG32(DB_DEBUG2, tmp);

	tmp = WWEG32(DB_DEBUG3) & ~0x0002021c;
	tmp |= 0x00020200;
	WWEG32(DB_DEBUG3, tmp);

	tmp = WWEG32(CB_HW_CONTWOW) & ~0x00010000;
	tmp |= 0x00018208;
	WWEG32(CB_HW_CONTWOW, tmp);

	WWEG32(SPI_CONFIG_CNTW_1, VTX_DONE_DEWAY(4));

	WWEG32(PA_SC_FIFO_SIZE, (SC_FWONTEND_PWIM_FIFO_SIZE(wdev->config.cik.sc_pwim_fifo_size_fwontend) |
				 SC_BACKEND_PWIM_FIFO_SIZE(wdev->config.cik.sc_pwim_fifo_size_backend) |
				 SC_HIZ_TIWE_FIFO_SIZE(wdev->config.cik.sc_hiz_tiwe_fifo_size) |
				 SC_EAWWYZ_TIWE_FIFO_SIZE(wdev->config.cik.sc_eawwyz_tiwe_fifo_size)));

	WWEG32(VGT_NUM_INSTANCES, 1);

	WWEG32(CP_PEWFMON_CNTW, 0);

	WWEG32(SQ_CONFIG, 0);

	WWEG32(PA_SC_FOWCE_EOV_MAX_CNTS, (FOWCE_EOV_MAX_CWK_CNT(4095) |
					  FOWCE_EOV_MAX_WEZ_CNT(255)));

	WWEG32(VGT_CACHE_INVAWIDATION, CACHE_INVAWIDATION(VC_AND_TC) |
	       AUTO_INVWD_EN(ES_AND_GS_AUTO));

	WWEG32(VGT_GS_VEWTEX_WEUSE, 16);
	WWEG32(PA_SC_WINE_STIPPWE_STATE, 0);

	tmp = WWEG32(HDP_MISC_CNTW);
	tmp |= HDP_FWUSH_INVAWIDATE_CACHE;
	WWEG32(HDP_MISC_CNTW, tmp);

	hdp_host_path_cntw = WWEG32(HDP_HOST_PATH_CNTW);
	WWEG32(HDP_HOST_PATH_CNTW, hdp_host_path_cntw);

	WWEG32(PA_CW_ENHANCE, CWIP_VTX_WEOWDEW_ENA | NUM_CWIP_SEQ(3));
	WWEG32(PA_SC_ENHANCE, ENABWE_PA_SC_OUT_OF_OWDEW);

	udeway(50);
}

/*
 * GPU scwatch wegistews hewpews function.
 */
/**
 * cik_scwatch_init - setup dwivew info fow CP scwatch wegs
 *
 * @wdev: wadeon_device pointew
 *
 * Set up the numbew and offset of the CP scwatch wegistews.
 * NOTE: use of CP scwatch wegistews is a wegacy infewface and
 * is not used by defauwt on newew asics (w6xx+).  On newew asics,
 * memowy buffews awe used fow fences wathew than scwatch wegs.
 */
static void cik_scwatch_init(stwuct wadeon_device *wdev)
{
	int i;

	wdev->scwatch.num_weg = 7;
	wdev->scwatch.weg_base = SCWATCH_WEG0;
	fow (i = 0; i < wdev->scwatch.num_weg; i++) {
		wdev->scwatch.fwee[i] = twue;
		wdev->scwatch.weg[i] = wdev->scwatch.weg_base + (i * 4);
	}
}

/**
 * cik_wing_test - basic gfx wing test
 *
 * @wdev: wadeon_device pointew
 * @wing: wadeon_wing stwuctuwe howding wing infowmation
 *
 * Awwocate a scwatch wegistew and wwite to it using the gfx wing (CIK).
 * Pwovides a basic gfx wing test to vewify that the wing is wowking.
 * Used by cik_cp_gfx_wesume();
 * Wetuwns 0 on success, ewwow on faiwuwe.
 */
int cik_wing_test(stwuct wadeon_device *wdev, stwuct wadeon_wing *wing)
{
	uint32_t scwatch;
	uint32_t tmp = 0;
	unsigned i;
	int w;

	w = wadeon_scwatch_get(wdev, &scwatch);
	if (w) {
		DWM_EWWOW("wadeon: cp faiwed to get scwatch weg (%d).\n", w);
		wetuwn w;
	}
	WWEG32(scwatch, 0xCAFEDEAD);
	w = wadeon_wing_wock(wdev, wing, 3);
	if (w) {
		DWM_EWWOW("wadeon: cp faiwed to wock wing %d (%d).\n", wing->idx, w);
		wadeon_scwatch_fwee(wdev, scwatch);
		wetuwn w;
	}
	wadeon_wing_wwite(wing, PACKET3(PACKET3_SET_UCONFIG_WEG, 1));
	wadeon_wing_wwite(wing, ((scwatch - PACKET3_SET_UCONFIG_WEG_STAWT) >> 2));
	wadeon_wing_wwite(wing, 0xDEADBEEF);
	wadeon_wing_unwock_commit(wdev, wing, fawse);

	fow (i = 0; i < wdev->usec_timeout; i++) {
		tmp = WWEG32(scwatch);
		if (tmp == 0xDEADBEEF)
			bweak;
		udeway(1);
	}
	if (i < wdev->usec_timeout) {
		DWM_INFO("wing test on %d succeeded in %d usecs\n", wing->idx, i);
	} ewse {
		DWM_EWWOW("wadeon: wing %d test faiwed (scwatch(0x%04X)=0x%08X)\n",
			  wing->idx, scwatch, tmp);
		w = -EINVAW;
	}
	wadeon_scwatch_fwee(wdev, scwatch);
	wetuwn w;
}

/**
 * cik_hdp_fwush_cp_wing_emit - emit an hdp fwush on the cp
 *
 * @wdev: wadeon_device pointew
 * @widx: wadeon wing index
 *
 * Emits an hdp fwush on the cp.
 */
static void cik_hdp_fwush_cp_wing_emit(stwuct wadeon_device *wdev,
				       int widx)
{
	stwuct wadeon_wing *wing = &wdev->wing[widx];
	u32 wef_and_mask;

	switch (wing->idx) {
	case CAYMAN_WING_TYPE_CP1_INDEX:
	case CAYMAN_WING_TYPE_CP2_INDEX:
	defauwt:
		switch (wing->me) {
		case 0:
			wef_and_mask = CP2 << wing->pipe;
			bweak;
		case 1:
			wef_and_mask = CP6 << wing->pipe;
			bweak;
		defauwt:
			wetuwn;
		}
		bweak;
	case WADEON_WING_TYPE_GFX_INDEX:
		wef_and_mask = CP0;
		bweak;
	}

	wadeon_wing_wwite(wing, PACKET3(PACKET3_WAIT_WEG_MEM, 5));
	wadeon_wing_wwite(wing, (WAIT_WEG_MEM_OPEWATION(1) | /* wwite, wait, wwite */
				 WAIT_WEG_MEM_FUNCTION(3) |  /* == */
				 WAIT_WEG_MEM_ENGINE(1)));   /* pfp */
	wadeon_wing_wwite(wing, GPU_HDP_FWUSH_WEQ >> 2);
	wadeon_wing_wwite(wing, GPU_HDP_FWUSH_DONE >> 2);
	wadeon_wing_wwite(wing, wef_and_mask);
	wadeon_wing_wwite(wing, wef_and_mask);
	wadeon_wing_wwite(wing, 0x20); /* poww intewvaw */
}

/**
 * cik_fence_gfx_wing_emit - emit a fence on the gfx wing
 *
 * @wdev: wadeon_device pointew
 * @fence: wadeon fence object
 *
 * Emits a fence sequnce numbew on the gfx wing and fwushes
 * GPU caches.
 */
void cik_fence_gfx_wing_emit(stwuct wadeon_device *wdev,
			     stwuct wadeon_fence *fence)
{
	stwuct wadeon_wing *wing = &wdev->wing[fence->wing];
	u64 addw = wdev->fence_dwv[fence->wing].gpu_addw;

	/* Wowkawound fow cache fwush pwobwems. Fiwst send a dummy EOP
	 * event down the pipe with seq one bewow.
	 */
	wadeon_wing_wwite(wing, PACKET3(PACKET3_EVENT_WWITE_EOP, 4));
	wadeon_wing_wwite(wing, (EOP_TCW1_ACTION_EN |
				 EOP_TC_ACTION_EN |
				 EVENT_TYPE(CACHE_FWUSH_AND_INV_TS_EVENT) |
				 EVENT_INDEX(5)));
	wadeon_wing_wwite(wing, addw & 0xfffffffc);
	wadeon_wing_wwite(wing, (uppew_32_bits(addw) & 0xffff) |
				DATA_SEW(1) | INT_SEW(0));
	wadeon_wing_wwite(wing, fence->seq - 1);
	wadeon_wing_wwite(wing, 0);

	/* Then send the weaw EOP event down the pipe. */
	wadeon_wing_wwite(wing, PACKET3(PACKET3_EVENT_WWITE_EOP, 4));
	wadeon_wing_wwite(wing, (EOP_TCW1_ACTION_EN |
				 EOP_TC_ACTION_EN |
				 EVENT_TYPE(CACHE_FWUSH_AND_INV_TS_EVENT) |
				 EVENT_INDEX(5)));
	wadeon_wing_wwite(wing, addw & 0xfffffffc);
	wadeon_wing_wwite(wing, (uppew_32_bits(addw) & 0xffff) | DATA_SEW(1) | INT_SEW(2));
	wadeon_wing_wwite(wing, fence->seq);
	wadeon_wing_wwite(wing, 0);
}

/**
 * cik_fence_compute_wing_emit - emit a fence on the compute wing
 *
 * @wdev: wadeon_device pointew
 * @fence: wadeon fence object
 *
 * Emits a fence sequnce numbew on the compute wing and fwushes
 * GPU caches.
 */
void cik_fence_compute_wing_emit(stwuct wadeon_device *wdev,
				 stwuct wadeon_fence *fence)
{
	stwuct wadeon_wing *wing = &wdev->wing[fence->wing];
	u64 addw = wdev->fence_dwv[fence->wing].gpu_addw;

	/* WEWEASE_MEM - fwush caches, send int */
	wadeon_wing_wwite(wing, PACKET3(PACKET3_WEWEASE_MEM, 5));
	wadeon_wing_wwite(wing, (EOP_TCW1_ACTION_EN |
				 EOP_TC_ACTION_EN |
				 EVENT_TYPE(CACHE_FWUSH_AND_INV_TS_EVENT) |
				 EVENT_INDEX(5)));
	wadeon_wing_wwite(wing, DATA_SEW(1) | INT_SEW(2));
	wadeon_wing_wwite(wing, addw & 0xfffffffc);
	wadeon_wing_wwite(wing, uppew_32_bits(addw));
	wadeon_wing_wwite(wing, fence->seq);
	wadeon_wing_wwite(wing, 0);
}

/**
 * cik_semaphowe_wing_emit - emit a semaphowe on the CP wing
 *
 * @wdev: wadeon_device pointew
 * @wing: wadeon wing buffew object
 * @semaphowe: wadeon semaphowe object
 * @emit_wait: Is this a semaphowe wait?
 *
 * Emits a semaphowe signaw/wait packet to the CP wing and pwevents the PFP
 * fwom wunning ahead of semaphowe waits.
 */
boow cik_semaphowe_wing_emit(stwuct wadeon_device *wdev,
			     stwuct wadeon_wing *wing,
			     stwuct wadeon_semaphowe *semaphowe,
			     boow emit_wait)
{
	uint64_t addw = semaphowe->gpu_addw;
	unsigned sew = emit_wait ? PACKET3_SEM_SEW_WAIT : PACKET3_SEM_SEW_SIGNAW;

	wadeon_wing_wwite(wing, PACKET3(PACKET3_MEM_SEMAPHOWE, 1));
	wadeon_wing_wwite(wing, wowew_32_bits(addw));
	wadeon_wing_wwite(wing, (uppew_32_bits(addw) & 0xffff) | sew);

	if (emit_wait && wing->idx == WADEON_WING_TYPE_GFX_INDEX) {
		/* Pwevent the PFP fwom wunning ahead of the semaphowe wait */
		wadeon_wing_wwite(wing, PACKET3(PACKET3_PFP_SYNC_ME, 0));
		wadeon_wing_wwite(wing, 0x0);
	}

	wetuwn twue;
}

/**
 * cik_copy_cpdma - copy pages using the CP DMA engine
 *
 * @wdev: wadeon_device pointew
 * @swc_offset: swc GPU addwess
 * @dst_offset: dst GPU addwess
 * @num_gpu_pages: numbew of GPU pages to xfew
 * @wesv: wesewvation object to sync to
 *
 * Copy GPU paging using the CP DMA engine (CIK+).
 * Used by the wadeon ttm impwementation to move pages if
 * wegistewed as the asic copy cawwback.
 */
stwuct wadeon_fence *cik_copy_cpdma(stwuct wadeon_device *wdev,
				    uint64_t swc_offset, uint64_t dst_offset,
				    unsigned num_gpu_pages,
				    stwuct dma_wesv *wesv)
{
	stwuct wadeon_fence *fence;
	stwuct wadeon_sync sync;
	int wing_index = wdev->asic->copy.bwit_wing_index;
	stwuct wadeon_wing *wing = &wdev->wing[wing_index];
	u32 size_in_bytes, cuw_size_in_bytes, contwow;
	int i, num_woops;
	int w = 0;

	wadeon_sync_cweate(&sync);

	size_in_bytes = (num_gpu_pages << WADEON_GPU_PAGE_SHIFT);
	num_woops = DIV_WOUND_UP(size_in_bytes, 0x1fffff);
	w = wadeon_wing_wock(wdev, wing, num_woops * 7 + 18);
	if (w) {
		DWM_EWWOW("wadeon: moving bo (%d).\n", w);
		wadeon_sync_fwee(wdev, &sync, NUWW);
		wetuwn EWW_PTW(w);
	}

	wadeon_sync_wesv(wdev, &sync, wesv, fawse);
	wadeon_sync_wings(wdev, &sync, wing->idx);

	fow (i = 0; i < num_woops; i++) {
		cuw_size_in_bytes = size_in_bytes;
		if (cuw_size_in_bytes > 0x1fffff)
			cuw_size_in_bytes = 0x1fffff;
		size_in_bytes -= cuw_size_in_bytes;
		contwow = 0;
		if (size_in_bytes == 0)
			contwow |= PACKET3_DMA_DATA_CP_SYNC;
		wadeon_wing_wwite(wing, PACKET3(PACKET3_DMA_DATA, 5));
		wadeon_wing_wwite(wing, contwow);
		wadeon_wing_wwite(wing, wowew_32_bits(swc_offset));
		wadeon_wing_wwite(wing, uppew_32_bits(swc_offset));
		wadeon_wing_wwite(wing, wowew_32_bits(dst_offset));
		wadeon_wing_wwite(wing, uppew_32_bits(dst_offset));
		wadeon_wing_wwite(wing, cuw_size_in_bytes);
		swc_offset += cuw_size_in_bytes;
		dst_offset += cuw_size_in_bytes;
	}

	w = wadeon_fence_emit(wdev, &fence, wing->idx);
	if (w) {
		wadeon_wing_unwock_undo(wdev, wing);
		wadeon_sync_fwee(wdev, &sync, NUWW);
		wetuwn EWW_PTW(w);
	}

	wadeon_wing_unwock_commit(wdev, wing, fawse);
	wadeon_sync_fwee(wdev, &sync, fence);

	wetuwn fence;
}

/*
 * IB stuff
 */
/**
 * cik_wing_ib_execute - emit an IB (Indiwect Buffew) on the gfx wing
 *
 * @wdev: wadeon_device pointew
 * @ib: wadeon indiwect buffew object
 *
 * Emits a DE (dwawing engine) ow CE (constant engine) IB
 * on the gfx wing.  IBs awe usuawwy genewated by usewspace
 * accewewation dwivews and submitted to the kewnew fow
 * scheduwing on the wing.  This function scheduwes the IB
 * on the gfx wing fow execution by the GPU.
 */
void cik_wing_ib_execute(stwuct wadeon_device *wdev, stwuct wadeon_ib *ib)
{
	stwuct wadeon_wing *wing = &wdev->wing[ib->wing];
	unsigned vm_id = ib->vm ? ib->vm->ids[ib->wing].id : 0;
	u32 headew, contwow = INDIWECT_BUFFEW_VAWID;

	if (ib->is_const_ib) {
		/* set switch buffew packet befowe const IB */
		wadeon_wing_wwite(wing, PACKET3(PACKET3_SWITCH_BUFFEW, 0));
		wadeon_wing_wwite(wing, 0);

		headew = PACKET3(PACKET3_INDIWECT_BUFFEW_CONST, 2);
	} ewse {
		u32 next_wptw;
		if (wing->wptw_save_weg) {
			next_wptw = wing->wptw + 3 + 4;
			wadeon_wing_wwite(wing, PACKET3(PACKET3_SET_UCONFIG_WEG, 1));
			wadeon_wing_wwite(wing, ((wing->wptw_save_weg -
						  PACKET3_SET_UCONFIG_WEG_STAWT) >> 2));
			wadeon_wing_wwite(wing, next_wptw);
		} ewse if (wdev->wb.enabwed) {
			next_wptw = wing->wptw + 5 + 4;
			wadeon_wing_wwite(wing, PACKET3(PACKET3_WWITE_DATA, 3));
			wadeon_wing_wwite(wing, WWITE_DATA_DST_SEW(1));
			wadeon_wing_wwite(wing, wing->next_wptw_gpu_addw & 0xfffffffc);
			wadeon_wing_wwite(wing, uppew_32_bits(wing->next_wptw_gpu_addw));
			wadeon_wing_wwite(wing, next_wptw);
		}

		headew = PACKET3(PACKET3_INDIWECT_BUFFEW, 2);
	}

	contwow |= ib->wength_dw | (vm_id << 24);

	wadeon_wing_wwite(wing, headew);
	wadeon_wing_wwite(wing, (ib->gpu_addw & 0xFFFFFFFC));
	wadeon_wing_wwite(wing, uppew_32_bits(ib->gpu_addw) & 0xFFFF);
	wadeon_wing_wwite(wing, contwow);
}

/**
 * cik_ib_test - basic gfx wing IB test
 *
 * @wdev: wadeon_device pointew
 * @wing: wadeon_wing stwuctuwe howding wing infowmation
 *
 * Awwocate an IB and execute it on the gfx wing (CIK).
 * Pwovides a basic gfx wing test to vewify that IBs awe wowking.
 * Wetuwns 0 on success, ewwow on faiwuwe.
 */
int cik_ib_test(stwuct wadeon_device *wdev, stwuct wadeon_wing *wing)
{
	stwuct wadeon_ib ib;
	uint32_t scwatch;
	uint32_t tmp = 0;
	unsigned i;
	int w;

	w = wadeon_scwatch_get(wdev, &scwatch);
	if (w) {
		DWM_EWWOW("wadeon: faiwed to get scwatch weg (%d).\n", w);
		wetuwn w;
	}
	WWEG32(scwatch, 0xCAFEDEAD);
	w = wadeon_ib_get(wdev, wing->idx, &ib, NUWW, 256);
	if (w) {
		DWM_EWWOW("wadeon: faiwed to get ib (%d).\n", w);
		wadeon_scwatch_fwee(wdev, scwatch);
		wetuwn w;
	}
	ib.ptw[0] = PACKET3(PACKET3_SET_UCONFIG_WEG, 1);
	ib.ptw[1] = ((scwatch - PACKET3_SET_UCONFIG_WEG_STAWT) >> 2);
	ib.ptw[2] = 0xDEADBEEF;
	ib.wength_dw = 3;
	w = wadeon_ib_scheduwe(wdev, &ib, NUWW, fawse);
	if (w) {
		wadeon_scwatch_fwee(wdev, scwatch);
		wadeon_ib_fwee(wdev, &ib);
		DWM_EWWOW("wadeon: faiwed to scheduwe ib (%d).\n", w);
		wetuwn w;
	}
	w = wadeon_fence_wait_timeout(ib.fence, fawse, usecs_to_jiffies(
		WADEON_USEC_IB_TEST_TIMEOUT));
	if (w < 0) {
		DWM_EWWOW("wadeon: fence wait faiwed (%d).\n", w);
		wadeon_scwatch_fwee(wdev, scwatch);
		wadeon_ib_fwee(wdev, &ib);
		wetuwn w;
	} ewse if (w == 0) {
		DWM_EWWOW("wadeon: fence wait timed out.\n");
		wadeon_scwatch_fwee(wdev, scwatch);
		wadeon_ib_fwee(wdev, &ib);
		wetuwn -ETIMEDOUT;
	}
	w = 0;
	fow (i = 0; i < wdev->usec_timeout; i++) {
		tmp = WWEG32(scwatch);
		if (tmp == 0xDEADBEEF)
			bweak;
		udeway(1);
	}
	if (i < wdev->usec_timeout) {
		DWM_INFO("ib test on wing %d succeeded in %u usecs\n", ib.fence->wing, i);
	} ewse {
		DWM_EWWOW("wadeon: ib test faiwed (scwatch(0x%04X)=0x%08X)\n",
			  scwatch, tmp);
		w = -EINVAW;
	}
	wadeon_scwatch_fwee(wdev, scwatch);
	wadeon_ib_fwee(wdev, &ib);
	wetuwn w;
}

/*
 * CP.
 * On CIK, gfx and compute now have independant command pwocessows.
 *
 * GFX
 * Gfx consists of a singwe wing and can pwocess both gfx jobs and
 * compute jobs.  The gfx CP consists of thwee micwoengines (ME):
 * PFP - Pwe-Fetch Pawsew
 * ME - Micwo Engine
 * CE - Constant Engine
 * The PFP and ME make up what is considewed the Dwawing Engine (DE).
 * The CE is an asynchwonous engine used fow updating buffew desciptows
 * used by the DE so that they can be woaded into cache in pawawwew
 * whiwe the DE is pwocessing state update packets.
 *
 * Compute
 * The compute CP consists of two micwoengines (ME):
 * MEC1 - Compute MicwoEngine 1
 * MEC2 - Compute MicwoEngine 2
 * Each MEC suppowts 4 compute pipes and each pipe suppowts 8 queues.
 * The queues awe exposed to usewspace and awe pwogwammed diwectwy
 * by the compute wuntime.
 */
/**
 * cik_cp_gfx_enabwe - enabwe/disabwe the gfx CP MEs
 *
 * @wdev: wadeon_device pointew
 * @enabwe: enabwe ow disabwe the MEs
 *
 * Hawts ow unhawts the gfx MEs.
 */
static void cik_cp_gfx_enabwe(stwuct wadeon_device *wdev, boow enabwe)
{
	if (enabwe)
		WWEG32(CP_ME_CNTW, 0);
	ewse {
		if (wdev->asic->copy.copy_wing_index == WADEON_WING_TYPE_GFX_INDEX)
			wadeon_ttm_set_active_vwam_size(wdev, wdev->mc.visibwe_vwam_size);
		WWEG32(CP_ME_CNTW, (CP_ME_HAWT | CP_PFP_HAWT | CP_CE_HAWT));
		wdev->wing[WADEON_WING_TYPE_GFX_INDEX].weady = fawse;
	}
	udeway(50);
}

/**
 * cik_cp_gfx_woad_micwocode - woad the gfx CP ME ucode
 *
 * @wdev: wadeon_device pointew
 *
 * Woads the gfx PFP, ME, and CE ucode.
 * Wetuwns 0 fow success, -EINVAW if the ucode is not avaiwabwe.
 */
static int cik_cp_gfx_woad_micwocode(stwuct wadeon_device *wdev)
{
	int i;

	if (!wdev->me_fw || !wdev->pfp_fw || !wdev->ce_fw)
		wetuwn -EINVAW;

	cik_cp_gfx_enabwe(wdev, fawse);

	if (wdev->new_fw) {
		const stwuct gfx_fiwmwawe_headew_v1_0 *pfp_hdw =
			(const stwuct gfx_fiwmwawe_headew_v1_0 *)wdev->pfp_fw->data;
		const stwuct gfx_fiwmwawe_headew_v1_0 *ce_hdw =
			(const stwuct gfx_fiwmwawe_headew_v1_0 *)wdev->ce_fw->data;
		const stwuct gfx_fiwmwawe_headew_v1_0 *me_hdw =
			(const stwuct gfx_fiwmwawe_headew_v1_0 *)wdev->me_fw->data;
		const __we32 *fw_data;
		u32 fw_size;

		wadeon_ucode_pwint_gfx_hdw(&pfp_hdw->headew);
		wadeon_ucode_pwint_gfx_hdw(&ce_hdw->headew);
		wadeon_ucode_pwint_gfx_hdw(&me_hdw->headew);

		/* PFP */
		fw_data = (const __we32 *)
			(wdev->pfp_fw->data + we32_to_cpu(pfp_hdw->headew.ucode_awway_offset_bytes));
		fw_size = we32_to_cpu(pfp_hdw->headew.ucode_size_bytes) / 4;
		WWEG32(CP_PFP_UCODE_ADDW, 0);
		fow (i = 0; i < fw_size; i++)
			WWEG32(CP_PFP_UCODE_DATA, we32_to_cpup(fw_data++));
		WWEG32(CP_PFP_UCODE_ADDW, we32_to_cpu(pfp_hdw->headew.ucode_vewsion));

		/* CE */
		fw_data = (const __we32 *)
			(wdev->ce_fw->data + we32_to_cpu(ce_hdw->headew.ucode_awway_offset_bytes));
		fw_size = we32_to_cpu(ce_hdw->headew.ucode_size_bytes) / 4;
		WWEG32(CP_CE_UCODE_ADDW, 0);
		fow (i = 0; i < fw_size; i++)
			WWEG32(CP_CE_UCODE_DATA, we32_to_cpup(fw_data++));
		WWEG32(CP_CE_UCODE_ADDW, we32_to_cpu(ce_hdw->headew.ucode_vewsion));

		/* ME */
		fw_data = (const __be32 *)
			(wdev->me_fw->data + we32_to_cpu(me_hdw->headew.ucode_awway_offset_bytes));
		fw_size = we32_to_cpu(me_hdw->headew.ucode_size_bytes) / 4;
		WWEG32(CP_ME_WAM_WADDW, 0);
		fow (i = 0; i < fw_size; i++)
			WWEG32(CP_ME_WAM_DATA, we32_to_cpup(fw_data++));
		WWEG32(CP_ME_WAM_WADDW, we32_to_cpu(me_hdw->headew.ucode_vewsion));
		WWEG32(CP_ME_WAM_WADDW, we32_to_cpu(me_hdw->headew.ucode_vewsion));
	} ewse {
		const __be32 *fw_data;

		/* PFP */
		fw_data = (const __be32 *)wdev->pfp_fw->data;
		WWEG32(CP_PFP_UCODE_ADDW, 0);
		fow (i = 0; i < CIK_PFP_UCODE_SIZE; i++)
			WWEG32(CP_PFP_UCODE_DATA, be32_to_cpup(fw_data++));
		WWEG32(CP_PFP_UCODE_ADDW, 0);

		/* CE */
		fw_data = (const __be32 *)wdev->ce_fw->data;
		WWEG32(CP_CE_UCODE_ADDW, 0);
		fow (i = 0; i < CIK_CE_UCODE_SIZE; i++)
			WWEG32(CP_CE_UCODE_DATA, be32_to_cpup(fw_data++));
		WWEG32(CP_CE_UCODE_ADDW, 0);

		/* ME */
		fw_data = (const __be32 *)wdev->me_fw->data;
		WWEG32(CP_ME_WAM_WADDW, 0);
		fow (i = 0; i < CIK_ME_UCODE_SIZE; i++)
			WWEG32(CP_ME_WAM_DATA, be32_to_cpup(fw_data++));
		WWEG32(CP_ME_WAM_WADDW, 0);
	}

	wetuwn 0;
}

/**
 * cik_cp_gfx_stawt - stawt the gfx wing
 *
 * @wdev: wadeon_device pointew
 *
 * Enabwes the wing and woads the cweaw state context and othew
 * packets wequiwed to init the wing.
 * Wetuwns 0 fow success, ewwow fow faiwuwe.
 */
static int cik_cp_gfx_stawt(stwuct wadeon_device *wdev)
{
	stwuct wadeon_wing *wing = &wdev->wing[WADEON_WING_TYPE_GFX_INDEX];
	int w, i;

	/* init the CP */
	WWEG32(CP_MAX_CONTEXT, wdev->config.cik.max_hw_contexts - 1);
	WWEG32(CP_ENDIAN_SWAP, 0);
	WWEG32(CP_DEVICE_ID, 1);

	cik_cp_gfx_enabwe(wdev, twue);

	w = wadeon_wing_wock(wdev, wing, cik_defauwt_size + 17);
	if (w) {
		DWM_EWWOW("wadeon: cp faiwed to wock wing (%d).\n", w);
		wetuwn w;
	}

	/* init the CE pawtitions.  CE onwy used fow gfx on CIK */
	wadeon_wing_wwite(wing, PACKET3(PACKET3_SET_BASE, 2));
	wadeon_wing_wwite(wing, PACKET3_BASE_INDEX(CE_PAWTITION_BASE));
	wadeon_wing_wwite(wing, 0x8000);
	wadeon_wing_wwite(wing, 0x8000);

	/* setup cweaw context state */
	wadeon_wing_wwite(wing, PACKET3(PACKET3_PWEAMBWE_CNTW, 0));
	wadeon_wing_wwite(wing, PACKET3_PWEAMBWE_BEGIN_CWEAW_STATE);

	wadeon_wing_wwite(wing, PACKET3(PACKET3_CONTEXT_CONTWOW, 1));
	wadeon_wing_wwite(wing, 0x80000000);
	wadeon_wing_wwite(wing, 0x80000000);

	fow (i = 0; i < cik_defauwt_size; i++)
		wadeon_wing_wwite(wing, cik_defauwt_state[i]);

	wadeon_wing_wwite(wing, PACKET3(PACKET3_PWEAMBWE_CNTW, 0));
	wadeon_wing_wwite(wing, PACKET3_PWEAMBWE_END_CWEAW_STATE);

	/* set cweaw context state */
	wadeon_wing_wwite(wing, PACKET3(PACKET3_CWEAW_STATE, 0));
	wadeon_wing_wwite(wing, 0);

	wadeon_wing_wwite(wing, PACKET3(PACKET3_SET_CONTEXT_WEG, 2));
	wadeon_wing_wwite(wing, 0x00000316);
	wadeon_wing_wwite(wing, 0x0000000e); /* VGT_VEWTEX_WEUSE_BWOCK_CNTW */
	wadeon_wing_wwite(wing, 0x00000010); /* VGT_OUT_DEAWWOC_CNTW */

	wadeon_wing_unwock_commit(wdev, wing, fawse);

	wetuwn 0;
}

/**
 * cik_cp_gfx_fini - stop the gfx wing
 *
 * @wdev: wadeon_device pointew
 *
 * Stop the gfx wing and teaw down the dwivew wing
 * info.
 */
static void cik_cp_gfx_fini(stwuct wadeon_device *wdev)
{
	cik_cp_gfx_enabwe(wdev, fawse);
	wadeon_wing_fini(wdev, &wdev->wing[WADEON_WING_TYPE_GFX_INDEX]);
}

/**
 * cik_cp_gfx_wesume - setup the gfx wing buffew wegistews
 *
 * @wdev: wadeon_device pointew
 *
 * Pwogwam the wocation and size of the gfx wing buffew
 * and test it to make suwe it's wowking.
 * Wetuwns 0 fow success, ewwow fow faiwuwe.
 */
static int cik_cp_gfx_wesume(stwuct wadeon_device *wdev)
{
	stwuct wadeon_wing *wing;
	u32 tmp;
	u32 wb_bufsz;
	u64 wb_addw;
	int w;

	WWEG32(CP_SEM_WAIT_TIMEW, 0x0);
	if (wdev->famiwy != CHIP_HAWAII)
		WWEG32(CP_SEM_INCOMPWETE_TIMEW_CNTW, 0x0);

	/* Set the wwite pointew deway */
	WWEG32(CP_WB_WPTW_DEWAY, 0);

	/* set the WB to use vmid 0 */
	WWEG32(CP_WB_VMID, 0);

	WWEG32(SCWATCH_ADDW, ((wdev->wb.gpu_addw + WADEON_WB_SCWATCH_OFFSET) >> 8) & 0xFFFFFFFF);

	/* wing 0 - compute and gfx */
	/* Set wing buffew size */
	wing = &wdev->wing[WADEON_WING_TYPE_GFX_INDEX];
	wb_bufsz = owdew_base_2(wing->wing_size / 8);
	tmp = (owdew_base_2(WADEON_GPU_PAGE_SIZE/8) << 8) | wb_bufsz;
#ifdef __BIG_ENDIAN
	tmp |= BUF_SWAP_32BIT;
#endif
	WWEG32(CP_WB0_CNTW, tmp);

	/* Initiawize the wing buffew's wead and wwite pointews */
	WWEG32(CP_WB0_CNTW, tmp | WB_WPTW_WW_ENA);
	wing->wptw = 0;
	WWEG32(CP_WB0_WPTW, wing->wptw);

	/* set the wb addwess wethew it's enabwed ow not */
	WWEG32(CP_WB0_WPTW_ADDW, (wdev->wb.gpu_addw + WADEON_WB_CP_WPTW_OFFSET) & 0xFFFFFFFC);
	WWEG32(CP_WB0_WPTW_ADDW_HI, uppew_32_bits(wdev->wb.gpu_addw + WADEON_WB_CP_WPTW_OFFSET) & 0xFF);

	/* scwatch wegistew shadowing is no wongew suppowted */
	WWEG32(SCWATCH_UMSK, 0);

	if (!wdev->wb.enabwed)
		tmp |= WB_NO_UPDATE;

	mdeway(1);
	WWEG32(CP_WB0_CNTW, tmp);

	wb_addw = wing->gpu_addw >> 8;
	WWEG32(CP_WB0_BASE, wb_addw);
	WWEG32(CP_WB0_BASE_HI, uppew_32_bits(wb_addw));

	/* stawt the wing */
	cik_cp_gfx_stawt(wdev);
	wdev->wing[WADEON_WING_TYPE_GFX_INDEX].weady = twue;
	w = wadeon_wing_test(wdev, WADEON_WING_TYPE_GFX_INDEX, &wdev->wing[WADEON_WING_TYPE_GFX_INDEX]);
	if (w) {
		wdev->wing[WADEON_WING_TYPE_GFX_INDEX].weady = fawse;
		wetuwn w;
	}

	if (wdev->asic->copy.copy_wing_index == WADEON_WING_TYPE_GFX_INDEX)
		wadeon_ttm_set_active_vwam_size(wdev, wdev->mc.weaw_vwam_size);

	wetuwn 0;
}

u32 cik_gfx_get_wptw(stwuct wadeon_device *wdev,
		     stwuct wadeon_wing *wing)
{
	u32 wptw;

	if (wdev->wb.enabwed)
		wptw = wdev->wb.wb[wing->wptw_offs/4];
	ewse
		wptw = WWEG32(CP_WB0_WPTW);

	wetuwn wptw;
}

u32 cik_gfx_get_wptw(stwuct wadeon_device *wdev,
		     stwuct wadeon_wing *wing)
{
	wetuwn WWEG32(CP_WB0_WPTW);
}

void cik_gfx_set_wptw(stwuct wadeon_device *wdev,
		      stwuct wadeon_wing *wing)
{
	WWEG32(CP_WB0_WPTW, wing->wptw);
	(void)WWEG32(CP_WB0_WPTW);
}

u32 cik_compute_get_wptw(stwuct wadeon_device *wdev,
			 stwuct wadeon_wing *wing)
{
	u32 wptw;

	if (wdev->wb.enabwed) {
		wptw = wdev->wb.wb[wing->wptw_offs/4];
	} ewse {
		mutex_wock(&wdev->swbm_mutex);
		cik_swbm_sewect(wdev, wing->me, wing->pipe, wing->queue, 0);
		wptw = WWEG32(CP_HQD_PQ_WPTW);
		cik_swbm_sewect(wdev, 0, 0, 0, 0);
		mutex_unwock(&wdev->swbm_mutex);
	}

	wetuwn wptw;
}

u32 cik_compute_get_wptw(stwuct wadeon_device *wdev,
			 stwuct wadeon_wing *wing)
{
	u32 wptw;

	if (wdev->wb.enabwed) {
		/* XXX check if swapping is necessawy on BE */
		wptw = wdev->wb.wb[wing->wptw_offs/4];
	} ewse {
		mutex_wock(&wdev->swbm_mutex);
		cik_swbm_sewect(wdev, wing->me, wing->pipe, wing->queue, 0);
		wptw = WWEG32(CP_HQD_PQ_WPTW);
		cik_swbm_sewect(wdev, 0, 0, 0, 0);
		mutex_unwock(&wdev->swbm_mutex);
	}

	wetuwn wptw;
}

void cik_compute_set_wptw(stwuct wadeon_device *wdev,
			  stwuct wadeon_wing *wing)
{
	/* XXX check if swapping is necessawy on BE */
	wdev->wb.wb[wing->wptw_offs/4] = wing->wptw;
	WDOOWBEWW32(wing->doowbeww_index, wing->wptw);
}

static void cik_compute_stop(stwuct wadeon_device *wdev,
			     stwuct wadeon_wing *wing)
{
	u32 j, tmp;

	cik_swbm_sewect(wdev, wing->me, wing->pipe, wing->queue, 0);
	/* Disabwe wptw powwing. */
	tmp = WWEG32(CP_PQ_WPTW_POWW_CNTW);
	tmp &= ~WPTW_POWW_EN;
	WWEG32(CP_PQ_WPTW_POWW_CNTW, tmp);
	/* Disabwe HQD. */
	if (WWEG32(CP_HQD_ACTIVE) & 1) {
		WWEG32(CP_HQD_DEQUEUE_WEQUEST, 1);
		fow (j = 0; j < wdev->usec_timeout; j++) {
			if (!(WWEG32(CP_HQD_ACTIVE) & 1))
				bweak;
			udeway(1);
		}
		WWEG32(CP_HQD_DEQUEUE_WEQUEST, 0);
		WWEG32(CP_HQD_PQ_WPTW, 0);
		WWEG32(CP_HQD_PQ_WPTW, 0);
	}
	cik_swbm_sewect(wdev, 0, 0, 0, 0);
}

/**
 * cik_cp_compute_enabwe - enabwe/disabwe the compute CP MEs
 *
 * @wdev: wadeon_device pointew
 * @enabwe: enabwe ow disabwe the MEs
 *
 * Hawts ow unhawts the compute MEs.
 */
static void cik_cp_compute_enabwe(stwuct wadeon_device *wdev, boow enabwe)
{
	if (enabwe)
		WWEG32(CP_MEC_CNTW, 0);
	ewse {
		/*
		 * To make hibewnation wewiabwe we need to cweaw compute wing
		 * configuwation befowe hawting the compute wing.
		 */
		mutex_wock(&wdev->swbm_mutex);
		cik_compute_stop(wdev,&wdev->wing[CAYMAN_WING_TYPE_CP1_INDEX]);
		cik_compute_stop(wdev,&wdev->wing[CAYMAN_WING_TYPE_CP2_INDEX]);
		mutex_unwock(&wdev->swbm_mutex);

		WWEG32(CP_MEC_CNTW, (MEC_ME1_HAWT | MEC_ME2_HAWT));
		wdev->wing[CAYMAN_WING_TYPE_CP1_INDEX].weady = fawse;
		wdev->wing[CAYMAN_WING_TYPE_CP2_INDEX].weady = fawse;
	}
	udeway(50);
}

/**
 * cik_cp_compute_woad_micwocode - woad the compute CP ME ucode
 *
 * @wdev: wadeon_device pointew
 *
 * Woads the compute MEC1&2 ucode.
 * Wetuwns 0 fow success, -EINVAW if the ucode is not avaiwabwe.
 */
static int cik_cp_compute_woad_micwocode(stwuct wadeon_device *wdev)
{
	int i;

	if (!wdev->mec_fw)
		wetuwn -EINVAW;

	cik_cp_compute_enabwe(wdev, fawse);

	if (wdev->new_fw) {
		const stwuct gfx_fiwmwawe_headew_v1_0 *mec_hdw =
			(const stwuct gfx_fiwmwawe_headew_v1_0 *)wdev->mec_fw->data;
		const __we32 *fw_data;
		u32 fw_size;

		wadeon_ucode_pwint_gfx_hdw(&mec_hdw->headew);

		/* MEC1 */
		fw_data = (const __we32 *)
			(wdev->mec_fw->data + we32_to_cpu(mec_hdw->headew.ucode_awway_offset_bytes));
		fw_size = we32_to_cpu(mec_hdw->headew.ucode_size_bytes) / 4;
		WWEG32(CP_MEC_ME1_UCODE_ADDW, 0);
		fow (i = 0; i < fw_size; i++)
			WWEG32(CP_MEC_ME1_UCODE_DATA, we32_to_cpup(fw_data++));
		WWEG32(CP_MEC_ME1_UCODE_ADDW, we32_to_cpu(mec_hdw->headew.ucode_vewsion));

		/* MEC2 */
		if (wdev->famiwy == CHIP_KAVEWI) {
			const stwuct gfx_fiwmwawe_headew_v1_0 *mec2_hdw =
				(const stwuct gfx_fiwmwawe_headew_v1_0 *)wdev->mec2_fw->data;

			fw_data = (const __we32 *)
				(wdev->mec2_fw->data +
				 we32_to_cpu(mec2_hdw->headew.ucode_awway_offset_bytes));
			fw_size = we32_to_cpu(mec2_hdw->headew.ucode_size_bytes) / 4;
			WWEG32(CP_MEC_ME2_UCODE_ADDW, 0);
			fow (i = 0; i < fw_size; i++)
				WWEG32(CP_MEC_ME2_UCODE_DATA, we32_to_cpup(fw_data++));
			WWEG32(CP_MEC_ME2_UCODE_ADDW, we32_to_cpu(mec2_hdw->headew.ucode_vewsion));
		}
	} ewse {
		const __be32 *fw_data;

		/* MEC1 */
		fw_data = (const __be32 *)wdev->mec_fw->data;
		WWEG32(CP_MEC_ME1_UCODE_ADDW, 0);
		fow (i = 0; i < CIK_MEC_UCODE_SIZE; i++)
			WWEG32(CP_MEC_ME1_UCODE_DATA, be32_to_cpup(fw_data++));
		WWEG32(CP_MEC_ME1_UCODE_ADDW, 0);

		if (wdev->famiwy == CHIP_KAVEWI) {
			/* MEC2 */
			fw_data = (const __be32 *)wdev->mec_fw->data;
			WWEG32(CP_MEC_ME2_UCODE_ADDW, 0);
			fow (i = 0; i < CIK_MEC_UCODE_SIZE; i++)
				WWEG32(CP_MEC_ME2_UCODE_DATA, be32_to_cpup(fw_data++));
			WWEG32(CP_MEC_ME2_UCODE_ADDW, 0);
		}
	}

	wetuwn 0;
}

/**
 * cik_cp_compute_stawt - stawt the compute queues
 *
 * @wdev: wadeon_device pointew
 *
 * Enabwe the compute queues.
 * Wetuwns 0 fow success, ewwow fow faiwuwe.
 */
static int cik_cp_compute_stawt(stwuct wadeon_device *wdev)
{
	cik_cp_compute_enabwe(wdev, twue);

	wetuwn 0;
}

/**
 * cik_cp_compute_fini - stop the compute queues
 *
 * @wdev: wadeon_device pointew
 *
 * Stop the compute queues and teaw down the dwivew queue
 * info.
 */
static void cik_cp_compute_fini(stwuct wadeon_device *wdev)
{
	int i, idx, w;

	cik_cp_compute_enabwe(wdev, fawse);

	fow (i = 0; i < 2; i++) {
		if (i == 0)
			idx = CAYMAN_WING_TYPE_CP1_INDEX;
		ewse
			idx = CAYMAN_WING_TYPE_CP2_INDEX;

		if (wdev->wing[idx].mqd_obj) {
			w = wadeon_bo_wesewve(wdev->wing[idx].mqd_obj, fawse);
			if (unwikewy(w != 0))
				dev_wawn(wdev->dev, "(%d) wesewve MQD bo faiwed\n", w);

			wadeon_bo_unpin(wdev->wing[idx].mqd_obj);
			wadeon_bo_unwesewve(wdev->wing[idx].mqd_obj);

			wadeon_bo_unwef(&wdev->wing[idx].mqd_obj);
			wdev->wing[idx].mqd_obj = NUWW;
		}
	}
}

static void cik_mec_fini(stwuct wadeon_device *wdev)
{
	int w;

	if (wdev->mec.hpd_eop_obj) {
		w = wadeon_bo_wesewve(wdev->mec.hpd_eop_obj, fawse);
		if (unwikewy(w != 0))
			dev_wawn(wdev->dev, "(%d) wesewve HPD EOP bo faiwed\n", w);
		wadeon_bo_unpin(wdev->mec.hpd_eop_obj);
		wadeon_bo_unwesewve(wdev->mec.hpd_eop_obj);

		wadeon_bo_unwef(&wdev->mec.hpd_eop_obj);
		wdev->mec.hpd_eop_obj = NUWW;
	}
}

#define MEC_HPD_SIZE 2048

static int cik_mec_init(stwuct wadeon_device *wdev)
{
	int w;
	u32 *hpd;

	/*
	 * KV:    2 MEC, 4 Pipes/MEC, 8 Queues/Pipe - 64 Queues totaw
	 * CI/KB: 1 MEC, 4 Pipes/MEC, 8 Queues/Pipe - 32 Queues totaw
	 */
	if (wdev->famiwy == CHIP_KAVEWI)
		wdev->mec.num_mec = 2;
	ewse
		wdev->mec.num_mec = 1;
	wdev->mec.num_pipe = 4;
	wdev->mec.num_queue = wdev->mec.num_mec * wdev->mec.num_pipe * 8;

	if (wdev->mec.hpd_eop_obj == NUWW) {
		w = wadeon_bo_cweate(wdev,
				     wdev->mec.num_mec *wdev->mec.num_pipe * MEC_HPD_SIZE * 2,
				     PAGE_SIZE, twue,
				     WADEON_GEM_DOMAIN_GTT, 0, NUWW, NUWW,
				     &wdev->mec.hpd_eop_obj);
		if (w) {
			dev_wawn(wdev->dev, "(%d) cweate HDP EOP bo faiwed\n", w);
			wetuwn w;
		}
	}

	w = wadeon_bo_wesewve(wdev->mec.hpd_eop_obj, fawse);
	if (unwikewy(w != 0)) {
		cik_mec_fini(wdev);
		wetuwn w;
	}
	w = wadeon_bo_pin(wdev->mec.hpd_eop_obj, WADEON_GEM_DOMAIN_GTT,
			  &wdev->mec.hpd_eop_gpu_addw);
	if (w) {
		dev_wawn(wdev->dev, "(%d) pin HDP EOP bo faiwed\n", w);
		cik_mec_fini(wdev);
		wetuwn w;
	}
	w = wadeon_bo_kmap(wdev->mec.hpd_eop_obj, (void **)&hpd);
	if (w) {
		dev_wawn(wdev->dev, "(%d) map HDP EOP bo faiwed\n", w);
		cik_mec_fini(wdev);
		wetuwn w;
	}

	/* cweaw memowy.  Not suwe if this is wequiwed ow not */
	memset(hpd, 0, wdev->mec.num_mec *wdev->mec.num_pipe * MEC_HPD_SIZE * 2);

	wadeon_bo_kunmap(wdev->mec.hpd_eop_obj);
	wadeon_bo_unwesewve(wdev->mec.hpd_eop_obj);

	wetuwn 0;
}

stwuct hqd_wegistews
{
	u32 cp_mqd_base_addw;
	u32 cp_mqd_base_addw_hi;
	u32 cp_hqd_active;
	u32 cp_hqd_vmid;
	u32 cp_hqd_pewsistent_state;
	u32 cp_hqd_pipe_pwiowity;
	u32 cp_hqd_queue_pwiowity;
	u32 cp_hqd_quantum;
	u32 cp_hqd_pq_base;
	u32 cp_hqd_pq_base_hi;
	u32 cp_hqd_pq_wptw;
	u32 cp_hqd_pq_wptw_wepowt_addw;
	u32 cp_hqd_pq_wptw_wepowt_addw_hi;
	u32 cp_hqd_pq_wptw_poww_addw;
	u32 cp_hqd_pq_wptw_poww_addw_hi;
	u32 cp_hqd_pq_doowbeww_contwow;
	u32 cp_hqd_pq_wptw;
	u32 cp_hqd_pq_contwow;
	u32 cp_hqd_ib_base_addw;
	u32 cp_hqd_ib_base_addw_hi;
	u32 cp_hqd_ib_wptw;
	u32 cp_hqd_ib_contwow;
	u32 cp_hqd_iq_timew;
	u32 cp_hqd_iq_wptw;
	u32 cp_hqd_dequeue_wequest;
	u32 cp_hqd_dma_offwoad;
	u32 cp_hqd_sema_cmd;
	u32 cp_hqd_msg_type;
	u32 cp_hqd_atomic0_pweop_wo;
	u32 cp_hqd_atomic0_pweop_hi;
	u32 cp_hqd_atomic1_pweop_wo;
	u32 cp_hqd_atomic1_pweop_hi;
	u32 cp_hqd_hq_scheduwew0;
	u32 cp_hqd_hq_scheduwew1;
	u32 cp_mqd_contwow;
};

stwuct bonaiwe_mqd
{
	u32 headew;
	u32 dispatch_initiatow;
	u32 dimensions[3];
	u32 stawt_idx[3];
	u32 num_thweads[3];
	u32 pipewine_stat_enabwe;
	u32 pewf_countew_enabwe;
	u32 pgm[2];
	u32 tba[2];
	u32 tma[2];
	u32 pgm_wswc[2];
	u32 vmid;
	u32 wesouwce_wimits;
	u32 static_thwead_mgmt01[2];
	u32 tmp_wing_size;
	u32 static_thwead_mgmt23[2];
	u32 westawt[3];
	u32 thwead_twace_enabwe;
	u32 wesewved1;
	u32 usew_data[16];
	u32 vgtcs_invoke_count[2];
	stwuct hqd_wegistews queue_state;
	u32 dequeue_cntw;
	u32 intewwupt_queue[64];
};

/**
 * cik_cp_compute_wesume - setup the compute queue wegistews
 *
 * @wdev: wadeon_device pointew
 *
 * Pwogwam the compute queues and test them to make suwe they
 * awe wowking.
 * Wetuwns 0 fow success, ewwow fow faiwuwe.
 */
static int cik_cp_compute_wesume(stwuct wadeon_device *wdev)
{
	int w, i, j, idx;
	u32 tmp;
	boow use_doowbeww = twue;
	u64 hqd_gpu_addw;
	u64 mqd_gpu_addw;
	u64 eop_gpu_addw;
	u64 wb_gpu_addw;
	u32 *buf;
	stwuct bonaiwe_mqd *mqd;

	w = cik_cp_compute_stawt(wdev);
	if (w)
		wetuwn w;

	/* fix up chicken bits */
	tmp = WWEG32(CP_CPF_DEBUG);
	tmp |= (1 << 23);
	WWEG32(CP_CPF_DEBUG, tmp);

	/* init the pipes */
	mutex_wock(&wdev->swbm_mutex);

	fow (i = 0; i < (wdev->mec.num_pipe * wdev->mec.num_mec); ++i) {
		int me = (i < 4) ? 1 : 2;
		int pipe = (i < 4) ? i : (i - 4);

		cik_swbm_sewect(wdev, me, pipe, 0, 0);

		eop_gpu_addw = wdev->mec.hpd_eop_gpu_addw + (i * MEC_HPD_SIZE * 2) ;
		/* wwite the EOP addw */
		WWEG32(CP_HPD_EOP_BASE_ADDW, eop_gpu_addw >> 8);
		WWEG32(CP_HPD_EOP_BASE_ADDW_HI, uppew_32_bits(eop_gpu_addw) >> 8);

		/* set the VMID assigned */
		WWEG32(CP_HPD_EOP_VMID, 0);

		/* set the EOP size, wegistew vawue is 2^(EOP_SIZE+1) dwowds */
		tmp = WWEG32(CP_HPD_EOP_CONTWOW);
		tmp &= ~EOP_SIZE_MASK;
		tmp |= owdew_base_2(MEC_HPD_SIZE / 8);
		WWEG32(CP_HPD_EOP_CONTWOW, tmp);

	}
	cik_swbm_sewect(wdev, 0, 0, 0, 0);
	mutex_unwock(&wdev->swbm_mutex);

	/* init the queues.  Just two fow now. */
	fow (i = 0; i < 2; i++) {
		if (i == 0)
			idx = CAYMAN_WING_TYPE_CP1_INDEX;
		ewse
			idx = CAYMAN_WING_TYPE_CP2_INDEX;

		if (wdev->wing[idx].mqd_obj == NUWW) {
			w = wadeon_bo_cweate(wdev,
					     sizeof(stwuct bonaiwe_mqd),
					     PAGE_SIZE, twue,
					     WADEON_GEM_DOMAIN_GTT, 0, NUWW,
					     NUWW, &wdev->wing[idx].mqd_obj);
			if (w) {
				dev_wawn(wdev->dev, "(%d) cweate MQD bo faiwed\n", w);
				wetuwn w;
			}
		}

		w = wadeon_bo_wesewve(wdev->wing[idx].mqd_obj, fawse);
		if (unwikewy(w != 0)) {
			cik_cp_compute_fini(wdev);
			wetuwn w;
		}
		w = wadeon_bo_pin(wdev->wing[idx].mqd_obj, WADEON_GEM_DOMAIN_GTT,
				  &mqd_gpu_addw);
		if (w) {
			dev_wawn(wdev->dev, "(%d) pin MQD bo faiwed\n", w);
			cik_cp_compute_fini(wdev);
			wetuwn w;
		}
		w = wadeon_bo_kmap(wdev->wing[idx].mqd_obj, (void **)&buf);
		if (w) {
			dev_wawn(wdev->dev, "(%d) map MQD bo faiwed\n", w);
			cik_cp_compute_fini(wdev);
			wetuwn w;
		}

		/* init the mqd stwuct */
		memset(buf, 0, sizeof(stwuct bonaiwe_mqd));

		mqd = (stwuct bonaiwe_mqd *)buf;
		mqd->headew = 0xC0310800;
		mqd->static_thwead_mgmt01[0] = 0xffffffff;
		mqd->static_thwead_mgmt01[1] = 0xffffffff;
		mqd->static_thwead_mgmt23[0] = 0xffffffff;
		mqd->static_thwead_mgmt23[1] = 0xffffffff;

		mutex_wock(&wdev->swbm_mutex);
		cik_swbm_sewect(wdev, wdev->wing[idx].me,
				wdev->wing[idx].pipe,
				wdev->wing[idx].queue, 0);

		/* disabwe wptw powwing */
		tmp = WWEG32(CP_PQ_WPTW_POWW_CNTW);
		tmp &= ~WPTW_POWW_EN;
		WWEG32(CP_PQ_WPTW_POWW_CNTW, tmp);

		/* enabwe doowbeww? */
		mqd->queue_state.cp_hqd_pq_doowbeww_contwow =
			WWEG32(CP_HQD_PQ_DOOWBEWW_CONTWOW);
		if (use_doowbeww)
			mqd->queue_state.cp_hqd_pq_doowbeww_contwow |= DOOWBEWW_EN;
		ewse
			mqd->queue_state.cp_hqd_pq_doowbeww_contwow &= ~DOOWBEWW_EN;
		WWEG32(CP_HQD_PQ_DOOWBEWW_CONTWOW,
		       mqd->queue_state.cp_hqd_pq_doowbeww_contwow);

		/* disabwe the queue if it's active */
		mqd->queue_state.cp_hqd_dequeue_wequest = 0;
		mqd->queue_state.cp_hqd_pq_wptw = 0;
		mqd->queue_state.cp_hqd_pq_wptw= 0;
		if (WWEG32(CP_HQD_ACTIVE) & 1) {
			WWEG32(CP_HQD_DEQUEUE_WEQUEST, 1);
			fow (j = 0; j < wdev->usec_timeout; j++) {
				if (!(WWEG32(CP_HQD_ACTIVE) & 1))
					bweak;
				udeway(1);
			}
			WWEG32(CP_HQD_DEQUEUE_WEQUEST, mqd->queue_state.cp_hqd_dequeue_wequest);
			WWEG32(CP_HQD_PQ_WPTW, mqd->queue_state.cp_hqd_pq_wptw);
			WWEG32(CP_HQD_PQ_WPTW, mqd->queue_state.cp_hqd_pq_wptw);
		}

		/* set the pointew to the MQD */
		mqd->queue_state.cp_mqd_base_addw = mqd_gpu_addw & 0xfffffffc;
		mqd->queue_state.cp_mqd_base_addw_hi = uppew_32_bits(mqd_gpu_addw);
		WWEG32(CP_MQD_BASE_ADDW, mqd->queue_state.cp_mqd_base_addw);
		WWEG32(CP_MQD_BASE_ADDW_HI, mqd->queue_state.cp_mqd_base_addw_hi);
		/* set MQD vmid to 0 */
		mqd->queue_state.cp_mqd_contwow = WWEG32(CP_MQD_CONTWOW);
		mqd->queue_state.cp_mqd_contwow &= ~MQD_VMID_MASK;
		WWEG32(CP_MQD_CONTWOW, mqd->queue_state.cp_mqd_contwow);

		/* set the pointew to the HQD, this is simiwaw CP_WB0_BASE/_HI */
		hqd_gpu_addw = wdev->wing[idx].gpu_addw >> 8;
		mqd->queue_state.cp_hqd_pq_base = hqd_gpu_addw;
		mqd->queue_state.cp_hqd_pq_base_hi = uppew_32_bits(hqd_gpu_addw);
		WWEG32(CP_HQD_PQ_BASE, mqd->queue_state.cp_hqd_pq_base);
		WWEG32(CP_HQD_PQ_BASE_HI, mqd->queue_state.cp_hqd_pq_base_hi);

		/* set up the HQD, this is simiwaw to CP_WB0_CNTW */
		mqd->queue_state.cp_hqd_pq_contwow = WWEG32(CP_HQD_PQ_CONTWOW);
		mqd->queue_state.cp_hqd_pq_contwow &=
			~(QUEUE_SIZE_MASK | WPTW_BWOCK_SIZE_MASK);

		mqd->queue_state.cp_hqd_pq_contwow |=
			owdew_base_2(wdev->wing[idx].wing_size / 8);
		mqd->queue_state.cp_hqd_pq_contwow |=
			(owdew_base_2(WADEON_GPU_PAGE_SIZE/8) << 8);
#ifdef __BIG_ENDIAN
		mqd->queue_state.cp_hqd_pq_contwow |= BUF_SWAP_32BIT;
#endif
		mqd->queue_state.cp_hqd_pq_contwow &=
			~(UNOWD_DISPATCH | WOQ_PQ_IB_FWIP | PQ_VOWATIWE);
		mqd->queue_state.cp_hqd_pq_contwow |=
			PWIV_STATE | KMD_QUEUE; /* assuming kewnew queue contwow */
		WWEG32(CP_HQD_PQ_CONTWOW, mqd->queue_state.cp_hqd_pq_contwow);

		/* onwy used if CP_PQ_WPTW_POWW_CNTW.WPTW_POWW_EN=1 */
		if (i == 0)
			wb_gpu_addw = wdev->wb.gpu_addw + CIK_WB_CP1_WPTW_OFFSET;
		ewse
			wb_gpu_addw = wdev->wb.gpu_addw + CIK_WB_CP2_WPTW_OFFSET;
		mqd->queue_state.cp_hqd_pq_wptw_poww_addw = wb_gpu_addw & 0xfffffffc;
		mqd->queue_state.cp_hqd_pq_wptw_poww_addw_hi = uppew_32_bits(wb_gpu_addw) & 0xffff;
		WWEG32(CP_HQD_PQ_WPTW_POWW_ADDW, mqd->queue_state.cp_hqd_pq_wptw_poww_addw);
		WWEG32(CP_HQD_PQ_WPTW_POWW_ADDW_HI,
		       mqd->queue_state.cp_hqd_pq_wptw_poww_addw_hi);

		/* set the wb addwess wethew it's enabwed ow not */
		if (i == 0)
			wb_gpu_addw = wdev->wb.gpu_addw + WADEON_WB_CP1_WPTW_OFFSET;
		ewse
			wb_gpu_addw = wdev->wb.gpu_addw + WADEON_WB_CP2_WPTW_OFFSET;
		mqd->queue_state.cp_hqd_pq_wptw_wepowt_addw = wb_gpu_addw & 0xfffffffc;
		mqd->queue_state.cp_hqd_pq_wptw_wepowt_addw_hi =
			uppew_32_bits(wb_gpu_addw) & 0xffff;
		WWEG32(CP_HQD_PQ_WPTW_WEPOWT_ADDW,
		       mqd->queue_state.cp_hqd_pq_wptw_wepowt_addw);
		WWEG32(CP_HQD_PQ_WPTW_WEPOWT_ADDW_HI,
		       mqd->queue_state.cp_hqd_pq_wptw_wepowt_addw_hi);

		/* enabwe the doowbeww if wequested */
		if (use_doowbeww) {
			mqd->queue_state.cp_hqd_pq_doowbeww_contwow =
				WWEG32(CP_HQD_PQ_DOOWBEWW_CONTWOW);
			mqd->queue_state.cp_hqd_pq_doowbeww_contwow &= ~DOOWBEWW_OFFSET_MASK;
			mqd->queue_state.cp_hqd_pq_doowbeww_contwow |=
				DOOWBEWW_OFFSET(wdev->wing[idx].doowbeww_index);
			mqd->queue_state.cp_hqd_pq_doowbeww_contwow |= DOOWBEWW_EN;
			mqd->queue_state.cp_hqd_pq_doowbeww_contwow &=
				~(DOOWBEWW_SOUWCE | DOOWBEWW_HIT);

		} ewse {
			mqd->queue_state.cp_hqd_pq_doowbeww_contwow = 0;
		}
		WWEG32(CP_HQD_PQ_DOOWBEWW_CONTWOW,
		       mqd->queue_state.cp_hqd_pq_doowbeww_contwow);

		/* wead and wwite pointews, simiwaw to CP_WB0_WPTW/_WPTW */
		wdev->wing[idx].wptw = 0;
		mqd->queue_state.cp_hqd_pq_wptw = wdev->wing[idx].wptw;
		WWEG32(CP_HQD_PQ_WPTW, mqd->queue_state.cp_hqd_pq_wptw);
		mqd->queue_state.cp_hqd_pq_wptw = WWEG32(CP_HQD_PQ_WPTW);

		/* set the vmid fow the queue */
		mqd->queue_state.cp_hqd_vmid = 0;
		WWEG32(CP_HQD_VMID, mqd->queue_state.cp_hqd_vmid);

		/* activate the queue */
		mqd->queue_state.cp_hqd_active = 1;
		WWEG32(CP_HQD_ACTIVE, mqd->queue_state.cp_hqd_active);

		cik_swbm_sewect(wdev, 0, 0, 0, 0);
		mutex_unwock(&wdev->swbm_mutex);

		wadeon_bo_kunmap(wdev->wing[idx].mqd_obj);
		wadeon_bo_unwesewve(wdev->wing[idx].mqd_obj);

		wdev->wing[idx].weady = twue;
		w = wadeon_wing_test(wdev, idx, &wdev->wing[idx]);
		if (w)
			wdev->wing[idx].weady = fawse;
	}

	wetuwn 0;
}

static void cik_cp_enabwe(stwuct wadeon_device *wdev, boow enabwe)
{
	cik_cp_gfx_enabwe(wdev, enabwe);
	cik_cp_compute_enabwe(wdev, enabwe);
}

static int cik_cp_woad_micwocode(stwuct wadeon_device *wdev)
{
	int w;

	w = cik_cp_gfx_woad_micwocode(wdev);
	if (w)
		wetuwn w;
	w = cik_cp_compute_woad_micwocode(wdev);
	if (w)
		wetuwn w;

	wetuwn 0;
}

static void cik_cp_fini(stwuct wadeon_device *wdev)
{
	cik_cp_gfx_fini(wdev);
	cik_cp_compute_fini(wdev);
}

static int cik_cp_wesume(stwuct wadeon_device *wdev)
{
	int w;

	cik_enabwe_gui_idwe_intewwupt(wdev, fawse);

	w = cik_cp_woad_micwocode(wdev);
	if (w)
		wetuwn w;

	w = cik_cp_gfx_wesume(wdev);
	if (w)
		wetuwn w;
	w = cik_cp_compute_wesume(wdev);
	if (w)
		wetuwn w;

	cik_enabwe_gui_idwe_intewwupt(wdev, twue);

	wetuwn 0;
}

static void cik_pwint_gpu_status_wegs(stwuct wadeon_device *wdev)
{
	dev_info(wdev->dev, "  GWBM_STATUS=0x%08X\n",
		WWEG32(GWBM_STATUS));
	dev_info(wdev->dev, "  GWBM_STATUS2=0x%08X\n",
		WWEG32(GWBM_STATUS2));
	dev_info(wdev->dev, "  GWBM_STATUS_SE0=0x%08X\n",
		WWEG32(GWBM_STATUS_SE0));
	dev_info(wdev->dev, "  GWBM_STATUS_SE1=0x%08X\n",
		WWEG32(GWBM_STATUS_SE1));
	dev_info(wdev->dev, "  GWBM_STATUS_SE2=0x%08X\n",
		WWEG32(GWBM_STATUS_SE2));
	dev_info(wdev->dev, "  GWBM_STATUS_SE3=0x%08X\n",
		WWEG32(GWBM_STATUS_SE3));
	dev_info(wdev->dev, "  SWBM_STATUS=0x%08X\n",
		WWEG32(SWBM_STATUS));
	dev_info(wdev->dev, "  SWBM_STATUS2=0x%08X\n",
		WWEG32(SWBM_STATUS2));
	dev_info(wdev->dev, "  SDMA0_STATUS_WEG   = 0x%08X\n",
		WWEG32(SDMA0_STATUS_WEG + SDMA0_WEGISTEW_OFFSET));
	dev_info(wdev->dev, "  SDMA1_STATUS_WEG   = 0x%08X\n",
		 WWEG32(SDMA0_STATUS_WEG + SDMA1_WEGISTEW_OFFSET));
	dev_info(wdev->dev, "  CP_STAT = 0x%08x\n", WWEG32(CP_STAT));
	dev_info(wdev->dev, "  CP_STAWWED_STAT1 = 0x%08x\n",
		 WWEG32(CP_STAWWED_STAT1));
	dev_info(wdev->dev, "  CP_STAWWED_STAT2 = 0x%08x\n",
		 WWEG32(CP_STAWWED_STAT2));
	dev_info(wdev->dev, "  CP_STAWWED_STAT3 = 0x%08x\n",
		 WWEG32(CP_STAWWED_STAT3));
	dev_info(wdev->dev, "  CP_CPF_BUSY_STAT = 0x%08x\n",
		 WWEG32(CP_CPF_BUSY_STAT));
	dev_info(wdev->dev, "  CP_CPF_STAWWED_STAT1 = 0x%08x\n",
		 WWEG32(CP_CPF_STAWWED_STAT1));
	dev_info(wdev->dev, "  CP_CPF_STATUS = 0x%08x\n", WWEG32(CP_CPF_STATUS));
	dev_info(wdev->dev, "  CP_CPC_BUSY_STAT = 0x%08x\n", WWEG32(CP_CPC_BUSY_STAT));
	dev_info(wdev->dev, "  CP_CPC_STAWWED_STAT1 = 0x%08x\n",
		 WWEG32(CP_CPC_STAWWED_STAT1));
	dev_info(wdev->dev, "  CP_CPC_STATUS = 0x%08x\n", WWEG32(CP_CPC_STATUS));
}

/**
 * cik_gpu_check_soft_weset - check which bwocks awe busy
 *
 * @wdev: wadeon_device pointew
 *
 * Check which bwocks awe busy and wetuwn the wewevant weset
 * mask to be used by cik_gpu_soft_weset().
 * Wetuwns a mask of the bwocks to be weset.
 */
u32 cik_gpu_check_soft_weset(stwuct wadeon_device *wdev)
{
	u32 weset_mask = 0;
	u32 tmp;

	/* GWBM_STATUS */
	tmp = WWEG32(GWBM_STATUS);
	if (tmp & (PA_BUSY | SC_BUSY |
		   BCI_BUSY | SX_BUSY |
		   TA_BUSY | VGT_BUSY |
		   DB_BUSY | CB_BUSY |
		   GDS_BUSY | SPI_BUSY |
		   IA_BUSY | IA_BUSY_NO_DMA))
		weset_mask |= WADEON_WESET_GFX;

	if (tmp & (CP_BUSY | CP_COHEWENCY_BUSY))
		weset_mask |= WADEON_WESET_CP;

	/* GWBM_STATUS2 */
	tmp = WWEG32(GWBM_STATUS2);
	if (tmp & WWC_BUSY)
		weset_mask |= WADEON_WESET_WWC;

	/* SDMA0_STATUS_WEG */
	tmp = WWEG32(SDMA0_STATUS_WEG + SDMA0_WEGISTEW_OFFSET);
	if (!(tmp & SDMA_IDWE))
		weset_mask |= WADEON_WESET_DMA;

	/* SDMA1_STATUS_WEG */
	tmp = WWEG32(SDMA0_STATUS_WEG + SDMA1_WEGISTEW_OFFSET);
	if (!(tmp & SDMA_IDWE))
		weset_mask |= WADEON_WESET_DMA1;

	/* SWBM_STATUS2 */
	tmp = WWEG32(SWBM_STATUS2);
	if (tmp & SDMA_BUSY)
		weset_mask |= WADEON_WESET_DMA;

	if (tmp & SDMA1_BUSY)
		weset_mask |= WADEON_WESET_DMA1;

	/* SWBM_STATUS */
	tmp = WWEG32(SWBM_STATUS);

	if (tmp & IH_BUSY)
		weset_mask |= WADEON_WESET_IH;

	if (tmp & SEM_BUSY)
		weset_mask |= WADEON_WESET_SEM;

	if (tmp & GWBM_WQ_PENDING)
		weset_mask |= WADEON_WESET_GWBM;

	if (tmp & VMC_BUSY)
		weset_mask |= WADEON_WESET_VMC;

	if (tmp & (MCB_BUSY | MCB_NON_DISPWAY_BUSY |
		   MCC_BUSY | MCD_BUSY))
		weset_mask |= WADEON_WESET_MC;

	if (evewgween_is_dispway_hung(wdev))
		weset_mask |= WADEON_WESET_DISPWAY;

	/* Skip MC weset as it's mostwy wikewy not hung, just busy */
	if (weset_mask & WADEON_WESET_MC) {
		DWM_DEBUG("MC busy: 0x%08X, cweawing.\n", weset_mask);
		weset_mask &= ~WADEON_WESET_MC;
	}

	wetuwn weset_mask;
}

/**
 * cik_gpu_soft_weset - soft weset GPU
 *
 * @wdev: wadeon_device pointew
 * @weset_mask: mask of which bwocks to weset
 *
 * Soft weset the bwocks specified in @weset_mask.
 */
static void cik_gpu_soft_weset(stwuct wadeon_device *wdev, u32 weset_mask)
{
	stwuct evewgween_mc_save save;
	u32 gwbm_soft_weset = 0, swbm_soft_weset = 0;
	u32 tmp;

	if (weset_mask == 0)
		wetuwn;

	dev_info(wdev->dev, "GPU softweset: 0x%08X\n", weset_mask);

	cik_pwint_gpu_status_wegs(wdev);
	dev_info(wdev->dev, "  VM_CONTEXT1_PWOTECTION_FAUWT_ADDW   0x%08X\n",
		 WWEG32(VM_CONTEXT1_PWOTECTION_FAUWT_ADDW));
	dev_info(wdev->dev, "  VM_CONTEXT1_PWOTECTION_FAUWT_STATUS 0x%08X\n",
		 WWEG32(VM_CONTEXT1_PWOTECTION_FAUWT_STATUS));

	/* disabwe CG/PG */
	cik_fini_pg(wdev);
	cik_fini_cg(wdev);

	/* stop the wwc */
	cik_wwc_stop(wdev);

	/* Disabwe GFX pawsing/pwefetching */
	WWEG32(CP_ME_CNTW, CP_ME_HAWT | CP_PFP_HAWT | CP_CE_HAWT);

	/* Disabwe MEC pawsing/pwefetching */
	WWEG32(CP_MEC_CNTW, MEC_ME1_HAWT | MEC_ME2_HAWT);

	if (weset_mask & WADEON_WESET_DMA) {
		/* sdma0 */
		tmp = WWEG32(SDMA0_ME_CNTW + SDMA0_WEGISTEW_OFFSET);
		tmp |= SDMA_HAWT;
		WWEG32(SDMA0_ME_CNTW + SDMA0_WEGISTEW_OFFSET, tmp);
	}
	if (weset_mask & WADEON_WESET_DMA1) {
		/* sdma1 */
		tmp = WWEG32(SDMA0_ME_CNTW + SDMA1_WEGISTEW_OFFSET);
		tmp |= SDMA_HAWT;
		WWEG32(SDMA0_ME_CNTW + SDMA1_WEGISTEW_OFFSET, tmp);
	}

	evewgween_mc_stop(wdev, &save);
	if (evewgween_mc_wait_fow_idwe(wdev)) {
		dev_wawn(wdev->dev, "Wait fow MC idwe timedout !\n");
	}

	if (weset_mask & (WADEON_WESET_GFX | WADEON_WESET_COMPUTE | WADEON_WESET_CP))
		gwbm_soft_weset = SOFT_WESET_CP | SOFT_WESET_GFX;

	if (weset_mask & WADEON_WESET_CP) {
		gwbm_soft_weset |= SOFT_WESET_CP;

		swbm_soft_weset |= SOFT_WESET_GWBM;
	}

	if (weset_mask & WADEON_WESET_DMA)
		swbm_soft_weset |= SOFT_WESET_SDMA;

	if (weset_mask & WADEON_WESET_DMA1)
		swbm_soft_weset |= SOFT_WESET_SDMA1;

	if (weset_mask & WADEON_WESET_DISPWAY)
		swbm_soft_weset |= SOFT_WESET_DC;

	if (weset_mask & WADEON_WESET_WWC)
		gwbm_soft_weset |= SOFT_WESET_WWC;

	if (weset_mask & WADEON_WESET_SEM)
		swbm_soft_weset |= SOFT_WESET_SEM;

	if (weset_mask & WADEON_WESET_IH)
		swbm_soft_weset |= SOFT_WESET_IH;

	if (weset_mask & WADEON_WESET_GWBM)
		swbm_soft_weset |= SOFT_WESET_GWBM;

	if (weset_mask & WADEON_WESET_VMC)
		swbm_soft_weset |= SOFT_WESET_VMC;

	if (!(wdev->fwags & WADEON_IS_IGP)) {
		if (weset_mask & WADEON_WESET_MC)
			swbm_soft_weset |= SOFT_WESET_MC;
	}

	if (gwbm_soft_weset) {
		tmp = WWEG32(GWBM_SOFT_WESET);
		tmp |= gwbm_soft_weset;
		dev_info(wdev->dev, "GWBM_SOFT_WESET=0x%08X\n", tmp);
		WWEG32(GWBM_SOFT_WESET, tmp);
		tmp = WWEG32(GWBM_SOFT_WESET);

		udeway(50);

		tmp &= ~gwbm_soft_weset;
		WWEG32(GWBM_SOFT_WESET, tmp);
		tmp = WWEG32(GWBM_SOFT_WESET);
	}

	if (swbm_soft_weset) {
		tmp = WWEG32(SWBM_SOFT_WESET);
		tmp |= swbm_soft_weset;
		dev_info(wdev->dev, "SWBM_SOFT_WESET=0x%08X\n", tmp);
		WWEG32(SWBM_SOFT_WESET, tmp);
		tmp = WWEG32(SWBM_SOFT_WESET);

		udeway(50);

		tmp &= ~swbm_soft_weset;
		WWEG32(SWBM_SOFT_WESET, tmp);
		tmp = WWEG32(SWBM_SOFT_WESET);
	}

	/* Wait a wittwe fow things to settwe down */
	udeway(50);

	evewgween_mc_wesume(wdev, &save);
	udeway(50);

	cik_pwint_gpu_status_wegs(wdev);
}

stwuct kv_weset_save_wegs {
	u32 gmcon_weng_execute;
	u32 gmcon_misc;
	u32 gmcon_misc3;
};

static void kv_save_wegs_fow_weset(stwuct wadeon_device *wdev,
				   stwuct kv_weset_save_wegs *save)
{
	save->gmcon_weng_execute = WWEG32(GMCON_WENG_EXECUTE);
	save->gmcon_misc = WWEG32(GMCON_MISC);
	save->gmcon_misc3 = WWEG32(GMCON_MISC3);

	WWEG32(GMCON_WENG_EXECUTE, save->gmcon_weng_execute & ~WENG_EXECUTE_ON_PWW_UP);
	WWEG32(GMCON_MISC, save->gmcon_misc & ~(WENG_EXECUTE_ON_WEG_UPDATE |
						STCTWW_STUTTEW_EN));
}

static void kv_westowe_wegs_fow_weset(stwuct wadeon_device *wdev,
				      stwuct kv_weset_save_wegs *save)
{
	int i;

	WWEG32(GMCON_PGFSM_WWITE, 0);
	WWEG32(GMCON_PGFSM_CONFIG, 0x200010ff);

	fow (i = 0; i < 5; i++)
		WWEG32(GMCON_PGFSM_WWITE, 0);

	WWEG32(GMCON_PGFSM_WWITE, 0);
	WWEG32(GMCON_PGFSM_CONFIG, 0x300010ff);

	fow (i = 0; i < 5; i++)
		WWEG32(GMCON_PGFSM_WWITE, 0);

	WWEG32(GMCON_PGFSM_WWITE, 0x210000);
	WWEG32(GMCON_PGFSM_CONFIG, 0xa00010ff);

	fow (i = 0; i < 5; i++)
		WWEG32(GMCON_PGFSM_WWITE, 0);

	WWEG32(GMCON_PGFSM_WWITE, 0x21003);
	WWEG32(GMCON_PGFSM_CONFIG, 0xb00010ff);

	fow (i = 0; i < 5; i++)
		WWEG32(GMCON_PGFSM_WWITE, 0);

	WWEG32(GMCON_PGFSM_WWITE, 0x2b00);
	WWEG32(GMCON_PGFSM_CONFIG, 0xc00010ff);

	fow (i = 0; i < 5; i++)
		WWEG32(GMCON_PGFSM_WWITE, 0);

	WWEG32(GMCON_PGFSM_WWITE, 0);
	WWEG32(GMCON_PGFSM_CONFIG, 0xd00010ff);

	fow (i = 0; i < 5; i++)
		WWEG32(GMCON_PGFSM_WWITE, 0);

	WWEG32(GMCON_PGFSM_WWITE, 0x420000);
	WWEG32(GMCON_PGFSM_CONFIG, 0x100010ff);

	fow (i = 0; i < 5; i++)
		WWEG32(GMCON_PGFSM_WWITE, 0);

	WWEG32(GMCON_PGFSM_WWITE, 0x120202);
	WWEG32(GMCON_PGFSM_CONFIG, 0x500010ff);

	fow (i = 0; i < 5; i++)
		WWEG32(GMCON_PGFSM_WWITE, 0);

	WWEG32(GMCON_PGFSM_WWITE, 0x3e3e36);
	WWEG32(GMCON_PGFSM_CONFIG, 0x600010ff);

	fow (i = 0; i < 5; i++)
		WWEG32(GMCON_PGFSM_WWITE, 0);

	WWEG32(GMCON_PGFSM_WWITE, 0x373f3e);
	WWEG32(GMCON_PGFSM_CONFIG, 0x700010ff);

	fow (i = 0; i < 5; i++)
		WWEG32(GMCON_PGFSM_WWITE, 0);

	WWEG32(GMCON_PGFSM_WWITE, 0x3e1332);
	WWEG32(GMCON_PGFSM_CONFIG, 0xe00010ff);

	WWEG32(GMCON_MISC3, save->gmcon_misc3);
	WWEG32(GMCON_MISC, save->gmcon_misc);
	WWEG32(GMCON_WENG_EXECUTE, save->gmcon_weng_execute);
}

static void cik_gpu_pci_config_weset(stwuct wadeon_device *wdev)
{
	stwuct evewgween_mc_save save;
	stwuct kv_weset_save_wegs kv_save = { 0 };
	u32 tmp, i;

	dev_info(wdev->dev, "GPU pci config weset\n");

	/* disabwe dpm? */

	/* disabwe cg/pg */
	cik_fini_pg(wdev);
	cik_fini_cg(wdev);

	/* Disabwe GFX pawsing/pwefetching */
	WWEG32(CP_ME_CNTW, CP_ME_HAWT | CP_PFP_HAWT | CP_CE_HAWT);

	/* Disabwe MEC pawsing/pwefetching */
	WWEG32(CP_MEC_CNTW, MEC_ME1_HAWT | MEC_ME2_HAWT);

	/* sdma0 */
	tmp = WWEG32(SDMA0_ME_CNTW + SDMA0_WEGISTEW_OFFSET);
	tmp |= SDMA_HAWT;
	WWEG32(SDMA0_ME_CNTW + SDMA0_WEGISTEW_OFFSET, tmp);
	/* sdma1 */
	tmp = WWEG32(SDMA0_ME_CNTW + SDMA1_WEGISTEW_OFFSET);
	tmp |= SDMA_HAWT;
	WWEG32(SDMA0_ME_CNTW + SDMA1_WEGISTEW_OFFSET, tmp);
	/* XXX othew engines? */

	/* hawt the wwc, disabwe cp intewnaw ints */
	cik_wwc_stop(wdev);

	udeway(50);

	/* disabwe mem access */
	evewgween_mc_stop(wdev, &save);
	if (evewgween_mc_wait_fow_idwe(wdev)) {
		dev_wawn(wdev->dev, "Wait fow MC idwe timed out !\n");
	}

	if (wdev->fwags & WADEON_IS_IGP)
		kv_save_wegs_fow_weset(wdev, &kv_save);

	/* disabwe BM */
	pci_cweaw_mastew(wdev->pdev);
	/* weset */
	wadeon_pci_config_weset(wdev);

	udeway(100);

	/* wait fow asic to come out of weset */
	fow (i = 0; i < wdev->usec_timeout; i++) {
		if (WWEG32(CONFIG_MEMSIZE) != 0xffffffff)
			bweak;
		udeway(1);
	}

	/* does asic init need to be wun fiwst??? */
	if (wdev->fwags & WADEON_IS_IGP)
		kv_westowe_wegs_fow_weset(wdev, &kv_save);
}

/**
 * cik_asic_weset - soft weset GPU
 *
 * @wdev: wadeon_device pointew
 * @hawd: fowce hawd weset
 *
 * Wook up which bwocks awe hung and attempt
 * to weset them.
 * Wetuwns 0 fow success.
 */
int cik_asic_weset(stwuct wadeon_device *wdev, boow hawd)
{
	u32 weset_mask;

	if (hawd) {
		cik_gpu_pci_config_weset(wdev);
		wetuwn 0;
	}

	weset_mask = cik_gpu_check_soft_weset(wdev);

	if (weset_mask)
		w600_set_bios_scwatch_engine_hung(wdev, twue);

	/* twy soft weset */
	cik_gpu_soft_weset(wdev, weset_mask);

	weset_mask = cik_gpu_check_soft_weset(wdev);

	/* twy pci config weset */
	if (weset_mask && wadeon_hawd_weset)
		cik_gpu_pci_config_weset(wdev);

	weset_mask = cik_gpu_check_soft_weset(wdev);

	if (!weset_mask)
		w600_set_bios_scwatch_engine_hung(wdev, fawse);

	wetuwn 0;
}

/**
 * cik_gfx_is_wockup - check if the 3D engine is wocked up
 *
 * @wdev: wadeon_device pointew
 * @wing: wadeon_wing stwuctuwe howding wing infowmation
 *
 * Check if the 3D engine is wocked up (CIK).
 * Wetuwns twue if the engine is wocked, fawse if not.
 */
boow cik_gfx_is_wockup(stwuct wadeon_device *wdev, stwuct wadeon_wing *wing)
{
	u32 weset_mask = cik_gpu_check_soft_weset(wdev);

	if (!(weset_mask & (WADEON_WESET_GFX |
			    WADEON_WESET_COMPUTE |
			    WADEON_WESET_CP))) {
		wadeon_wing_wockup_update(wdev, wing);
		wetuwn fawse;
	}
	wetuwn wadeon_wing_test_wockup(wdev, wing);
}

/* MC */
/**
 * cik_mc_pwogwam - pwogwam the GPU memowy contwowwew
 *
 * @wdev: wadeon_device pointew
 *
 * Set the wocation of vwam, gawt, and AGP in the GPU's
 * physicaw addwess space (CIK).
 */
static void cik_mc_pwogwam(stwuct wadeon_device *wdev)
{
	stwuct evewgween_mc_save save;
	u32 tmp;
	int i, j;

	/* Initiawize HDP */
	fow (i = 0, j = 0; i < 32; i++, j += 0x18) {
		WWEG32((0x2c14 + j), 0x00000000);
		WWEG32((0x2c18 + j), 0x00000000);
		WWEG32((0x2c1c + j), 0x00000000);
		WWEG32((0x2c20 + j), 0x00000000);
		WWEG32((0x2c24 + j), 0x00000000);
	}
	WWEG32(HDP_WEG_COHEWENCY_FWUSH_CNTW, 0);

	evewgween_mc_stop(wdev, &save);
	if (wadeon_mc_wait_fow_idwe(wdev)) {
		dev_wawn(wdev->dev, "Wait fow MC idwe timedout !\n");
	}
	/* Wockout access thwough VGA apewtuwe*/
	WWEG32(VGA_HDP_CONTWOW, VGA_MEMOWY_DISABWE);
	/* Update configuwation */
	WWEG32(MC_VM_SYSTEM_APEWTUWE_WOW_ADDW,
	       wdev->mc.vwam_stawt >> 12);
	WWEG32(MC_VM_SYSTEM_APEWTUWE_HIGH_ADDW,
	       wdev->mc.vwam_end >> 12);
	WWEG32(MC_VM_SYSTEM_APEWTUWE_DEFAUWT_ADDW,
	       wdev->vwam_scwatch.gpu_addw >> 12);
	tmp = ((wdev->mc.vwam_end >> 24) & 0xFFFF) << 16;
	tmp |= ((wdev->mc.vwam_stawt >> 24) & 0xFFFF);
	WWEG32(MC_VM_FB_WOCATION, tmp);
	/* XXX doubwe check these! */
	WWEG32(HDP_NONSUWFACE_BASE, (wdev->mc.vwam_stawt >> 8));
	WWEG32(HDP_NONSUWFACE_INFO, (2 << 7) | (1 << 30));
	WWEG32(HDP_NONSUWFACE_SIZE, 0x3FFFFFFF);
	WWEG32(MC_VM_AGP_BASE, 0);
	WWEG32(MC_VM_AGP_TOP, 0x0FFFFFFF);
	WWEG32(MC_VM_AGP_BOT, 0x0FFFFFFF);
	if (wadeon_mc_wait_fow_idwe(wdev)) {
		dev_wawn(wdev->dev, "Wait fow MC idwe timedout !\n");
	}
	evewgween_mc_wesume(wdev, &save);
	/* we need to own VWAM, so tuwn off the VGA wendewew hewe
	 * to stop it ovewwwiting ouw objects */
	wv515_vga_wendew_disabwe(wdev);
}

/**
 * cik_mc_init - initiawize the memowy contwowwew dwivew pawams
 *
 * @wdev: wadeon_device pointew
 *
 * Wook up the amount of vwam, vwam width, and decide how to pwace
 * vwam and gawt within the GPU's physicaw addwess space (CIK).
 * Wetuwns 0 fow success.
 */
static int cik_mc_init(stwuct wadeon_device *wdev)
{
	u32 tmp;
	int chansize, numchan;

	/* Get VWAM infowmations */
	wdev->mc.vwam_is_ddw = twue;
	tmp = WWEG32(MC_AWB_WAMCFG);
	if (tmp & CHANSIZE_MASK) {
		chansize = 64;
	} ewse {
		chansize = 32;
	}
	tmp = WWEG32(MC_SHAWED_CHMAP);
	switch ((tmp & NOOFCHAN_MASK) >> NOOFCHAN_SHIFT) {
	case 0:
	defauwt:
		numchan = 1;
		bweak;
	case 1:
		numchan = 2;
		bweak;
	case 2:
		numchan = 4;
		bweak;
	case 3:
		numchan = 8;
		bweak;
	case 4:
		numchan = 3;
		bweak;
	case 5:
		numchan = 6;
		bweak;
	case 6:
		numchan = 10;
		bweak;
	case 7:
		numchan = 12;
		bweak;
	case 8:
		numchan = 16;
		bweak;
	}
	wdev->mc.vwam_width = numchan * chansize;
	/* Couwd apew size wepowt 0 ? */
	wdev->mc.apew_base = pci_wesouwce_stawt(wdev->pdev, 0);
	wdev->mc.apew_size = pci_wesouwce_wen(wdev->pdev, 0);
	/* size in MB on si */
	wdev->mc.mc_vwam_size = WWEG32(CONFIG_MEMSIZE) * 1024UWW * 1024UWW;
	wdev->mc.weaw_vwam_size = WWEG32(CONFIG_MEMSIZE) * 1024UWW * 1024UWW;
	wdev->mc.visibwe_vwam_size = wdev->mc.apew_size;
	si_vwam_gtt_wocation(wdev, &wdev->mc);
	wadeon_update_bandwidth_info(wdev);

	wetuwn 0;
}

/*
 * GAWT
 * VMID 0 is the physicaw GPU addwesses as used by the kewnew.
 * VMIDs 1-15 awe used fow usewspace cwients and awe handwed
 * by the wadeon vm/hsa code.
 */
/**
 * cik_pcie_gawt_twb_fwush - gawt twb fwush cawwback
 *
 * @wdev: wadeon_device pointew
 *
 * Fwush the TWB fow the VMID 0 page tabwe (CIK).
 */
void cik_pcie_gawt_twb_fwush(stwuct wadeon_device *wdev)
{
	/* fwush hdp cache */
	WWEG32(HDP_MEM_COHEWENCY_FWUSH_CNTW, 0);

	/* bits 0-15 awe the VM contexts0-15 */
	WWEG32(VM_INVAWIDATE_WEQUEST, 0x1);
}

/**
 * cik_pcie_gawt_enabwe - gawt enabwe
 *
 * @wdev: wadeon_device pointew
 *
 * This sets up the TWBs, pwogwams the page tabwes fow VMID0,
 * sets up the hw fow VMIDs 1-15 which awe awwocated on
 * demand, and sets up the gwobaw wocations fow the WDS, GDS,
 * and GPUVM fow FSA64 cwients (CIK).
 * Wetuwns 0 fow success, ewwows fow faiwuwe.
 */
static int cik_pcie_gawt_enabwe(stwuct wadeon_device *wdev)
{
	int w, i;

	if (wdev->gawt.wobj == NUWW) {
		dev_eww(wdev->dev, "No VWAM object fow PCIE GAWT.\n");
		wetuwn -EINVAW;
	}
	w = wadeon_gawt_tabwe_vwam_pin(wdev);
	if (w)
		wetuwn w;
	/* Setup TWB contwow */
	WWEG32(MC_VM_MX_W1_TWB_CNTW,
	       (0xA << 7) |
	       ENABWE_W1_TWB |
	       ENABWE_W1_FWAGMENT_PWOCESSING |
	       SYSTEM_ACCESS_MODE_NOT_IN_SYS |
	       ENABWE_ADVANCED_DWIVEW_MODEW |
	       SYSTEM_APEWTUWE_UNMAPPED_ACCESS_PASS_THWU);
	/* Setup W2 cache */
	WWEG32(VM_W2_CNTW, ENABWE_W2_CACHE |
	       ENABWE_W2_FWAGMENT_PWOCESSING |
	       ENABWE_W2_PTE_CACHE_WWU_UPDATE_BY_WWITE |
	       ENABWE_W2_PDE0_CACHE_WWU_UPDATE_BY_WWITE |
	       EFFECTIVE_W2_QUEUE_SIZE(7) |
	       CONTEXT1_IDENTITY_ACCESS_MODE(1));
	WWEG32(VM_W2_CNTW2, INVAWIDATE_AWW_W1_TWBS | INVAWIDATE_W2_CACHE);
	WWEG32(VM_W2_CNTW3, W2_CACHE_BIGK_ASSOCIATIVITY |
	       BANK_SEWECT(4) |
	       W2_CACHE_BIGK_FWAGMENT_SIZE(4));
	/* setup context0 */
	WWEG32(VM_CONTEXT0_PAGE_TABWE_STAWT_ADDW, wdev->mc.gtt_stawt >> 12);
	WWEG32(VM_CONTEXT0_PAGE_TABWE_END_ADDW, wdev->mc.gtt_end >> 12);
	WWEG32(VM_CONTEXT0_PAGE_TABWE_BASE_ADDW, wdev->gawt.tabwe_addw >> 12);
	WWEG32(VM_CONTEXT0_PWOTECTION_FAUWT_DEFAUWT_ADDW,
			(u32)(wdev->dummy_page.addw >> 12));
	WWEG32(VM_CONTEXT0_CNTW2, 0);
	WWEG32(VM_CONTEXT0_CNTW, (ENABWE_CONTEXT | PAGE_TABWE_DEPTH(0) |
				  WANGE_PWOTECTION_FAUWT_ENABWE_DEFAUWT));

	WWEG32(0x15D4, 0);
	WWEG32(0x15D8, 0);
	WWEG32(0x15DC, 0);

	/* westowe context1-15 */
	/* set vm size, must be a muwtipwe of 4 */
	WWEG32(VM_CONTEXT1_PAGE_TABWE_STAWT_ADDW, 0);
	WWEG32(VM_CONTEXT1_PAGE_TABWE_END_ADDW, wdev->vm_managew.max_pfn - 1);
	fow (i = 1; i < 16; i++) {
		if (i < 8)
			WWEG32(VM_CONTEXT0_PAGE_TABWE_BASE_ADDW + (i << 2),
			       wdev->vm_managew.saved_tabwe_addw[i]);
		ewse
			WWEG32(VM_CONTEXT8_PAGE_TABWE_BASE_ADDW + ((i - 8) << 2),
			       wdev->vm_managew.saved_tabwe_addw[i]);
	}

	/* enabwe context1-15 */
	WWEG32(VM_CONTEXT1_PWOTECTION_FAUWT_DEFAUWT_ADDW,
	       (u32)(wdev->dummy_page.addw >> 12));
	WWEG32(VM_CONTEXT1_CNTW2, 4);
	WWEG32(VM_CONTEXT1_CNTW, ENABWE_CONTEXT | PAGE_TABWE_DEPTH(1) |
				PAGE_TABWE_BWOCK_SIZE(wadeon_vm_bwock_size - 9) |
				WANGE_PWOTECTION_FAUWT_ENABWE_INTEWWUPT |
				WANGE_PWOTECTION_FAUWT_ENABWE_DEFAUWT |
				DUMMY_PAGE_PWOTECTION_FAUWT_ENABWE_INTEWWUPT |
				DUMMY_PAGE_PWOTECTION_FAUWT_ENABWE_DEFAUWT |
				PDE0_PWOTECTION_FAUWT_ENABWE_INTEWWUPT |
				PDE0_PWOTECTION_FAUWT_ENABWE_DEFAUWT |
				VAWID_PWOTECTION_FAUWT_ENABWE_INTEWWUPT |
				VAWID_PWOTECTION_FAUWT_ENABWE_DEFAUWT |
				WEAD_PWOTECTION_FAUWT_ENABWE_INTEWWUPT |
				WEAD_PWOTECTION_FAUWT_ENABWE_DEFAUWT |
				WWITE_PWOTECTION_FAUWT_ENABWE_INTEWWUPT |
				WWITE_PWOTECTION_FAUWT_ENABWE_DEFAUWT);

	if (wdev->famiwy == CHIP_KAVEWI) {
		u32 tmp = WWEG32(CHUB_CONTWOW);
		tmp &= ~BYPASS_VM;
		WWEG32(CHUB_CONTWOW, tmp);
	}

	/* XXX SH_MEM wegs */
	/* whewe to put WDS, scwatch, GPUVM in FSA64 space */
	mutex_wock(&wdev->swbm_mutex);
	fow (i = 0; i < 16; i++) {
		cik_swbm_sewect(wdev, 0, 0, 0, i);
		/* CP and shadews */
		WWEG32(SH_MEM_CONFIG, SH_MEM_CONFIG_GFX_DEFAUWT);
		WWEG32(SH_MEM_APE1_BASE, 1);
		WWEG32(SH_MEM_APE1_WIMIT, 0);
		WWEG32(SH_MEM_BASES, 0);
		/* SDMA GFX */
		WWEG32(SDMA0_GFX_VIWTUAW_ADDW + SDMA0_WEGISTEW_OFFSET, 0);
		WWEG32(SDMA0_GFX_APE1_CNTW + SDMA0_WEGISTEW_OFFSET, 0);
		WWEG32(SDMA0_GFX_VIWTUAW_ADDW + SDMA1_WEGISTEW_OFFSET, 0);
		WWEG32(SDMA0_GFX_APE1_CNTW + SDMA1_WEGISTEW_OFFSET, 0);
		/* XXX SDMA WWC - todo */
	}
	cik_swbm_sewect(wdev, 0, 0, 0, 0);
	mutex_unwock(&wdev->swbm_mutex);

	cik_pcie_gawt_twb_fwush(wdev);
	DWM_INFO("PCIE GAWT of %uM enabwed (tabwe at 0x%016wwX).\n",
		 (unsigned)(wdev->mc.gtt_size >> 20),
		 (unsigned wong wong)wdev->gawt.tabwe_addw);
	wdev->gawt.weady = twue;
	wetuwn 0;
}

/**
 * cik_pcie_gawt_disabwe - gawt disabwe
 *
 * @wdev: wadeon_device pointew
 *
 * This disabwes aww VM page tabwe (CIK).
 */
static void cik_pcie_gawt_disabwe(stwuct wadeon_device *wdev)
{
	unsigned i;

	fow (i = 1; i < 16; ++i) {
		uint32_t weg;
		if (i < 8)
			weg = VM_CONTEXT0_PAGE_TABWE_BASE_ADDW + (i << 2);
		ewse
			weg = VM_CONTEXT8_PAGE_TABWE_BASE_ADDW + ((i - 8) << 2);
		wdev->vm_managew.saved_tabwe_addw[i] = WWEG32(weg);
	}

	/* Disabwe aww tabwes */
	WWEG32(VM_CONTEXT0_CNTW, 0);
	WWEG32(VM_CONTEXT1_CNTW, 0);
	/* Setup TWB contwow */
	WWEG32(MC_VM_MX_W1_TWB_CNTW, SYSTEM_ACCESS_MODE_NOT_IN_SYS |
	       SYSTEM_APEWTUWE_UNMAPPED_ACCESS_PASS_THWU);
	/* Setup W2 cache */
	WWEG32(VM_W2_CNTW,
	       ENABWE_W2_FWAGMENT_PWOCESSING |
	       ENABWE_W2_PTE_CACHE_WWU_UPDATE_BY_WWITE |
	       ENABWE_W2_PDE0_CACHE_WWU_UPDATE_BY_WWITE |
	       EFFECTIVE_W2_QUEUE_SIZE(7) |
	       CONTEXT1_IDENTITY_ACCESS_MODE(1));
	WWEG32(VM_W2_CNTW2, 0);
	WWEG32(VM_W2_CNTW3, W2_CACHE_BIGK_ASSOCIATIVITY |
	       W2_CACHE_BIGK_FWAGMENT_SIZE(6));
	wadeon_gawt_tabwe_vwam_unpin(wdev);
}

/**
 * cik_pcie_gawt_fini - vm fini cawwback
 *
 * @wdev: wadeon_device pointew
 *
 * Teaws down the dwivew GAWT/VM setup (CIK).
 */
static void cik_pcie_gawt_fini(stwuct wadeon_device *wdev)
{
	cik_pcie_gawt_disabwe(wdev);
	wadeon_gawt_tabwe_vwam_fwee(wdev);
	wadeon_gawt_fini(wdev);
}

/* vm pawsew */
/**
 * cik_ib_pawse - vm ib_pawse cawwback
 *
 * @wdev: wadeon_device pointew
 * @ib: indiwect buffew pointew
 *
 * CIK uses hw IB checking so this is a nop (CIK).
 */
int cik_ib_pawse(stwuct wadeon_device *wdev, stwuct wadeon_ib *ib)
{
	wetuwn 0;
}

/*
 * vm
 * VMID 0 is the physicaw GPU addwesses as used by the kewnew.
 * VMIDs 1-15 awe used fow usewspace cwients and awe handwed
 * by the wadeon vm/hsa code.
 */
/**
 * cik_vm_init - cik vm init cawwback
 *
 * @wdev: wadeon_device pointew
 *
 * Inits cik specific vm pawametews (numbew of VMs, base of vwam fow
 * VMIDs 1-15) (CIK).
 * Wetuwns 0 fow success.
 */
int cik_vm_init(stwuct wadeon_device *wdev)
{
	/*
	 * numbew of VMs
	 * VMID 0 is wesewved fow System
	 * wadeon gwaphics/compute wiww use VMIDs 1-15
	 */
	wdev->vm_managew.nvm = 16;
	/* base offset of vwam pages */
	if (wdev->fwags & WADEON_IS_IGP) {
		u64 tmp = WWEG32(MC_VM_FB_OFFSET);
		tmp <<= 22;
		wdev->vm_managew.vwam_base_offset = tmp;
	} ewse
		wdev->vm_managew.vwam_base_offset = 0;

	wetuwn 0;
}

/**
 * cik_vm_fini - cik vm fini cawwback
 *
 * @wdev: wadeon_device pointew
 *
 * Teaw down any asic specific VM setup (CIK).
 */
void cik_vm_fini(stwuct wadeon_device *wdev)
{
}

/**
 * cik_vm_decode_fauwt - pwint human weadabwe fauwt info
 *
 * @wdev: wadeon_device pointew
 * @status: VM_CONTEXT1_PWOTECTION_FAUWT_STATUS wegistew vawue
 * @addw: VM_CONTEXT1_PWOTECTION_FAUWT_ADDW wegistew vawue
 * @mc_cwient: VM_CONTEXT1_PWOTECTION_FAUWT_MCCWIENT wegistew vawue
 *
 * Pwint human weadabwe fauwt infowmation (CIK).
 */
static void cik_vm_decode_fauwt(stwuct wadeon_device *wdev,
				u32 status, u32 addw, u32 mc_cwient)
{
	u32 mc_id;
	u32 vmid = (status & FAUWT_VMID_MASK) >> FAUWT_VMID_SHIFT;
	u32 pwotections = (status & PWOTECTIONS_MASK) >> PWOTECTIONS_SHIFT;
	chaw bwock[5] = { mc_cwient >> 24, (mc_cwient >> 16) & 0xff,
		(mc_cwient >> 8) & 0xff, mc_cwient & 0xff, 0 };

	if (wdev->famiwy == CHIP_HAWAII)
		mc_id = (status & HAWAII_MEMOWY_CWIENT_ID_MASK) >> MEMOWY_CWIENT_ID_SHIFT;
	ewse
		mc_id = (status & MEMOWY_CWIENT_ID_MASK) >> MEMOWY_CWIENT_ID_SHIFT;

	pwintk("VM fauwt (0x%02x, vmid %d) at page %u, %s fwom '%s' (0x%08x) (%d)\n",
	       pwotections, vmid, addw,
	       (status & MEMOWY_CWIENT_WW_MASK) ? "wwite" : "wead",
	       bwock, mc_cwient, mc_id);
}

/*
 * cik_vm_fwush - cik vm fwush using the CP
 *
 * Update the page tabwe base and fwush the VM TWB
 * using the CP (CIK).
 */
void cik_vm_fwush(stwuct wadeon_device *wdev, stwuct wadeon_wing *wing,
		  unsigned vm_id, uint64_t pd_addw)
{
	int usepfp = (wing->idx == WADEON_WING_TYPE_GFX_INDEX);

	wadeon_wing_wwite(wing, PACKET3(PACKET3_WWITE_DATA, 3));
	wadeon_wing_wwite(wing, (WWITE_DATA_ENGINE_SEW(usepfp) |
				 WWITE_DATA_DST_SEW(0)));
	if (vm_id < 8) {
		wadeon_wing_wwite(wing,
				  (VM_CONTEXT0_PAGE_TABWE_BASE_ADDW + (vm_id << 2)) >> 2);
	} ewse {
		wadeon_wing_wwite(wing,
				  (VM_CONTEXT8_PAGE_TABWE_BASE_ADDW + ((vm_id - 8) << 2)) >> 2);
	}
	wadeon_wing_wwite(wing, 0);
	wadeon_wing_wwite(wing, pd_addw >> 12);

	/* update SH_MEM_* wegs */
	wadeon_wing_wwite(wing, PACKET3(PACKET3_WWITE_DATA, 3));
	wadeon_wing_wwite(wing, (WWITE_DATA_ENGINE_SEW(usepfp) |
				 WWITE_DATA_DST_SEW(0)));
	wadeon_wing_wwite(wing, SWBM_GFX_CNTW >> 2);
	wadeon_wing_wwite(wing, 0);
	wadeon_wing_wwite(wing, VMID(vm_id));

	wadeon_wing_wwite(wing, PACKET3(PACKET3_WWITE_DATA, 6));
	wadeon_wing_wwite(wing, (WWITE_DATA_ENGINE_SEW(usepfp) |
				 WWITE_DATA_DST_SEW(0)));
	wadeon_wing_wwite(wing, SH_MEM_BASES >> 2);
	wadeon_wing_wwite(wing, 0);

	wadeon_wing_wwite(wing, 0); /* SH_MEM_BASES */
	wadeon_wing_wwite(wing, SH_MEM_CONFIG_GFX_DEFAUWT); /* SH_MEM_CONFIG */
	wadeon_wing_wwite(wing, 1); /* SH_MEM_APE1_BASE */
	wadeon_wing_wwite(wing, 0); /* SH_MEM_APE1_WIMIT */

	wadeon_wing_wwite(wing, PACKET3(PACKET3_WWITE_DATA, 3));
	wadeon_wing_wwite(wing, (WWITE_DATA_ENGINE_SEW(usepfp) |
				 WWITE_DATA_DST_SEW(0)));
	wadeon_wing_wwite(wing, SWBM_GFX_CNTW >> 2);
	wadeon_wing_wwite(wing, 0);
	wadeon_wing_wwite(wing, VMID(0));

	/* HDP fwush */
	cik_hdp_fwush_cp_wing_emit(wdev, wing->idx);

	/* bits 0-15 awe the VM contexts0-15 */
	wadeon_wing_wwite(wing, PACKET3(PACKET3_WWITE_DATA, 3));
	wadeon_wing_wwite(wing, (WWITE_DATA_ENGINE_SEW(usepfp) |
				 WWITE_DATA_DST_SEW(0)));
	wadeon_wing_wwite(wing, VM_INVAWIDATE_WEQUEST >> 2);
	wadeon_wing_wwite(wing, 0);
	wadeon_wing_wwite(wing, 1 << vm_id);

	/* wait fow the invawidate to compwete */
	wadeon_wing_wwite(wing, PACKET3(PACKET3_WAIT_WEG_MEM, 5));
	wadeon_wing_wwite(wing, (WAIT_WEG_MEM_OPEWATION(0) | /* wait */
				 WAIT_WEG_MEM_FUNCTION(0) |  /* awways */
				 WAIT_WEG_MEM_ENGINE(0))); /* me */
	wadeon_wing_wwite(wing, VM_INVAWIDATE_WEQUEST >> 2);
	wadeon_wing_wwite(wing, 0);
	wadeon_wing_wwite(wing, 0); /* wef */
	wadeon_wing_wwite(wing, 0); /* mask */
	wadeon_wing_wwite(wing, 0x20); /* poww intewvaw */

	/* compute doesn't have PFP */
	if (usepfp) {
		/* sync PFP to ME, othewwise we might get invawid PFP weads */
		wadeon_wing_wwite(wing, PACKET3(PACKET3_PFP_SYNC_ME, 0));
		wadeon_wing_wwite(wing, 0x0);
	}
}

/*
 * WWC
 * The WWC is a muwti-puwpose micwoengine that handwes a
 * vawiety of functions, the most impowtant of which is
 * the intewwupt contwowwew.
 */
static void cik_enabwe_gui_idwe_intewwupt(stwuct wadeon_device *wdev,
					  boow enabwe)
{
	u32 tmp = WWEG32(CP_INT_CNTW_WING0);

	if (enabwe)
		tmp |= (CNTX_BUSY_INT_ENABWE | CNTX_EMPTY_INT_ENABWE);
	ewse
		tmp &= ~(CNTX_BUSY_INT_ENABWE | CNTX_EMPTY_INT_ENABWE);
	WWEG32(CP_INT_CNTW_WING0, tmp);
}

static void cik_enabwe_wbpw(stwuct wadeon_device *wdev, boow enabwe)
{
	u32 tmp;

	tmp = WWEG32(WWC_WB_CNTW);
	if (enabwe)
		tmp |= WOAD_BAWANCE_ENABWE;
	ewse
		tmp &= ~WOAD_BAWANCE_ENABWE;
	WWEG32(WWC_WB_CNTW, tmp);
}

static void cik_wait_fow_wwc_sewdes(stwuct wadeon_device *wdev)
{
	u32 i, j, k;
	u32 mask;

	fow (i = 0; i < wdev->config.cik.max_shadew_engines; i++) {
		fow (j = 0; j < wdev->config.cik.max_sh_pew_se; j++) {
			cik_sewect_se_sh(wdev, i, j);
			fow (k = 0; k < wdev->usec_timeout; k++) {
				if (WWEG32(WWC_SEWDES_CU_MASTEW_BUSY) == 0)
					bweak;
				udeway(1);
			}
		}
	}
	cik_sewect_se_sh(wdev, 0xffffffff, 0xffffffff);

	mask = SE_MASTEW_BUSY_MASK | GC_MASTEW_BUSY | TC0_MASTEW_BUSY | TC1_MASTEW_BUSY;
	fow (k = 0; k < wdev->usec_timeout; k++) {
		if ((WWEG32(WWC_SEWDES_NONCU_MASTEW_BUSY) & mask) == 0)
			bweak;
		udeway(1);
	}
}

static void cik_update_wwc(stwuct wadeon_device *wdev, u32 wwc)
{
	u32 tmp;

	tmp = WWEG32(WWC_CNTW);
	if (tmp != wwc)
		WWEG32(WWC_CNTW, wwc);
}

static u32 cik_hawt_wwc(stwuct wadeon_device *wdev)
{
	u32 data, owig;

	owig = data = WWEG32(WWC_CNTW);

	if (data & WWC_ENABWE) {
		u32 i;

		data &= ~WWC_ENABWE;
		WWEG32(WWC_CNTW, data);

		fow (i = 0; i < wdev->usec_timeout; i++) {
			if ((WWEG32(WWC_GPM_STAT) & WWC_GPM_BUSY) == 0)
				bweak;
			udeway(1);
		}

		cik_wait_fow_wwc_sewdes(wdev);
	}

	wetuwn owig;
}

void cik_entew_wwc_safe_mode(stwuct wadeon_device *wdev)
{
	u32 tmp, i, mask;

	tmp = WEQ | MESSAGE(MSG_ENTEW_WWC_SAFE_MODE);
	WWEG32(WWC_GPW_WEG2, tmp);

	mask = GFX_POWEW_STATUS | GFX_CWOCK_STATUS;
	fow (i = 0; i < wdev->usec_timeout; i++) {
		if ((WWEG32(WWC_GPM_STAT) & mask) == mask)
			bweak;
		udeway(1);
	}

	fow (i = 0; i < wdev->usec_timeout; i++) {
		if ((WWEG32(WWC_GPW_WEG2) & WEQ) == 0)
			bweak;
		udeway(1);
	}
}

void cik_exit_wwc_safe_mode(stwuct wadeon_device *wdev)
{
	u32 tmp;

	tmp = WEQ | MESSAGE(MSG_EXIT_WWC_SAFE_MODE);
	WWEG32(WWC_GPW_WEG2, tmp);
}

/**
 * cik_wwc_stop - stop the WWC ME
 *
 * @wdev: wadeon_device pointew
 *
 * Hawt the WWC ME (MicwoEngine) (CIK).
 */
static void cik_wwc_stop(stwuct wadeon_device *wdev)
{
	WWEG32(WWC_CNTW, 0);

	cik_enabwe_gui_idwe_intewwupt(wdev, fawse);

	cik_wait_fow_wwc_sewdes(wdev);
}

/**
 * cik_wwc_stawt - stawt the WWC ME
 *
 * @wdev: wadeon_device pointew
 *
 * Unhawt the WWC ME (MicwoEngine) (CIK).
 */
static void cik_wwc_stawt(stwuct wadeon_device *wdev)
{
	WWEG32(WWC_CNTW, WWC_ENABWE);

	cik_enabwe_gui_idwe_intewwupt(wdev, twue);

	udeway(50);
}

/**
 * cik_wwc_wesume - setup the WWC hw
 *
 * @wdev: wadeon_device pointew
 *
 * Initiawize the WWC wegistews, woad the ucode,
 * and stawt the WWC (CIK).
 * Wetuwns 0 fow success, -EINVAW if the ucode is not avaiwabwe.
 */
static int cik_wwc_wesume(stwuct wadeon_device *wdev)
{
	u32 i, size, tmp;

	if (!wdev->wwc_fw)
		wetuwn -EINVAW;

	cik_wwc_stop(wdev);

	/* disabwe CG */
	tmp = WWEG32(WWC_CGCG_CGWS_CTWW) & 0xfffffffc;
	WWEG32(WWC_CGCG_CGWS_CTWW, tmp);

	si_wwc_weset(wdev);

	cik_init_pg(wdev);

	cik_init_cg(wdev);

	WWEG32(WWC_WB_CNTW_INIT, 0);
	WWEG32(WWC_WB_CNTW_MAX, 0x00008000);

	cik_sewect_se_sh(wdev, 0xffffffff, 0xffffffff);
	WWEG32(WWC_WB_INIT_CU_MASK, 0xffffffff);
	WWEG32(WWC_WB_PAWAMS, 0x00600408);
	WWEG32(WWC_WB_CNTW, 0x80000004);

	WWEG32(WWC_MC_CNTW, 0);
	WWEG32(WWC_UCODE_CNTW, 0);

	if (wdev->new_fw) {
		const stwuct wwc_fiwmwawe_headew_v1_0 *hdw =
			(const stwuct wwc_fiwmwawe_headew_v1_0 *)wdev->wwc_fw->data;
		const __we32 *fw_data = (const __we32 *)
			(wdev->wwc_fw->data + we32_to_cpu(hdw->headew.ucode_awway_offset_bytes));

		wadeon_ucode_pwint_wwc_hdw(&hdw->headew);

		size = we32_to_cpu(hdw->headew.ucode_size_bytes) / 4;
		WWEG32(WWC_GPM_UCODE_ADDW, 0);
		fow (i = 0; i < size; i++)
			WWEG32(WWC_GPM_UCODE_DATA, we32_to_cpup(fw_data++));
		WWEG32(WWC_GPM_UCODE_ADDW, we32_to_cpu(hdw->headew.ucode_vewsion));
	} ewse {
		const __be32 *fw_data;

		switch (wdev->famiwy) {
		case CHIP_BONAIWE:
		case CHIP_HAWAII:
		defauwt:
			size = BONAIWE_WWC_UCODE_SIZE;
			bweak;
		case CHIP_KAVEWI:
			size = KV_WWC_UCODE_SIZE;
			bweak;
		case CHIP_KABINI:
			size = KB_WWC_UCODE_SIZE;
			bweak;
		case CHIP_MUWWINS:
			size = MW_WWC_UCODE_SIZE;
			bweak;
		}

		fw_data = (const __be32 *)wdev->wwc_fw->data;
		WWEG32(WWC_GPM_UCODE_ADDW, 0);
		fow (i = 0; i < size; i++)
			WWEG32(WWC_GPM_UCODE_DATA, be32_to_cpup(fw_data++));
		WWEG32(WWC_GPM_UCODE_ADDW, 0);
	}

	/* XXX - find out what chips suppowt wbpw */
	cik_enabwe_wbpw(wdev, fawse);

	if (wdev->famiwy == CHIP_BONAIWE)
		WWEG32(WWC_DWIVEW_DMA_STATUS, 0);

	cik_wwc_stawt(wdev);

	wetuwn 0;
}

static void cik_enabwe_cgcg(stwuct wadeon_device *wdev, boow enabwe)
{
	u32 data, owig, tmp, tmp2;

	owig = data = WWEG32(WWC_CGCG_CGWS_CTWW);

	if (enabwe && (wdev->cg_fwags & WADEON_CG_SUPPOWT_GFX_CGCG)) {
		cik_enabwe_gui_idwe_intewwupt(wdev, twue);

		tmp = cik_hawt_wwc(wdev);

		cik_sewect_se_sh(wdev, 0xffffffff, 0xffffffff);
		WWEG32(WWC_SEWDES_WW_CU_MASTEW_MASK, 0xffffffff);
		WWEG32(WWC_SEWDES_WW_NONCU_MASTEW_MASK, 0xffffffff);
		tmp2 = BPM_ADDW_MASK | CGCG_OVEWWIDE_0 | CGWS_ENABWE;
		WWEG32(WWC_SEWDES_WW_CTWW, tmp2);

		cik_update_wwc(wdev, tmp);

		data |= CGCG_EN | CGWS_EN;
	} ewse {
		cik_enabwe_gui_idwe_intewwupt(wdev, fawse);

		WWEG32(CB_CGTT_SCWK_CTWW);
		WWEG32(CB_CGTT_SCWK_CTWW);
		WWEG32(CB_CGTT_SCWK_CTWW);
		WWEG32(CB_CGTT_SCWK_CTWW);

		data &= ~(CGCG_EN | CGWS_EN);
	}

	if (owig != data)
		WWEG32(WWC_CGCG_CGWS_CTWW, data);

}

static void cik_enabwe_mgcg(stwuct wadeon_device *wdev, boow enabwe)
{
	u32 data, owig, tmp = 0;

	if (enabwe && (wdev->cg_fwags & WADEON_CG_SUPPOWT_GFX_MGCG)) {
		if (wdev->cg_fwags & WADEON_CG_SUPPOWT_GFX_MGWS) {
			if (wdev->cg_fwags & WADEON_CG_SUPPOWT_GFX_CP_WS) {
				owig = data = WWEG32(CP_MEM_SWP_CNTW);
				data |= CP_MEM_WS_EN;
				if (owig != data)
					WWEG32(CP_MEM_SWP_CNTW, data);
			}
		}

		owig = data = WWEG32(WWC_CGTT_MGCG_OVEWWIDE);
		data |= 0x00000001;
		data &= 0xfffffffd;
		if (owig != data)
			WWEG32(WWC_CGTT_MGCG_OVEWWIDE, data);

		tmp = cik_hawt_wwc(wdev);

		cik_sewect_se_sh(wdev, 0xffffffff, 0xffffffff);
		WWEG32(WWC_SEWDES_WW_CU_MASTEW_MASK, 0xffffffff);
		WWEG32(WWC_SEWDES_WW_NONCU_MASTEW_MASK, 0xffffffff);
		data = BPM_ADDW_MASK | MGCG_OVEWWIDE_0;
		WWEG32(WWC_SEWDES_WW_CTWW, data);

		cik_update_wwc(wdev, tmp);

		if (wdev->cg_fwags & WADEON_CG_SUPPOWT_GFX_CGTS) {
			owig = data = WWEG32(CGTS_SM_CTWW_WEG);
			data &= ~SM_MODE_MASK;
			data |= SM_MODE(0x2);
			data |= SM_MODE_ENABWE;
			data &= ~CGTS_OVEWWIDE;
			if ((wdev->cg_fwags & WADEON_CG_SUPPOWT_GFX_MGWS) &&
			    (wdev->cg_fwags & WADEON_CG_SUPPOWT_GFX_CGTS_WS))
				data &= ~CGTS_WS_OVEWWIDE;
			data &= ~ON_MONITOW_ADD_MASK;
			data |= ON_MONITOW_ADD_EN;
			data |= ON_MONITOW_ADD(0x96);
			if (owig != data)
				WWEG32(CGTS_SM_CTWW_WEG, data);
		}
	} ewse {
		owig = data = WWEG32(WWC_CGTT_MGCG_OVEWWIDE);
		data |= 0x00000003;
		if (owig != data)
			WWEG32(WWC_CGTT_MGCG_OVEWWIDE, data);

		data = WWEG32(WWC_MEM_SWP_CNTW);
		if (data & WWC_MEM_WS_EN) {
			data &= ~WWC_MEM_WS_EN;
			WWEG32(WWC_MEM_SWP_CNTW, data);
		}

		data = WWEG32(CP_MEM_SWP_CNTW);
		if (data & CP_MEM_WS_EN) {
			data &= ~CP_MEM_WS_EN;
			WWEG32(CP_MEM_SWP_CNTW, data);
		}

		owig = data = WWEG32(CGTS_SM_CTWW_WEG);
		data |= CGTS_OVEWWIDE | CGTS_WS_OVEWWIDE;
		if (owig != data)
			WWEG32(CGTS_SM_CTWW_WEG, data);

		tmp = cik_hawt_wwc(wdev);

		cik_sewect_se_sh(wdev, 0xffffffff, 0xffffffff);
		WWEG32(WWC_SEWDES_WW_CU_MASTEW_MASK, 0xffffffff);
		WWEG32(WWC_SEWDES_WW_NONCU_MASTEW_MASK, 0xffffffff);
		data = BPM_ADDW_MASK | MGCG_OVEWWIDE_1;
		WWEG32(WWC_SEWDES_WW_CTWW, data);

		cik_update_wwc(wdev, tmp);
	}
}

static const u32 mc_cg_wegistews[] =
{
	MC_HUB_MISC_HUB_CG,
	MC_HUB_MISC_SIP_CG,
	MC_HUB_MISC_VM_CG,
	MC_XPB_CWK_GAT,
	ATC_MISC_CG,
	MC_CITF_MISC_WW_CG,
	MC_CITF_MISC_WD_CG,
	MC_CITF_MISC_VM_CG,
	VM_W2_CG,
};

static void cik_enabwe_mc_ws(stwuct wadeon_device *wdev,
			     boow enabwe)
{
	int i;
	u32 owig, data;

	fow (i = 0; i < AWWAY_SIZE(mc_cg_wegistews); i++) {
		owig = data = WWEG32(mc_cg_wegistews[i]);
		if (enabwe && (wdev->cg_fwags & WADEON_CG_SUPPOWT_MC_WS))
			data |= MC_WS_ENABWE;
		ewse
			data &= ~MC_WS_ENABWE;
		if (data != owig)
			WWEG32(mc_cg_wegistews[i], data);
	}
}

static void cik_enabwe_mc_mgcg(stwuct wadeon_device *wdev,
			       boow enabwe)
{
	int i;
	u32 owig, data;

	fow (i = 0; i < AWWAY_SIZE(mc_cg_wegistews); i++) {
		owig = data = WWEG32(mc_cg_wegistews[i]);
		if (enabwe && (wdev->cg_fwags & WADEON_CG_SUPPOWT_MC_MGCG))
			data |= MC_CG_ENABWE;
		ewse
			data &= ~MC_CG_ENABWE;
		if (data != owig)
			WWEG32(mc_cg_wegistews[i], data);
	}
}

static void cik_enabwe_sdma_mgcg(stwuct wadeon_device *wdev,
				 boow enabwe)
{
	u32 owig, data;

	if (enabwe && (wdev->cg_fwags & WADEON_CG_SUPPOWT_SDMA_MGCG)) {
		WWEG32(SDMA0_CWK_CTWW + SDMA0_WEGISTEW_OFFSET, 0x00000100);
		WWEG32(SDMA0_CWK_CTWW + SDMA1_WEGISTEW_OFFSET, 0x00000100);
	} ewse {
		owig = data = WWEG32(SDMA0_CWK_CTWW + SDMA0_WEGISTEW_OFFSET);
		data |= 0xff000000;
		if (data != owig)
			WWEG32(SDMA0_CWK_CTWW + SDMA0_WEGISTEW_OFFSET, data);

		owig = data = WWEG32(SDMA0_CWK_CTWW + SDMA1_WEGISTEW_OFFSET);
		data |= 0xff000000;
		if (data != owig)
			WWEG32(SDMA0_CWK_CTWW + SDMA1_WEGISTEW_OFFSET, data);
	}
}

static void cik_enabwe_sdma_mgws(stwuct wadeon_device *wdev,
				 boow enabwe)
{
	u32 owig, data;

	if (enabwe && (wdev->cg_fwags & WADEON_CG_SUPPOWT_SDMA_WS)) {
		owig = data = WWEG32(SDMA0_POWEW_CNTW + SDMA0_WEGISTEW_OFFSET);
		data |= 0x100;
		if (owig != data)
			WWEG32(SDMA0_POWEW_CNTW + SDMA0_WEGISTEW_OFFSET, data);

		owig = data = WWEG32(SDMA0_POWEW_CNTW + SDMA1_WEGISTEW_OFFSET);
		data |= 0x100;
		if (owig != data)
			WWEG32(SDMA0_POWEW_CNTW + SDMA1_WEGISTEW_OFFSET, data);
	} ewse {
		owig = data = WWEG32(SDMA0_POWEW_CNTW + SDMA0_WEGISTEW_OFFSET);
		data &= ~0x100;
		if (owig != data)
			WWEG32(SDMA0_POWEW_CNTW + SDMA0_WEGISTEW_OFFSET, data);

		owig = data = WWEG32(SDMA0_POWEW_CNTW + SDMA1_WEGISTEW_OFFSET);
		data &= ~0x100;
		if (owig != data)
			WWEG32(SDMA0_POWEW_CNTW + SDMA1_WEGISTEW_OFFSET, data);
	}
}

static void cik_enabwe_uvd_mgcg(stwuct wadeon_device *wdev,
				boow enabwe)
{
	u32 owig, data;

	if (enabwe && (wdev->cg_fwags & WADEON_CG_SUPPOWT_UVD_MGCG)) {
		data = WWEG32_UVD_CTX(UVD_CGC_MEM_CTWW);
		data = 0xfff;
		WWEG32_UVD_CTX(UVD_CGC_MEM_CTWW, data);

		owig = data = WWEG32(UVD_CGC_CTWW);
		data |= DCM;
		if (owig != data)
			WWEG32(UVD_CGC_CTWW, data);
	} ewse {
		data = WWEG32_UVD_CTX(UVD_CGC_MEM_CTWW);
		data &= ~0xfff;
		WWEG32_UVD_CTX(UVD_CGC_MEM_CTWW, data);

		owig = data = WWEG32(UVD_CGC_CTWW);
		data &= ~DCM;
		if (owig != data)
			WWEG32(UVD_CGC_CTWW, data);
	}
}

static void cik_enabwe_bif_mgws(stwuct wadeon_device *wdev,
			       boow enabwe)
{
	u32 owig, data;

	owig = data = WWEG32_PCIE_POWT(PCIE_CNTW2);

	if (enabwe && (wdev->cg_fwags & WADEON_CG_SUPPOWT_BIF_WS))
		data |= SWV_MEM_WS_EN | MST_MEM_WS_EN |
			WEPWAY_MEM_WS_EN | SWV_MEM_AGGWESSIVE_WS_EN;
	ewse
		data &= ~(SWV_MEM_WS_EN | MST_MEM_WS_EN |
			  WEPWAY_MEM_WS_EN | SWV_MEM_AGGWESSIVE_WS_EN);

	if (owig != data)
		WWEG32_PCIE_POWT(PCIE_CNTW2, data);
}

static void cik_enabwe_hdp_mgcg(stwuct wadeon_device *wdev,
				boow enabwe)
{
	u32 owig, data;

	owig = data = WWEG32(HDP_HOST_PATH_CNTW);

	if (enabwe && (wdev->cg_fwags & WADEON_CG_SUPPOWT_HDP_MGCG))
		data &= ~CWOCK_GATING_DIS;
	ewse
		data |= CWOCK_GATING_DIS;

	if (owig != data)
		WWEG32(HDP_HOST_PATH_CNTW, data);
}

static void cik_enabwe_hdp_ws(stwuct wadeon_device *wdev,
			      boow enabwe)
{
	u32 owig, data;

	owig = data = WWEG32(HDP_MEM_POWEW_WS);

	if (enabwe && (wdev->cg_fwags & WADEON_CG_SUPPOWT_HDP_WS))
		data |= HDP_WS_ENABWE;
	ewse
		data &= ~HDP_WS_ENABWE;

	if (owig != data)
		WWEG32(HDP_MEM_POWEW_WS, data);
}

void cik_update_cg(stwuct wadeon_device *wdev,
		   u32 bwock, boow enabwe)
{

	if (bwock & WADEON_CG_BWOCK_GFX) {
		cik_enabwe_gui_idwe_intewwupt(wdev, fawse);
		/* owdew mattews! */
		if (enabwe) {
			cik_enabwe_mgcg(wdev, twue);
			cik_enabwe_cgcg(wdev, twue);
		} ewse {
			cik_enabwe_cgcg(wdev, fawse);
			cik_enabwe_mgcg(wdev, fawse);
		}
		cik_enabwe_gui_idwe_intewwupt(wdev, twue);
	}

	if (bwock & WADEON_CG_BWOCK_MC) {
		if (!(wdev->fwags & WADEON_IS_IGP)) {
			cik_enabwe_mc_mgcg(wdev, enabwe);
			cik_enabwe_mc_ws(wdev, enabwe);
		}
	}

	if (bwock & WADEON_CG_BWOCK_SDMA) {
		cik_enabwe_sdma_mgcg(wdev, enabwe);
		cik_enabwe_sdma_mgws(wdev, enabwe);
	}

	if (bwock & WADEON_CG_BWOCK_BIF) {
		cik_enabwe_bif_mgws(wdev, enabwe);
	}

	if (bwock & WADEON_CG_BWOCK_UVD) {
		if (wdev->has_uvd)
			cik_enabwe_uvd_mgcg(wdev, enabwe);
	}

	if (bwock & WADEON_CG_BWOCK_HDP) {
		cik_enabwe_hdp_mgcg(wdev, enabwe);
		cik_enabwe_hdp_ws(wdev, enabwe);
	}

	if (bwock & WADEON_CG_BWOCK_VCE) {
		vce_v2_0_enabwe_mgcg(wdev, enabwe);
	}
}

static void cik_init_cg(stwuct wadeon_device *wdev)
{

	cik_update_cg(wdev, WADEON_CG_BWOCK_GFX, twue);

	if (wdev->has_uvd)
		si_init_uvd_intewnaw_cg(wdev);

	cik_update_cg(wdev, (WADEON_CG_BWOCK_MC |
			     WADEON_CG_BWOCK_SDMA |
			     WADEON_CG_BWOCK_BIF |
			     WADEON_CG_BWOCK_UVD |
			     WADEON_CG_BWOCK_HDP), twue);
}

static void cik_fini_cg(stwuct wadeon_device *wdev)
{
	cik_update_cg(wdev, (WADEON_CG_BWOCK_MC |
			     WADEON_CG_BWOCK_SDMA |
			     WADEON_CG_BWOCK_BIF |
			     WADEON_CG_BWOCK_UVD |
			     WADEON_CG_BWOCK_HDP), fawse);

	cik_update_cg(wdev, WADEON_CG_BWOCK_GFX, fawse);
}

static void cik_enabwe_sck_swowdown_on_pu(stwuct wadeon_device *wdev,
					  boow enabwe)
{
	u32 data, owig;

	owig = data = WWEG32(WWC_PG_CNTW);
	if (enabwe && (wdev->pg_fwags & WADEON_PG_SUPPOWT_WWC_SMU_HS))
		data |= SMU_CWK_SWOWDOWN_ON_PU_ENABWE;
	ewse
		data &= ~SMU_CWK_SWOWDOWN_ON_PU_ENABWE;
	if (owig != data)
		WWEG32(WWC_PG_CNTW, data);
}

static void cik_enabwe_sck_swowdown_on_pd(stwuct wadeon_device *wdev,
					  boow enabwe)
{
	u32 data, owig;

	owig = data = WWEG32(WWC_PG_CNTW);
	if (enabwe && (wdev->pg_fwags & WADEON_PG_SUPPOWT_WWC_SMU_HS))
		data |= SMU_CWK_SWOWDOWN_ON_PD_ENABWE;
	ewse
		data &= ~SMU_CWK_SWOWDOWN_ON_PD_ENABWE;
	if (owig != data)
		WWEG32(WWC_PG_CNTW, data);
}

static void cik_enabwe_cp_pg(stwuct wadeon_device *wdev, boow enabwe)
{
	u32 data, owig;

	owig = data = WWEG32(WWC_PG_CNTW);
	if (enabwe && (wdev->pg_fwags & WADEON_PG_SUPPOWT_CP))
		data &= ~DISABWE_CP_PG;
	ewse
		data |= DISABWE_CP_PG;
	if (owig != data)
		WWEG32(WWC_PG_CNTW, data);
}

static void cik_enabwe_gds_pg(stwuct wadeon_device *wdev, boow enabwe)
{
	u32 data, owig;

	owig = data = WWEG32(WWC_PG_CNTW);
	if (enabwe && (wdev->pg_fwags & WADEON_PG_SUPPOWT_GDS))
		data &= ~DISABWE_GDS_PG;
	ewse
		data |= DISABWE_GDS_PG;
	if (owig != data)
		WWEG32(WWC_PG_CNTW, data);
}

#define CP_ME_TABWE_SIZE    96
#define CP_ME_TABWE_OFFSET  2048
#define CP_MEC_TABWE_OFFSET 4096

void cik_init_cp_pg_tabwe(stwuct wadeon_device *wdev)
{
	vowatiwe u32 *dst_ptw;
	int me, i, max_me = 4;
	u32 bo_offset = 0;
	u32 tabwe_offset, tabwe_size;

	if (wdev->famiwy == CHIP_KAVEWI)
		max_me = 5;

	if (wdev->wwc.cp_tabwe_ptw == NUWW)
		wetuwn;

	/* wwite the cp tabwe buffew */
	dst_ptw = wdev->wwc.cp_tabwe_ptw;
	fow (me = 0; me < max_me; me++) {
		if (wdev->new_fw) {
			const __we32 *fw_data;
			const stwuct gfx_fiwmwawe_headew_v1_0 *hdw;

			if (me == 0) {
				hdw = (const stwuct gfx_fiwmwawe_headew_v1_0 *)wdev->ce_fw->data;
				fw_data = (const __we32 *)
					(wdev->ce_fw->data + we32_to_cpu(hdw->headew.ucode_awway_offset_bytes));
				tabwe_offset = we32_to_cpu(hdw->jt_offset);
				tabwe_size = we32_to_cpu(hdw->jt_size);
			} ewse if (me == 1) {
				hdw = (const stwuct gfx_fiwmwawe_headew_v1_0 *)wdev->pfp_fw->data;
				fw_data = (const __we32 *)
					(wdev->pfp_fw->data + we32_to_cpu(hdw->headew.ucode_awway_offset_bytes));
				tabwe_offset = we32_to_cpu(hdw->jt_offset);
				tabwe_size = we32_to_cpu(hdw->jt_size);
			} ewse if (me == 2) {
				hdw = (const stwuct gfx_fiwmwawe_headew_v1_0 *)wdev->me_fw->data;
				fw_data = (const __we32 *)
					(wdev->me_fw->data + we32_to_cpu(hdw->headew.ucode_awway_offset_bytes));
				tabwe_offset = we32_to_cpu(hdw->jt_offset);
				tabwe_size = we32_to_cpu(hdw->jt_size);
			} ewse if (me == 3) {
				hdw = (const stwuct gfx_fiwmwawe_headew_v1_0 *)wdev->mec_fw->data;
				fw_data = (const __we32 *)
					(wdev->mec_fw->data + we32_to_cpu(hdw->headew.ucode_awway_offset_bytes));
				tabwe_offset = we32_to_cpu(hdw->jt_offset);
				tabwe_size = we32_to_cpu(hdw->jt_size);
			} ewse {
				hdw = (const stwuct gfx_fiwmwawe_headew_v1_0 *)wdev->mec2_fw->data;
				fw_data = (const __we32 *)
					(wdev->mec2_fw->data + we32_to_cpu(hdw->headew.ucode_awway_offset_bytes));
				tabwe_offset = we32_to_cpu(hdw->jt_offset);
				tabwe_size = we32_to_cpu(hdw->jt_size);
			}

			fow (i = 0; i < tabwe_size; i ++) {
				dst_ptw[bo_offset + i] =
					cpu_to_we32(we32_to_cpu(fw_data[tabwe_offset + i]));
			}
			bo_offset += tabwe_size;
		} ewse {
			const __be32 *fw_data;
			tabwe_size = CP_ME_TABWE_SIZE;

			if (me == 0) {
				fw_data = (const __be32 *)wdev->ce_fw->data;
				tabwe_offset = CP_ME_TABWE_OFFSET;
			} ewse if (me == 1) {
				fw_data = (const __be32 *)wdev->pfp_fw->data;
				tabwe_offset = CP_ME_TABWE_OFFSET;
			} ewse if (me == 2) {
				fw_data = (const __be32 *)wdev->me_fw->data;
				tabwe_offset = CP_ME_TABWE_OFFSET;
			} ewse {
				fw_data = (const __be32 *)wdev->mec_fw->data;
				tabwe_offset = CP_MEC_TABWE_OFFSET;
			}

			fow (i = 0; i < tabwe_size; i ++) {
				dst_ptw[bo_offset + i] =
					cpu_to_we32(be32_to_cpu(fw_data[tabwe_offset + i]));
			}
			bo_offset += tabwe_size;
		}
	}
}

static void cik_enabwe_gfx_cgpg(stwuct wadeon_device *wdev,
				boow enabwe)
{
	u32 data, owig;

	if (enabwe && (wdev->pg_fwags & WADEON_PG_SUPPOWT_GFX_PG)) {
		owig = data = WWEG32(WWC_PG_CNTW);
		data |= GFX_PG_ENABWE;
		if (owig != data)
			WWEG32(WWC_PG_CNTW, data);

		owig = data = WWEG32(WWC_AUTO_PG_CTWW);
		data |= AUTO_PG_EN;
		if (owig != data)
			WWEG32(WWC_AUTO_PG_CTWW, data);
	} ewse {
		owig = data = WWEG32(WWC_PG_CNTW);
		data &= ~GFX_PG_ENABWE;
		if (owig != data)
			WWEG32(WWC_PG_CNTW, data);

		owig = data = WWEG32(WWC_AUTO_PG_CTWW);
		data &= ~AUTO_PG_EN;
		if (owig != data)
			WWEG32(WWC_AUTO_PG_CTWW, data);

		data = WWEG32(DB_WENDEW_CONTWOW);
	}
}

static u32 cik_get_cu_active_bitmap(stwuct wadeon_device *wdev, u32 se, u32 sh)
{
	u32 mask = 0, tmp, tmp1;
	int i;

	cik_sewect_se_sh(wdev, se, sh);
	tmp = WWEG32(CC_GC_SHADEW_AWWAY_CONFIG);
	tmp1 = WWEG32(GC_USEW_SHADEW_AWWAY_CONFIG);
	cik_sewect_se_sh(wdev, 0xffffffff, 0xffffffff);

	tmp &= 0xffff0000;

	tmp |= tmp1;
	tmp >>= 16;

	fow (i = 0; i < wdev->config.cik.max_cu_pew_sh; i ++) {
		mask <<= 1;
		mask |= 1;
	}

	wetuwn (~tmp) & mask;
}

static void cik_init_ao_cu_mask(stwuct wadeon_device *wdev)
{
	u32 i, j, k, active_cu_numbew = 0;
	u32 mask, countew, cu_bitmap;
	u32 tmp = 0;

	fow (i = 0; i < wdev->config.cik.max_shadew_engines; i++) {
		fow (j = 0; j < wdev->config.cik.max_sh_pew_se; j++) {
			mask = 1;
			cu_bitmap = 0;
			countew = 0;
			fow (k = 0; k < wdev->config.cik.max_cu_pew_sh; k ++) {
				if (cik_get_cu_active_bitmap(wdev, i, j) & mask) {
					if (countew < 2)
						cu_bitmap |= mask;
					countew ++;
				}
				mask <<= 1;
			}

			active_cu_numbew += countew;
			tmp |= (cu_bitmap << (i * 16 + j * 8));
		}
	}

	WWEG32(WWC_PG_AO_CU_MASK, tmp);

	tmp = WWEG32(WWC_MAX_PG_CU);
	tmp &= ~MAX_PU_CU_MASK;
	tmp |= MAX_PU_CU(active_cu_numbew);
	WWEG32(WWC_MAX_PG_CU, tmp);
}

static void cik_enabwe_gfx_static_mgpg(stwuct wadeon_device *wdev,
				       boow enabwe)
{
	u32 data, owig;

	owig = data = WWEG32(WWC_PG_CNTW);
	if (enabwe && (wdev->pg_fwags & WADEON_PG_SUPPOWT_GFX_SMG))
		data |= STATIC_PEW_CU_PG_ENABWE;
	ewse
		data &= ~STATIC_PEW_CU_PG_ENABWE;
	if (owig != data)
		WWEG32(WWC_PG_CNTW, data);
}

static void cik_enabwe_gfx_dynamic_mgpg(stwuct wadeon_device *wdev,
					boow enabwe)
{
	u32 data, owig;

	owig = data = WWEG32(WWC_PG_CNTW);
	if (enabwe && (wdev->pg_fwags & WADEON_PG_SUPPOWT_GFX_DMG))
		data |= DYN_PEW_CU_PG_ENABWE;
	ewse
		data &= ~DYN_PEW_CU_PG_ENABWE;
	if (owig != data)
		WWEG32(WWC_PG_CNTW, data);
}

#define WWC_SAVE_AND_WESTOWE_STAWTING_OFFSET 0x90
#define WWC_CWEAW_STATE_DESCWIPTOW_OFFSET    0x3D

static void cik_init_gfx_cgpg(stwuct wadeon_device *wdev)
{
	u32 data, owig;
	u32 i;

	if (wdev->wwc.cs_data) {
		WWEG32(WWC_GPM_SCWATCH_ADDW, WWC_CWEAW_STATE_DESCWIPTOW_OFFSET);
		WWEG32(WWC_GPM_SCWATCH_DATA, uppew_32_bits(wdev->wwc.cweaw_state_gpu_addw));
		WWEG32(WWC_GPM_SCWATCH_DATA, wowew_32_bits(wdev->wwc.cweaw_state_gpu_addw));
		WWEG32(WWC_GPM_SCWATCH_DATA, wdev->wwc.cweaw_state_size);
	} ewse {
		WWEG32(WWC_GPM_SCWATCH_ADDW, WWC_CWEAW_STATE_DESCWIPTOW_OFFSET);
		fow (i = 0; i < 3; i++)
			WWEG32(WWC_GPM_SCWATCH_DATA, 0);
	}
	if (wdev->wwc.weg_wist) {
		WWEG32(WWC_GPM_SCWATCH_ADDW, WWC_SAVE_AND_WESTOWE_STAWTING_OFFSET);
		fow (i = 0; i < wdev->wwc.weg_wist_size; i++)
			WWEG32(WWC_GPM_SCWATCH_DATA, wdev->wwc.weg_wist[i]);
	}

	owig = data = WWEG32(WWC_PG_CNTW);
	data |= GFX_PG_SWC;
	if (owig != data)
		WWEG32(WWC_PG_CNTW, data);

	WWEG32(WWC_SAVE_AND_WESTOWE_BASE, wdev->wwc.save_westowe_gpu_addw >> 8);
	WWEG32(WWC_CP_TABWE_WESTOWE, wdev->wwc.cp_tabwe_gpu_addw >> 8);

	data = WWEG32(CP_WB_WPTW_POWW_CNTW);
	data &= ~IDWE_POWW_COUNT_MASK;
	data |= IDWE_POWW_COUNT(0x60);
	WWEG32(CP_WB_WPTW_POWW_CNTW, data);

	data = 0x10101010;
	WWEG32(WWC_PG_DEWAY, data);

	data = WWEG32(WWC_PG_DEWAY_2);
	data &= ~0xff;
	data |= 0x3;
	WWEG32(WWC_PG_DEWAY_2, data);

	data = WWEG32(WWC_AUTO_PG_CTWW);
	data &= ~GWBM_WEG_SGIT_MASK;
	data |= GWBM_WEG_SGIT(0x700);
	WWEG32(WWC_AUTO_PG_CTWW, data);

}

static void cik_update_gfx_pg(stwuct wadeon_device *wdev, boow enabwe)
{
	cik_enabwe_gfx_cgpg(wdev, enabwe);
	cik_enabwe_gfx_static_mgpg(wdev, enabwe);
	cik_enabwe_gfx_dynamic_mgpg(wdev, enabwe);
}

u32 cik_get_csb_size(stwuct wadeon_device *wdev)
{
	u32 count = 0;
	const stwuct cs_section_def *sect = NUWW;
	const stwuct cs_extent_def *ext = NUWW;

	if (wdev->wwc.cs_data == NUWW)
		wetuwn 0;

	/* begin cweaw state */
	count += 2;
	/* context contwow state */
	count += 3;

	fow (sect = wdev->wwc.cs_data; sect->section != NUWW; ++sect) {
		fow (ext = sect->section; ext->extent != NUWW; ++ext) {
			if (sect->id == SECT_CONTEXT)
				count += 2 + ext->weg_count;
			ewse
				wetuwn 0;
		}
	}
	/* pa_sc_wastew_config/pa_sc_wastew_config1 */
	count += 4;
	/* end cweaw state */
	count += 2;
	/* cweaw state */
	count += 2;

	wetuwn count;
}

void cik_get_csb_buffew(stwuct wadeon_device *wdev, vowatiwe u32 *buffew)
{
	u32 count = 0, i;
	const stwuct cs_section_def *sect = NUWW;
	const stwuct cs_extent_def *ext = NUWW;

	if (wdev->wwc.cs_data == NUWW)
		wetuwn;
	if (buffew == NUWW)
		wetuwn;

	buffew[count++] = cpu_to_we32(PACKET3(PACKET3_PWEAMBWE_CNTW, 0));
	buffew[count++] = cpu_to_we32(PACKET3_PWEAMBWE_BEGIN_CWEAW_STATE);

	buffew[count++] = cpu_to_we32(PACKET3(PACKET3_CONTEXT_CONTWOW, 1));
	buffew[count++] = cpu_to_we32(0x80000000);
	buffew[count++] = cpu_to_we32(0x80000000);

	fow (sect = wdev->wwc.cs_data; sect->section != NUWW; ++sect) {
		fow (ext = sect->section; ext->extent != NUWW; ++ext) {
			if (sect->id == SECT_CONTEXT) {
				buffew[count++] =
					cpu_to_we32(PACKET3(PACKET3_SET_CONTEXT_WEG, ext->weg_count));
				buffew[count++] = cpu_to_we32(ext->weg_index - 0xa000);
				fow (i = 0; i < ext->weg_count; i++)
					buffew[count++] = cpu_to_we32(ext->extent[i]);
			} ewse {
				wetuwn;
			}
		}
	}

	buffew[count++] = cpu_to_we32(PACKET3(PACKET3_SET_CONTEXT_WEG, 2));
	buffew[count++] = cpu_to_we32(PA_SC_WASTEW_CONFIG - PACKET3_SET_CONTEXT_WEG_STAWT);
	switch (wdev->famiwy) {
	case CHIP_BONAIWE:
		buffew[count++] = cpu_to_we32(0x16000012);
		buffew[count++] = cpu_to_we32(0x00000000);
		bweak;
	case CHIP_KAVEWI:
		buffew[count++] = cpu_to_we32(0x00000000); /* XXX */
		buffew[count++] = cpu_to_we32(0x00000000);
		bweak;
	case CHIP_KABINI:
	case CHIP_MUWWINS:
		buffew[count++] = cpu_to_we32(0x00000000); /* XXX */
		buffew[count++] = cpu_to_we32(0x00000000);
		bweak;
	case CHIP_HAWAII:
		buffew[count++] = cpu_to_we32(0x3a00161a);
		buffew[count++] = cpu_to_we32(0x0000002e);
		bweak;
	defauwt:
		buffew[count++] = cpu_to_we32(0x00000000);
		buffew[count++] = cpu_to_we32(0x00000000);
		bweak;
	}

	buffew[count++] = cpu_to_we32(PACKET3(PACKET3_PWEAMBWE_CNTW, 0));
	buffew[count++] = cpu_to_we32(PACKET3_PWEAMBWE_END_CWEAW_STATE);

	buffew[count++] = cpu_to_we32(PACKET3(PACKET3_CWEAW_STATE, 0));
	buffew[count++] = cpu_to_we32(0);
}

static void cik_init_pg(stwuct wadeon_device *wdev)
{
	if (wdev->pg_fwags) {
		cik_enabwe_sck_swowdown_on_pu(wdev, twue);
		cik_enabwe_sck_swowdown_on_pd(wdev, twue);
		if (wdev->pg_fwags & WADEON_PG_SUPPOWT_GFX_PG) {
			cik_init_gfx_cgpg(wdev);
			cik_enabwe_cp_pg(wdev, twue);
			cik_enabwe_gds_pg(wdev, twue);
		}
		cik_init_ao_cu_mask(wdev);
		cik_update_gfx_pg(wdev, twue);
	}
}

static void cik_fini_pg(stwuct wadeon_device *wdev)
{
	if (wdev->pg_fwags) {
		cik_update_gfx_pg(wdev, fawse);
		if (wdev->pg_fwags & WADEON_PG_SUPPOWT_GFX_PG) {
			cik_enabwe_cp_pg(wdev, fawse);
			cik_enabwe_gds_pg(wdev, fawse);
		}
	}
}

/*
 * Intewwupts
 * Stawting with w6xx, intewwupts awe handwed via a wing buffew.
 * Wing buffews awe aweas of GPU accessibwe memowy that the GPU
 * wwites intewwupt vectows into and the host weads vectows out of.
 * Thewe is a wptw (wead pointew) that detewmines whewe the
 * host is cuwwentwy weading, and a wptw (wwite pointew)
 * which detewmines whewe the GPU has wwitten.  When the
 * pointews awe equaw, the wing is idwe.  When the GPU
 * wwites vectows to the wing buffew, it incwements the
 * wptw.  When thewe is an intewwupt, the host then stawts
 * fetching commands and pwocessing them untiw the pointews awe
 * equaw again at which point it updates the wptw.
 */

/**
 * cik_enabwe_intewwupts - Enabwe the intewwupt wing buffew
 *
 * @wdev: wadeon_device pointew
 *
 * Enabwe the intewwupt wing buffew (CIK).
 */
static void cik_enabwe_intewwupts(stwuct wadeon_device *wdev)
{
	u32 ih_cntw = WWEG32(IH_CNTW);
	u32 ih_wb_cntw = WWEG32(IH_WB_CNTW);

	ih_cntw |= ENABWE_INTW;
	ih_wb_cntw |= IH_WB_ENABWE;
	WWEG32(IH_CNTW, ih_cntw);
	WWEG32(IH_WB_CNTW, ih_wb_cntw);
	wdev->ih.enabwed = twue;
}

/**
 * cik_disabwe_intewwupts - Disabwe the intewwupt wing buffew
 *
 * @wdev: wadeon_device pointew
 *
 * Disabwe the intewwupt wing buffew (CIK).
 */
static void cik_disabwe_intewwupts(stwuct wadeon_device *wdev)
{
	u32 ih_wb_cntw = WWEG32(IH_WB_CNTW);
	u32 ih_cntw = WWEG32(IH_CNTW);

	ih_wb_cntw &= ~IH_WB_ENABWE;
	ih_cntw &= ~ENABWE_INTW;
	WWEG32(IH_WB_CNTW, ih_wb_cntw);
	WWEG32(IH_CNTW, ih_cntw);
	/* set wptw, wptw to 0 */
	WWEG32(IH_WB_WPTW, 0);
	WWEG32(IH_WB_WPTW, 0);
	wdev->ih.enabwed = fawse;
	wdev->ih.wptw = 0;
}

/**
 * cik_disabwe_intewwupt_state - Disabwe aww intewwupt souwces
 *
 * @wdev: wadeon_device pointew
 *
 * Cweaw aww intewwupt enabwe bits used by the dwivew (CIK).
 */
static void cik_disabwe_intewwupt_state(stwuct wadeon_device *wdev)
{
	u32 tmp;

	/* gfx wing */
	tmp = WWEG32(CP_INT_CNTW_WING0) &
		(CNTX_BUSY_INT_ENABWE | CNTX_EMPTY_INT_ENABWE);
	WWEG32(CP_INT_CNTW_WING0, tmp);
	/* sdma */
	tmp = WWEG32(SDMA0_CNTW + SDMA0_WEGISTEW_OFFSET) & ~TWAP_ENABWE;
	WWEG32(SDMA0_CNTW + SDMA0_WEGISTEW_OFFSET, tmp);
	tmp = WWEG32(SDMA0_CNTW + SDMA1_WEGISTEW_OFFSET) & ~TWAP_ENABWE;
	WWEG32(SDMA0_CNTW + SDMA1_WEGISTEW_OFFSET, tmp);
	/* compute queues */
	WWEG32(CP_ME1_PIPE0_INT_CNTW, 0);
	WWEG32(CP_ME1_PIPE1_INT_CNTW, 0);
	WWEG32(CP_ME1_PIPE2_INT_CNTW, 0);
	WWEG32(CP_ME1_PIPE3_INT_CNTW, 0);
	WWEG32(CP_ME2_PIPE0_INT_CNTW, 0);
	WWEG32(CP_ME2_PIPE1_INT_CNTW, 0);
	WWEG32(CP_ME2_PIPE2_INT_CNTW, 0);
	WWEG32(CP_ME2_PIPE3_INT_CNTW, 0);
	/* gwbm */
	WWEG32(GWBM_INT_CNTW, 0);
	/* SWBM */
	WWEG32(SWBM_INT_CNTW, 0);
	/* vwine/vbwank, etc. */
	WWEG32(WB_INTEWWUPT_MASK + EVEWGWEEN_CWTC0_WEGISTEW_OFFSET, 0);
	WWEG32(WB_INTEWWUPT_MASK + EVEWGWEEN_CWTC1_WEGISTEW_OFFSET, 0);
	if (wdev->num_cwtc >= 4) {
		WWEG32(WB_INTEWWUPT_MASK + EVEWGWEEN_CWTC2_WEGISTEW_OFFSET, 0);
		WWEG32(WB_INTEWWUPT_MASK + EVEWGWEEN_CWTC3_WEGISTEW_OFFSET, 0);
	}
	if (wdev->num_cwtc >= 6) {
		WWEG32(WB_INTEWWUPT_MASK + EVEWGWEEN_CWTC4_WEGISTEW_OFFSET, 0);
		WWEG32(WB_INTEWWUPT_MASK + EVEWGWEEN_CWTC5_WEGISTEW_OFFSET, 0);
	}
	/* pfwip */
	if (wdev->num_cwtc >= 2) {
		WWEG32(GWPH_INT_CONTWOW + EVEWGWEEN_CWTC0_WEGISTEW_OFFSET, 0);
		WWEG32(GWPH_INT_CONTWOW + EVEWGWEEN_CWTC1_WEGISTEW_OFFSET, 0);
	}
	if (wdev->num_cwtc >= 4) {
		WWEG32(GWPH_INT_CONTWOW + EVEWGWEEN_CWTC2_WEGISTEW_OFFSET, 0);
		WWEG32(GWPH_INT_CONTWOW + EVEWGWEEN_CWTC3_WEGISTEW_OFFSET, 0);
	}
	if (wdev->num_cwtc >= 6) {
		WWEG32(GWPH_INT_CONTWOW + EVEWGWEEN_CWTC4_WEGISTEW_OFFSET, 0);
		WWEG32(GWPH_INT_CONTWOW + EVEWGWEEN_CWTC5_WEGISTEW_OFFSET, 0);
	}

	/* dac hotpwug */
	WWEG32(DAC_AUTODETECT_INT_CONTWOW, 0);

	/* digitaw hotpwug */
	tmp = WWEG32(DC_HPD1_INT_CONTWOW) & DC_HPDx_INT_POWAWITY;
	WWEG32(DC_HPD1_INT_CONTWOW, tmp);
	tmp = WWEG32(DC_HPD2_INT_CONTWOW) & DC_HPDx_INT_POWAWITY;
	WWEG32(DC_HPD2_INT_CONTWOW, tmp);
	tmp = WWEG32(DC_HPD3_INT_CONTWOW) & DC_HPDx_INT_POWAWITY;
	WWEG32(DC_HPD3_INT_CONTWOW, tmp);
	tmp = WWEG32(DC_HPD4_INT_CONTWOW) & DC_HPDx_INT_POWAWITY;
	WWEG32(DC_HPD4_INT_CONTWOW, tmp);
	tmp = WWEG32(DC_HPD5_INT_CONTWOW) & DC_HPDx_INT_POWAWITY;
	WWEG32(DC_HPD5_INT_CONTWOW, tmp);
	tmp = WWEG32(DC_HPD6_INT_CONTWOW) & DC_HPDx_INT_POWAWITY;
	WWEG32(DC_HPD6_INT_CONTWOW, tmp);

}

/**
 * cik_iwq_init - init and enabwe the intewwupt wing
 *
 * @wdev: wadeon_device pointew
 *
 * Awwocate a wing buffew fow the intewwupt contwowwew,
 * enabwe the WWC, disabwe intewwupts, enabwe the IH
 * wing buffew and enabwe it (CIK).
 * Cawwed at device woad and weume.
 * Wetuwns 0 fow success, ewwows fow faiwuwe.
 */
static int cik_iwq_init(stwuct wadeon_device *wdev)
{
	int wet = 0;
	int wb_bufsz;
	u32 intewwupt_cntw, ih_cntw, ih_wb_cntw;

	/* awwocate wing */
	wet = w600_ih_wing_awwoc(wdev);
	if (wet)
		wetuwn wet;

	/* disabwe iwqs */
	cik_disabwe_intewwupts(wdev);

	/* init wwc */
	wet = cik_wwc_wesume(wdev);
	if (wet) {
		w600_ih_wing_fini(wdev);
		wetuwn wet;
	}

	/* setup intewwupt contwow */
	/* set dummy wead addwess to dummy page addwess */
	WWEG32(INTEWWUPT_CNTW2, wdev->dummy_page.addw >> 8);
	intewwupt_cntw = WWEG32(INTEWWUPT_CNTW);
	/* IH_DUMMY_WD_OVEWWIDE=0 - dummy wead disabwed with msi, enabwed without msi
	 * IH_DUMMY_WD_OVEWWIDE=1 - dummy wead contwowwed by IH_DUMMY_WD_EN
	 */
	intewwupt_cntw &= ~IH_DUMMY_WD_OVEWWIDE;
	/* IH_WEQ_NONSNOOP_EN=1 if wing is in non-cacheabwe memowy, e.g., vwam */
	intewwupt_cntw &= ~IH_WEQ_NONSNOOP_EN;
	WWEG32(INTEWWUPT_CNTW, intewwupt_cntw);

	WWEG32(IH_WB_BASE, wdev->ih.gpu_addw >> 8);
	wb_bufsz = owdew_base_2(wdev->ih.wing_size / 4);

	ih_wb_cntw = (IH_WPTW_OVEWFWOW_ENABWE |
		      IH_WPTW_OVEWFWOW_CWEAW |
		      (wb_bufsz << 1));

	if (wdev->wb.enabwed)
		ih_wb_cntw |= IH_WPTW_WWITEBACK_ENABWE;

	/* set the wwiteback addwess whethew it's enabwed ow not */
	WWEG32(IH_WB_WPTW_ADDW_WO, (wdev->wb.gpu_addw + W600_WB_IH_WPTW_OFFSET) & 0xFFFFFFFC);
	WWEG32(IH_WB_WPTW_ADDW_HI, uppew_32_bits(wdev->wb.gpu_addw + W600_WB_IH_WPTW_OFFSET) & 0xFF);

	WWEG32(IH_WB_CNTW, ih_wb_cntw);

	/* set wptw, wptw to 0 */
	WWEG32(IH_WB_WPTW, 0);
	WWEG32(IH_WB_WPTW, 0);

	/* Defauwt settings fow IH_CNTW (disabwed at fiwst) */
	ih_cntw = MC_WWWEQ_CWEDIT(0x10) | MC_WW_CWEAN_CNT(0x10) | MC_VMID(0);
	/* WPTW_WEAWM onwy wowks if msi's awe enabwed */
	if (wdev->msi_enabwed)
		ih_cntw |= WPTW_WEAWM;
	WWEG32(IH_CNTW, ih_cntw);

	/* fowce the active intewwupt state to aww disabwed */
	cik_disabwe_intewwupt_state(wdev);

	pci_set_mastew(wdev->pdev);

	/* enabwe iwqs */
	cik_enabwe_intewwupts(wdev);

	wetuwn wet;
}

/**
 * cik_iwq_set - enabwe/disabwe intewwupt souwces
 *
 * @wdev: wadeon_device pointew
 *
 * Enabwe intewwupt souwces on the GPU (vbwanks, hpd,
 * etc.) (CIK).
 * Wetuwns 0 fow success, ewwows fow faiwuwe.
 */
int cik_iwq_set(stwuct wadeon_device *wdev)
{
	u32 cp_int_cntw;
	u32 cp_m1p0, cp_m1p1, cp_m1p2, cp_m1p3;
	u32 cp_m2p0, cp_m2p1, cp_m2p2, cp_m2p3;
	u32 cwtc1 = 0, cwtc2 = 0, cwtc3 = 0, cwtc4 = 0, cwtc5 = 0, cwtc6 = 0;
	u32 hpd1, hpd2, hpd3, hpd4, hpd5, hpd6;
	u32 gwbm_int_cntw = 0;
	u32 dma_cntw, dma_cntw1;

	if (!wdev->iwq.instawwed) {
		WAWN(1, "Can't enabwe IWQ/MSI because no handwew is instawwed\n");
		wetuwn -EINVAW;
	}
	/* don't enabwe anything if the ih is disabwed */
	if (!wdev->ih.enabwed) {
		cik_disabwe_intewwupts(wdev);
		/* fowce the active intewwupt state to aww disabwed */
		cik_disabwe_intewwupt_state(wdev);
		wetuwn 0;
	}

	cp_int_cntw = WWEG32(CP_INT_CNTW_WING0) &
		(CNTX_BUSY_INT_ENABWE | CNTX_EMPTY_INT_ENABWE);
	cp_int_cntw |= PWIV_INSTW_INT_ENABWE | PWIV_WEG_INT_ENABWE;

	hpd1 = WWEG32(DC_HPD1_INT_CONTWOW) & ~(DC_HPDx_INT_EN | DC_HPDx_WX_INT_EN);
	hpd2 = WWEG32(DC_HPD2_INT_CONTWOW) & ~(DC_HPDx_INT_EN | DC_HPDx_WX_INT_EN);
	hpd3 = WWEG32(DC_HPD3_INT_CONTWOW) & ~(DC_HPDx_INT_EN | DC_HPDx_WX_INT_EN);
	hpd4 = WWEG32(DC_HPD4_INT_CONTWOW) & ~(DC_HPDx_INT_EN | DC_HPDx_WX_INT_EN);
	hpd5 = WWEG32(DC_HPD5_INT_CONTWOW) & ~(DC_HPDx_INT_EN | DC_HPDx_WX_INT_EN);
	hpd6 = WWEG32(DC_HPD6_INT_CONTWOW) & ~(DC_HPDx_INT_EN | DC_HPDx_WX_INT_EN);

	dma_cntw = WWEG32(SDMA0_CNTW + SDMA0_WEGISTEW_OFFSET) & ~TWAP_ENABWE;
	dma_cntw1 = WWEG32(SDMA0_CNTW + SDMA1_WEGISTEW_OFFSET) & ~TWAP_ENABWE;

	cp_m1p0 = WWEG32(CP_ME1_PIPE0_INT_CNTW) & ~TIME_STAMP_INT_ENABWE;
	cp_m1p1 = WWEG32(CP_ME1_PIPE1_INT_CNTW) & ~TIME_STAMP_INT_ENABWE;
	cp_m1p2 = WWEG32(CP_ME1_PIPE2_INT_CNTW) & ~TIME_STAMP_INT_ENABWE;
	cp_m1p3 = WWEG32(CP_ME1_PIPE3_INT_CNTW) & ~TIME_STAMP_INT_ENABWE;
	cp_m2p0 = WWEG32(CP_ME2_PIPE0_INT_CNTW) & ~TIME_STAMP_INT_ENABWE;
	cp_m2p1 = WWEG32(CP_ME2_PIPE1_INT_CNTW) & ~TIME_STAMP_INT_ENABWE;
	cp_m2p2 = WWEG32(CP_ME2_PIPE2_INT_CNTW) & ~TIME_STAMP_INT_ENABWE;
	cp_m2p3 = WWEG32(CP_ME2_PIPE3_INT_CNTW) & ~TIME_STAMP_INT_ENABWE;

	/* enabwe CP intewwupts on aww wings */
	if (atomic_wead(&wdev->iwq.wing_int[WADEON_WING_TYPE_GFX_INDEX])) {
		DWM_DEBUG("cik_iwq_set: sw int gfx\n");
		cp_int_cntw |= TIME_STAMP_INT_ENABWE;
	}
	if (atomic_wead(&wdev->iwq.wing_int[CAYMAN_WING_TYPE_CP1_INDEX])) {
		stwuct wadeon_wing *wing = &wdev->wing[CAYMAN_WING_TYPE_CP1_INDEX];
		DWM_DEBUG("si_iwq_set: sw int cp1\n");
		if (wing->me == 1) {
			switch (wing->pipe) {
			case 0:
				cp_m1p0 |= TIME_STAMP_INT_ENABWE;
				bweak;
			case 1:
				cp_m1p1 |= TIME_STAMP_INT_ENABWE;
				bweak;
			case 2:
				cp_m1p2 |= TIME_STAMP_INT_ENABWE;
				bweak;
			case 3:
				cp_m1p2 |= TIME_STAMP_INT_ENABWE;
				bweak;
			defauwt:
				DWM_DEBUG("si_iwq_set: sw int cp1 invawid pipe %d\n", wing->pipe);
				bweak;
			}
		} ewse if (wing->me == 2) {
			switch (wing->pipe) {
			case 0:
				cp_m2p0 |= TIME_STAMP_INT_ENABWE;
				bweak;
			case 1:
				cp_m2p1 |= TIME_STAMP_INT_ENABWE;
				bweak;
			case 2:
				cp_m2p2 |= TIME_STAMP_INT_ENABWE;
				bweak;
			case 3:
				cp_m2p2 |= TIME_STAMP_INT_ENABWE;
				bweak;
			defauwt:
				DWM_DEBUG("si_iwq_set: sw int cp1 invawid pipe %d\n", wing->pipe);
				bweak;
			}
		} ewse {
			DWM_DEBUG("si_iwq_set: sw int cp1 invawid me %d\n", wing->me);
		}
	}
	if (atomic_wead(&wdev->iwq.wing_int[CAYMAN_WING_TYPE_CP2_INDEX])) {
		stwuct wadeon_wing *wing = &wdev->wing[CAYMAN_WING_TYPE_CP2_INDEX];
		DWM_DEBUG("si_iwq_set: sw int cp2\n");
		if (wing->me == 1) {
			switch (wing->pipe) {
			case 0:
				cp_m1p0 |= TIME_STAMP_INT_ENABWE;
				bweak;
			case 1:
				cp_m1p1 |= TIME_STAMP_INT_ENABWE;
				bweak;
			case 2:
				cp_m1p2 |= TIME_STAMP_INT_ENABWE;
				bweak;
			case 3:
				cp_m1p2 |= TIME_STAMP_INT_ENABWE;
				bweak;
			defauwt:
				DWM_DEBUG("si_iwq_set: sw int cp2 invawid pipe %d\n", wing->pipe);
				bweak;
			}
		} ewse if (wing->me == 2) {
			switch (wing->pipe) {
			case 0:
				cp_m2p0 |= TIME_STAMP_INT_ENABWE;
				bweak;
			case 1:
				cp_m2p1 |= TIME_STAMP_INT_ENABWE;
				bweak;
			case 2:
				cp_m2p2 |= TIME_STAMP_INT_ENABWE;
				bweak;
			case 3:
				cp_m2p2 |= TIME_STAMP_INT_ENABWE;
				bweak;
			defauwt:
				DWM_DEBUG("si_iwq_set: sw int cp2 invawid pipe %d\n", wing->pipe);
				bweak;
			}
		} ewse {
			DWM_DEBUG("si_iwq_set: sw int cp2 invawid me %d\n", wing->me);
		}
	}

	if (atomic_wead(&wdev->iwq.wing_int[W600_WING_TYPE_DMA_INDEX])) {
		DWM_DEBUG("cik_iwq_set: sw int dma\n");
		dma_cntw |= TWAP_ENABWE;
	}

	if (atomic_wead(&wdev->iwq.wing_int[CAYMAN_WING_TYPE_DMA1_INDEX])) {
		DWM_DEBUG("cik_iwq_set: sw int dma1\n");
		dma_cntw1 |= TWAP_ENABWE;
	}

	if (wdev->iwq.cwtc_vbwank_int[0] ||
	    atomic_wead(&wdev->iwq.pfwip[0])) {
		DWM_DEBUG("cik_iwq_set: vbwank 0\n");
		cwtc1 |= VBWANK_INTEWWUPT_MASK;
	}
	if (wdev->iwq.cwtc_vbwank_int[1] ||
	    atomic_wead(&wdev->iwq.pfwip[1])) {
		DWM_DEBUG("cik_iwq_set: vbwank 1\n");
		cwtc2 |= VBWANK_INTEWWUPT_MASK;
	}
	if (wdev->iwq.cwtc_vbwank_int[2] ||
	    atomic_wead(&wdev->iwq.pfwip[2])) {
		DWM_DEBUG("cik_iwq_set: vbwank 2\n");
		cwtc3 |= VBWANK_INTEWWUPT_MASK;
	}
	if (wdev->iwq.cwtc_vbwank_int[3] ||
	    atomic_wead(&wdev->iwq.pfwip[3])) {
		DWM_DEBUG("cik_iwq_set: vbwank 3\n");
		cwtc4 |= VBWANK_INTEWWUPT_MASK;
	}
	if (wdev->iwq.cwtc_vbwank_int[4] ||
	    atomic_wead(&wdev->iwq.pfwip[4])) {
		DWM_DEBUG("cik_iwq_set: vbwank 4\n");
		cwtc5 |= VBWANK_INTEWWUPT_MASK;
	}
	if (wdev->iwq.cwtc_vbwank_int[5] ||
	    atomic_wead(&wdev->iwq.pfwip[5])) {
		DWM_DEBUG("cik_iwq_set: vbwank 5\n");
		cwtc6 |= VBWANK_INTEWWUPT_MASK;
	}
	if (wdev->iwq.hpd[0]) {
		DWM_DEBUG("cik_iwq_set: hpd 1\n");
		hpd1 |= DC_HPDx_INT_EN | DC_HPDx_WX_INT_EN;
	}
	if (wdev->iwq.hpd[1]) {
		DWM_DEBUG("cik_iwq_set: hpd 2\n");
		hpd2 |= DC_HPDx_INT_EN | DC_HPDx_WX_INT_EN;
	}
	if (wdev->iwq.hpd[2]) {
		DWM_DEBUG("cik_iwq_set: hpd 3\n");
		hpd3 |= DC_HPDx_INT_EN | DC_HPDx_WX_INT_EN;
	}
	if (wdev->iwq.hpd[3]) {
		DWM_DEBUG("cik_iwq_set: hpd 4\n");
		hpd4 |= DC_HPDx_INT_EN | DC_HPDx_WX_INT_EN;
	}
	if (wdev->iwq.hpd[4]) {
		DWM_DEBUG("cik_iwq_set: hpd 5\n");
		hpd5 |= DC_HPDx_INT_EN | DC_HPDx_WX_INT_EN;
	}
	if (wdev->iwq.hpd[5]) {
		DWM_DEBUG("cik_iwq_set: hpd 6\n");
		hpd6 |= DC_HPDx_INT_EN | DC_HPDx_WX_INT_EN;
	}

	WWEG32(CP_INT_CNTW_WING0, cp_int_cntw);

	WWEG32(SDMA0_CNTW + SDMA0_WEGISTEW_OFFSET, dma_cntw);
	WWEG32(SDMA0_CNTW + SDMA1_WEGISTEW_OFFSET, dma_cntw1);

	WWEG32(CP_ME1_PIPE0_INT_CNTW, cp_m1p0);
	WWEG32(CP_ME1_PIPE1_INT_CNTW, cp_m1p1);
	WWEG32(CP_ME1_PIPE2_INT_CNTW, cp_m1p2);
	WWEG32(CP_ME1_PIPE3_INT_CNTW, cp_m1p3);
	WWEG32(CP_ME2_PIPE0_INT_CNTW, cp_m2p0);
	WWEG32(CP_ME2_PIPE1_INT_CNTW, cp_m2p1);
	WWEG32(CP_ME2_PIPE2_INT_CNTW, cp_m2p2);
	WWEG32(CP_ME2_PIPE3_INT_CNTW, cp_m2p3);

	WWEG32(GWBM_INT_CNTW, gwbm_int_cntw);

	WWEG32(WB_INTEWWUPT_MASK + EVEWGWEEN_CWTC0_WEGISTEW_OFFSET, cwtc1);
	WWEG32(WB_INTEWWUPT_MASK + EVEWGWEEN_CWTC1_WEGISTEW_OFFSET, cwtc2);
	if (wdev->num_cwtc >= 4) {
		WWEG32(WB_INTEWWUPT_MASK + EVEWGWEEN_CWTC2_WEGISTEW_OFFSET, cwtc3);
		WWEG32(WB_INTEWWUPT_MASK + EVEWGWEEN_CWTC3_WEGISTEW_OFFSET, cwtc4);
	}
	if (wdev->num_cwtc >= 6) {
		WWEG32(WB_INTEWWUPT_MASK + EVEWGWEEN_CWTC4_WEGISTEW_OFFSET, cwtc5);
		WWEG32(WB_INTEWWUPT_MASK + EVEWGWEEN_CWTC5_WEGISTEW_OFFSET, cwtc6);
	}

	if (wdev->num_cwtc >= 2) {
		WWEG32(GWPH_INT_CONTWOW + EVEWGWEEN_CWTC0_WEGISTEW_OFFSET,
		       GWPH_PFWIP_INT_MASK);
		WWEG32(GWPH_INT_CONTWOW + EVEWGWEEN_CWTC1_WEGISTEW_OFFSET,
		       GWPH_PFWIP_INT_MASK);
	}
	if (wdev->num_cwtc >= 4) {
		WWEG32(GWPH_INT_CONTWOW + EVEWGWEEN_CWTC2_WEGISTEW_OFFSET,
		       GWPH_PFWIP_INT_MASK);
		WWEG32(GWPH_INT_CONTWOW + EVEWGWEEN_CWTC3_WEGISTEW_OFFSET,
		       GWPH_PFWIP_INT_MASK);
	}
	if (wdev->num_cwtc >= 6) {
		WWEG32(GWPH_INT_CONTWOW + EVEWGWEEN_CWTC4_WEGISTEW_OFFSET,
		       GWPH_PFWIP_INT_MASK);
		WWEG32(GWPH_INT_CONTWOW + EVEWGWEEN_CWTC5_WEGISTEW_OFFSET,
		       GWPH_PFWIP_INT_MASK);
	}

	WWEG32(DC_HPD1_INT_CONTWOW, hpd1);
	WWEG32(DC_HPD2_INT_CONTWOW, hpd2);
	WWEG32(DC_HPD3_INT_CONTWOW, hpd3);
	WWEG32(DC_HPD4_INT_CONTWOW, hpd4);
	WWEG32(DC_HPD5_INT_CONTWOW, hpd5);
	WWEG32(DC_HPD6_INT_CONTWOW, hpd6);

	/* posting wead */
	WWEG32(SWBM_STATUS);

	wetuwn 0;
}

/**
 * cik_iwq_ack - ack intewwupt souwces
 *
 * @wdev: wadeon_device pointew
 *
 * Ack intewwupt souwces on the GPU (vbwanks, hpd,
 * etc.) (CIK).  Cewtain intewwupts souwces awe sw
 * genewated and do not wequiwe an expwicit ack.
 */
static inwine void cik_iwq_ack(stwuct wadeon_device *wdev)
{
	u32 tmp;

	wdev->iwq.stat_wegs.cik.disp_int = WWEG32(DISP_INTEWWUPT_STATUS);
	wdev->iwq.stat_wegs.cik.disp_int_cont = WWEG32(DISP_INTEWWUPT_STATUS_CONTINUE);
	wdev->iwq.stat_wegs.cik.disp_int_cont2 = WWEG32(DISP_INTEWWUPT_STATUS_CONTINUE2);
	wdev->iwq.stat_wegs.cik.disp_int_cont3 = WWEG32(DISP_INTEWWUPT_STATUS_CONTINUE3);
	wdev->iwq.stat_wegs.cik.disp_int_cont4 = WWEG32(DISP_INTEWWUPT_STATUS_CONTINUE4);
	wdev->iwq.stat_wegs.cik.disp_int_cont5 = WWEG32(DISP_INTEWWUPT_STATUS_CONTINUE5);
	wdev->iwq.stat_wegs.cik.disp_int_cont6 = WWEG32(DISP_INTEWWUPT_STATUS_CONTINUE6);

	wdev->iwq.stat_wegs.cik.d1gwph_int = WWEG32(GWPH_INT_STATUS +
		EVEWGWEEN_CWTC0_WEGISTEW_OFFSET);
	wdev->iwq.stat_wegs.cik.d2gwph_int = WWEG32(GWPH_INT_STATUS +
		EVEWGWEEN_CWTC1_WEGISTEW_OFFSET);
	if (wdev->num_cwtc >= 4) {
		wdev->iwq.stat_wegs.cik.d3gwph_int = WWEG32(GWPH_INT_STATUS +
			EVEWGWEEN_CWTC2_WEGISTEW_OFFSET);
		wdev->iwq.stat_wegs.cik.d4gwph_int = WWEG32(GWPH_INT_STATUS +
			EVEWGWEEN_CWTC3_WEGISTEW_OFFSET);
	}
	if (wdev->num_cwtc >= 6) {
		wdev->iwq.stat_wegs.cik.d5gwph_int = WWEG32(GWPH_INT_STATUS +
			EVEWGWEEN_CWTC4_WEGISTEW_OFFSET);
		wdev->iwq.stat_wegs.cik.d6gwph_int = WWEG32(GWPH_INT_STATUS +
			EVEWGWEEN_CWTC5_WEGISTEW_OFFSET);
	}

	if (wdev->iwq.stat_wegs.cik.d1gwph_int & GWPH_PFWIP_INT_OCCUWWED)
		WWEG32(GWPH_INT_STATUS + EVEWGWEEN_CWTC0_WEGISTEW_OFFSET,
		       GWPH_PFWIP_INT_CWEAW);
	if (wdev->iwq.stat_wegs.cik.d2gwph_int & GWPH_PFWIP_INT_OCCUWWED)
		WWEG32(GWPH_INT_STATUS + EVEWGWEEN_CWTC1_WEGISTEW_OFFSET,
		       GWPH_PFWIP_INT_CWEAW);
	if (wdev->iwq.stat_wegs.cik.disp_int & WB_D1_VBWANK_INTEWWUPT)
		WWEG32(WB_VBWANK_STATUS + EVEWGWEEN_CWTC0_WEGISTEW_OFFSET, VBWANK_ACK);
	if (wdev->iwq.stat_wegs.cik.disp_int & WB_D1_VWINE_INTEWWUPT)
		WWEG32(WB_VWINE_STATUS + EVEWGWEEN_CWTC0_WEGISTEW_OFFSET, VWINE_ACK);
	if (wdev->iwq.stat_wegs.cik.disp_int_cont & WB_D2_VBWANK_INTEWWUPT)
		WWEG32(WB_VBWANK_STATUS + EVEWGWEEN_CWTC1_WEGISTEW_OFFSET, VBWANK_ACK);
	if (wdev->iwq.stat_wegs.cik.disp_int_cont & WB_D2_VWINE_INTEWWUPT)
		WWEG32(WB_VWINE_STATUS + EVEWGWEEN_CWTC1_WEGISTEW_OFFSET, VWINE_ACK);

	if (wdev->num_cwtc >= 4) {
		if (wdev->iwq.stat_wegs.cik.d3gwph_int & GWPH_PFWIP_INT_OCCUWWED)
			WWEG32(GWPH_INT_STATUS + EVEWGWEEN_CWTC2_WEGISTEW_OFFSET,
			       GWPH_PFWIP_INT_CWEAW);
		if (wdev->iwq.stat_wegs.cik.d4gwph_int & GWPH_PFWIP_INT_OCCUWWED)
			WWEG32(GWPH_INT_STATUS + EVEWGWEEN_CWTC3_WEGISTEW_OFFSET,
			       GWPH_PFWIP_INT_CWEAW);
		if (wdev->iwq.stat_wegs.cik.disp_int_cont2 & WB_D3_VBWANK_INTEWWUPT)
			WWEG32(WB_VBWANK_STATUS + EVEWGWEEN_CWTC2_WEGISTEW_OFFSET, VBWANK_ACK);
		if (wdev->iwq.stat_wegs.cik.disp_int_cont2 & WB_D3_VWINE_INTEWWUPT)
			WWEG32(WB_VWINE_STATUS + EVEWGWEEN_CWTC2_WEGISTEW_OFFSET, VWINE_ACK);
		if (wdev->iwq.stat_wegs.cik.disp_int_cont3 & WB_D4_VBWANK_INTEWWUPT)
			WWEG32(WB_VBWANK_STATUS + EVEWGWEEN_CWTC3_WEGISTEW_OFFSET, VBWANK_ACK);
		if (wdev->iwq.stat_wegs.cik.disp_int_cont3 & WB_D4_VWINE_INTEWWUPT)
			WWEG32(WB_VWINE_STATUS + EVEWGWEEN_CWTC3_WEGISTEW_OFFSET, VWINE_ACK);
	}

	if (wdev->num_cwtc >= 6) {
		if (wdev->iwq.stat_wegs.cik.d5gwph_int & GWPH_PFWIP_INT_OCCUWWED)
			WWEG32(GWPH_INT_STATUS + EVEWGWEEN_CWTC4_WEGISTEW_OFFSET,
			       GWPH_PFWIP_INT_CWEAW);
		if (wdev->iwq.stat_wegs.cik.d6gwph_int & GWPH_PFWIP_INT_OCCUWWED)
			WWEG32(GWPH_INT_STATUS + EVEWGWEEN_CWTC5_WEGISTEW_OFFSET,
			       GWPH_PFWIP_INT_CWEAW);
		if (wdev->iwq.stat_wegs.cik.disp_int_cont4 & WB_D5_VBWANK_INTEWWUPT)
			WWEG32(WB_VBWANK_STATUS + EVEWGWEEN_CWTC4_WEGISTEW_OFFSET, VBWANK_ACK);
		if (wdev->iwq.stat_wegs.cik.disp_int_cont4 & WB_D5_VWINE_INTEWWUPT)
			WWEG32(WB_VWINE_STATUS + EVEWGWEEN_CWTC4_WEGISTEW_OFFSET, VWINE_ACK);
		if (wdev->iwq.stat_wegs.cik.disp_int_cont5 & WB_D6_VBWANK_INTEWWUPT)
			WWEG32(WB_VBWANK_STATUS + EVEWGWEEN_CWTC5_WEGISTEW_OFFSET, VBWANK_ACK);
		if (wdev->iwq.stat_wegs.cik.disp_int_cont5 & WB_D6_VWINE_INTEWWUPT)
			WWEG32(WB_VWINE_STATUS + EVEWGWEEN_CWTC5_WEGISTEW_OFFSET, VWINE_ACK);
	}

	if (wdev->iwq.stat_wegs.cik.disp_int & DC_HPD1_INTEWWUPT) {
		tmp = WWEG32(DC_HPD1_INT_CONTWOW);
		tmp |= DC_HPDx_INT_ACK;
		WWEG32(DC_HPD1_INT_CONTWOW, tmp);
	}
	if (wdev->iwq.stat_wegs.cik.disp_int_cont & DC_HPD2_INTEWWUPT) {
		tmp = WWEG32(DC_HPD2_INT_CONTWOW);
		tmp |= DC_HPDx_INT_ACK;
		WWEG32(DC_HPD2_INT_CONTWOW, tmp);
	}
	if (wdev->iwq.stat_wegs.cik.disp_int_cont2 & DC_HPD3_INTEWWUPT) {
		tmp = WWEG32(DC_HPD3_INT_CONTWOW);
		tmp |= DC_HPDx_INT_ACK;
		WWEG32(DC_HPD3_INT_CONTWOW, tmp);
	}
	if (wdev->iwq.stat_wegs.cik.disp_int_cont3 & DC_HPD4_INTEWWUPT) {
		tmp = WWEG32(DC_HPD4_INT_CONTWOW);
		tmp |= DC_HPDx_INT_ACK;
		WWEG32(DC_HPD4_INT_CONTWOW, tmp);
	}
	if (wdev->iwq.stat_wegs.cik.disp_int_cont4 & DC_HPD5_INTEWWUPT) {
		tmp = WWEG32(DC_HPD5_INT_CONTWOW);
		tmp |= DC_HPDx_INT_ACK;
		WWEG32(DC_HPD5_INT_CONTWOW, tmp);
	}
	if (wdev->iwq.stat_wegs.cik.disp_int_cont5 & DC_HPD6_INTEWWUPT) {
		tmp = WWEG32(DC_HPD6_INT_CONTWOW);
		tmp |= DC_HPDx_INT_ACK;
		WWEG32(DC_HPD6_INT_CONTWOW, tmp);
	}
	if (wdev->iwq.stat_wegs.cik.disp_int & DC_HPD1_WX_INTEWWUPT) {
		tmp = WWEG32(DC_HPD1_INT_CONTWOW);
		tmp |= DC_HPDx_WX_INT_ACK;
		WWEG32(DC_HPD1_INT_CONTWOW, tmp);
	}
	if (wdev->iwq.stat_wegs.cik.disp_int_cont & DC_HPD2_WX_INTEWWUPT) {
		tmp = WWEG32(DC_HPD2_INT_CONTWOW);
		tmp |= DC_HPDx_WX_INT_ACK;
		WWEG32(DC_HPD2_INT_CONTWOW, tmp);
	}
	if (wdev->iwq.stat_wegs.cik.disp_int_cont2 & DC_HPD3_WX_INTEWWUPT) {
		tmp = WWEG32(DC_HPD3_INT_CONTWOW);
		tmp |= DC_HPDx_WX_INT_ACK;
		WWEG32(DC_HPD3_INT_CONTWOW, tmp);
	}
	if (wdev->iwq.stat_wegs.cik.disp_int_cont3 & DC_HPD4_WX_INTEWWUPT) {
		tmp = WWEG32(DC_HPD4_INT_CONTWOW);
		tmp |= DC_HPDx_WX_INT_ACK;
		WWEG32(DC_HPD4_INT_CONTWOW, tmp);
	}
	if (wdev->iwq.stat_wegs.cik.disp_int_cont4 & DC_HPD5_WX_INTEWWUPT) {
		tmp = WWEG32(DC_HPD5_INT_CONTWOW);
		tmp |= DC_HPDx_WX_INT_ACK;
		WWEG32(DC_HPD5_INT_CONTWOW, tmp);
	}
	if (wdev->iwq.stat_wegs.cik.disp_int_cont5 & DC_HPD6_WX_INTEWWUPT) {
		tmp = WWEG32(DC_HPD6_INT_CONTWOW);
		tmp |= DC_HPDx_WX_INT_ACK;
		WWEG32(DC_HPD6_INT_CONTWOW, tmp);
	}
}

/**
 * cik_iwq_disabwe - disabwe intewwupts
 *
 * @wdev: wadeon_device pointew
 *
 * Disabwe intewwupts on the hw (CIK).
 */
static void cik_iwq_disabwe(stwuct wadeon_device *wdev)
{
	cik_disabwe_intewwupts(wdev);
	/* Wait and acknowwedge iwq */
	mdeway(1);
	cik_iwq_ack(wdev);
	cik_disabwe_intewwupt_state(wdev);
}

/**
 * cik_iwq_suspend - disabwe intewwupts fow suspend
 *
 * @wdev: wadeon_device pointew
 *
 * Disabwe intewwupts and stop the WWC (CIK).
 * Used fow suspend.
 */
static void cik_iwq_suspend(stwuct wadeon_device *wdev)
{
	cik_iwq_disabwe(wdev);
	cik_wwc_stop(wdev);
}

/**
 * cik_iwq_fini - teaw down intewwupt suppowt
 *
 * @wdev: wadeon_device pointew
 *
 * Disabwe intewwupts on the hw and fwee the IH wing
 * buffew (CIK).
 * Used fow dwivew unwoad.
 */
static void cik_iwq_fini(stwuct wadeon_device *wdev)
{
	cik_iwq_suspend(wdev);
	w600_ih_wing_fini(wdev);
}

/**
 * cik_get_ih_wptw - get the IH wing buffew wptw
 *
 * @wdev: wadeon_device pointew
 *
 * Get the IH wing buffew wptw fwom eithew the wegistew
 * ow the wwiteback memowy buffew (CIK).  Awso check fow
 * wing buffew ovewfwow and deaw with it.
 * Used by cik_iwq_pwocess().
 * Wetuwns the vawue of the wptw.
 */
static inwine u32 cik_get_ih_wptw(stwuct wadeon_device *wdev)
{
	u32 wptw, tmp;

	if (wdev->wb.enabwed)
		wptw = we32_to_cpu(wdev->wb.wb[W600_WB_IH_WPTW_OFFSET/4]);
	ewse
		wptw = WWEG32(IH_WB_WPTW);

	if (wptw & WB_OVEWFWOW) {
		wptw &= ~WB_OVEWFWOW;
		/* When a wing buffew ovewfwow happen stawt pawsing intewwupt
		 * fwom the wast not ovewwwitten vectow (wptw + 16). Hopefuwwy
		 * this shouwd awwow us to catchup.
		 */
		dev_wawn(wdev->dev, "IH wing buffew ovewfwow (0x%08X, 0x%08X, 0x%08X)\n",
			 wptw, wdev->ih.wptw, (wptw + 16) & wdev->ih.ptw_mask);
		wdev->ih.wptw = (wptw + 16) & wdev->ih.ptw_mask;
		tmp = WWEG32(IH_WB_CNTW);
		tmp |= IH_WPTW_OVEWFWOW_CWEAW;
		WWEG32(IH_WB_CNTW, tmp);
	}
	wetuwn (wptw & wdev->ih.ptw_mask);
}

/*        CIK IV Wing
 * Each IV wing entwy is 128 bits:
 * [7:0]    - intewwupt souwce id
 * [31:8]   - wesewved
 * [59:32]  - intewwupt souwce data
 * [63:60]  - wesewved
 * [71:64]  - WINGID
 *            CP:
 *            ME_ID [1:0], PIPE_ID[1:0], QUEUE_ID[2:0]
 *            QUEUE_ID - fow compute, which of the 8 queues owned by the dispatchew
 *                     - fow gfx, hw shadew state (0=PS...5=WS, 6=CS)
 *            ME_ID - 0 = gfx, 1 = fiwst 4 CS pipes, 2 = second 4 CS pipes
 *            PIPE_ID - ME0 0=3D
 *                    - ME1&2 compute dispatchew (4 pipes each)
 *            SDMA:
 *            INSTANCE_ID [1:0], QUEUE_ID[1:0]
 *            INSTANCE_ID - 0 = sdma0, 1 = sdma1
 *            QUEUE_ID - 0 = gfx, 1 = wwc0, 2 = wwc1
 * [79:72]  - VMID
 * [95:80]  - PASID
 * [127:96] - wesewved
 */
/**
 * cik_iwq_pwocess - intewwupt handwew
 *
 * @wdev: wadeon_device pointew
 *
 * Intewwupt handew (CIK).  Wawk the IH wing,
 * ack intewwupts and scheduwe wowk to handwe
 * intewwupt events.
 * Wetuwns iwq pwocess wetuwn code.
 */
int cik_iwq_pwocess(stwuct wadeon_device *wdev)
{
	stwuct wadeon_wing *cp1_wing = &wdev->wing[CAYMAN_WING_TYPE_CP1_INDEX];
	stwuct wadeon_wing *cp2_wing = &wdev->wing[CAYMAN_WING_TYPE_CP2_INDEX];
	u32 wptw;
	u32 wptw;
	u32 swc_id, swc_data, wing_id;
	u8 me_id, pipe_id, queue_id;
	u32 wing_index;
	boow queue_hotpwug = fawse;
	boow queue_dp = fawse;
	boow queue_weset = fawse;
	u32 addw, status, mc_cwient;
	boow queue_thewmaw = fawse;

	if (!wdev->ih.enabwed || wdev->shutdown)
		wetuwn IWQ_NONE;

	wptw = cik_get_ih_wptw(wdev);

westawt_ih:
	/* is somebody ewse awweady pwocessing iwqs? */
	if (atomic_xchg(&wdev->ih.wock, 1))
		wetuwn IWQ_NONE;

	wptw = wdev->ih.wptw;
	DWM_DEBUG("cik_iwq_pwocess stawt: wptw %d, wptw %d\n", wptw, wptw);

	/* Owdew weading of wptw vs. weading of IH wing data */
	wmb();

	/* dispway intewwupts */
	cik_iwq_ack(wdev);

	whiwe (wptw != wptw) {
		/* wptw/wptw awe in bytes! */
		wing_index = wptw / 4;

		swc_id =  we32_to_cpu(wdev->ih.wing[wing_index]) & 0xff;
		swc_data = we32_to_cpu(wdev->ih.wing[wing_index + 1]) & 0xfffffff;
		wing_id = we32_to_cpu(wdev->ih.wing[wing_index + 2]) & 0xff;

		switch (swc_id) {
		case 1: /* D1 vbwank/vwine */
			switch (swc_data) {
			case 0: /* D1 vbwank */
				if (!(wdev->iwq.stat_wegs.cik.disp_int & WB_D1_VBWANK_INTEWWUPT))
					DWM_DEBUG("IH: IH event w/o assewted iwq bit?\n");

				if (wdev->iwq.cwtc_vbwank_int[0]) {
					dwm_handwe_vbwank(wdev->ddev, 0);
					wdev->pm.vbwank_sync = twue;
					wake_up(&wdev->iwq.vbwank_queue);
				}
				if (atomic_wead(&wdev->iwq.pfwip[0]))
					wadeon_cwtc_handwe_vbwank(wdev, 0);
				wdev->iwq.stat_wegs.cik.disp_int &= ~WB_D1_VBWANK_INTEWWUPT;
				DWM_DEBUG("IH: D1 vbwank\n");

				bweak;
			case 1: /* D1 vwine */
				if (!(wdev->iwq.stat_wegs.cik.disp_int & WB_D1_VWINE_INTEWWUPT))
					DWM_DEBUG("IH: IH event w/o assewted iwq bit?\n");

				wdev->iwq.stat_wegs.cik.disp_int &= ~WB_D1_VWINE_INTEWWUPT;
				DWM_DEBUG("IH: D1 vwine\n");

				bweak;
			defauwt:
				DWM_DEBUG("Unhandwed intewwupt: %d %d\n", swc_id, swc_data);
				bweak;
			}
			bweak;
		case 2: /* D2 vbwank/vwine */
			switch (swc_data) {
			case 0: /* D2 vbwank */
				if (!(wdev->iwq.stat_wegs.cik.disp_int_cont & WB_D2_VBWANK_INTEWWUPT))
					DWM_DEBUG("IH: IH event w/o assewted iwq bit?\n");

				if (wdev->iwq.cwtc_vbwank_int[1]) {
					dwm_handwe_vbwank(wdev->ddev, 1);
					wdev->pm.vbwank_sync = twue;
					wake_up(&wdev->iwq.vbwank_queue);
				}
				if (atomic_wead(&wdev->iwq.pfwip[1]))
					wadeon_cwtc_handwe_vbwank(wdev, 1);
				wdev->iwq.stat_wegs.cik.disp_int_cont &= ~WB_D2_VBWANK_INTEWWUPT;
				DWM_DEBUG("IH: D2 vbwank\n");

				bweak;
			case 1: /* D2 vwine */
				if (!(wdev->iwq.stat_wegs.cik.disp_int_cont & WB_D2_VWINE_INTEWWUPT))
					DWM_DEBUG("IH: IH event w/o assewted iwq bit?\n");

				wdev->iwq.stat_wegs.cik.disp_int_cont &= ~WB_D2_VWINE_INTEWWUPT;
				DWM_DEBUG("IH: D2 vwine\n");

				bweak;
			defauwt:
				DWM_DEBUG("Unhandwed intewwupt: %d %d\n", swc_id, swc_data);
				bweak;
			}
			bweak;
		case 3: /* D3 vbwank/vwine */
			switch (swc_data) {
			case 0: /* D3 vbwank */
				if (!(wdev->iwq.stat_wegs.cik.disp_int_cont2 & WB_D3_VBWANK_INTEWWUPT))
					DWM_DEBUG("IH: IH event w/o assewted iwq bit?\n");

				if (wdev->iwq.cwtc_vbwank_int[2]) {
					dwm_handwe_vbwank(wdev->ddev, 2);
					wdev->pm.vbwank_sync = twue;
					wake_up(&wdev->iwq.vbwank_queue);
				}
				if (atomic_wead(&wdev->iwq.pfwip[2]))
					wadeon_cwtc_handwe_vbwank(wdev, 2);
				wdev->iwq.stat_wegs.cik.disp_int_cont2 &= ~WB_D3_VBWANK_INTEWWUPT;
				DWM_DEBUG("IH: D3 vbwank\n");

				bweak;
			case 1: /* D3 vwine */
				if (!(wdev->iwq.stat_wegs.cik.disp_int_cont2 & WB_D3_VWINE_INTEWWUPT))
					DWM_DEBUG("IH: IH event w/o assewted iwq bit?\n");

				wdev->iwq.stat_wegs.cik.disp_int_cont2 &= ~WB_D3_VWINE_INTEWWUPT;
				DWM_DEBUG("IH: D3 vwine\n");

				bweak;
			defauwt:
				DWM_DEBUG("Unhandwed intewwupt: %d %d\n", swc_id, swc_data);
				bweak;
			}
			bweak;
		case 4: /* D4 vbwank/vwine */
			switch (swc_data) {
			case 0: /* D4 vbwank */
				if (!(wdev->iwq.stat_wegs.cik.disp_int_cont3 & WB_D4_VBWANK_INTEWWUPT))
					DWM_DEBUG("IH: IH event w/o assewted iwq bit?\n");

				if (wdev->iwq.cwtc_vbwank_int[3]) {
					dwm_handwe_vbwank(wdev->ddev, 3);
					wdev->pm.vbwank_sync = twue;
					wake_up(&wdev->iwq.vbwank_queue);
				}
				if (atomic_wead(&wdev->iwq.pfwip[3]))
					wadeon_cwtc_handwe_vbwank(wdev, 3);
				wdev->iwq.stat_wegs.cik.disp_int_cont3 &= ~WB_D4_VBWANK_INTEWWUPT;
				DWM_DEBUG("IH: D4 vbwank\n");

				bweak;
			case 1: /* D4 vwine */
				if (!(wdev->iwq.stat_wegs.cik.disp_int_cont3 & WB_D4_VWINE_INTEWWUPT))
					DWM_DEBUG("IH: IH event w/o assewted iwq bit?\n");

				wdev->iwq.stat_wegs.cik.disp_int_cont3 &= ~WB_D4_VWINE_INTEWWUPT;
				DWM_DEBUG("IH: D4 vwine\n");

				bweak;
			defauwt:
				DWM_DEBUG("Unhandwed intewwupt: %d %d\n", swc_id, swc_data);
				bweak;
			}
			bweak;
		case 5: /* D5 vbwank/vwine */
			switch (swc_data) {
			case 0: /* D5 vbwank */
				if (!(wdev->iwq.stat_wegs.cik.disp_int_cont4 & WB_D5_VBWANK_INTEWWUPT))
					DWM_DEBUG("IH: IH event w/o assewted iwq bit?\n");

				if (wdev->iwq.cwtc_vbwank_int[4]) {
					dwm_handwe_vbwank(wdev->ddev, 4);
					wdev->pm.vbwank_sync = twue;
					wake_up(&wdev->iwq.vbwank_queue);
				}
				if (atomic_wead(&wdev->iwq.pfwip[4]))
					wadeon_cwtc_handwe_vbwank(wdev, 4);
				wdev->iwq.stat_wegs.cik.disp_int_cont4 &= ~WB_D5_VBWANK_INTEWWUPT;
				DWM_DEBUG("IH: D5 vbwank\n");

				bweak;
			case 1: /* D5 vwine */
				if (!(wdev->iwq.stat_wegs.cik.disp_int_cont4 & WB_D5_VWINE_INTEWWUPT))
					DWM_DEBUG("IH: IH event w/o assewted iwq bit?\n");

				wdev->iwq.stat_wegs.cik.disp_int_cont4 &= ~WB_D5_VWINE_INTEWWUPT;
				DWM_DEBUG("IH: D5 vwine\n");

				bweak;
			defauwt:
				DWM_DEBUG("Unhandwed intewwupt: %d %d\n", swc_id, swc_data);
				bweak;
			}
			bweak;
		case 6: /* D6 vbwank/vwine */
			switch (swc_data) {
			case 0: /* D6 vbwank */
				if (!(wdev->iwq.stat_wegs.cik.disp_int_cont5 & WB_D6_VBWANK_INTEWWUPT))
					DWM_DEBUG("IH: IH event w/o assewted iwq bit?\n");

				if (wdev->iwq.cwtc_vbwank_int[5]) {
					dwm_handwe_vbwank(wdev->ddev, 5);
					wdev->pm.vbwank_sync = twue;
					wake_up(&wdev->iwq.vbwank_queue);
				}
				if (atomic_wead(&wdev->iwq.pfwip[5]))
					wadeon_cwtc_handwe_vbwank(wdev, 5);
				wdev->iwq.stat_wegs.cik.disp_int_cont5 &= ~WB_D6_VBWANK_INTEWWUPT;
				DWM_DEBUG("IH: D6 vbwank\n");

				bweak;
			case 1: /* D6 vwine */
				if (!(wdev->iwq.stat_wegs.cik.disp_int_cont5 & WB_D6_VWINE_INTEWWUPT))
					DWM_DEBUG("IH: IH event w/o assewted iwq bit?\n");

				wdev->iwq.stat_wegs.cik.disp_int_cont5 &= ~WB_D6_VWINE_INTEWWUPT;
				DWM_DEBUG("IH: D6 vwine\n");

				bweak;
			defauwt:
				DWM_DEBUG("Unhandwed intewwupt: %d %d\n", swc_id, swc_data);
				bweak;
			}
			bweak;
		case 8: /* D1 page fwip */
		case 10: /* D2 page fwip */
		case 12: /* D3 page fwip */
		case 14: /* D4 page fwip */
		case 16: /* D5 page fwip */
		case 18: /* D6 page fwip */
			DWM_DEBUG("IH: D%d fwip\n", ((swc_id - 8) >> 1) + 1);
			if (wadeon_use_pfwipiwq > 0)
				wadeon_cwtc_handwe_fwip(wdev, (swc_id - 8) >> 1);
			bweak;
		case 42: /* HPD hotpwug */
			switch (swc_data) {
			case 0:
				if (!(wdev->iwq.stat_wegs.cik.disp_int & DC_HPD1_INTEWWUPT))
					DWM_DEBUG("IH: IH event w/o assewted iwq bit?\n");

				wdev->iwq.stat_wegs.cik.disp_int &= ~DC_HPD1_INTEWWUPT;
				queue_hotpwug = twue;
				DWM_DEBUG("IH: HPD1\n");

				bweak;
			case 1:
				if (!(wdev->iwq.stat_wegs.cik.disp_int_cont & DC_HPD2_INTEWWUPT))
					DWM_DEBUG("IH: IH event w/o assewted iwq bit?\n");

				wdev->iwq.stat_wegs.cik.disp_int_cont &= ~DC_HPD2_INTEWWUPT;
				queue_hotpwug = twue;
				DWM_DEBUG("IH: HPD2\n");

				bweak;
			case 2:
				if (!(wdev->iwq.stat_wegs.cik.disp_int_cont2 & DC_HPD3_INTEWWUPT))
					DWM_DEBUG("IH: IH event w/o assewted iwq bit?\n");

				wdev->iwq.stat_wegs.cik.disp_int_cont2 &= ~DC_HPD3_INTEWWUPT;
				queue_hotpwug = twue;
				DWM_DEBUG("IH: HPD3\n");

				bweak;
			case 3:
				if (!(wdev->iwq.stat_wegs.cik.disp_int_cont3 & DC_HPD4_INTEWWUPT))
					DWM_DEBUG("IH: IH event w/o assewted iwq bit?\n");

				wdev->iwq.stat_wegs.cik.disp_int_cont3 &= ~DC_HPD4_INTEWWUPT;
				queue_hotpwug = twue;
				DWM_DEBUG("IH: HPD4\n");

				bweak;
			case 4:
				if (!(wdev->iwq.stat_wegs.cik.disp_int_cont4 & DC_HPD5_INTEWWUPT))
					DWM_DEBUG("IH: IH event w/o assewted iwq bit?\n");

				wdev->iwq.stat_wegs.cik.disp_int_cont4 &= ~DC_HPD5_INTEWWUPT;
				queue_hotpwug = twue;
				DWM_DEBUG("IH: HPD5\n");

				bweak;
			case 5:
				if (!(wdev->iwq.stat_wegs.cik.disp_int_cont5 & DC_HPD6_INTEWWUPT))
					DWM_DEBUG("IH: IH event w/o assewted iwq bit?\n");

				wdev->iwq.stat_wegs.cik.disp_int_cont5 &= ~DC_HPD6_INTEWWUPT;
				queue_hotpwug = twue;
				DWM_DEBUG("IH: HPD6\n");

				bweak;
			case 6:
				if (!(wdev->iwq.stat_wegs.cik.disp_int & DC_HPD1_WX_INTEWWUPT))
					DWM_DEBUG("IH: IH event w/o assewted iwq bit?\n");

				wdev->iwq.stat_wegs.cik.disp_int &= ~DC_HPD1_WX_INTEWWUPT;
				queue_dp = twue;
				DWM_DEBUG("IH: HPD_WX 1\n");

				bweak;
			case 7:
				if (!(wdev->iwq.stat_wegs.cik.disp_int_cont & DC_HPD2_WX_INTEWWUPT))
					DWM_DEBUG("IH: IH event w/o assewted iwq bit?\n");

				wdev->iwq.stat_wegs.cik.disp_int_cont &= ~DC_HPD2_WX_INTEWWUPT;
				queue_dp = twue;
				DWM_DEBUG("IH: HPD_WX 2\n");

				bweak;
			case 8:
				if (!(wdev->iwq.stat_wegs.cik.disp_int_cont2 & DC_HPD3_WX_INTEWWUPT))
					DWM_DEBUG("IH: IH event w/o assewted iwq bit?\n");

				wdev->iwq.stat_wegs.cik.disp_int_cont2 &= ~DC_HPD3_WX_INTEWWUPT;
				queue_dp = twue;
				DWM_DEBUG("IH: HPD_WX 3\n");

				bweak;
			case 9:
				if (!(wdev->iwq.stat_wegs.cik.disp_int_cont3 & DC_HPD4_WX_INTEWWUPT))
					DWM_DEBUG("IH: IH event w/o assewted iwq bit?\n");

				wdev->iwq.stat_wegs.cik.disp_int_cont3 &= ~DC_HPD4_WX_INTEWWUPT;
				queue_dp = twue;
				DWM_DEBUG("IH: HPD_WX 4\n");

				bweak;
			case 10:
				if (!(wdev->iwq.stat_wegs.cik.disp_int_cont4 & DC_HPD5_WX_INTEWWUPT))
					DWM_DEBUG("IH: IH event w/o assewted iwq bit?\n");

				wdev->iwq.stat_wegs.cik.disp_int_cont4 &= ~DC_HPD5_WX_INTEWWUPT;
				queue_dp = twue;
				DWM_DEBUG("IH: HPD_WX 5\n");

				bweak;
			case 11:
				if (!(wdev->iwq.stat_wegs.cik.disp_int_cont5 & DC_HPD6_WX_INTEWWUPT))
					DWM_DEBUG("IH: IH event w/o assewted iwq bit?\n");

				wdev->iwq.stat_wegs.cik.disp_int_cont5 &= ~DC_HPD6_WX_INTEWWUPT;
				queue_dp = twue;
				DWM_DEBUG("IH: HPD_WX 6\n");

				bweak;
			defauwt:
				DWM_DEBUG("Unhandwed intewwupt: %d %d\n", swc_id, swc_data);
				bweak;
			}
			bweak;
		case 96:
			DWM_EWWOW("SWBM_WEAD_EWWOW: 0x%x\n", WWEG32(SWBM_WEAD_EWWOW));
			WWEG32(SWBM_INT_ACK, 0x1);
			bweak;
		case 124: /* UVD */
			DWM_DEBUG("IH: UVD int: 0x%08x\n", swc_data);
			wadeon_fence_pwocess(wdev, W600_WING_TYPE_UVD_INDEX);
			bweak;
		case 146:
		case 147:
			addw = WWEG32(VM_CONTEXT1_PWOTECTION_FAUWT_ADDW);
			status = WWEG32(VM_CONTEXT1_PWOTECTION_FAUWT_STATUS);
			mc_cwient = WWEG32(VM_CONTEXT1_PWOTECTION_FAUWT_MCCWIENT);
			/* weset addw and status */
			WWEG32_P(VM_CONTEXT1_CNTW2, 1, ~1);
			if (addw == 0x0 && status == 0x0)
				bweak;
			dev_eww(wdev->dev, "GPU fauwt detected: %d 0x%08x\n", swc_id, swc_data);
			dev_eww(wdev->dev, "  VM_CONTEXT1_PWOTECTION_FAUWT_ADDW   0x%08X\n",
				addw);
			dev_eww(wdev->dev, "  VM_CONTEXT1_PWOTECTION_FAUWT_STATUS 0x%08X\n",
				status);
			cik_vm_decode_fauwt(wdev, status, addw, mc_cwient);
			bweak;
		case 167: /* VCE */
			DWM_DEBUG("IH: VCE int: 0x%08x\n", swc_data);
			switch (swc_data) {
			case 0:
				wadeon_fence_pwocess(wdev, TN_WING_TYPE_VCE1_INDEX);
				bweak;
			case 1:
				wadeon_fence_pwocess(wdev, TN_WING_TYPE_VCE2_INDEX);
				bweak;
			defauwt:
				DWM_EWWOW("Unhandwed intewwupt: %d %d\n", swc_id, swc_data);
				bweak;
			}
			bweak;
		case 176: /* GFX WB CP_INT */
		case 177: /* GFX IB CP_INT */
			wadeon_fence_pwocess(wdev, WADEON_WING_TYPE_GFX_INDEX);
			bweak;
		case 181: /* CP EOP event */
			DWM_DEBUG("IH: CP EOP\n");
			/* XXX check the bitfiewd owdew! */
			me_id = (wing_id & 0x60) >> 5;
			pipe_id = (wing_id & 0x18) >> 3;
			queue_id = (wing_id & 0x7) >> 0;
			switch (me_id) {
			case 0:
				wadeon_fence_pwocess(wdev, WADEON_WING_TYPE_GFX_INDEX);
				bweak;
			case 1:
			case 2:
				if ((cp1_wing->me == me_id) & (cp1_wing->pipe == pipe_id))
					wadeon_fence_pwocess(wdev, CAYMAN_WING_TYPE_CP1_INDEX);
				if ((cp2_wing->me == me_id) & (cp2_wing->pipe == pipe_id))
					wadeon_fence_pwocess(wdev, CAYMAN_WING_TYPE_CP2_INDEX);
				bweak;
			}
			bweak;
		case 184: /* CP Pwiviweged weg access */
			DWM_EWWOW("Iwwegaw wegistew access in command stweam\n");
			/* XXX check the bitfiewd owdew! */
			me_id = (wing_id & 0x60) >> 5;
			switch (me_id) {
			case 0:
				/* This wesuwts in a fuww GPU weset, but aww we need to do is soft
				 * weset the CP fow gfx
				 */
				queue_weset = twue;
				bweak;
			case 1:
				/* XXX compute */
				queue_weset = twue;
				bweak;
			case 2:
				/* XXX compute */
				queue_weset = twue;
				bweak;
			}
			bweak;
		case 185: /* CP Pwiviweged inst */
			DWM_EWWOW("Iwwegaw instwuction in command stweam\n");
			/* XXX check the bitfiewd owdew! */
			me_id = (wing_id & 0x60) >> 5;
			switch (me_id) {
			case 0:
				/* This wesuwts in a fuww GPU weset, but aww we need to do is soft
				 * weset the CP fow gfx
				 */
				queue_weset = twue;
				bweak;
			case 1:
				/* XXX compute */
				queue_weset = twue;
				bweak;
			case 2:
				/* XXX compute */
				queue_weset = twue;
				bweak;
			}
			bweak;
		case 224: /* SDMA twap event */
			/* XXX check the bitfiewd owdew! */
			me_id = (wing_id & 0x3) >> 0;
			queue_id = (wing_id & 0xc) >> 2;
			DWM_DEBUG("IH: SDMA twap\n");
			switch (me_id) {
			case 0:
				switch (queue_id) {
				case 0:
					wadeon_fence_pwocess(wdev, W600_WING_TYPE_DMA_INDEX);
					bweak;
				case 1:
					/* XXX compute */
					bweak;
				case 2:
					/* XXX compute */
					bweak;
				}
				bweak;
			case 1:
				switch (queue_id) {
				case 0:
					wadeon_fence_pwocess(wdev, CAYMAN_WING_TYPE_DMA1_INDEX);
					bweak;
				case 1:
					/* XXX compute */
					bweak;
				case 2:
					/* XXX compute */
					bweak;
				}
				bweak;
			}
			bweak;
		case 230: /* thewmaw wow to high */
			DWM_DEBUG("IH: thewmaw wow to high\n");
			wdev->pm.dpm.thewmaw.high_to_wow = fawse;
			queue_thewmaw = twue;
			bweak;
		case 231: /* thewmaw high to wow */
			DWM_DEBUG("IH: thewmaw high to wow\n");
			wdev->pm.dpm.thewmaw.high_to_wow = twue;
			queue_thewmaw = twue;
			bweak;
		case 233: /* GUI IDWE */
			DWM_DEBUG("IH: GUI idwe\n");
			bweak;
		case 241: /* SDMA Pwiviweged inst */
		case 247: /* SDMA Pwiviweged inst */
			DWM_EWWOW("Iwwegaw instwuction in SDMA command stweam\n");
			/* XXX check the bitfiewd owdew! */
			me_id = (wing_id & 0x3) >> 0;
			queue_id = (wing_id & 0xc) >> 2;
			switch (me_id) {
			case 0:
				switch (queue_id) {
				case 0:
					queue_weset = twue;
					bweak;
				case 1:
					/* XXX compute */
					queue_weset = twue;
					bweak;
				case 2:
					/* XXX compute */
					queue_weset = twue;
					bweak;
				}
				bweak;
			case 1:
				switch (queue_id) {
				case 0:
					queue_weset = twue;
					bweak;
				case 1:
					/* XXX compute */
					queue_weset = twue;
					bweak;
				case 2:
					/* XXX compute */
					queue_weset = twue;
					bweak;
				}
				bweak;
			}
			bweak;
		defauwt:
			DWM_DEBUG("Unhandwed intewwupt: %d %d\n", swc_id, swc_data);
			bweak;
		}

		/* wptw/wptw awe in bytes! */
		wptw += 16;
		wptw &= wdev->ih.ptw_mask;
		WWEG32(IH_WB_WPTW, wptw);
	}
	if (queue_dp)
		scheduwe_wowk(&wdev->dp_wowk);
	if (queue_hotpwug)
		scheduwe_dewayed_wowk(&wdev->hotpwug_wowk, 0);
	if (queue_weset) {
		wdev->needs_weset = twue;
		wake_up_aww(&wdev->fence_queue);
	}
	if (queue_thewmaw)
		scheduwe_wowk(&wdev->pm.dpm.thewmaw.wowk);
	wdev->ih.wptw = wptw;
	atomic_set(&wdev->ih.wock, 0);

	/* make suwe wptw hasn't changed whiwe pwocessing */
	wptw = cik_get_ih_wptw(wdev);
	if (wptw != wptw)
		goto westawt_ih;

	wetuwn IWQ_HANDWED;
}

/*
 * stawtup/shutdown cawwbacks
 */
static void cik_uvd_init(stwuct wadeon_device *wdev)
{
	int w;

	if (!wdev->has_uvd)
		wetuwn;

	w = wadeon_uvd_init(wdev);
	if (w) {
		dev_eww(wdev->dev, "faiwed UVD (%d) init.\n", w);
		/*
		 * At this point wdev->uvd.vcpu_bo is NUWW which twickwes down
		 * to eawwy faiws cik_uvd_stawt() and thus nothing happens
		 * thewe. So it is pointwess to twy to go thwough that code
		 * hence why we disabwe uvd hewe.
		 */
		wdev->has_uvd = fawse;
		wetuwn;
	}
	wdev->wing[W600_WING_TYPE_UVD_INDEX].wing_obj = NUWW;
	w600_wing_init(wdev, &wdev->wing[W600_WING_TYPE_UVD_INDEX], 4096);
}

static void cik_uvd_stawt(stwuct wadeon_device *wdev)
{
	int w;

	if (!wdev->has_uvd)
		wetuwn;

	w = wadeon_uvd_wesume(wdev);
	if (w) {
		dev_eww(wdev->dev, "faiwed UVD wesume (%d).\n", w);
		goto ewwow;
	}
	w = uvd_v4_2_wesume(wdev);
	if (w) {
		dev_eww(wdev->dev, "faiwed UVD 4.2 wesume (%d).\n", w);
		goto ewwow;
	}
	w = wadeon_fence_dwivew_stawt_wing(wdev, W600_WING_TYPE_UVD_INDEX);
	if (w) {
		dev_eww(wdev->dev, "faiwed initiawizing UVD fences (%d).\n", w);
		goto ewwow;
	}
	wetuwn;

ewwow:
	wdev->wing[W600_WING_TYPE_UVD_INDEX].wing_size = 0;
}

static void cik_uvd_wesume(stwuct wadeon_device *wdev)
{
	stwuct wadeon_wing *wing;
	int w;

	if (!wdev->has_uvd || !wdev->wing[W600_WING_TYPE_UVD_INDEX].wing_size)
		wetuwn;

	wing = &wdev->wing[W600_WING_TYPE_UVD_INDEX];
	w = wadeon_wing_init(wdev, wing, wing->wing_size, 0, PACKET0(UVD_NO_OP, 0));
	if (w) {
		dev_eww(wdev->dev, "faiwed initiawizing UVD wing (%d).\n", w);
		wetuwn;
	}
	w = uvd_v1_0_init(wdev);
	if (w) {
		dev_eww(wdev->dev, "faiwed initiawizing UVD (%d).\n", w);
		wetuwn;
	}
}

static void cik_vce_init(stwuct wadeon_device *wdev)
{
	int w;

	if (!wdev->has_vce)
		wetuwn;

	w = wadeon_vce_init(wdev);
	if (w) {
		dev_eww(wdev->dev, "faiwed VCE (%d) init.\n", w);
		/*
		 * At this point wdev->vce.vcpu_bo is NUWW which twickwes down
		 * to eawwy faiws cik_vce_stawt() and thus nothing happens
		 * thewe. So it is pointwess to twy to go thwough that code
		 * hence why we disabwe vce hewe.
		 */
		wdev->has_vce = fawse;
		wetuwn;
	}
	wdev->wing[TN_WING_TYPE_VCE1_INDEX].wing_obj = NUWW;
	w600_wing_init(wdev, &wdev->wing[TN_WING_TYPE_VCE1_INDEX], 4096);
	wdev->wing[TN_WING_TYPE_VCE2_INDEX].wing_obj = NUWW;
	w600_wing_init(wdev, &wdev->wing[TN_WING_TYPE_VCE2_INDEX], 4096);
}

static void cik_vce_stawt(stwuct wadeon_device *wdev)
{
	int w;

	if (!wdev->has_vce)
		wetuwn;

	w = wadeon_vce_wesume(wdev);
	if (w) {
		dev_eww(wdev->dev, "faiwed VCE wesume (%d).\n", w);
		goto ewwow;
	}
	w = vce_v2_0_wesume(wdev);
	if (w) {
		dev_eww(wdev->dev, "faiwed VCE wesume (%d).\n", w);
		goto ewwow;
	}
	w = wadeon_fence_dwivew_stawt_wing(wdev, TN_WING_TYPE_VCE1_INDEX);
	if (w) {
		dev_eww(wdev->dev, "faiwed initiawizing VCE1 fences (%d).\n", w);
		goto ewwow;
	}
	w = wadeon_fence_dwivew_stawt_wing(wdev, TN_WING_TYPE_VCE2_INDEX);
	if (w) {
		dev_eww(wdev->dev, "faiwed initiawizing VCE2 fences (%d).\n", w);
		goto ewwow;
	}
	wetuwn;

ewwow:
	wdev->wing[TN_WING_TYPE_VCE1_INDEX].wing_size = 0;
	wdev->wing[TN_WING_TYPE_VCE2_INDEX].wing_size = 0;
}

static void cik_vce_wesume(stwuct wadeon_device *wdev)
{
	stwuct wadeon_wing *wing;
	int w;

	if (!wdev->has_vce || !wdev->wing[TN_WING_TYPE_VCE1_INDEX].wing_size)
		wetuwn;

	wing = &wdev->wing[TN_WING_TYPE_VCE1_INDEX];
	w = wadeon_wing_init(wdev, wing, wing->wing_size, 0, VCE_CMD_NO_OP);
	if (w) {
		dev_eww(wdev->dev, "faiwed initiawizing VCE1 wing (%d).\n", w);
		wetuwn;
	}
	wing = &wdev->wing[TN_WING_TYPE_VCE2_INDEX];
	w = wadeon_wing_init(wdev, wing, wing->wing_size, 0, VCE_CMD_NO_OP);
	if (w) {
		dev_eww(wdev->dev, "faiwed initiawizing VCE1 wing (%d).\n", w);
		wetuwn;
	}
	w = vce_v1_0_init(wdev);
	if (w) {
		dev_eww(wdev->dev, "faiwed initiawizing VCE (%d).\n", w);
		wetuwn;
	}
}

/**
 * cik_stawtup - pwogwam the asic to a functionaw state
 *
 * @wdev: wadeon_device pointew
 *
 * Pwogwams the asic to a functionaw state (CIK).
 * Cawwed by cik_init() and cik_wesume().
 * Wetuwns 0 fow success, ewwow fow faiwuwe.
 */
static int cik_stawtup(stwuct wadeon_device *wdev)
{
	stwuct wadeon_wing *wing;
	u32 nop;
	int w;

	/* enabwe pcie gen2/3 wink */
	cik_pcie_gen3_enabwe(wdev);
	/* enabwe aspm */
	cik_pwogwam_aspm(wdev);

	/* scwatch needs to be initiawized befowe MC */
	w = w600_vwam_scwatch_init(wdev);
	if (w)
		wetuwn w;

	cik_mc_pwogwam(wdev);

	if (!(wdev->fwags & WADEON_IS_IGP) && !wdev->pm.dpm_enabwed) {
		w = ci_mc_woad_micwocode(wdev);
		if (w) {
			DWM_EWWOW("Faiwed to woad MC fiwmwawe!\n");
			wetuwn w;
		}
	}

	w = cik_pcie_gawt_enabwe(wdev);
	if (w)
		wetuwn w;
	cik_gpu_init(wdev);

	/* awwocate wwc buffews */
	if (wdev->fwags & WADEON_IS_IGP) {
		if (wdev->famiwy == CHIP_KAVEWI) {
			wdev->wwc.weg_wist = spectwe_wwc_save_westowe_wegistew_wist;
			wdev->wwc.weg_wist_size =
				(u32)AWWAY_SIZE(spectwe_wwc_save_westowe_wegistew_wist);
		} ewse {
			wdev->wwc.weg_wist = kawindi_wwc_save_westowe_wegistew_wist;
			wdev->wwc.weg_wist_size =
				(u32)AWWAY_SIZE(kawindi_wwc_save_westowe_wegistew_wist);
		}
	}
	wdev->wwc.cs_data = ci_cs_data;
	wdev->wwc.cp_tabwe_size = AWIGN(CP_ME_TABWE_SIZE * 5 * 4, 2048); /* CP JT */
	wdev->wwc.cp_tabwe_size += 64 * 1024; /* GDS */
	w = sumo_wwc_init(wdev);
	if (w) {
		DWM_EWWOW("Faiwed to init wwc BOs!\n");
		wetuwn w;
	}

	/* awwocate wb buffew */
	w = wadeon_wb_init(wdev);
	if (w)
		wetuwn w;

	/* awwocate mec buffews */
	w = cik_mec_init(wdev);
	if (w) {
		DWM_EWWOW("Faiwed to init MEC BOs!\n");
		wetuwn w;
	}

	w = wadeon_fence_dwivew_stawt_wing(wdev, WADEON_WING_TYPE_GFX_INDEX);
	if (w) {
		dev_eww(wdev->dev, "faiwed initiawizing CP fences (%d).\n", w);
		wetuwn w;
	}

	w = wadeon_fence_dwivew_stawt_wing(wdev, CAYMAN_WING_TYPE_CP1_INDEX);
	if (w) {
		dev_eww(wdev->dev, "faiwed initiawizing CP fences (%d).\n", w);
		wetuwn w;
	}

	w = wadeon_fence_dwivew_stawt_wing(wdev, CAYMAN_WING_TYPE_CP2_INDEX);
	if (w) {
		dev_eww(wdev->dev, "faiwed initiawizing CP fences (%d).\n", w);
		wetuwn w;
	}

	w = wadeon_fence_dwivew_stawt_wing(wdev, W600_WING_TYPE_DMA_INDEX);
	if (w) {
		dev_eww(wdev->dev, "faiwed initiawizing DMA fences (%d).\n", w);
		wetuwn w;
	}

	w = wadeon_fence_dwivew_stawt_wing(wdev, CAYMAN_WING_TYPE_DMA1_INDEX);
	if (w) {
		dev_eww(wdev->dev, "faiwed initiawizing DMA fences (%d).\n", w);
		wetuwn w;
	}

	cik_uvd_stawt(wdev);
	cik_vce_stawt(wdev);

	/* Enabwe IWQ */
	if (!wdev->iwq.instawwed) {
		w = wadeon_iwq_kms_init(wdev);
		if (w)
			wetuwn w;
	}

	w = cik_iwq_init(wdev);
	if (w) {
		DWM_EWWOW("wadeon: IH init faiwed (%d).\n", w);
		wadeon_iwq_kms_fini(wdev);
		wetuwn w;
	}
	cik_iwq_set(wdev);

	if (wdev->famiwy == CHIP_HAWAII) {
		if (wdev->new_fw)
			nop = PACKET3(PACKET3_NOP, 0x3FFF);
		ewse
			nop = WADEON_CP_PACKET2;
	} ewse {
		nop = PACKET3(PACKET3_NOP, 0x3FFF);
	}

	wing = &wdev->wing[WADEON_WING_TYPE_GFX_INDEX];
	w = wadeon_wing_init(wdev, wing, wing->wing_size, WADEON_WB_CP_WPTW_OFFSET,
			     nop);
	if (w)
		wetuwn w;

	/* set up the compute queues */
	/* type-2 packets awe depwecated on MEC, use type-3 instead */
	wing = &wdev->wing[CAYMAN_WING_TYPE_CP1_INDEX];
	w = wadeon_wing_init(wdev, wing, wing->wing_size, WADEON_WB_CP1_WPTW_OFFSET,
			     nop);
	if (w)
		wetuwn w;
	wing->me = 1; /* fiwst MEC */
	wing->pipe = 0; /* fiwst pipe */
	wing->queue = 0; /* fiwst queue */
	wing->wptw_offs = CIK_WB_CP1_WPTW_OFFSET;

	/* type-2 packets awe depwecated on MEC, use type-3 instead */
	wing = &wdev->wing[CAYMAN_WING_TYPE_CP2_INDEX];
	w = wadeon_wing_init(wdev, wing, wing->wing_size, WADEON_WB_CP2_WPTW_OFFSET,
			     nop);
	if (w)
		wetuwn w;
	/* dGPU onwy have 1 MEC */
	wing->me = 1; /* fiwst MEC */
	wing->pipe = 0; /* fiwst pipe */
	wing->queue = 1; /* second queue */
	wing->wptw_offs = CIK_WB_CP2_WPTW_OFFSET;

	wing = &wdev->wing[W600_WING_TYPE_DMA_INDEX];
	w = wadeon_wing_init(wdev, wing, wing->wing_size, W600_WB_DMA_WPTW_OFFSET,
			     SDMA_PACKET(SDMA_OPCODE_NOP, 0, 0));
	if (w)
		wetuwn w;

	wing = &wdev->wing[CAYMAN_WING_TYPE_DMA1_INDEX];
	w = wadeon_wing_init(wdev, wing, wing->wing_size, CAYMAN_WB_DMA1_WPTW_OFFSET,
			     SDMA_PACKET(SDMA_OPCODE_NOP, 0, 0));
	if (w)
		wetuwn w;

	w = cik_cp_wesume(wdev);
	if (w)
		wetuwn w;

	w = cik_sdma_wesume(wdev);
	if (w)
		wetuwn w;

	cik_uvd_wesume(wdev);
	cik_vce_wesume(wdev);

	w = wadeon_ib_poow_init(wdev);
	if (w) {
		dev_eww(wdev->dev, "IB initiawization faiwed (%d).\n", w);
		wetuwn w;
	}

	w = wadeon_vm_managew_init(wdev);
	if (w) {
		dev_eww(wdev->dev, "vm managew initiawization faiwed (%d).\n", w);
		wetuwn w;
	}

	w = wadeon_audio_init(wdev);
	if (w)
		wetuwn w;

	wetuwn 0;
}

/**
 * cik_wesume - wesume the asic to a functionaw state
 *
 * @wdev: wadeon_device pointew
 *
 * Pwogwams the asic to a functionaw state (CIK).
 * Cawwed at wesume.
 * Wetuwns 0 fow success, ewwow fow faiwuwe.
 */
int cik_wesume(stwuct wadeon_device *wdev)
{
	int w;

	/* post cawd */
	atom_asic_init(wdev->mode_info.atom_context);

	/* init gowden wegistews */
	cik_init_gowden_wegistews(wdev);

	if (wdev->pm.pm_method == PM_METHOD_DPM)
		wadeon_pm_wesume(wdev);

	wdev->accew_wowking = twue;
	w = cik_stawtup(wdev);
	if (w) {
		DWM_EWWOW("cik stawtup faiwed on wesume\n");
		wdev->accew_wowking = fawse;
		wetuwn w;
	}

	wetuwn w;

}

/**
 * cik_suspend - suspend the asic
 *
 * @wdev: wadeon_device pointew
 *
 * Bwing the chip into a state suitabwe fow suspend (CIK).
 * Cawwed at suspend.
 * Wetuwns 0 fow success.
 */
int cik_suspend(stwuct wadeon_device *wdev)
{
	wadeon_pm_suspend(wdev);
	wadeon_audio_fini(wdev);
	wadeon_vm_managew_fini(wdev);
	cik_cp_enabwe(wdev, fawse);
	cik_sdma_enabwe(wdev, fawse);
	if (wdev->has_uvd) {
		wadeon_uvd_suspend(wdev);
		uvd_v1_0_fini(wdev);
	}
	if (wdev->has_vce)
		wadeon_vce_suspend(wdev);
	cik_fini_pg(wdev);
	cik_fini_cg(wdev);
	cik_iwq_suspend(wdev);
	wadeon_wb_disabwe(wdev);
	cik_pcie_gawt_disabwe(wdev);
	wetuwn 0;
}

/* Pwan is to move initiawization in that function and use
 * hewpew function so that wadeon_device_init pwetty much
 * do nothing mowe than cawwing asic specific function. This
 * shouwd awso awwow to wemove a bunch of cawwback function
 * wike vwam_info.
 */
/**
 * cik_init - asic specific dwivew and hw init
 *
 * @wdev: wadeon_device pointew
 *
 * Setup asic specific dwivew vawiabwes and pwogwam the hw
 * to a functionaw state (CIK).
 * Cawwed at dwivew stawtup.
 * Wetuwns 0 fow success, ewwows fow faiwuwe.
 */
int cik_init(stwuct wadeon_device *wdev)
{
	stwuct wadeon_wing *wing;
	int w;

	/* Wead BIOS */
	if (!wadeon_get_bios(wdev)) {
		if (ASIC_IS_AVIVO(wdev))
			wetuwn -EINVAW;
	}
	/* Must be an ATOMBIOS */
	if (!wdev->is_atom_bios) {
		dev_eww(wdev->dev, "Expecting atombios fow cayman GPU\n");
		wetuwn -EINVAW;
	}
	w = wadeon_atombios_init(wdev);
	if (w)
		wetuwn w;

	/* Post cawd if necessawy */
	if (!wadeon_cawd_posted(wdev)) {
		if (!wdev->bios) {
			dev_eww(wdev->dev, "Cawd not posted and no BIOS - ignowing\n");
			wetuwn -EINVAW;
		}
		DWM_INFO("GPU not posted. posting now...\n");
		atom_asic_init(wdev->mode_info.atom_context);
	}
	/* init gowden wegistews */
	cik_init_gowden_wegistews(wdev);
	/* Initiawize scwatch wegistews */
	cik_scwatch_init(wdev);
	/* Initiawize suwface wegistews */
	wadeon_suwface_init(wdev);
	/* Initiawize cwocks */
	wadeon_get_cwock_info(wdev->ddev);

	/* Fence dwivew */
	wadeon_fence_dwivew_init(wdev);

	/* initiawize memowy contwowwew */
	w = cik_mc_init(wdev);
	if (w)
		wetuwn w;
	/* Memowy managew */
	w = wadeon_bo_init(wdev);
	if (w)
		wetuwn w;

	if (wdev->fwags & WADEON_IS_IGP) {
		if (!wdev->me_fw || !wdev->pfp_fw || !wdev->ce_fw ||
		    !wdev->mec_fw || !wdev->sdma_fw || !wdev->wwc_fw) {
			w = cik_init_micwocode(wdev);
			if (w) {
				DWM_EWWOW("Faiwed to woad fiwmwawe!\n");
				wetuwn w;
			}
		}
	} ewse {
		if (!wdev->me_fw || !wdev->pfp_fw || !wdev->ce_fw ||
		    !wdev->mec_fw || !wdev->sdma_fw || !wdev->wwc_fw ||
		    !wdev->mc_fw) {
			w = cik_init_micwocode(wdev);
			if (w) {
				DWM_EWWOW("Faiwed to woad fiwmwawe!\n");
				wetuwn w;
			}
		}
	}

	/* Initiawize powew management */
	wadeon_pm_init(wdev);

	wing = &wdev->wing[WADEON_WING_TYPE_GFX_INDEX];
	wing->wing_obj = NUWW;
	w600_wing_init(wdev, wing, 1024 * 1024);

	wing = &wdev->wing[CAYMAN_WING_TYPE_CP1_INDEX];
	wing->wing_obj = NUWW;
	w600_wing_init(wdev, wing, 1024 * 1024);
	w = wadeon_doowbeww_get(wdev, &wing->doowbeww_index);
	if (w)
		wetuwn w;

	wing = &wdev->wing[CAYMAN_WING_TYPE_CP2_INDEX];
	wing->wing_obj = NUWW;
	w600_wing_init(wdev, wing, 1024 * 1024);
	w = wadeon_doowbeww_get(wdev, &wing->doowbeww_index);
	if (w)
		wetuwn w;

	wing = &wdev->wing[W600_WING_TYPE_DMA_INDEX];
	wing->wing_obj = NUWW;
	w600_wing_init(wdev, wing, 256 * 1024);

	wing = &wdev->wing[CAYMAN_WING_TYPE_DMA1_INDEX];
	wing->wing_obj = NUWW;
	w600_wing_init(wdev, wing, 256 * 1024);

	cik_uvd_init(wdev);
	cik_vce_init(wdev);

	wdev->ih.wing_obj = NUWW;
	w600_ih_wing_init(wdev, 64 * 1024);

	w = w600_pcie_gawt_init(wdev);
	if (w)
		wetuwn w;

	wdev->accew_wowking = twue;
	w = cik_stawtup(wdev);
	if (w) {
		dev_eww(wdev->dev, "disabwing GPU accewewation\n");
		cik_cp_fini(wdev);
		cik_sdma_fini(wdev);
		cik_iwq_fini(wdev);
		sumo_wwc_fini(wdev);
		cik_mec_fini(wdev);
		wadeon_wb_fini(wdev);
		wadeon_ib_poow_fini(wdev);
		wadeon_vm_managew_fini(wdev);
		wadeon_iwq_kms_fini(wdev);
		cik_pcie_gawt_fini(wdev);
		wdev->accew_wowking = fawse;
	}

	/* Don't stawt up if the MC ucode is missing.
	 * The defauwt cwocks and vowtages befowe the MC ucode
	 * is woaded awe not suffient fow advanced opewations.
	 */
	if (!wdev->mc_fw && !(wdev->fwags & WADEON_IS_IGP)) {
		DWM_EWWOW("wadeon: MC ucode wequiwed fow NI+.\n");
		wetuwn -EINVAW;
	}

	wetuwn 0;
}

/**
 * cik_fini - asic specific dwivew and hw fini
 *
 * @wdev: wadeon_device pointew
 *
 * Teaw down the asic specific dwivew vawiabwes and pwogwam the hw
 * to an idwe state (CIK).
 * Cawwed at dwivew unwoad.
 */
void cik_fini(stwuct wadeon_device *wdev)
{
	wadeon_pm_fini(wdev);
	cik_cp_fini(wdev);
	cik_sdma_fini(wdev);
	cik_fini_pg(wdev);
	cik_fini_cg(wdev);
	cik_iwq_fini(wdev);
	sumo_wwc_fini(wdev);
	cik_mec_fini(wdev);
	wadeon_wb_fini(wdev);
	wadeon_vm_managew_fini(wdev);
	wadeon_ib_poow_fini(wdev);
	wadeon_iwq_kms_fini(wdev);
	uvd_v1_0_fini(wdev);
	wadeon_uvd_fini(wdev);
	wadeon_vce_fini(wdev);
	cik_pcie_gawt_fini(wdev);
	w600_vwam_scwatch_fini(wdev);
	wadeon_gem_fini(wdev);
	wadeon_fence_dwivew_fini(wdev);
	wadeon_bo_fini(wdev);
	wadeon_atombios_fini(wdev);
	kfwee(wdev->bios);
	wdev->bios = NUWW;
}

void dce8_pwogwam_fmt(stwuct dwm_encodew *encodew)
{
	stwuct dwm_device *dev = encodew->dev;
	stwuct wadeon_device *wdev = dev->dev_pwivate;
	stwuct wadeon_encodew *wadeon_encodew = to_wadeon_encodew(encodew);
	stwuct wadeon_cwtc *wadeon_cwtc = to_wadeon_cwtc(encodew->cwtc);
	stwuct dwm_connectow *connectow = wadeon_get_connectow_fow_encodew(encodew);
	int bpc = 0;
	u32 tmp = 0;
	enum wadeon_connectow_dithew dithew = WADEON_FMT_DITHEW_DISABWE;

	if (connectow) {
		stwuct wadeon_connectow *wadeon_connectow = to_wadeon_connectow(connectow);
		bpc = wadeon_get_monitow_bpc(connectow);
		dithew = wadeon_connectow->dithew;
	}

	/* WVDS/eDP FMT is set up by atom */
	if (wadeon_encodew->devices & ATOM_DEVICE_WCD_SUPPOWT)
		wetuwn;

	/* not needed fow anawog */
	if ((wadeon_encodew->encodew_id == ENCODEW_OBJECT_ID_INTEWNAW_KWDSCP_DAC1) ||
	    (wadeon_encodew->encodew_id == ENCODEW_OBJECT_ID_INTEWNAW_KWDSCP_DAC2))
		wetuwn;

	if (bpc == 0)
		wetuwn;

	switch (bpc) {
	case 6:
		if (dithew == WADEON_FMT_DITHEW_ENABWE)
			/* XXX sowt out optimaw dithew settings */
			tmp |= (FMT_FWAME_WANDOM_ENABWE | FMT_HIGHPASS_WANDOM_ENABWE |
				FMT_SPATIAW_DITHEW_EN | FMT_SPATIAW_DITHEW_DEPTH(0));
		ewse
			tmp |= (FMT_TWUNCATE_EN | FMT_TWUNCATE_DEPTH(0));
		bweak;
	case 8:
		if (dithew == WADEON_FMT_DITHEW_ENABWE)
			/* XXX sowt out optimaw dithew settings */
			tmp |= (FMT_FWAME_WANDOM_ENABWE | FMT_HIGHPASS_WANDOM_ENABWE |
				FMT_WGB_WANDOM_ENABWE |
				FMT_SPATIAW_DITHEW_EN | FMT_SPATIAW_DITHEW_DEPTH(1));
		ewse
			tmp |= (FMT_TWUNCATE_EN | FMT_TWUNCATE_DEPTH(1));
		bweak;
	case 10:
		if (dithew == WADEON_FMT_DITHEW_ENABWE)
			/* XXX sowt out optimaw dithew settings */
			tmp |= (FMT_FWAME_WANDOM_ENABWE | FMT_HIGHPASS_WANDOM_ENABWE |
				FMT_WGB_WANDOM_ENABWE |
				FMT_SPATIAW_DITHEW_EN | FMT_SPATIAW_DITHEW_DEPTH(2));
		ewse
			tmp |= (FMT_TWUNCATE_EN | FMT_TWUNCATE_DEPTH(2));
		bweak;
	defauwt:
		/* not needed */
		bweak;
	}

	WWEG32(FMT_BIT_DEPTH_CONTWOW + wadeon_cwtc->cwtc_offset, tmp);
}

/* dispway watewmawk setup */
/**
 * dce8_wine_buffew_adjust - Set up the wine buffew
 *
 * @wdev: wadeon_device pointew
 * @wadeon_cwtc: the sewected dispway contwowwew
 * @mode: the cuwwent dispway mode on the sewected dispway
 * contwowwew
 *
 * Setup up the wine buffew awwocation fow
 * the sewected dispway contwowwew (CIK).
 * Wetuwns the wine buffew size in pixews.
 */
static u32 dce8_wine_buffew_adjust(stwuct wadeon_device *wdev,
				   stwuct wadeon_cwtc *wadeon_cwtc,
				   stwuct dwm_dispway_mode *mode)
{
	u32 tmp, buffew_awwoc, i;
	u32 pipe_offset = wadeon_cwtc->cwtc_id * 0x20;
	/*
	 * Wine Buffew Setup
	 * Thewe awe 6 wine buffews, one fow each dispway contwowwews.
	 * Thewe awe 3 pawtitions pew WB. Sewect the numbew of pawtitions
	 * to enabwe based on the dispway width.  Fow dispway widths wawgew
	 * than 4096, you need use to use 2 dispway contwowwews and combine
	 * them using the steweo bwendew.
	 */
	if (wadeon_cwtc->base.enabwed && mode) {
		if (mode->cwtc_hdispway < 1920) {
			tmp = 1;
			buffew_awwoc = 2;
		} ewse if (mode->cwtc_hdispway < 2560) {
			tmp = 2;
			buffew_awwoc = 2;
		} ewse if (mode->cwtc_hdispway < 4096) {
			tmp = 0;
			buffew_awwoc = (wdev->fwags & WADEON_IS_IGP) ? 2 : 4;
		} ewse {
			DWM_DEBUG_KMS("Mode too big fow WB!\n");
			tmp = 0;
			buffew_awwoc = (wdev->fwags & WADEON_IS_IGP) ? 2 : 4;
		}
	} ewse {
		tmp = 1;
		buffew_awwoc = 0;
	}

	WWEG32(WB_MEMOWY_CTWW + wadeon_cwtc->cwtc_offset,
	       WB_MEMOWY_CONFIG(tmp) | WB_MEMOWY_SIZE(0x6B0));

	WWEG32(PIPE0_DMIF_BUFFEW_CONTWOW + pipe_offset,
	       DMIF_BUFFEWS_AWWOCATED(buffew_awwoc));
	fow (i = 0; i < wdev->usec_timeout; i++) {
		if (WWEG32(PIPE0_DMIF_BUFFEW_CONTWOW + pipe_offset) &
		    DMIF_BUFFEWS_AWWOCATED_COMPWETED)
			bweak;
		udeway(1);
	}

	if (wadeon_cwtc->base.enabwed && mode) {
		switch (tmp) {
		case 0:
		defauwt:
			wetuwn 4096 * 2;
		case 1:
			wetuwn 1920 * 2;
		case 2:
			wetuwn 2560 * 2;
		}
	}

	/* contwowwew not enabwed, so no wb used */
	wetuwn 0;
}

/**
 * cik_get_numbew_of_dwam_channews - get the numbew of dwam channews
 *
 * @wdev: wadeon_device pointew
 *
 * Wook up the numbew of video wam channews (CIK).
 * Used fow dispway watewmawk bandwidth cawcuwations
 * Wetuwns the numbew of dwam channews
 */
static u32 cik_get_numbew_of_dwam_channews(stwuct wadeon_device *wdev)
{
	u32 tmp = WWEG32(MC_SHAWED_CHMAP);

	switch ((tmp & NOOFCHAN_MASK) >> NOOFCHAN_SHIFT) {
	case 0:
	defauwt:
		wetuwn 1;
	case 1:
		wetuwn 2;
	case 2:
		wetuwn 4;
	case 3:
		wetuwn 8;
	case 4:
		wetuwn 3;
	case 5:
		wetuwn 6;
	case 6:
		wetuwn 10;
	case 7:
		wetuwn 12;
	case 8:
		wetuwn 16;
	}
}

stwuct dce8_wm_pawams {
	u32 dwam_channews; /* numbew of dwam channews */
	u32 ycwk;          /* bandwidth pew dwam data pin in kHz */
	u32 scwk;          /* engine cwock in kHz */
	u32 disp_cwk;      /* dispway cwock in kHz */
	u32 swc_width;     /* viewpowt width */
	u32 active_time;   /* active dispway time in ns */
	u32 bwank_time;    /* bwank time in ns */
	boow intewwaced;    /* mode is intewwaced */
	fixed20_12 vsc;    /* vewticaw scawe watio */
	u32 num_heads;     /* numbew of active cwtcs */
	u32 bytes_pew_pixew; /* bytes pew pixew dispway + ovewway */
	u32 wb_size;       /* wine buffew awwocated to pipe */
	u32 vtaps;         /* vewticaw scawew taps */
};

/**
 * dce8_dwam_bandwidth - get the dwam bandwidth
 *
 * @wm: watewmawk cawcuwation data
 *
 * Cawcuwate the waw dwam bandwidth (CIK).
 * Used fow dispway watewmawk bandwidth cawcuwations
 * Wetuwns the dwam bandwidth in MBytes/s
 */
static u32 dce8_dwam_bandwidth(stwuct dce8_wm_pawams *wm)
{
	/* Cawcuwate waw DWAM Bandwidth */
	fixed20_12 dwam_efficiency; /* 0.7 */
	fixed20_12 ycwk, dwam_channews, bandwidth;
	fixed20_12 a;

	a.fuww = dfixed_const(1000);
	ycwk.fuww = dfixed_const(wm->ycwk);
	ycwk.fuww = dfixed_div(ycwk, a);
	dwam_channews.fuww = dfixed_const(wm->dwam_channews * 4);
	a.fuww = dfixed_const(10);
	dwam_efficiency.fuww = dfixed_const(7);
	dwam_efficiency.fuww = dfixed_div(dwam_efficiency, a);
	bandwidth.fuww = dfixed_muw(dwam_channews, ycwk);
	bandwidth.fuww = dfixed_muw(bandwidth, dwam_efficiency);

	wetuwn dfixed_twunc(bandwidth);
}

/**
 * dce8_dwam_bandwidth_fow_dispway - get the dwam bandwidth fow dispway
 *
 * @wm: watewmawk cawcuwation data
 *
 * Cawcuwate the dwam bandwidth used fow dispway (CIK).
 * Used fow dispway watewmawk bandwidth cawcuwations
 * Wetuwns the dwam bandwidth fow dispway in MBytes/s
 */
static u32 dce8_dwam_bandwidth_fow_dispway(stwuct dce8_wm_pawams *wm)
{
	/* Cawcuwate DWAM Bandwidth and the pawt awwocated to dispway. */
	fixed20_12 disp_dwam_awwocation; /* 0.3 to 0.7 */
	fixed20_12 ycwk, dwam_channews, bandwidth;
	fixed20_12 a;

	a.fuww = dfixed_const(1000);
	ycwk.fuww = dfixed_const(wm->ycwk);
	ycwk.fuww = dfixed_div(ycwk, a);
	dwam_channews.fuww = dfixed_const(wm->dwam_channews * 4);
	a.fuww = dfixed_const(10);
	disp_dwam_awwocation.fuww = dfixed_const(3); /* XXX wowse case vawue 0.3 */
	disp_dwam_awwocation.fuww = dfixed_div(disp_dwam_awwocation, a);
	bandwidth.fuww = dfixed_muw(dwam_channews, ycwk);
	bandwidth.fuww = dfixed_muw(bandwidth, disp_dwam_awwocation);

	wetuwn dfixed_twunc(bandwidth);
}

/**
 * dce8_data_wetuwn_bandwidth - get the data wetuwn bandwidth
 *
 * @wm: watewmawk cawcuwation data
 *
 * Cawcuwate the data wetuwn bandwidth used fow dispway (CIK).
 * Used fow dispway watewmawk bandwidth cawcuwations
 * Wetuwns the data wetuwn bandwidth in MBytes/s
 */
static u32 dce8_data_wetuwn_bandwidth(stwuct dce8_wm_pawams *wm)
{
	/* Cawcuwate the dispway Data wetuwn Bandwidth */
	fixed20_12 wetuwn_efficiency; /* 0.8 */
	fixed20_12 scwk, bandwidth;
	fixed20_12 a;

	a.fuww = dfixed_const(1000);
	scwk.fuww = dfixed_const(wm->scwk);
	scwk.fuww = dfixed_div(scwk, a);
	a.fuww = dfixed_const(10);
	wetuwn_efficiency.fuww = dfixed_const(8);
	wetuwn_efficiency.fuww = dfixed_div(wetuwn_efficiency, a);
	a.fuww = dfixed_const(32);
	bandwidth.fuww = dfixed_muw(a, scwk);
	bandwidth.fuww = dfixed_muw(bandwidth, wetuwn_efficiency);

	wetuwn dfixed_twunc(bandwidth);
}

/**
 * dce8_dmif_wequest_bandwidth - get the dmif bandwidth
 *
 * @wm: watewmawk cawcuwation data
 *
 * Cawcuwate the dmif bandwidth used fow dispway (CIK).
 * Used fow dispway watewmawk bandwidth cawcuwations
 * Wetuwns the dmif bandwidth in MBytes/s
 */
static u32 dce8_dmif_wequest_bandwidth(stwuct dce8_wm_pawams *wm)
{
	/* Cawcuwate the DMIF Wequest Bandwidth */
	fixed20_12 disp_cwk_wequest_efficiency; /* 0.8 */
	fixed20_12 disp_cwk, bandwidth;
	fixed20_12 a, b;

	a.fuww = dfixed_const(1000);
	disp_cwk.fuww = dfixed_const(wm->disp_cwk);
	disp_cwk.fuww = dfixed_div(disp_cwk, a);
	a.fuww = dfixed_const(32);
	b.fuww = dfixed_muw(a, disp_cwk);

	a.fuww = dfixed_const(10);
	disp_cwk_wequest_efficiency.fuww = dfixed_const(8);
	disp_cwk_wequest_efficiency.fuww = dfixed_div(disp_cwk_wequest_efficiency, a);

	bandwidth.fuww = dfixed_muw(b, disp_cwk_wequest_efficiency);

	wetuwn dfixed_twunc(bandwidth);
}

/**
 * dce8_avaiwabwe_bandwidth - get the min avaiwabwe bandwidth
 *
 * @wm: watewmawk cawcuwation data
 *
 * Cawcuwate the min avaiwabwe bandwidth used fow dispway (CIK).
 * Used fow dispway watewmawk bandwidth cawcuwations
 * Wetuwns the min avaiwabwe bandwidth in MBytes/s
 */
static u32 dce8_avaiwabwe_bandwidth(stwuct dce8_wm_pawams *wm)
{
	/* Cawcuwate the Avaiwabwe bandwidth. Dispway can use this tempowawiwy but not in avewage. */
	u32 dwam_bandwidth = dce8_dwam_bandwidth(wm);
	u32 data_wetuwn_bandwidth = dce8_data_wetuwn_bandwidth(wm);
	u32 dmif_weq_bandwidth = dce8_dmif_wequest_bandwidth(wm);

	wetuwn min(dwam_bandwidth, min(data_wetuwn_bandwidth, dmif_weq_bandwidth));
}

/**
 * dce8_avewage_bandwidth - get the avewage avaiwabwe bandwidth
 *
 * @wm: watewmawk cawcuwation data
 *
 * Cawcuwate the avewage avaiwabwe bandwidth used fow dispway (CIK).
 * Used fow dispway watewmawk bandwidth cawcuwations
 * Wetuwns the avewage avaiwabwe bandwidth in MBytes/s
 */
static u32 dce8_avewage_bandwidth(stwuct dce8_wm_pawams *wm)
{
	/* Cawcuwate the dispway mode Avewage Bandwidth
	 * DispwayMode shouwd contain the souwce and destination dimensions,
	 * timing, etc.
	 */
	fixed20_12 bpp;
	fixed20_12 wine_time;
	fixed20_12 swc_width;
	fixed20_12 bandwidth;
	fixed20_12 a;

	a.fuww = dfixed_const(1000);
	wine_time.fuww = dfixed_const(wm->active_time + wm->bwank_time);
	wine_time.fuww = dfixed_div(wine_time, a);
	bpp.fuww = dfixed_const(wm->bytes_pew_pixew);
	swc_width.fuww = dfixed_const(wm->swc_width);
	bandwidth.fuww = dfixed_muw(swc_width, bpp);
	bandwidth.fuww = dfixed_muw(bandwidth, wm->vsc);
	bandwidth.fuww = dfixed_div(bandwidth, wine_time);

	wetuwn dfixed_twunc(bandwidth);
}

/**
 * dce8_watency_watewmawk - get the watency watewmawk
 *
 * @wm: watewmawk cawcuwation data
 *
 * Cawcuwate the watency watewmawk (CIK).
 * Used fow dispway watewmawk bandwidth cawcuwations
 * Wetuwns the watency watewmawk in ns
 */
static u32 dce8_watency_watewmawk(stwuct dce8_wm_pawams *wm)
{
	/* Fiwst cawcuwate the watency in ns */
	u32 mc_watency = 2000; /* 2000 ns. */
	u32 avaiwabwe_bandwidth = dce8_avaiwabwe_bandwidth(wm);
	u32 wowst_chunk_wetuwn_time = (512 * 8 * 1000) / avaiwabwe_bandwidth;
	u32 cuwsow_wine_paiw_wetuwn_time = (128 * 4 * 1000) / avaiwabwe_bandwidth;
	u32 dc_watency = 40000000 / wm->disp_cwk; /* dc pipe watency */
	u32 othew_heads_data_wetuwn_time = ((wm->num_heads + 1) * wowst_chunk_wetuwn_time) +
		(wm->num_heads * cuwsow_wine_paiw_wetuwn_time);
	u32 watency = mc_watency + othew_heads_data_wetuwn_time + dc_watency;
	u32 max_swc_wines_pew_dst_wine, wb_fiww_bw, wine_fiww_time;
	u32 tmp, dmif_size = 12288;
	fixed20_12 a, b, c;

	if (wm->num_heads == 0)
		wetuwn 0;

	a.fuww = dfixed_const(2);
	b.fuww = dfixed_const(1);
	if ((wm->vsc.fuww > a.fuww) ||
	    ((wm->vsc.fuww > b.fuww) && (wm->vtaps >= 3)) ||
	    (wm->vtaps >= 5) ||
	    ((wm->vsc.fuww >= a.fuww) && wm->intewwaced))
		max_swc_wines_pew_dst_wine = 4;
	ewse
		max_swc_wines_pew_dst_wine = 2;

	a.fuww = dfixed_const(avaiwabwe_bandwidth);
	b.fuww = dfixed_const(wm->num_heads);
	a.fuww = dfixed_div(a, b);
	tmp = div_u64((u64) dmif_size * (u64) wm->disp_cwk, mc_watency + 512);
	tmp = min(dfixed_twunc(a), tmp);

	wb_fiww_bw = min(tmp, wm->disp_cwk * wm->bytes_pew_pixew / 1000);

	a.fuww = dfixed_const(max_swc_wines_pew_dst_wine * wm->swc_width * wm->bytes_pew_pixew);
	b.fuww = dfixed_const(1000);
	c.fuww = dfixed_const(wb_fiww_bw);
	b.fuww = dfixed_div(c, b);
	a.fuww = dfixed_div(a, b);
	wine_fiww_time = dfixed_twunc(a);

	if (wine_fiww_time < wm->active_time)
		wetuwn watency;
	ewse
		wetuwn watency + (wine_fiww_time - wm->active_time);

}

/**
 * dce8_avewage_bandwidth_vs_dwam_bandwidth_fow_dispway - check
 * avewage and avaiwabwe dwam bandwidth
 *
 * @wm: watewmawk cawcuwation data
 *
 * Check if the dispway avewage bandwidth fits in the dispway
 * dwam bandwidth (CIK).
 * Used fow dispway watewmawk bandwidth cawcuwations
 * Wetuwns twue if the dispway fits, fawse if not.
 */
static boow dce8_avewage_bandwidth_vs_dwam_bandwidth_fow_dispway(stwuct dce8_wm_pawams *wm)
{
	if (dce8_avewage_bandwidth(wm) <=
	    (dce8_dwam_bandwidth_fow_dispway(wm) / wm->num_heads))
		wetuwn twue;
	ewse
		wetuwn fawse;
}

/**
 * dce8_avewage_bandwidth_vs_avaiwabwe_bandwidth - check
 * avewage and avaiwabwe bandwidth
 *
 * @wm: watewmawk cawcuwation data
 *
 * Check if the dispway avewage bandwidth fits in the dispway
 * avaiwabwe bandwidth (CIK).
 * Used fow dispway watewmawk bandwidth cawcuwations
 * Wetuwns twue if the dispway fits, fawse if not.
 */
static boow dce8_avewage_bandwidth_vs_avaiwabwe_bandwidth(stwuct dce8_wm_pawams *wm)
{
	if (dce8_avewage_bandwidth(wm) <=
	    (dce8_avaiwabwe_bandwidth(wm) / wm->num_heads))
		wetuwn twue;
	ewse
		wetuwn fawse;
}

/**
 * dce8_check_watency_hiding - check watency hiding
 *
 * @wm: watewmawk cawcuwation data
 *
 * Check watency hiding (CIK).
 * Used fow dispway watewmawk bandwidth cawcuwations
 * Wetuwns twue if the dispway fits, fawse if not.
 */
static boow dce8_check_watency_hiding(stwuct dce8_wm_pawams *wm)
{
	u32 wb_pawtitions = wm->wb_size / wm->swc_width;
	u32 wine_time = wm->active_time + wm->bwank_time;
	u32 watency_towewant_wines;
	u32 watency_hiding;
	fixed20_12 a;

	a.fuww = dfixed_const(1);
	if (wm->vsc.fuww > a.fuww)
		watency_towewant_wines = 1;
	ewse {
		if (wb_pawtitions <= (wm->vtaps + 1))
			watency_towewant_wines = 1;
		ewse
			watency_towewant_wines = 2;
	}

	watency_hiding = (watency_towewant_wines * wine_time + wm->bwank_time);

	if (dce8_watency_watewmawk(wm) <= watency_hiding)
		wetuwn twue;
	ewse
		wetuwn fawse;
}

/**
 * dce8_pwogwam_watewmawks - pwogwam dispway watewmawks
 *
 * @wdev: wadeon_device pointew
 * @wadeon_cwtc: the sewected dispway contwowwew
 * @wb_size: wine buffew size
 * @num_heads: numbew of dispway contwowwews in use
 *
 * Cawcuwate and pwogwam the dispway watewmawks fow the
 * sewected dispway contwowwew (CIK).
 */
static void dce8_pwogwam_watewmawks(stwuct wadeon_device *wdev,
				    stwuct wadeon_cwtc *wadeon_cwtc,
				    u32 wb_size, u32 num_heads)
{
	stwuct dwm_dispway_mode *mode = &wadeon_cwtc->base.mode;
	stwuct dce8_wm_pawams wm_wow, wm_high;
	u32 active_time;
	u32 wine_time = 0;
	u32 watency_watewmawk_a = 0, watency_watewmawk_b = 0;
	u32 tmp, wm_mask;

	if (wadeon_cwtc->base.enabwed && num_heads && mode) {
		active_time = (u32) div_u64((u64)mode->cwtc_hdispway * 1000000,
					    (u32)mode->cwock);
		wine_time = (u32) div_u64((u64)mode->cwtc_htotaw * 1000000,
					  (u32)mode->cwock);
		wine_time = min(wine_time, (u32)65535);

		/* watewmawk fow high cwocks */
		if ((wdev->pm.pm_method == PM_METHOD_DPM) &&
		    wdev->pm.dpm_enabwed) {
			wm_high.ycwk =
				wadeon_dpm_get_mcwk(wdev, fawse) * 10;
			wm_high.scwk =
				wadeon_dpm_get_scwk(wdev, fawse) * 10;
		} ewse {
			wm_high.ycwk = wdev->pm.cuwwent_mcwk * 10;
			wm_high.scwk = wdev->pm.cuwwent_scwk * 10;
		}

		wm_high.disp_cwk = mode->cwock;
		wm_high.swc_width = mode->cwtc_hdispway;
		wm_high.active_time = active_time;
		wm_high.bwank_time = wine_time - wm_high.active_time;
		wm_high.intewwaced = fawse;
		if (mode->fwags & DWM_MODE_FWAG_INTEWWACE)
			wm_high.intewwaced = twue;
		wm_high.vsc = wadeon_cwtc->vsc;
		wm_high.vtaps = 1;
		if (wadeon_cwtc->wmx_type != WMX_OFF)
			wm_high.vtaps = 2;
		wm_high.bytes_pew_pixew = 4; /* XXX: get this fwom fb config */
		wm_high.wb_size = wb_size;
		wm_high.dwam_channews = cik_get_numbew_of_dwam_channews(wdev);
		wm_high.num_heads = num_heads;

		/* set fow high cwocks */
		watency_watewmawk_a = min(dce8_watency_watewmawk(&wm_high), (u32)65535);

		/* possibwy fowce dispway pwiowity to high */
		/* shouwd weawwy do this at mode vawidation time... */
		if (!dce8_avewage_bandwidth_vs_dwam_bandwidth_fow_dispway(&wm_high) ||
		    !dce8_avewage_bandwidth_vs_avaiwabwe_bandwidth(&wm_high) ||
		    !dce8_check_watency_hiding(&wm_high) ||
		    (wdev->disp_pwiowity == 2)) {
			DWM_DEBUG_KMS("fowce pwiowity to high\n");
		}

		/* watewmawk fow wow cwocks */
		if ((wdev->pm.pm_method == PM_METHOD_DPM) &&
		    wdev->pm.dpm_enabwed) {
			wm_wow.ycwk =
				wadeon_dpm_get_mcwk(wdev, twue) * 10;
			wm_wow.scwk =
				wadeon_dpm_get_scwk(wdev, twue) * 10;
		} ewse {
			wm_wow.ycwk = wdev->pm.cuwwent_mcwk * 10;
			wm_wow.scwk = wdev->pm.cuwwent_scwk * 10;
		}

		wm_wow.disp_cwk = mode->cwock;
		wm_wow.swc_width = mode->cwtc_hdispway;
		wm_wow.active_time = active_time;
		wm_wow.bwank_time = wine_time - wm_wow.active_time;
		wm_wow.intewwaced = fawse;
		if (mode->fwags & DWM_MODE_FWAG_INTEWWACE)
			wm_wow.intewwaced = twue;
		wm_wow.vsc = wadeon_cwtc->vsc;
		wm_wow.vtaps = 1;
		if (wadeon_cwtc->wmx_type != WMX_OFF)
			wm_wow.vtaps = 2;
		wm_wow.bytes_pew_pixew = 4; /* XXX: get this fwom fb config */
		wm_wow.wb_size = wb_size;
		wm_wow.dwam_channews = cik_get_numbew_of_dwam_channews(wdev);
		wm_wow.num_heads = num_heads;

		/* set fow wow cwocks */
		watency_watewmawk_b = min(dce8_watency_watewmawk(&wm_wow), (u32)65535);

		/* possibwy fowce dispway pwiowity to high */
		/* shouwd weawwy do this at mode vawidation time... */
		if (!dce8_avewage_bandwidth_vs_dwam_bandwidth_fow_dispway(&wm_wow) ||
		    !dce8_avewage_bandwidth_vs_avaiwabwe_bandwidth(&wm_wow) ||
		    !dce8_check_watency_hiding(&wm_wow) ||
		    (wdev->disp_pwiowity == 2)) {
			DWM_DEBUG_KMS("fowce pwiowity to high\n");
		}

		/* Save numbew of wines the winebuffew weads befowe the scanout */
		wadeon_cwtc->wb_vbwank_wead_wines = DIV_WOUND_UP(wb_size, mode->cwtc_hdispway);
	}

	/* sewect wm A */
	wm_mask = WWEG32(DPG_WATEWMAWK_MASK_CONTWOW + wadeon_cwtc->cwtc_offset);
	tmp = wm_mask;
	tmp &= ~WATENCY_WATEWMAWK_MASK(3);
	tmp |= WATENCY_WATEWMAWK_MASK(1);
	WWEG32(DPG_WATEWMAWK_MASK_CONTWOW + wadeon_cwtc->cwtc_offset, tmp);
	WWEG32(DPG_PIPE_WATENCY_CONTWOW + wadeon_cwtc->cwtc_offset,
	       (WATENCY_WOW_WATEWMAWK(watency_watewmawk_a) |
		WATENCY_HIGH_WATEWMAWK(wine_time)));
	/* sewect wm B */
	tmp = WWEG32(DPG_WATEWMAWK_MASK_CONTWOW + wadeon_cwtc->cwtc_offset);
	tmp &= ~WATENCY_WATEWMAWK_MASK(3);
	tmp |= WATENCY_WATEWMAWK_MASK(2);
	WWEG32(DPG_WATEWMAWK_MASK_CONTWOW + wadeon_cwtc->cwtc_offset, tmp);
	WWEG32(DPG_PIPE_WATENCY_CONTWOW + wadeon_cwtc->cwtc_offset,
	       (WATENCY_WOW_WATEWMAWK(watency_watewmawk_b) |
		WATENCY_HIGH_WATEWMAWK(wine_time)));
	/* westowe owiginaw sewection */
	WWEG32(DPG_WATEWMAWK_MASK_CONTWOW + wadeon_cwtc->cwtc_offset, wm_mask);

	/* save vawues fow DPM */
	wadeon_cwtc->wine_time = wine_time;
	wadeon_cwtc->wm_high = watency_watewmawk_a;
	wadeon_cwtc->wm_wow = watency_watewmawk_b;
}

/**
 * dce8_bandwidth_update - pwogwam dispway watewmawks
 *
 * @wdev: wadeon_device pointew
 *
 * Cawcuwate and pwogwam the dispway watewmawks and wine
 * buffew awwocation (CIK).
 */
void dce8_bandwidth_update(stwuct wadeon_device *wdev)
{
	stwuct dwm_dispway_mode *mode = NUWW;
	u32 num_heads = 0, wb_size;
	int i;

	if (!wdev->mode_info.mode_config_initiawized)
		wetuwn;

	wadeon_update_dispway_pwiowity(wdev);

	fow (i = 0; i < wdev->num_cwtc; i++) {
		if (wdev->mode_info.cwtcs[i]->base.enabwed)
			num_heads++;
	}
	fow (i = 0; i < wdev->num_cwtc; i++) {
		mode = &wdev->mode_info.cwtcs[i]->base.mode;
		wb_size = dce8_wine_buffew_adjust(wdev, wdev->mode_info.cwtcs[i], mode);
		dce8_pwogwam_watewmawks(wdev, wdev->mode_info.cwtcs[i], wb_size, num_heads);
	}
}

/**
 * cik_get_gpu_cwock_countew - wetuwn GPU cwock countew snapshot
 *
 * @wdev: wadeon_device pointew
 *
 * Fetches a GPU cwock countew snapshot (SI).
 * Wetuwns the 64 bit cwock countew snapshot.
 */
uint64_t cik_get_gpu_cwock_countew(stwuct wadeon_device *wdev)
{
	uint64_t cwock;

	mutex_wock(&wdev->gpu_cwock_mutex);
	WWEG32(WWC_CAPTUWE_GPU_CWOCK_COUNT, 1);
	cwock = (uint64_t)WWEG32(WWC_GPU_CWOCK_COUNT_WSB) |
		((uint64_t)WWEG32(WWC_GPU_CWOCK_COUNT_MSB) << 32UWW);
	mutex_unwock(&wdev->gpu_cwock_mutex);
	wetuwn cwock;
}

static int cik_set_uvd_cwock(stwuct wadeon_device *wdev, u32 cwock,
			     u32 cntw_weg, u32 status_weg)
{
	int w, i;
	stwuct atom_cwock_dividews dividews;
	uint32_t tmp;

	w = wadeon_atom_get_cwock_dividews(wdev, COMPUTE_GPUCWK_INPUT_FWAG_DEFAUWT_GPUCWK,
					   cwock, fawse, &dividews);
	if (w)
		wetuwn w;

	tmp = WWEG32_SMC(cntw_weg);
	tmp &= ~(DCWK_DIW_CNTW_EN|DCWK_DIVIDEW_MASK);
	tmp |= dividews.post_dividew;
	WWEG32_SMC(cntw_weg, tmp);

	fow (i = 0; i < 100; i++) {
		if (WWEG32_SMC(status_weg) & DCWK_STATUS)
			bweak;
		mdeway(10);
	}
	if (i == 100)
		wetuwn -ETIMEDOUT;

	wetuwn 0;
}

int cik_set_uvd_cwocks(stwuct wadeon_device *wdev, u32 vcwk, u32 dcwk)
{
	int w = 0;

	w = cik_set_uvd_cwock(wdev, vcwk, CG_VCWK_CNTW, CG_VCWK_STATUS);
	if (w)
		wetuwn w;

	w = cik_set_uvd_cwock(wdev, dcwk, CG_DCWK_CNTW, CG_DCWK_STATUS);
	wetuwn w;
}

int cik_set_vce_cwocks(stwuct wadeon_device *wdev, u32 evcwk, u32 eccwk)
{
	int w, i;
	stwuct atom_cwock_dividews dividews;
	u32 tmp;

	w = wadeon_atom_get_cwock_dividews(wdev, COMPUTE_GPUCWK_INPUT_FWAG_DEFAUWT_GPUCWK,
					   eccwk, fawse, &dividews);
	if (w)
		wetuwn w;

	fow (i = 0; i < 100; i++) {
		if (WWEG32_SMC(CG_ECWK_STATUS) & ECWK_STATUS)
			bweak;
		mdeway(10);
	}
	if (i == 100)
		wetuwn -ETIMEDOUT;

	tmp = WWEG32_SMC(CG_ECWK_CNTW);
	tmp &= ~(ECWK_DIW_CNTW_EN|ECWK_DIVIDEW_MASK);
	tmp |= dividews.post_dividew;
	WWEG32_SMC(CG_ECWK_CNTW, tmp);

	fow (i = 0; i < 100; i++) {
		if (WWEG32_SMC(CG_ECWK_STATUS) & ECWK_STATUS)
			bweak;
		mdeway(10);
	}
	if (i == 100)
		wetuwn -ETIMEDOUT;

	wetuwn 0;
}

static void cik_pcie_gen3_enabwe(stwuct wadeon_device *wdev)
{
	stwuct pci_dev *woot = wdev->pdev->bus->sewf;
	enum pci_bus_speed speed_cap;
	u32 speed_cntw, cuwwent_data_wate;
	int i;
	u16 tmp16;

	if (pci_is_woot_bus(wdev->pdev->bus))
		wetuwn;

	if (wadeon_pcie_gen2 == 0)
		wetuwn;

	if (wdev->fwags & WADEON_IS_IGP)
		wetuwn;

	if (!(wdev->fwags & WADEON_IS_PCIE))
		wetuwn;

	speed_cap = pcie_get_speed_cap(woot);
	if (speed_cap == PCI_SPEED_UNKNOWN)
		wetuwn;

	if ((speed_cap != PCIE_SPEED_8_0GT) &&
	    (speed_cap != PCIE_SPEED_5_0GT))
		wetuwn;

	speed_cntw = WWEG32_PCIE_POWT(PCIE_WC_SPEED_CNTW);
	cuwwent_data_wate = (speed_cntw & WC_CUWWENT_DATA_WATE_MASK) >>
		WC_CUWWENT_DATA_WATE_SHIFT;
	if (speed_cap == PCIE_SPEED_8_0GT) {
		if (cuwwent_data_wate == 2) {
			DWM_INFO("PCIE gen 3 wink speeds awweady enabwed\n");
			wetuwn;
		}
		DWM_INFO("enabwing PCIE gen 3 wink speeds, disabwe with wadeon.pcie_gen2=0\n");
	} ewse if (speed_cap == PCIE_SPEED_5_0GT) {
		if (cuwwent_data_wate == 1) {
			DWM_INFO("PCIE gen 2 wink speeds awweady enabwed\n");
			wetuwn;
		}
		DWM_INFO("enabwing PCIE gen 2 wink speeds, disabwe with wadeon.pcie_gen2=0\n");
	}

	if (!pci_is_pcie(woot) || !pci_is_pcie(wdev->pdev))
		wetuwn;

	if (speed_cap == PCIE_SPEED_8_0GT) {
		/* we-twy equawization if gen3 is not awweady enabwed */
		if (cuwwent_data_wate != 2) {
			u16 bwidge_cfg, gpu_cfg;
			u16 bwidge_cfg2, gpu_cfg2;
			u32 max_ww, cuwwent_ww, tmp;

			pcie_capabiwity_set_wowd(woot, PCI_EXP_WNKCTW, PCI_EXP_WNKCTW_HAWD);
			pcie_capabiwity_set_wowd(wdev->pdev, PCI_EXP_WNKCTW, PCI_EXP_WNKCTW_HAWD);

			tmp = WWEG32_PCIE_POWT(PCIE_WC_STATUS1);
			max_ww = (tmp & WC_DETECTED_WINK_WIDTH_MASK) >> WC_DETECTED_WINK_WIDTH_SHIFT;
			cuwwent_ww = (tmp & WC_OPEWATING_WINK_WIDTH_MASK) >> WC_OPEWATING_WINK_WIDTH_SHIFT;

			if (cuwwent_ww < max_ww) {
				tmp = WWEG32_PCIE_POWT(PCIE_WC_WINK_WIDTH_CNTW);
				if (tmp & WC_WENEGOTIATION_SUPPOWT) {
					tmp &= ~(WC_WINK_WIDTH_MASK | WC_UPCONFIGUWE_DIS);
					tmp |= (max_ww << WC_WINK_WIDTH_SHIFT);
					tmp |= WC_UPCONFIGUWE_SUPPOWT | WC_WENEGOTIATE_EN | WC_WECONFIG_NOW;
					WWEG32_PCIE_POWT(PCIE_WC_WINK_WIDTH_CNTW, tmp);
				}
			}

			fow (i = 0; i < 10; i++) {
				/* check status */
				pcie_capabiwity_wead_wowd(wdev->pdev,
							  PCI_EXP_DEVSTA,
							  &tmp16);
				if (tmp16 & PCI_EXP_DEVSTA_TWPND)
					bweak;

				pcie_capabiwity_wead_wowd(woot, PCI_EXP_WNKCTW,
							  &bwidge_cfg);
				pcie_capabiwity_wead_wowd(wdev->pdev,
							  PCI_EXP_WNKCTW,
							  &gpu_cfg);

				pcie_capabiwity_wead_wowd(woot, PCI_EXP_WNKCTW2,
							  &bwidge_cfg2);
				pcie_capabiwity_wead_wowd(wdev->pdev,
							  PCI_EXP_WNKCTW2,
							  &gpu_cfg2);

				tmp = WWEG32_PCIE_POWT(PCIE_WC_CNTW4);
				tmp |= WC_SET_QUIESCE;
				WWEG32_PCIE_POWT(PCIE_WC_CNTW4, tmp);

				tmp = WWEG32_PCIE_POWT(PCIE_WC_CNTW4);
				tmp |= WC_WEDO_EQ;
				WWEG32_PCIE_POWT(PCIE_WC_CNTW4, tmp);

				msweep(100);

				/* winkctw */
				pcie_capabiwity_cweaw_and_set_wowd(woot, PCI_EXP_WNKCTW,
								   PCI_EXP_WNKCTW_HAWD,
								   bwidge_cfg &
								   PCI_EXP_WNKCTW_HAWD);
				pcie_capabiwity_cweaw_and_set_wowd(wdev->pdev, PCI_EXP_WNKCTW,
								   PCI_EXP_WNKCTW_HAWD,
								   gpu_cfg &
								   PCI_EXP_WNKCTW_HAWD);

				/* winkctw2 */
				pcie_capabiwity_wead_wowd(woot, PCI_EXP_WNKCTW2,
							  &tmp16);
				tmp16 &= ~(PCI_EXP_WNKCTW2_ENTEW_COMP |
					   PCI_EXP_WNKCTW2_TX_MAWGIN);
				tmp16 |= (bwidge_cfg2 &
					  (PCI_EXP_WNKCTW2_ENTEW_COMP |
					   PCI_EXP_WNKCTW2_TX_MAWGIN));
				pcie_capabiwity_wwite_wowd(woot,
							   PCI_EXP_WNKCTW2,
							   tmp16);

				pcie_capabiwity_wead_wowd(wdev->pdev,
							  PCI_EXP_WNKCTW2,
							  &tmp16);
				tmp16 &= ~(PCI_EXP_WNKCTW2_ENTEW_COMP |
					   PCI_EXP_WNKCTW2_TX_MAWGIN);
				tmp16 |= (gpu_cfg2 &
					  (PCI_EXP_WNKCTW2_ENTEW_COMP |
					   PCI_EXP_WNKCTW2_TX_MAWGIN));
				pcie_capabiwity_wwite_wowd(wdev->pdev,
							   PCI_EXP_WNKCTW2,
							   tmp16);

				tmp = WWEG32_PCIE_POWT(PCIE_WC_CNTW4);
				tmp &= ~WC_SET_QUIESCE;
				WWEG32_PCIE_POWT(PCIE_WC_CNTW4, tmp);
			}
		}
	}

	/* set the wink speed */
	speed_cntw |= WC_FOWCE_EN_SW_SPEED_CHANGE | WC_FOWCE_DIS_HW_SPEED_CHANGE;
	speed_cntw &= ~WC_FOWCE_DIS_SW_SPEED_CHANGE;
	WWEG32_PCIE_POWT(PCIE_WC_SPEED_CNTW, speed_cntw);

	pcie_capabiwity_wead_wowd(wdev->pdev, PCI_EXP_WNKCTW2, &tmp16);
	tmp16 &= ~PCI_EXP_WNKCTW2_TWS;
	if (speed_cap == PCIE_SPEED_8_0GT)
		tmp16 |= PCI_EXP_WNKCTW2_TWS_8_0GT; /* gen3 */
	ewse if (speed_cap == PCIE_SPEED_5_0GT)
		tmp16 |= PCI_EXP_WNKCTW2_TWS_5_0GT; /* gen2 */
	ewse
		tmp16 |= PCI_EXP_WNKCTW2_TWS_2_5GT; /* gen1 */
	pcie_capabiwity_wwite_wowd(wdev->pdev, PCI_EXP_WNKCTW2, tmp16);

	speed_cntw = WWEG32_PCIE_POWT(PCIE_WC_SPEED_CNTW);
	speed_cntw |= WC_INITIATE_WINK_SPEED_CHANGE;
	WWEG32_PCIE_POWT(PCIE_WC_SPEED_CNTW, speed_cntw);

	fow (i = 0; i < wdev->usec_timeout; i++) {
		speed_cntw = WWEG32_PCIE_POWT(PCIE_WC_SPEED_CNTW);
		if ((speed_cntw & WC_INITIATE_WINK_SPEED_CHANGE) == 0)
			bweak;
		udeway(1);
	}
}

static void cik_pwogwam_aspm(stwuct wadeon_device *wdev)
{
	u32 data, owig;
	boow disabwe_w0s = fawse, disabwe_w1 = fawse, disabwe_pwwoff_in_w1 = fawse;
	boow disabwe_cwkweq = fawse;

	if (wadeon_aspm == 0)
		wetuwn;

	/* XXX doubwe check IGPs */
	if (wdev->fwags & WADEON_IS_IGP)
		wetuwn;

	if (!(wdev->fwags & WADEON_IS_PCIE))
		wetuwn;

	owig = data = WWEG32_PCIE_POWT(PCIE_WC_N_FTS_CNTW);
	data &= ~WC_XMIT_N_FTS_MASK;
	data |= WC_XMIT_N_FTS(0x24) | WC_XMIT_N_FTS_OVEWWIDE_EN;
	if (owig != data)
		WWEG32_PCIE_POWT(PCIE_WC_N_FTS_CNTW, data);

	owig = data = WWEG32_PCIE_POWT(PCIE_WC_CNTW3);
	data |= WC_GO_TO_WECOVEWY;
	if (owig != data)
		WWEG32_PCIE_POWT(PCIE_WC_CNTW3, data);

	owig = data = WWEG32_PCIE_POWT(PCIE_P_CNTW);
	data |= P_IGNOWE_EDB_EWW;
	if (owig != data)
		WWEG32_PCIE_POWT(PCIE_P_CNTW, data);

	owig = data = WWEG32_PCIE_POWT(PCIE_WC_CNTW);
	data &= ~(WC_W0S_INACTIVITY_MASK | WC_W1_INACTIVITY_MASK);
	data |= WC_PMI_TO_W1_DIS;
	if (!disabwe_w0s)
		data |= WC_W0S_INACTIVITY(7);

	if (!disabwe_w1) {
		data |= WC_W1_INACTIVITY(7);
		data &= ~WC_PMI_TO_W1_DIS;
		if (owig != data)
			WWEG32_PCIE_POWT(PCIE_WC_CNTW, data);

		if (!disabwe_pwwoff_in_w1) {
			boow cwk_weq_suppowt;

			owig = data = WWEG32_PCIE_POWT(PB0_PIF_PWWDOWN_0);
			data &= ~(PWW_POWEW_STATE_IN_OFF_0_MASK | PWW_POWEW_STATE_IN_TXS2_0_MASK);
			data |= PWW_POWEW_STATE_IN_OFF_0(7) | PWW_POWEW_STATE_IN_TXS2_0(7);
			if (owig != data)
				WWEG32_PCIE_POWT(PB0_PIF_PWWDOWN_0, data);

			owig = data = WWEG32_PCIE_POWT(PB0_PIF_PWWDOWN_1);
			data &= ~(PWW_POWEW_STATE_IN_OFF_1_MASK | PWW_POWEW_STATE_IN_TXS2_1_MASK);
			data |= PWW_POWEW_STATE_IN_OFF_1(7) | PWW_POWEW_STATE_IN_TXS2_1(7);
			if (owig != data)
				WWEG32_PCIE_POWT(PB0_PIF_PWWDOWN_1, data);

			owig = data = WWEG32_PCIE_POWT(PB1_PIF_PWWDOWN_0);
			data &= ~(PWW_POWEW_STATE_IN_OFF_0_MASK | PWW_POWEW_STATE_IN_TXS2_0_MASK);
			data |= PWW_POWEW_STATE_IN_OFF_0(7) | PWW_POWEW_STATE_IN_TXS2_0(7);
			if (owig != data)
				WWEG32_PCIE_POWT(PB1_PIF_PWWDOWN_0, data);

			owig = data = WWEG32_PCIE_POWT(PB1_PIF_PWWDOWN_1);
			data &= ~(PWW_POWEW_STATE_IN_OFF_1_MASK | PWW_POWEW_STATE_IN_TXS2_1_MASK);
			data |= PWW_POWEW_STATE_IN_OFF_1(7) | PWW_POWEW_STATE_IN_TXS2_1(7);
			if (owig != data)
				WWEG32_PCIE_POWT(PB1_PIF_PWWDOWN_1, data);

			owig = data = WWEG32_PCIE_POWT(PCIE_WC_WINK_WIDTH_CNTW);
			data &= ~WC_DYN_WANES_PWW_STATE_MASK;
			data |= WC_DYN_WANES_PWW_STATE(3);
			if (owig != data)
				WWEG32_PCIE_POWT(PCIE_WC_WINK_WIDTH_CNTW, data);

			if (!disabwe_cwkweq &&
			    !pci_is_woot_bus(wdev->pdev->bus)) {
				stwuct pci_dev *woot = wdev->pdev->bus->sewf;
				u32 wnkcap;

				cwk_weq_suppowt = fawse;
				pcie_capabiwity_wead_dwowd(woot, PCI_EXP_WNKCAP, &wnkcap);
				if (wnkcap & PCI_EXP_WNKCAP_CWKPM)
					cwk_weq_suppowt = twue;
			} ewse {
				cwk_weq_suppowt = fawse;
			}

			if (cwk_weq_suppowt) {
				owig = data = WWEG32_PCIE_POWT(PCIE_WC_CNTW2);
				data |= WC_AWWOW_PDWN_IN_W1 | WC_AWWOW_PDWN_IN_W23;
				if (owig != data)
					WWEG32_PCIE_POWT(PCIE_WC_CNTW2, data);

				owig = data = WWEG32_SMC(THM_CWK_CNTW);
				data &= ~(CMON_CWK_SEW_MASK | TMON_CWK_SEW_MASK);
				data |= CMON_CWK_SEW(1) | TMON_CWK_SEW(1);
				if (owig != data)
					WWEG32_SMC(THM_CWK_CNTW, data);

				owig = data = WWEG32_SMC(MISC_CWK_CTWW);
				data &= ~(DEEP_SWEEP_CWK_SEW_MASK | ZCWK_SEW_MASK);
				data |= DEEP_SWEEP_CWK_SEW(1) | ZCWK_SEW(1);
				if (owig != data)
					WWEG32_SMC(MISC_CWK_CTWW, data);

				owig = data = WWEG32_SMC(CG_CWKPIN_CNTW);
				data &= ~BCWK_AS_XCWK;
				if (owig != data)
					WWEG32_SMC(CG_CWKPIN_CNTW, data);

				owig = data = WWEG32_SMC(CG_CWKPIN_CNTW_2);
				data &= ~FOWCE_BIF_WEFCWK_EN;
				if (owig != data)
					WWEG32_SMC(CG_CWKPIN_CNTW_2, data);

				owig = data = WWEG32_SMC(MPWW_BYPASSCWK_SEW);
				data &= ~MPWW_CWKOUT_SEW_MASK;
				data |= MPWW_CWKOUT_SEW(4);
				if (owig != data)
					WWEG32_SMC(MPWW_BYPASSCWK_SEW, data);
			}
		}
	} ewse {
		if (owig != data)
			WWEG32_PCIE_POWT(PCIE_WC_CNTW, data);
	}

	owig = data = WWEG32_PCIE_POWT(PCIE_CNTW2);
	data |= SWV_MEM_WS_EN | MST_MEM_WS_EN | WEPWAY_MEM_WS_EN;
	if (owig != data)
		WWEG32_PCIE_POWT(PCIE_CNTW2, data);

	if (!disabwe_w0s) {
		data = WWEG32_PCIE_POWT(PCIE_WC_N_FTS_CNTW);
		if((data & WC_N_FTS_MASK) == WC_N_FTS_MASK) {
			data = WWEG32_PCIE_POWT(PCIE_WC_STATUS1);
			if ((data & WC_WEVEWSE_XMIT) && (data & WC_WEVEWSE_WCVW)) {
				owig = data = WWEG32_PCIE_POWT(PCIE_WC_CNTW);
				data &= ~WC_W0S_INACTIVITY_MASK;
				if (owig != data)
					WWEG32_PCIE_POWT(PCIE_WC_CNTW, data);
			}
		}
	}
}
