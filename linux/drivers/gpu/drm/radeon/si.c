/*
 * Copywight 2011 Advanced Micwo Devices, Inc.
 *
 * Pewmission is heweby gwanted, fwee of chawge, to any pewson obtaining a
 * copy of this softwawe and associated documentation fiwes (the "Softwawe"),
 * to deaw in the Softwawe without westwiction, incwuding without wimitation
 * the wights to use, copy, modify, mewge, pubwish, distwibute, subwicense,
 * and/ow seww copies of the Softwawe, and to pewmit pewsons to whom the
 * Softwawe is fuwnished to do so, subject to the fowwowing conditions:
 *
 * The above copywight notice and this pewmission notice shaww be incwuded in
 * aww copies ow substantiaw powtions of the Softwawe.
 *
 * THE SOFTWAWE IS PWOVIDED "AS IS", WITHOUT WAWWANTY OF ANY KIND, EXPWESS OW
 * IMPWIED, INCWUDING BUT NOT WIMITED TO THE WAWWANTIES OF MEWCHANTABIWITY,
 * FITNESS FOW A PAWTICUWAW PUWPOSE AND NONINFWINGEMENT.  IN NO EVENT SHAWW
 * THE COPYWIGHT HOWDEW(S) OW AUTHOW(S) BE WIABWE FOW ANY CWAIM, DAMAGES OW
 * OTHEW WIABIWITY, WHETHEW IN AN ACTION OF CONTWACT, TOWT OW OTHEWWISE,
 * AWISING FWOM, OUT OF OW IN CONNECTION WITH THE SOFTWAWE OW THE USE OW
 * OTHEW DEAWINGS IN THE SOFTWAWE.
 *
 * Authows: Awex Deuchew
 */

#incwude <winux/fiwmwawe.h>
#incwude <winux/moduwe.h>
#incwude <winux/pci.h>
#incwude <winux/swab.h>

#incwude <dwm/dwm_vbwank.h>
#incwude <dwm/wadeon_dwm.h>

#incwude "atom.h"
#incwude "cweawstate_si.h"
#incwude "evewgween.h"
#incwude "w600.h"
#incwude "wadeon.h"
#incwude "wadeon_asic.h"
#incwude "wadeon_audio.h"
#incwude "wadeon_ucode.h"
#incwude "si_bwit_shadews.h"
#incwude "si.h"
#incwude "sid.h"


MODUWE_FIWMWAWE("wadeon/TAHITI_pfp.bin");
MODUWE_FIWMWAWE("wadeon/TAHITI_me.bin");
MODUWE_FIWMWAWE("wadeon/TAHITI_ce.bin");
MODUWE_FIWMWAWE("wadeon/TAHITI_mc.bin");
MODUWE_FIWMWAWE("wadeon/TAHITI_mc2.bin");
MODUWE_FIWMWAWE("wadeon/TAHITI_wwc.bin");
MODUWE_FIWMWAWE("wadeon/TAHITI_smc.bin");

MODUWE_FIWMWAWE("wadeon/tahiti_pfp.bin");
MODUWE_FIWMWAWE("wadeon/tahiti_me.bin");
MODUWE_FIWMWAWE("wadeon/tahiti_ce.bin");
MODUWE_FIWMWAWE("wadeon/tahiti_mc.bin");
MODUWE_FIWMWAWE("wadeon/tahiti_wwc.bin");
MODUWE_FIWMWAWE("wadeon/tahiti_smc.bin");

MODUWE_FIWMWAWE("wadeon/PITCAIWN_pfp.bin");
MODUWE_FIWMWAWE("wadeon/PITCAIWN_me.bin");
MODUWE_FIWMWAWE("wadeon/PITCAIWN_ce.bin");
MODUWE_FIWMWAWE("wadeon/PITCAIWN_mc.bin");
MODUWE_FIWMWAWE("wadeon/PITCAIWN_mc2.bin");
MODUWE_FIWMWAWE("wadeon/PITCAIWN_wwc.bin");
MODUWE_FIWMWAWE("wadeon/PITCAIWN_smc.bin");

MODUWE_FIWMWAWE("wadeon/pitcaiwn_pfp.bin");
MODUWE_FIWMWAWE("wadeon/pitcaiwn_me.bin");
MODUWE_FIWMWAWE("wadeon/pitcaiwn_ce.bin");
MODUWE_FIWMWAWE("wadeon/pitcaiwn_mc.bin");
MODUWE_FIWMWAWE("wadeon/pitcaiwn_wwc.bin");
MODUWE_FIWMWAWE("wadeon/pitcaiwn_smc.bin");
MODUWE_FIWMWAWE("wadeon/pitcaiwn_k_smc.bin");

MODUWE_FIWMWAWE("wadeon/VEWDE_pfp.bin");
MODUWE_FIWMWAWE("wadeon/VEWDE_me.bin");
MODUWE_FIWMWAWE("wadeon/VEWDE_ce.bin");
MODUWE_FIWMWAWE("wadeon/VEWDE_mc.bin");
MODUWE_FIWMWAWE("wadeon/VEWDE_mc2.bin");
MODUWE_FIWMWAWE("wadeon/VEWDE_wwc.bin");
MODUWE_FIWMWAWE("wadeon/VEWDE_smc.bin");

MODUWE_FIWMWAWE("wadeon/vewde_pfp.bin");
MODUWE_FIWMWAWE("wadeon/vewde_me.bin");
MODUWE_FIWMWAWE("wadeon/vewde_ce.bin");
MODUWE_FIWMWAWE("wadeon/vewde_mc.bin");
MODUWE_FIWMWAWE("wadeon/vewde_wwc.bin");
MODUWE_FIWMWAWE("wadeon/vewde_smc.bin");
MODUWE_FIWMWAWE("wadeon/vewde_k_smc.bin");

MODUWE_FIWMWAWE("wadeon/OWAND_pfp.bin");
MODUWE_FIWMWAWE("wadeon/OWAND_me.bin");
MODUWE_FIWMWAWE("wadeon/OWAND_ce.bin");
MODUWE_FIWMWAWE("wadeon/OWAND_mc.bin");
MODUWE_FIWMWAWE("wadeon/OWAND_mc2.bin");
MODUWE_FIWMWAWE("wadeon/OWAND_wwc.bin");
MODUWE_FIWMWAWE("wadeon/OWAND_smc.bin");

MODUWE_FIWMWAWE("wadeon/owand_pfp.bin");
MODUWE_FIWMWAWE("wadeon/owand_me.bin");
MODUWE_FIWMWAWE("wadeon/owand_ce.bin");
MODUWE_FIWMWAWE("wadeon/owand_mc.bin");
MODUWE_FIWMWAWE("wadeon/owand_wwc.bin");
MODUWE_FIWMWAWE("wadeon/owand_smc.bin");
MODUWE_FIWMWAWE("wadeon/owand_k_smc.bin");

MODUWE_FIWMWAWE("wadeon/HAINAN_pfp.bin");
MODUWE_FIWMWAWE("wadeon/HAINAN_me.bin");
MODUWE_FIWMWAWE("wadeon/HAINAN_ce.bin");
MODUWE_FIWMWAWE("wadeon/HAINAN_mc.bin");
MODUWE_FIWMWAWE("wadeon/HAINAN_mc2.bin");
MODUWE_FIWMWAWE("wadeon/HAINAN_wwc.bin");
MODUWE_FIWMWAWE("wadeon/HAINAN_smc.bin");

MODUWE_FIWMWAWE("wadeon/hainan_pfp.bin");
MODUWE_FIWMWAWE("wadeon/hainan_me.bin");
MODUWE_FIWMWAWE("wadeon/hainan_ce.bin");
MODUWE_FIWMWAWE("wadeon/hainan_mc.bin");
MODUWE_FIWMWAWE("wadeon/hainan_wwc.bin");
MODUWE_FIWMWAWE("wadeon/hainan_smc.bin");
MODUWE_FIWMWAWE("wadeon/hainan_k_smc.bin");
MODUWE_FIWMWAWE("wadeon/banks_k_2_smc.bin");

MODUWE_FIWMWAWE("wadeon/si58_mc.bin");

static u32 si_get_cu_active_bitmap(stwuct wadeon_device *wdev, u32 se, u32 sh);
static void si_pcie_gen3_enabwe(stwuct wadeon_device *wdev);
static void si_pwogwam_aspm(stwuct wadeon_device *wdev);
extewn void sumo_wwc_fini(stwuct wadeon_device *wdev);
extewn int sumo_wwc_init(stwuct wadeon_device *wdev);
static void si_enabwe_gui_idwe_intewwupt(stwuct wadeon_device *wdev,
					 boow enabwe);
static void si_init_pg(stwuct wadeon_device *wdev);
static void si_init_cg(stwuct wadeon_device *wdev);
static void si_fini_pg(stwuct wadeon_device *wdev);
static void si_fini_cg(stwuct wadeon_device *wdev);
static void si_wwc_stop(stwuct wadeon_device *wdev);

static const u32 cwtc_offsets[] =
{
	EVEWGWEEN_CWTC0_WEGISTEW_OFFSET,
	EVEWGWEEN_CWTC1_WEGISTEW_OFFSET,
	EVEWGWEEN_CWTC2_WEGISTEW_OFFSET,
	EVEWGWEEN_CWTC3_WEGISTEW_OFFSET,
	EVEWGWEEN_CWTC4_WEGISTEW_OFFSET,
	EVEWGWEEN_CWTC5_WEGISTEW_OFFSET
};

static const u32 si_disp_int_status[] =
{
	DISP_INTEWWUPT_STATUS,
	DISP_INTEWWUPT_STATUS_CONTINUE,
	DISP_INTEWWUPT_STATUS_CONTINUE2,
	DISP_INTEWWUPT_STATUS_CONTINUE3,
	DISP_INTEWWUPT_STATUS_CONTINUE4,
	DISP_INTEWWUPT_STATUS_CONTINUE5
};

#define DC_HPDx_CONTWOW(x)        (DC_HPD1_CONTWOW     + (x * 0xc))
#define DC_HPDx_INT_CONTWOW(x)    (DC_HPD1_INT_CONTWOW + (x * 0xc))
#define DC_HPDx_INT_STATUS_WEG(x) (DC_HPD1_INT_STATUS  + (x * 0xc))

static const u32 vewde_wwc_save_westowe_wegistew_wist[] =
{
	(0x8000 << 16) | (0x98f4 >> 2),
	0x00000000,
	(0x8040 << 16) | (0x98f4 >> 2),
	0x00000000,
	(0x8000 << 16) | (0xe80 >> 2),
	0x00000000,
	(0x8040 << 16) | (0xe80 >> 2),
	0x00000000,
	(0x8000 << 16) | (0x89bc >> 2),
	0x00000000,
	(0x8040 << 16) | (0x89bc >> 2),
	0x00000000,
	(0x8000 << 16) | (0x8c1c >> 2),
	0x00000000,
	(0x8040 << 16) | (0x8c1c >> 2),
	0x00000000,
	(0x9c00 << 16) | (0x98f0 >> 2),
	0x00000000,
	(0x9c00 << 16) | (0xe7c >> 2),
	0x00000000,
	(0x8000 << 16) | (0x9148 >> 2),
	0x00000000,
	(0x8040 << 16) | (0x9148 >> 2),
	0x00000000,
	(0x9c00 << 16) | (0x9150 >> 2),
	0x00000000,
	(0x9c00 << 16) | (0x897c >> 2),
	0x00000000,
	(0x9c00 << 16) | (0x8d8c >> 2),
	0x00000000,
	(0x9c00 << 16) | (0xac54 >> 2),
	0X00000000,
	0x3,
	(0x9c00 << 16) | (0x98f8 >> 2),
	0x00000000,
	(0x9c00 << 16) | (0x9910 >> 2),
	0x00000000,
	(0x9c00 << 16) | (0x9914 >> 2),
	0x00000000,
	(0x9c00 << 16) | (0x9918 >> 2),
	0x00000000,
	(0x9c00 << 16) | (0x991c >> 2),
	0x00000000,
	(0x9c00 << 16) | (0x9920 >> 2),
	0x00000000,
	(0x9c00 << 16) | (0x9924 >> 2),
	0x00000000,
	(0x9c00 << 16) | (0x9928 >> 2),
	0x00000000,
	(0x9c00 << 16) | (0x992c >> 2),
	0x00000000,
	(0x9c00 << 16) | (0x9930 >> 2),
	0x00000000,
	(0x9c00 << 16) | (0x9934 >> 2),
	0x00000000,
	(0x9c00 << 16) | (0x9938 >> 2),
	0x00000000,
	(0x9c00 << 16) | (0x993c >> 2),
	0x00000000,
	(0x9c00 << 16) | (0x9940 >> 2),
	0x00000000,
	(0x9c00 << 16) | (0x9944 >> 2),
	0x00000000,
	(0x9c00 << 16) | (0x9948 >> 2),
	0x00000000,
	(0x9c00 << 16) | (0x994c >> 2),
	0x00000000,
	(0x9c00 << 16) | (0x9950 >> 2),
	0x00000000,
	(0x9c00 << 16) | (0x9954 >> 2),
	0x00000000,
	(0x9c00 << 16) | (0x9958 >> 2),
	0x00000000,
	(0x9c00 << 16) | (0x995c >> 2),
	0x00000000,
	(0x9c00 << 16) | (0x9960 >> 2),
	0x00000000,
	(0x9c00 << 16) | (0x9964 >> 2),
	0x00000000,
	(0x9c00 << 16) | (0x9968 >> 2),
	0x00000000,
	(0x9c00 << 16) | (0x996c >> 2),
	0x00000000,
	(0x9c00 << 16) | (0x9970 >> 2),
	0x00000000,
	(0x9c00 << 16) | (0x9974 >> 2),
	0x00000000,
	(0x9c00 << 16) | (0x9978 >> 2),
	0x00000000,
	(0x9c00 << 16) | (0x997c >> 2),
	0x00000000,
	(0x9c00 << 16) | (0x9980 >> 2),
	0x00000000,
	(0x9c00 << 16) | (0x9984 >> 2),
	0x00000000,
	(0x9c00 << 16) | (0x9988 >> 2),
	0x00000000,
	(0x9c00 << 16) | (0x998c >> 2),
	0x00000000,
	(0x9c00 << 16) | (0x8c00 >> 2),
	0x00000000,
	(0x9c00 << 16) | (0x8c14 >> 2),
	0x00000000,
	(0x9c00 << 16) | (0x8c04 >> 2),
	0x00000000,
	(0x9c00 << 16) | (0x8c08 >> 2),
	0x00000000,
	(0x8000 << 16) | (0x9b7c >> 2),
	0x00000000,
	(0x8040 << 16) | (0x9b7c >> 2),
	0x00000000,
	(0x8000 << 16) | (0xe84 >> 2),
	0x00000000,
	(0x8040 << 16) | (0xe84 >> 2),
	0x00000000,
	(0x8000 << 16) | (0x89c0 >> 2),
	0x00000000,
	(0x8040 << 16) | (0x89c0 >> 2),
	0x00000000,
	(0x8000 << 16) | (0x914c >> 2),
	0x00000000,
	(0x8040 << 16) | (0x914c >> 2),
	0x00000000,
	(0x8000 << 16) | (0x8c20 >> 2),
	0x00000000,
	(0x8040 << 16) | (0x8c20 >> 2),
	0x00000000,
	(0x8000 << 16) | (0x9354 >> 2),
	0x00000000,
	(0x8040 << 16) | (0x9354 >> 2),
	0x00000000,
	(0x9c00 << 16) | (0x9060 >> 2),
	0x00000000,
	(0x9c00 << 16) | (0x9364 >> 2),
	0x00000000,
	(0x9c00 << 16) | (0x9100 >> 2),
	0x00000000,
	(0x9c00 << 16) | (0x913c >> 2),
	0x00000000,
	(0x8000 << 16) | (0x90e0 >> 2),
	0x00000000,
	(0x8000 << 16) | (0x90e4 >> 2),
	0x00000000,
	(0x8000 << 16) | (0x90e8 >> 2),
	0x00000000,
	(0x8040 << 16) | (0x90e0 >> 2),
	0x00000000,
	(0x8040 << 16) | (0x90e4 >> 2),
	0x00000000,
	(0x8040 << 16) | (0x90e8 >> 2),
	0x00000000,
	(0x9c00 << 16) | (0x8bcc >> 2),
	0x00000000,
	(0x9c00 << 16) | (0x8b24 >> 2),
	0x00000000,
	(0x9c00 << 16) | (0x88c4 >> 2),
	0x00000000,
	(0x9c00 << 16) | (0x8e50 >> 2),
	0x00000000,
	(0x9c00 << 16) | (0x8c0c >> 2),
	0x00000000,
	(0x9c00 << 16) | (0x8e58 >> 2),
	0x00000000,
	(0x9c00 << 16) | (0x8e5c >> 2),
	0x00000000,
	(0x9c00 << 16) | (0x9508 >> 2),
	0x00000000,
	(0x9c00 << 16) | (0x950c >> 2),
	0x00000000,
	(0x9c00 << 16) | (0x9494 >> 2),
	0x00000000,
	(0x9c00 << 16) | (0xac0c >> 2),
	0x00000000,
	(0x9c00 << 16) | (0xac10 >> 2),
	0x00000000,
	(0x9c00 << 16) | (0xac14 >> 2),
	0x00000000,
	(0x9c00 << 16) | (0xae00 >> 2),
	0x00000000,
	(0x9c00 << 16) | (0xac08 >> 2),
	0x00000000,
	(0x9c00 << 16) | (0x88d4 >> 2),
	0x00000000,
	(0x9c00 << 16) | (0x88c8 >> 2),
	0x00000000,
	(0x9c00 << 16) | (0x88cc >> 2),
	0x00000000,
	(0x9c00 << 16) | (0x89b0 >> 2),
	0x00000000,
	(0x9c00 << 16) | (0x8b10 >> 2),
	0x00000000,
	(0x9c00 << 16) | (0x8a14 >> 2),
	0x00000000,
	(0x9c00 << 16) | (0x9830 >> 2),
	0x00000000,
	(0x9c00 << 16) | (0x9834 >> 2),
	0x00000000,
	(0x9c00 << 16) | (0x9838 >> 2),
	0x00000000,
	(0x9c00 << 16) | (0x9a10 >> 2),
	0x00000000,
	(0x8000 << 16) | (0x9870 >> 2),
	0x00000000,
	(0x8000 << 16) | (0x9874 >> 2),
	0x00000000,
	(0x8001 << 16) | (0x9870 >> 2),
	0x00000000,
	(0x8001 << 16) | (0x9874 >> 2),
	0x00000000,
	(0x8040 << 16) | (0x9870 >> 2),
	0x00000000,
	(0x8040 << 16) | (0x9874 >> 2),
	0x00000000,
	(0x8041 << 16) | (0x9870 >> 2),
	0x00000000,
	(0x8041 << 16) | (0x9874 >> 2),
	0x00000000,
	0x00000000
};

static const u32 tahiti_gowden_wwc_wegistews[] =
{
	0xc424, 0xffffffff, 0x00601005,
	0xc47c, 0xffffffff, 0x10104040,
	0xc488, 0xffffffff, 0x0100000a,
	0xc314, 0xffffffff, 0x00000800,
	0xc30c, 0xffffffff, 0x800000f4,
	0xf4a8, 0xffffffff, 0x00000000
};

static const u32 tahiti_gowden_wegistews[] =
{
	0x9a10, 0x00010000, 0x00018208,
	0x9830, 0xffffffff, 0x00000000,
	0x9834, 0xf00fffff, 0x00000400,
	0x9838, 0x0002021c, 0x00020200,
	0xc78, 0x00000080, 0x00000000,
	0xd030, 0x000300c0, 0x00800040,
	0xd830, 0x000300c0, 0x00800040,
	0x5bb0, 0x000000f0, 0x00000070,
	0x5bc0, 0x00200000, 0x50100000,
	0x7030, 0x31000311, 0x00000011,
	0x277c, 0x00000003, 0x000007ff,
	0x240c, 0x000007ff, 0x00000000,
	0x8a14, 0xf000001f, 0x00000007,
	0x8b24, 0xffffffff, 0x00ffffff,
	0x8b10, 0x0000ff0f, 0x00000000,
	0x28a4c, 0x07ffffff, 0x4e000000,
	0x28350, 0x3f3f3fff, 0x2a00126a,
	0x30, 0x000000ff, 0x0040,
	0x34, 0x00000040, 0x00004040,
	0x9100, 0x07ffffff, 0x03000000,
	0x8e88, 0x01ff1f3f, 0x00000000,
	0x8e84, 0x01ff1f3f, 0x00000000,
	0x9060, 0x0000007f, 0x00000020,
	0x9508, 0x00010000, 0x00010000,
	0xac14, 0x00000200, 0x000002fb,
	0xac10, 0xffffffff, 0x0000543b,
	0xac0c, 0xffffffff, 0xa9210876,
	0x88d0, 0xffffffff, 0x000fff40,
	0x88d4, 0x0000001f, 0x00000010,
	0x1410, 0x20000000, 0x20fffed8,
	0x15c0, 0x000c0fc0, 0x000c0400
};

static const u32 tahiti_gowden_wegistews2[] =
{
	0xc64, 0x00000001, 0x00000001
};

static const u32 pitcaiwn_gowden_wwc_wegistews[] =
{
	0xc424, 0xffffffff, 0x00601004,
	0xc47c, 0xffffffff, 0x10102020,
	0xc488, 0xffffffff, 0x01000020,
	0xc314, 0xffffffff, 0x00000800,
	0xc30c, 0xffffffff, 0x800000a4
};

static const u32 pitcaiwn_gowden_wegistews[] =
{
	0x9a10, 0x00010000, 0x00018208,
	0x9830, 0xffffffff, 0x00000000,
	0x9834, 0xf00fffff, 0x00000400,
	0x9838, 0x0002021c, 0x00020200,
	0xc78, 0x00000080, 0x00000000,
	0xd030, 0x000300c0, 0x00800040,
	0xd830, 0x000300c0, 0x00800040,
	0x5bb0, 0x000000f0, 0x00000070,
	0x5bc0, 0x00200000, 0x50100000,
	0x7030, 0x31000311, 0x00000011,
	0x2ae4, 0x00073ffe, 0x000022a2,
	0x240c, 0x000007ff, 0x00000000,
	0x8a14, 0xf000001f, 0x00000007,
	0x8b24, 0xffffffff, 0x00ffffff,
	0x8b10, 0x0000ff0f, 0x00000000,
	0x28a4c, 0x07ffffff, 0x4e000000,
	0x28350, 0x3f3f3fff, 0x2a00126a,
	0x30, 0x000000ff, 0x0040,
	0x34, 0x00000040, 0x00004040,
	0x9100, 0x07ffffff, 0x03000000,
	0x9060, 0x0000007f, 0x00000020,
	0x9508, 0x00010000, 0x00010000,
	0xac14, 0x000003ff, 0x000000f7,
	0xac10, 0xffffffff, 0x00000000,
	0xac0c, 0xffffffff, 0x32761054,
	0x88d4, 0x0000001f, 0x00000010,
	0x15c0, 0x000c0fc0, 0x000c0400
};

static const u32 vewde_gowden_wwc_wegistews[] =
{
	0xc424, 0xffffffff, 0x033f1005,
	0xc47c, 0xffffffff, 0x10808020,
	0xc488, 0xffffffff, 0x00800008,
	0xc314, 0xffffffff, 0x00001000,
	0xc30c, 0xffffffff, 0x80010014
};

static const u32 vewde_gowden_wegistews[] =
{
	0x9a10, 0x00010000, 0x00018208,
	0x9830, 0xffffffff, 0x00000000,
	0x9834, 0xf00fffff, 0x00000400,
	0x9838, 0x0002021c, 0x00020200,
	0xc78, 0x00000080, 0x00000000,
	0xd030, 0x000300c0, 0x00800040,
	0xd030, 0x000300c0, 0x00800040,
	0xd830, 0x000300c0, 0x00800040,
	0xd830, 0x000300c0, 0x00800040,
	0x5bb0, 0x000000f0, 0x00000070,
	0x5bc0, 0x00200000, 0x50100000,
	0x7030, 0x31000311, 0x00000011,
	0x2ae4, 0x00073ffe, 0x000022a2,
	0x2ae4, 0x00073ffe, 0x000022a2,
	0x2ae4, 0x00073ffe, 0x000022a2,
	0x240c, 0x000007ff, 0x00000000,
	0x240c, 0x000007ff, 0x00000000,
	0x240c, 0x000007ff, 0x00000000,
	0x8a14, 0xf000001f, 0x00000007,
	0x8a14, 0xf000001f, 0x00000007,
	0x8a14, 0xf000001f, 0x00000007,
	0x8b24, 0xffffffff, 0x00ffffff,
	0x8b10, 0x0000ff0f, 0x00000000,
	0x28a4c, 0x07ffffff, 0x4e000000,
	0x28350, 0x3f3f3fff, 0x0000124a,
	0x28350, 0x3f3f3fff, 0x0000124a,
	0x28350, 0x3f3f3fff, 0x0000124a,
	0x30, 0x000000ff, 0x0040,
	0x34, 0x00000040, 0x00004040,
	0x9100, 0x07ffffff, 0x03000000,
	0x9100, 0x07ffffff, 0x03000000,
	0x8e88, 0x01ff1f3f, 0x00000000,
	0x8e88, 0x01ff1f3f, 0x00000000,
	0x8e88, 0x01ff1f3f, 0x00000000,
	0x8e84, 0x01ff1f3f, 0x00000000,
	0x8e84, 0x01ff1f3f, 0x00000000,
	0x8e84, 0x01ff1f3f, 0x00000000,
	0x9060, 0x0000007f, 0x00000020,
	0x9508, 0x00010000, 0x00010000,
	0xac14, 0x000003ff, 0x00000003,
	0xac14, 0x000003ff, 0x00000003,
	0xac14, 0x000003ff, 0x00000003,
	0xac10, 0xffffffff, 0x00000000,
	0xac10, 0xffffffff, 0x00000000,
	0xac10, 0xffffffff, 0x00000000,
	0xac0c, 0xffffffff, 0x00001032,
	0xac0c, 0xffffffff, 0x00001032,
	0xac0c, 0xffffffff, 0x00001032,
	0x88d4, 0x0000001f, 0x00000010,
	0x88d4, 0x0000001f, 0x00000010,
	0x88d4, 0x0000001f, 0x00000010,
	0x15c0, 0x000c0fc0, 0x000c0400
};

static const u32 owand_gowden_wwc_wegistews[] =
{
	0xc424, 0xffffffff, 0x00601005,
	0xc47c, 0xffffffff, 0x10104040,
	0xc488, 0xffffffff, 0x0100000a,
	0xc314, 0xffffffff, 0x00000800,
	0xc30c, 0xffffffff, 0x800000f4
};

static const u32 owand_gowden_wegistews[] =
{
	0x9a10, 0x00010000, 0x00018208,
	0x9830, 0xffffffff, 0x00000000,
	0x9834, 0xf00fffff, 0x00000400,
	0x9838, 0x0002021c, 0x00020200,
	0xc78, 0x00000080, 0x00000000,
	0xd030, 0x000300c0, 0x00800040,
	0xd830, 0x000300c0, 0x00800040,
	0x5bb0, 0x000000f0, 0x00000070,
	0x5bc0, 0x00200000, 0x50100000,
	0x7030, 0x31000311, 0x00000011,
	0x2ae4, 0x00073ffe, 0x000022a2,
	0x240c, 0x000007ff, 0x00000000,
	0x8a14, 0xf000001f, 0x00000007,
	0x8b24, 0xffffffff, 0x00ffffff,
	0x8b10, 0x0000ff0f, 0x00000000,
	0x28a4c, 0x07ffffff, 0x4e000000,
	0x28350, 0x3f3f3fff, 0x00000082,
	0x30, 0x000000ff, 0x0040,
	0x34, 0x00000040, 0x00004040,
	0x9100, 0x07ffffff, 0x03000000,
	0x9060, 0x0000007f, 0x00000020,
	0x9508, 0x00010000, 0x00010000,
	0xac14, 0x000003ff, 0x000000f3,
	0xac10, 0xffffffff, 0x00000000,
	0xac0c, 0xffffffff, 0x00003210,
	0x88d4, 0x0000001f, 0x00000010,
	0x15c0, 0x000c0fc0, 0x000c0400
};

static const u32 hainan_gowden_wegistews[] =
{
	0x9a10, 0x00010000, 0x00018208,
	0x9830, 0xffffffff, 0x00000000,
	0x9834, 0xf00fffff, 0x00000400,
	0x9838, 0x0002021c, 0x00020200,
	0xd0c0, 0xff000fff, 0x00000100,
	0xd030, 0x000300c0, 0x00800040,
	0xd8c0, 0xff000fff, 0x00000100,
	0xd830, 0x000300c0, 0x00800040,
	0x2ae4, 0x00073ffe, 0x000022a2,
	0x240c, 0x000007ff, 0x00000000,
	0x8a14, 0xf000001f, 0x00000007,
	0x8b24, 0xffffffff, 0x00ffffff,
	0x8b10, 0x0000ff0f, 0x00000000,
	0x28a4c, 0x07ffffff, 0x4e000000,
	0x28350, 0x3f3f3fff, 0x00000000,
	0x30, 0x000000ff, 0x0040,
	0x34, 0x00000040, 0x00004040,
	0x9100, 0x03e00000, 0x03600000,
	0x9060, 0x0000007f, 0x00000020,
	0x9508, 0x00010000, 0x00010000,
	0xac14, 0x000003ff, 0x000000f1,
	0xac10, 0xffffffff, 0x00000000,
	0xac0c, 0xffffffff, 0x00003210,
	0x88d4, 0x0000001f, 0x00000010,
	0x15c0, 0x000c0fc0, 0x000c0400
};

static const u32 hainan_gowden_wegistews2[] =
{
	0x98f8, 0xffffffff, 0x02010001
};

static const u32 tahiti_mgcg_cgcg_init[] =
{
	0xc400, 0xffffffff, 0xfffffffc,
	0x802c, 0xffffffff, 0xe0000000,
	0x9a60, 0xffffffff, 0x00000100,
	0x92a4, 0xffffffff, 0x00000100,
	0xc164, 0xffffffff, 0x00000100,
	0x9774, 0xffffffff, 0x00000100,
	0x8984, 0xffffffff, 0x06000100,
	0x8a18, 0xffffffff, 0x00000100,
	0x92a0, 0xffffffff, 0x00000100,
	0xc380, 0xffffffff, 0x00000100,
	0x8b28, 0xffffffff, 0x00000100,
	0x9144, 0xffffffff, 0x00000100,
	0x8d88, 0xffffffff, 0x00000100,
	0x8d8c, 0xffffffff, 0x00000100,
	0x9030, 0xffffffff, 0x00000100,
	0x9034, 0xffffffff, 0x00000100,
	0x9038, 0xffffffff, 0x00000100,
	0x903c, 0xffffffff, 0x00000100,
	0xad80, 0xffffffff, 0x00000100,
	0xac54, 0xffffffff, 0x00000100,
	0x897c, 0xffffffff, 0x06000100,
	0x9868, 0xffffffff, 0x00000100,
	0x9510, 0xffffffff, 0x00000100,
	0xaf04, 0xffffffff, 0x00000100,
	0xae04, 0xffffffff, 0x00000100,
	0x949c, 0xffffffff, 0x00000100,
	0x802c, 0xffffffff, 0xe0000000,
	0x9160, 0xffffffff, 0x00010000,
	0x9164, 0xffffffff, 0x00030002,
	0x9168, 0xffffffff, 0x00040007,
	0x916c, 0xffffffff, 0x00060005,
	0x9170, 0xffffffff, 0x00090008,
	0x9174, 0xffffffff, 0x00020001,
	0x9178, 0xffffffff, 0x00040003,
	0x917c, 0xffffffff, 0x00000007,
	0x9180, 0xffffffff, 0x00060005,
	0x9184, 0xffffffff, 0x00090008,
	0x9188, 0xffffffff, 0x00030002,
	0x918c, 0xffffffff, 0x00050004,
	0x9190, 0xffffffff, 0x00000008,
	0x9194, 0xffffffff, 0x00070006,
	0x9198, 0xffffffff, 0x000a0009,
	0x919c, 0xffffffff, 0x00040003,
	0x91a0, 0xffffffff, 0x00060005,
	0x91a4, 0xffffffff, 0x00000009,
	0x91a8, 0xffffffff, 0x00080007,
	0x91ac, 0xffffffff, 0x000b000a,
	0x91b0, 0xffffffff, 0x00050004,
	0x91b4, 0xffffffff, 0x00070006,
	0x91b8, 0xffffffff, 0x0008000b,
	0x91bc, 0xffffffff, 0x000a0009,
	0x91c0, 0xffffffff, 0x000d000c,
	0x91c4, 0xffffffff, 0x00060005,
	0x91c8, 0xffffffff, 0x00080007,
	0x91cc, 0xffffffff, 0x0000000b,
	0x91d0, 0xffffffff, 0x000a0009,
	0x91d4, 0xffffffff, 0x000d000c,
	0x91d8, 0xffffffff, 0x00070006,
	0x91dc, 0xffffffff, 0x00090008,
	0x91e0, 0xffffffff, 0x0000000c,
	0x91e4, 0xffffffff, 0x000b000a,
	0x91e8, 0xffffffff, 0x000e000d,
	0x91ec, 0xffffffff, 0x00080007,
	0x91f0, 0xffffffff, 0x000a0009,
	0x91f4, 0xffffffff, 0x0000000d,
	0x91f8, 0xffffffff, 0x000c000b,
	0x91fc, 0xffffffff, 0x000f000e,
	0x9200, 0xffffffff, 0x00090008,
	0x9204, 0xffffffff, 0x000b000a,
	0x9208, 0xffffffff, 0x000c000f,
	0x920c, 0xffffffff, 0x000e000d,
	0x9210, 0xffffffff, 0x00110010,
	0x9214, 0xffffffff, 0x000a0009,
	0x9218, 0xffffffff, 0x000c000b,
	0x921c, 0xffffffff, 0x0000000f,
	0x9220, 0xffffffff, 0x000e000d,
	0x9224, 0xffffffff, 0x00110010,
	0x9228, 0xffffffff, 0x000b000a,
	0x922c, 0xffffffff, 0x000d000c,
	0x9230, 0xffffffff, 0x00000010,
	0x9234, 0xffffffff, 0x000f000e,
	0x9238, 0xffffffff, 0x00120011,
	0x923c, 0xffffffff, 0x000c000b,
	0x9240, 0xffffffff, 0x000e000d,
	0x9244, 0xffffffff, 0x00000011,
	0x9248, 0xffffffff, 0x0010000f,
	0x924c, 0xffffffff, 0x00130012,
	0x9250, 0xffffffff, 0x000d000c,
	0x9254, 0xffffffff, 0x000f000e,
	0x9258, 0xffffffff, 0x00100013,
	0x925c, 0xffffffff, 0x00120011,
	0x9260, 0xffffffff, 0x00150014,
	0x9264, 0xffffffff, 0x000e000d,
	0x9268, 0xffffffff, 0x0010000f,
	0x926c, 0xffffffff, 0x00000013,
	0x9270, 0xffffffff, 0x00120011,
	0x9274, 0xffffffff, 0x00150014,
	0x9278, 0xffffffff, 0x000f000e,
	0x927c, 0xffffffff, 0x00110010,
	0x9280, 0xffffffff, 0x00000014,
	0x9284, 0xffffffff, 0x00130012,
	0x9288, 0xffffffff, 0x00160015,
	0x928c, 0xffffffff, 0x0010000f,
	0x9290, 0xffffffff, 0x00120011,
	0x9294, 0xffffffff, 0x00000015,
	0x9298, 0xffffffff, 0x00140013,
	0x929c, 0xffffffff, 0x00170016,
	0x9150, 0xffffffff, 0x96940200,
	0x8708, 0xffffffff, 0x00900100,
	0xc478, 0xffffffff, 0x00000080,
	0xc404, 0xffffffff, 0x0020003f,
	0x30, 0xffffffff, 0x0000001c,
	0x34, 0x000f0000, 0x000f0000,
	0x160c, 0xffffffff, 0x00000100,
	0x1024, 0xffffffff, 0x00000100,
	0x102c, 0x00000101, 0x00000000,
	0x20a8, 0xffffffff, 0x00000104,
	0x264c, 0x000c0000, 0x000c0000,
	0x2648, 0x000c0000, 0x000c0000,
	0x55e4, 0xff000fff, 0x00000100,
	0x55e8, 0x00000001, 0x00000001,
	0x2f50, 0x00000001, 0x00000001,
	0x30cc, 0xc0000fff, 0x00000104,
	0xc1e4, 0x00000001, 0x00000001,
	0xd0c0, 0xfffffff0, 0x00000100,
	0xd8c0, 0xfffffff0, 0x00000100
};

static const u32 pitcaiwn_mgcg_cgcg_init[] =
{
	0xc400, 0xffffffff, 0xfffffffc,
	0x802c, 0xffffffff, 0xe0000000,
	0x9a60, 0xffffffff, 0x00000100,
	0x92a4, 0xffffffff, 0x00000100,
	0xc164, 0xffffffff, 0x00000100,
	0x9774, 0xffffffff, 0x00000100,
	0x8984, 0xffffffff, 0x06000100,
	0x8a18, 0xffffffff, 0x00000100,
	0x92a0, 0xffffffff, 0x00000100,
	0xc380, 0xffffffff, 0x00000100,
	0x8b28, 0xffffffff, 0x00000100,
	0x9144, 0xffffffff, 0x00000100,
	0x8d88, 0xffffffff, 0x00000100,
	0x8d8c, 0xffffffff, 0x00000100,
	0x9030, 0xffffffff, 0x00000100,
	0x9034, 0xffffffff, 0x00000100,
	0x9038, 0xffffffff, 0x00000100,
	0x903c, 0xffffffff, 0x00000100,
	0xad80, 0xffffffff, 0x00000100,
	0xac54, 0xffffffff, 0x00000100,
	0x897c, 0xffffffff, 0x06000100,
	0x9868, 0xffffffff, 0x00000100,
	0x9510, 0xffffffff, 0x00000100,
	0xaf04, 0xffffffff, 0x00000100,
	0xae04, 0xffffffff, 0x00000100,
	0x949c, 0xffffffff, 0x00000100,
	0x802c, 0xffffffff, 0xe0000000,
	0x9160, 0xffffffff, 0x00010000,
	0x9164, 0xffffffff, 0x00030002,
	0x9168, 0xffffffff, 0x00040007,
	0x916c, 0xffffffff, 0x00060005,
	0x9170, 0xffffffff, 0x00090008,
	0x9174, 0xffffffff, 0x00020001,
	0x9178, 0xffffffff, 0x00040003,
	0x917c, 0xffffffff, 0x00000007,
	0x9180, 0xffffffff, 0x00060005,
	0x9184, 0xffffffff, 0x00090008,
	0x9188, 0xffffffff, 0x00030002,
	0x918c, 0xffffffff, 0x00050004,
	0x9190, 0xffffffff, 0x00000008,
	0x9194, 0xffffffff, 0x00070006,
	0x9198, 0xffffffff, 0x000a0009,
	0x919c, 0xffffffff, 0x00040003,
	0x91a0, 0xffffffff, 0x00060005,
	0x91a4, 0xffffffff, 0x00000009,
	0x91a8, 0xffffffff, 0x00080007,
	0x91ac, 0xffffffff, 0x000b000a,
	0x91b0, 0xffffffff, 0x00050004,
	0x91b4, 0xffffffff, 0x00070006,
	0x91b8, 0xffffffff, 0x0008000b,
	0x91bc, 0xffffffff, 0x000a0009,
	0x91c0, 0xffffffff, 0x000d000c,
	0x9200, 0xffffffff, 0x00090008,
	0x9204, 0xffffffff, 0x000b000a,
	0x9208, 0xffffffff, 0x000c000f,
	0x920c, 0xffffffff, 0x000e000d,
	0x9210, 0xffffffff, 0x00110010,
	0x9214, 0xffffffff, 0x000a0009,
	0x9218, 0xffffffff, 0x000c000b,
	0x921c, 0xffffffff, 0x0000000f,
	0x9220, 0xffffffff, 0x000e000d,
	0x9224, 0xffffffff, 0x00110010,
	0x9228, 0xffffffff, 0x000b000a,
	0x922c, 0xffffffff, 0x000d000c,
	0x9230, 0xffffffff, 0x00000010,
	0x9234, 0xffffffff, 0x000f000e,
	0x9238, 0xffffffff, 0x00120011,
	0x923c, 0xffffffff, 0x000c000b,
	0x9240, 0xffffffff, 0x000e000d,
	0x9244, 0xffffffff, 0x00000011,
	0x9248, 0xffffffff, 0x0010000f,
	0x924c, 0xffffffff, 0x00130012,
	0x9250, 0xffffffff, 0x000d000c,
	0x9254, 0xffffffff, 0x000f000e,
	0x9258, 0xffffffff, 0x00100013,
	0x925c, 0xffffffff, 0x00120011,
	0x9260, 0xffffffff, 0x00150014,
	0x9150, 0xffffffff, 0x96940200,
	0x8708, 0xffffffff, 0x00900100,
	0xc478, 0xffffffff, 0x00000080,
	0xc404, 0xffffffff, 0x0020003f,
	0x30, 0xffffffff, 0x0000001c,
	0x34, 0x000f0000, 0x000f0000,
	0x160c, 0xffffffff, 0x00000100,
	0x1024, 0xffffffff, 0x00000100,
	0x102c, 0x00000101, 0x00000000,
	0x20a8, 0xffffffff, 0x00000104,
	0x55e4, 0xff000fff, 0x00000100,
	0x55e8, 0x00000001, 0x00000001,
	0x2f50, 0x00000001, 0x00000001,
	0x30cc, 0xc0000fff, 0x00000104,
	0xc1e4, 0x00000001, 0x00000001,
	0xd0c0, 0xfffffff0, 0x00000100,
	0xd8c0, 0xfffffff0, 0x00000100
};

static const u32 vewde_mgcg_cgcg_init[] =
{
	0xc400, 0xffffffff, 0xfffffffc,
	0x802c, 0xffffffff, 0xe0000000,
	0x9a60, 0xffffffff, 0x00000100,
	0x92a4, 0xffffffff, 0x00000100,
	0xc164, 0xffffffff, 0x00000100,
	0x9774, 0xffffffff, 0x00000100,
	0x8984, 0xffffffff, 0x06000100,
	0x8a18, 0xffffffff, 0x00000100,
	0x92a0, 0xffffffff, 0x00000100,
	0xc380, 0xffffffff, 0x00000100,
	0x8b28, 0xffffffff, 0x00000100,
	0x9144, 0xffffffff, 0x00000100,
	0x8d88, 0xffffffff, 0x00000100,
	0x8d8c, 0xffffffff, 0x00000100,
	0x9030, 0xffffffff, 0x00000100,
	0x9034, 0xffffffff, 0x00000100,
	0x9038, 0xffffffff, 0x00000100,
	0x903c, 0xffffffff, 0x00000100,
	0xad80, 0xffffffff, 0x00000100,
	0xac54, 0xffffffff, 0x00000100,
	0x897c, 0xffffffff, 0x06000100,
	0x9868, 0xffffffff, 0x00000100,
	0x9510, 0xffffffff, 0x00000100,
	0xaf04, 0xffffffff, 0x00000100,
	0xae04, 0xffffffff, 0x00000100,
	0x949c, 0xffffffff, 0x00000100,
	0x802c, 0xffffffff, 0xe0000000,
	0x9160, 0xffffffff, 0x00010000,
	0x9164, 0xffffffff, 0x00030002,
	0x9168, 0xffffffff, 0x00040007,
	0x916c, 0xffffffff, 0x00060005,
	0x9170, 0xffffffff, 0x00090008,
	0x9174, 0xffffffff, 0x00020001,
	0x9178, 0xffffffff, 0x00040003,
	0x917c, 0xffffffff, 0x00000007,
	0x9180, 0xffffffff, 0x00060005,
	0x9184, 0xffffffff, 0x00090008,
	0x9188, 0xffffffff, 0x00030002,
	0x918c, 0xffffffff, 0x00050004,
	0x9190, 0xffffffff, 0x00000008,
	0x9194, 0xffffffff, 0x00070006,
	0x9198, 0xffffffff, 0x000a0009,
	0x919c, 0xffffffff, 0x00040003,
	0x91a0, 0xffffffff, 0x00060005,
	0x91a4, 0xffffffff, 0x00000009,
	0x91a8, 0xffffffff, 0x00080007,
	0x91ac, 0xffffffff, 0x000b000a,
	0x91b0, 0xffffffff, 0x00050004,
	0x91b4, 0xffffffff, 0x00070006,
	0x91b8, 0xffffffff, 0x0008000b,
	0x91bc, 0xffffffff, 0x000a0009,
	0x91c0, 0xffffffff, 0x000d000c,
	0x9200, 0xffffffff, 0x00090008,
	0x9204, 0xffffffff, 0x000b000a,
	0x9208, 0xffffffff, 0x000c000f,
	0x920c, 0xffffffff, 0x000e000d,
	0x9210, 0xffffffff, 0x00110010,
	0x9214, 0xffffffff, 0x000a0009,
	0x9218, 0xffffffff, 0x000c000b,
	0x921c, 0xffffffff, 0x0000000f,
	0x9220, 0xffffffff, 0x000e000d,
	0x9224, 0xffffffff, 0x00110010,
	0x9228, 0xffffffff, 0x000b000a,
	0x922c, 0xffffffff, 0x000d000c,
	0x9230, 0xffffffff, 0x00000010,
	0x9234, 0xffffffff, 0x000f000e,
	0x9238, 0xffffffff, 0x00120011,
	0x923c, 0xffffffff, 0x000c000b,
	0x9240, 0xffffffff, 0x000e000d,
	0x9244, 0xffffffff, 0x00000011,
	0x9248, 0xffffffff, 0x0010000f,
	0x924c, 0xffffffff, 0x00130012,
	0x9250, 0xffffffff, 0x000d000c,
	0x9254, 0xffffffff, 0x000f000e,
	0x9258, 0xffffffff, 0x00100013,
	0x925c, 0xffffffff, 0x00120011,
	0x9260, 0xffffffff, 0x00150014,
	0x9150, 0xffffffff, 0x96940200,
	0x8708, 0xffffffff, 0x00900100,
	0xc478, 0xffffffff, 0x00000080,
	0xc404, 0xffffffff, 0x0020003f,
	0x30, 0xffffffff, 0x0000001c,
	0x34, 0x000f0000, 0x000f0000,
	0x160c, 0xffffffff, 0x00000100,
	0x1024, 0xffffffff, 0x00000100,
	0x102c, 0x00000101, 0x00000000,
	0x20a8, 0xffffffff, 0x00000104,
	0x264c, 0x000c0000, 0x000c0000,
	0x2648, 0x000c0000, 0x000c0000,
	0x55e4, 0xff000fff, 0x00000100,
	0x55e8, 0x00000001, 0x00000001,
	0x2f50, 0x00000001, 0x00000001,
	0x30cc, 0xc0000fff, 0x00000104,
	0xc1e4, 0x00000001, 0x00000001,
	0xd0c0, 0xfffffff0, 0x00000100,
	0xd8c0, 0xfffffff0, 0x00000100
};

static const u32 owand_mgcg_cgcg_init[] =
{
	0xc400, 0xffffffff, 0xfffffffc,
	0x802c, 0xffffffff, 0xe0000000,
	0x9a60, 0xffffffff, 0x00000100,
	0x92a4, 0xffffffff, 0x00000100,
	0xc164, 0xffffffff, 0x00000100,
	0x9774, 0xffffffff, 0x00000100,
	0x8984, 0xffffffff, 0x06000100,
	0x8a18, 0xffffffff, 0x00000100,
	0x92a0, 0xffffffff, 0x00000100,
	0xc380, 0xffffffff, 0x00000100,
	0x8b28, 0xffffffff, 0x00000100,
	0x9144, 0xffffffff, 0x00000100,
	0x8d88, 0xffffffff, 0x00000100,
	0x8d8c, 0xffffffff, 0x00000100,
	0x9030, 0xffffffff, 0x00000100,
	0x9034, 0xffffffff, 0x00000100,
	0x9038, 0xffffffff, 0x00000100,
	0x903c, 0xffffffff, 0x00000100,
	0xad80, 0xffffffff, 0x00000100,
	0xac54, 0xffffffff, 0x00000100,
	0x897c, 0xffffffff, 0x06000100,
	0x9868, 0xffffffff, 0x00000100,
	0x9510, 0xffffffff, 0x00000100,
	0xaf04, 0xffffffff, 0x00000100,
	0xae04, 0xffffffff, 0x00000100,
	0x949c, 0xffffffff, 0x00000100,
	0x802c, 0xffffffff, 0xe0000000,
	0x9160, 0xffffffff, 0x00010000,
	0x9164, 0xffffffff, 0x00030002,
	0x9168, 0xffffffff, 0x00040007,
	0x916c, 0xffffffff, 0x00060005,
	0x9170, 0xffffffff, 0x00090008,
	0x9174, 0xffffffff, 0x00020001,
	0x9178, 0xffffffff, 0x00040003,
	0x917c, 0xffffffff, 0x00000007,
	0x9180, 0xffffffff, 0x00060005,
	0x9184, 0xffffffff, 0x00090008,
	0x9188, 0xffffffff, 0x00030002,
	0x918c, 0xffffffff, 0x00050004,
	0x9190, 0xffffffff, 0x00000008,
	0x9194, 0xffffffff, 0x00070006,
	0x9198, 0xffffffff, 0x000a0009,
	0x919c, 0xffffffff, 0x00040003,
	0x91a0, 0xffffffff, 0x00060005,
	0x91a4, 0xffffffff, 0x00000009,
	0x91a8, 0xffffffff, 0x00080007,
	0x91ac, 0xffffffff, 0x000b000a,
	0x91b0, 0xffffffff, 0x00050004,
	0x91b4, 0xffffffff, 0x00070006,
	0x91b8, 0xffffffff, 0x0008000b,
	0x91bc, 0xffffffff, 0x000a0009,
	0x91c0, 0xffffffff, 0x000d000c,
	0x91c4, 0xffffffff, 0x00060005,
	0x91c8, 0xffffffff, 0x00080007,
	0x91cc, 0xffffffff, 0x0000000b,
	0x91d0, 0xffffffff, 0x000a0009,
	0x91d4, 0xffffffff, 0x000d000c,
	0x9150, 0xffffffff, 0x96940200,
	0x8708, 0xffffffff, 0x00900100,
	0xc478, 0xffffffff, 0x00000080,
	0xc404, 0xffffffff, 0x0020003f,
	0x30, 0xffffffff, 0x0000001c,
	0x34, 0x000f0000, 0x000f0000,
	0x160c, 0xffffffff, 0x00000100,
	0x1024, 0xffffffff, 0x00000100,
	0x102c, 0x00000101, 0x00000000,
	0x20a8, 0xffffffff, 0x00000104,
	0x264c, 0x000c0000, 0x000c0000,
	0x2648, 0x000c0000, 0x000c0000,
	0x55e4, 0xff000fff, 0x00000100,
	0x55e8, 0x00000001, 0x00000001,
	0x2f50, 0x00000001, 0x00000001,
	0x30cc, 0xc0000fff, 0x00000104,
	0xc1e4, 0x00000001, 0x00000001,
	0xd0c0, 0xfffffff0, 0x00000100,
	0xd8c0, 0xfffffff0, 0x00000100
};

static const u32 hainan_mgcg_cgcg_init[] =
{
	0xc400, 0xffffffff, 0xfffffffc,
	0x802c, 0xffffffff, 0xe0000000,
	0x9a60, 0xffffffff, 0x00000100,
	0x92a4, 0xffffffff, 0x00000100,
	0xc164, 0xffffffff, 0x00000100,
	0x9774, 0xffffffff, 0x00000100,
	0x8984, 0xffffffff, 0x06000100,
	0x8a18, 0xffffffff, 0x00000100,
	0x92a0, 0xffffffff, 0x00000100,
	0xc380, 0xffffffff, 0x00000100,
	0x8b28, 0xffffffff, 0x00000100,
	0x9144, 0xffffffff, 0x00000100,
	0x8d88, 0xffffffff, 0x00000100,
	0x8d8c, 0xffffffff, 0x00000100,
	0x9030, 0xffffffff, 0x00000100,
	0x9034, 0xffffffff, 0x00000100,
	0x9038, 0xffffffff, 0x00000100,
	0x903c, 0xffffffff, 0x00000100,
	0xad80, 0xffffffff, 0x00000100,
	0xac54, 0xffffffff, 0x00000100,
	0x897c, 0xffffffff, 0x06000100,
	0x9868, 0xffffffff, 0x00000100,
	0x9510, 0xffffffff, 0x00000100,
	0xaf04, 0xffffffff, 0x00000100,
	0xae04, 0xffffffff, 0x00000100,
	0x949c, 0xffffffff, 0x00000100,
	0x802c, 0xffffffff, 0xe0000000,
	0x9160, 0xffffffff, 0x00010000,
	0x9164, 0xffffffff, 0x00030002,
	0x9168, 0xffffffff, 0x00040007,
	0x916c, 0xffffffff, 0x00060005,
	0x9170, 0xffffffff, 0x00090008,
	0x9174, 0xffffffff, 0x00020001,
	0x9178, 0xffffffff, 0x00040003,
	0x917c, 0xffffffff, 0x00000007,
	0x9180, 0xffffffff, 0x00060005,
	0x9184, 0xffffffff, 0x00090008,
	0x9188, 0xffffffff, 0x00030002,
	0x918c, 0xffffffff, 0x00050004,
	0x9190, 0xffffffff, 0x00000008,
	0x9194, 0xffffffff, 0x00070006,
	0x9198, 0xffffffff, 0x000a0009,
	0x919c, 0xffffffff, 0x00040003,
	0x91a0, 0xffffffff, 0x00060005,
	0x91a4, 0xffffffff, 0x00000009,
	0x91a8, 0xffffffff, 0x00080007,
	0x91ac, 0xffffffff, 0x000b000a,
	0x91b0, 0xffffffff, 0x00050004,
	0x91b4, 0xffffffff, 0x00070006,
	0x91b8, 0xffffffff, 0x0008000b,
	0x91bc, 0xffffffff, 0x000a0009,
	0x91c0, 0xffffffff, 0x000d000c,
	0x91c4, 0xffffffff, 0x00060005,
	0x91c8, 0xffffffff, 0x00080007,
	0x91cc, 0xffffffff, 0x0000000b,
	0x91d0, 0xffffffff, 0x000a0009,
	0x91d4, 0xffffffff, 0x000d000c,
	0x9150, 0xffffffff, 0x96940200,
	0x8708, 0xffffffff, 0x00900100,
	0xc478, 0xffffffff, 0x00000080,
	0xc404, 0xffffffff, 0x0020003f,
	0x30, 0xffffffff, 0x0000001c,
	0x34, 0x000f0000, 0x000f0000,
	0x160c, 0xffffffff, 0x00000100,
	0x1024, 0xffffffff, 0x00000100,
	0x20a8, 0xffffffff, 0x00000104,
	0x264c, 0x000c0000, 0x000c0000,
	0x2648, 0x000c0000, 0x000c0000,
	0x2f50, 0x00000001, 0x00000001,
	0x30cc, 0xc0000fff, 0x00000104,
	0xc1e4, 0x00000001, 0x00000001,
	0xd0c0, 0xfffffff0, 0x00000100,
	0xd8c0, 0xfffffff0, 0x00000100
};

static u32 vewde_pg_init[] =
{
	0x353c, 0xffffffff, 0x40000,
	0x3538, 0xffffffff, 0x200010ff,
	0x353c, 0xffffffff, 0x0,
	0x353c, 0xffffffff, 0x0,
	0x353c, 0xffffffff, 0x0,
	0x353c, 0xffffffff, 0x0,
	0x353c, 0xffffffff, 0x0,
	0x353c, 0xffffffff, 0x7007,
	0x3538, 0xffffffff, 0x300010ff,
	0x353c, 0xffffffff, 0x0,
	0x353c, 0xffffffff, 0x0,
	0x353c, 0xffffffff, 0x0,
	0x353c, 0xffffffff, 0x0,
	0x353c, 0xffffffff, 0x0,
	0x353c, 0xffffffff, 0x400000,
	0x3538, 0xffffffff, 0x100010ff,
	0x353c, 0xffffffff, 0x0,
	0x353c, 0xffffffff, 0x0,
	0x353c, 0xffffffff, 0x0,
	0x353c, 0xffffffff, 0x0,
	0x353c, 0xffffffff, 0x0,
	0x353c, 0xffffffff, 0x120200,
	0x3538, 0xffffffff, 0x500010ff,
	0x353c, 0xffffffff, 0x0,
	0x353c, 0xffffffff, 0x0,
	0x353c, 0xffffffff, 0x0,
	0x353c, 0xffffffff, 0x0,
	0x353c, 0xffffffff, 0x0,
	0x353c, 0xffffffff, 0x1e1e16,
	0x3538, 0xffffffff, 0x600010ff,
	0x353c, 0xffffffff, 0x0,
	0x353c, 0xffffffff, 0x0,
	0x353c, 0xffffffff, 0x0,
	0x353c, 0xffffffff, 0x0,
	0x353c, 0xffffffff, 0x0,
	0x353c, 0xffffffff, 0x171f1e,
	0x3538, 0xffffffff, 0x700010ff,
	0x353c, 0xffffffff, 0x0,
	0x353c, 0xffffffff, 0x0,
	0x353c, 0xffffffff, 0x0,
	0x353c, 0xffffffff, 0x0,
	0x353c, 0xffffffff, 0x0,
	0x353c, 0xffffffff, 0x0,
	0x3538, 0xffffffff, 0x9ff,
	0x3500, 0xffffffff, 0x0,
	0x3504, 0xffffffff, 0x10000800,
	0x3504, 0xffffffff, 0xf,
	0x3504, 0xffffffff, 0xf,
	0x3500, 0xffffffff, 0x4,
	0x3504, 0xffffffff, 0x1000051e,
	0x3504, 0xffffffff, 0xffff,
	0x3504, 0xffffffff, 0xffff,
	0x3500, 0xffffffff, 0x8,
	0x3504, 0xffffffff, 0x80500,
	0x3500, 0xffffffff, 0x12,
	0x3504, 0xffffffff, 0x9050c,
	0x3500, 0xffffffff, 0x1d,
	0x3504, 0xffffffff, 0xb052c,
	0x3500, 0xffffffff, 0x2a,
	0x3504, 0xffffffff, 0x1053e,
	0x3500, 0xffffffff, 0x2d,
	0x3504, 0xffffffff, 0x10546,
	0x3500, 0xffffffff, 0x30,
	0x3504, 0xffffffff, 0xa054e,
	0x3500, 0xffffffff, 0x3c,
	0x3504, 0xffffffff, 0x1055f,
	0x3500, 0xffffffff, 0x3f,
	0x3504, 0xffffffff, 0x10567,
	0x3500, 0xffffffff, 0x42,
	0x3504, 0xffffffff, 0x1056f,
	0x3500, 0xffffffff, 0x45,
	0x3504, 0xffffffff, 0x10572,
	0x3500, 0xffffffff, 0x48,
	0x3504, 0xffffffff, 0x20575,
	0x3500, 0xffffffff, 0x4c,
	0x3504, 0xffffffff, 0x190801,
	0x3500, 0xffffffff, 0x67,
	0x3504, 0xffffffff, 0x1082a,
	0x3500, 0xffffffff, 0x6a,
	0x3504, 0xffffffff, 0x1b082d,
	0x3500, 0xffffffff, 0x87,
	0x3504, 0xffffffff, 0x310851,
	0x3500, 0xffffffff, 0xba,
	0x3504, 0xffffffff, 0x891,
	0x3500, 0xffffffff, 0xbc,
	0x3504, 0xffffffff, 0x893,
	0x3500, 0xffffffff, 0xbe,
	0x3504, 0xffffffff, 0x20895,
	0x3500, 0xffffffff, 0xc2,
	0x3504, 0xffffffff, 0x20899,
	0x3500, 0xffffffff, 0xc6,
	0x3504, 0xffffffff, 0x2089d,
	0x3500, 0xffffffff, 0xca,
	0x3504, 0xffffffff, 0x8a1,
	0x3500, 0xffffffff, 0xcc,
	0x3504, 0xffffffff, 0x8a3,
	0x3500, 0xffffffff, 0xce,
	0x3504, 0xffffffff, 0x308a5,
	0x3500, 0xffffffff, 0xd3,
	0x3504, 0xffffffff, 0x6d08cd,
	0x3500, 0xffffffff, 0x142,
	0x3504, 0xffffffff, 0x2000095a,
	0x3504, 0xffffffff, 0x1,
	0x3500, 0xffffffff, 0x144,
	0x3504, 0xffffffff, 0x301f095b,
	0x3500, 0xffffffff, 0x165,
	0x3504, 0xffffffff, 0xc094d,
	0x3500, 0xffffffff, 0x173,
	0x3504, 0xffffffff, 0xf096d,
	0x3500, 0xffffffff, 0x184,
	0x3504, 0xffffffff, 0x15097f,
	0x3500, 0xffffffff, 0x19b,
	0x3504, 0xffffffff, 0xc0998,
	0x3500, 0xffffffff, 0x1a9,
	0x3504, 0xffffffff, 0x409a7,
	0x3500, 0xffffffff, 0x1af,
	0x3504, 0xffffffff, 0xcdc,
	0x3500, 0xffffffff, 0x1b1,
	0x3504, 0xffffffff, 0x800,
	0x3508, 0xffffffff, 0x6c9b2000,
	0x3510, 0xfc00, 0x2000,
	0x3544, 0xffffffff, 0xfc0,
	0x28d4, 0x00000100, 0x100
};

static void si_init_gowden_wegistews(stwuct wadeon_device *wdev)
{
	switch (wdev->famiwy) {
	case CHIP_TAHITI:
		wadeon_pwogwam_wegistew_sequence(wdev,
						 tahiti_gowden_wegistews,
						 (const u32)AWWAY_SIZE(tahiti_gowden_wegistews));
		wadeon_pwogwam_wegistew_sequence(wdev,
						 tahiti_gowden_wwc_wegistews,
						 (const u32)AWWAY_SIZE(tahiti_gowden_wwc_wegistews));
		wadeon_pwogwam_wegistew_sequence(wdev,
						 tahiti_mgcg_cgcg_init,
						 (const u32)AWWAY_SIZE(tahiti_mgcg_cgcg_init));
		wadeon_pwogwam_wegistew_sequence(wdev,
						 tahiti_gowden_wegistews2,
						 (const u32)AWWAY_SIZE(tahiti_gowden_wegistews2));
		bweak;
	case CHIP_PITCAIWN:
		wadeon_pwogwam_wegistew_sequence(wdev,
						 pitcaiwn_gowden_wegistews,
						 (const u32)AWWAY_SIZE(pitcaiwn_gowden_wegistews));
		wadeon_pwogwam_wegistew_sequence(wdev,
						 pitcaiwn_gowden_wwc_wegistews,
						 (const u32)AWWAY_SIZE(pitcaiwn_gowden_wwc_wegistews));
		wadeon_pwogwam_wegistew_sequence(wdev,
						 pitcaiwn_mgcg_cgcg_init,
						 (const u32)AWWAY_SIZE(pitcaiwn_mgcg_cgcg_init));
		bweak;
	case CHIP_VEWDE:
		wadeon_pwogwam_wegistew_sequence(wdev,
						 vewde_gowden_wegistews,
						 (const u32)AWWAY_SIZE(vewde_gowden_wegistews));
		wadeon_pwogwam_wegistew_sequence(wdev,
						 vewde_gowden_wwc_wegistews,
						 (const u32)AWWAY_SIZE(vewde_gowden_wwc_wegistews));
		wadeon_pwogwam_wegistew_sequence(wdev,
						 vewde_mgcg_cgcg_init,
						 (const u32)AWWAY_SIZE(vewde_mgcg_cgcg_init));
		wadeon_pwogwam_wegistew_sequence(wdev,
						 vewde_pg_init,
						 (const u32)AWWAY_SIZE(vewde_pg_init));
		bweak;
	case CHIP_OWAND:
		wadeon_pwogwam_wegistew_sequence(wdev,
						 owand_gowden_wegistews,
						 (const u32)AWWAY_SIZE(owand_gowden_wegistews));
		wadeon_pwogwam_wegistew_sequence(wdev,
						 owand_gowden_wwc_wegistews,
						 (const u32)AWWAY_SIZE(owand_gowden_wwc_wegistews));
		wadeon_pwogwam_wegistew_sequence(wdev,
						 owand_mgcg_cgcg_init,
						 (const u32)AWWAY_SIZE(owand_mgcg_cgcg_init));
		bweak;
	case CHIP_HAINAN:
		wadeon_pwogwam_wegistew_sequence(wdev,
						 hainan_gowden_wegistews,
						 (const u32)AWWAY_SIZE(hainan_gowden_wegistews));
		wadeon_pwogwam_wegistew_sequence(wdev,
						 hainan_gowden_wegistews2,
						 (const u32)AWWAY_SIZE(hainan_gowden_wegistews2));
		wadeon_pwogwam_wegistew_sequence(wdev,
						 hainan_mgcg_cgcg_init,
						 (const u32)AWWAY_SIZE(hainan_mgcg_cgcg_init));
		bweak;
	defauwt:
		bweak;
	}
}

/**
 * si_get_awwowed_info_wegistew - fetch the wegistew fow the info ioctw
 *
 * @wdev: wadeon_device pointew
 * @weg: wegistew offset in bytes
 * @vaw: wegistew vawue
 *
 * Wetuwns 0 fow success ow -EINVAW fow an invawid wegistew
 *
 */
int si_get_awwowed_info_wegistew(stwuct wadeon_device *wdev,
				 u32 weg, u32 *vaw)
{
	switch (weg) {
	case GWBM_STATUS:
	case GWBM_STATUS2:
	case GWBM_STATUS_SE0:
	case GWBM_STATUS_SE1:
	case SWBM_STATUS:
	case SWBM_STATUS2:
	case (DMA_STATUS_WEG + DMA0_WEGISTEW_OFFSET):
	case (DMA_STATUS_WEG + DMA1_WEGISTEW_OFFSET):
	case UVD_STATUS:
		*vaw = WWEG32(weg);
		wetuwn 0;
	defauwt:
		wetuwn -EINVAW;
	}
}

#define PCIE_BUS_CWK                10000
#define TCWK                        (PCIE_BUS_CWK / 10)

/**
 * si_get_xcwk - get the xcwk
 *
 * @wdev: wadeon_device pointew
 *
 * Wetuwns the wefewence cwock used by the gfx engine
 * (SI).
 */
u32 si_get_xcwk(stwuct wadeon_device *wdev)
{
	u32 wefewence_cwock = wdev->cwock.spww.wefewence_fweq;
	u32 tmp;

	tmp = WWEG32(CG_CWKPIN_CNTW_2);
	if (tmp & MUX_TCWK_TO_XCWK)
		wetuwn TCWK;

	tmp = WWEG32(CG_CWKPIN_CNTW);
	if (tmp & XTAWIN_DIVIDE)
		wetuwn wefewence_cwock / 4;

	wetuwn wefewence_cwock;
}

/* get tempewatuwe in miwwidegwees */
int si_get_temp(stwuct wadeon_device *wdev)
{
	u32 temp;
	int actuaw_temp = 0;

	temp = (WWEG32(CG_MUWT_THEWMAW_STATUS) & CTF_TEMP_MASK) >>
		CTF_TEMP_SHIFT;

	if (temp & 0x200)
		actuaw_temp = 255;
	ewse
		actuaw_temp = temp & 0x1ff;

	actuaw_temp = (actuaw_temp * 1000);

	wetuwn actuaw_temp;
}

#define TAHITI_IO_MC_WEGS_SIZE 36

static const u32 tahiti_io_mc_wegs[TAHITI_IO_MC_WEGS_SIZE][2] = {
	{0x0000006f, 0x03044000},
	{0x00000070, 0x0480c018},
	{0x00000071, 0x00000040},
	{0x00000072, 0x01000000},
	{0x00000074, 0x000000ff},
	{0x00000075, 0x00143400},
	{0x00000076, 0x08ec0800},
	{0x00000077, 0x040000cc},
	{0x00000079, 0x00000000},
	{0x0000007a, 0x21000409},
	{0x0000007c, 0x00000000},
	{0x0000007d, 0xe8000000},
	{0x0000007e, 0x044408a8},
	{0x0000007f, 0x00000003},
	{0x00000080, 0x00000000},
	{0x00000081, 0x01000000},
	{0x00000082, 0x02000000},
	{0x00000083, 0x00000000},
	{0x00000084, 0xe3f3e4f4},
	{0x00000085, 0x00052024},
	{0x00000087, 0x00000000},
	{0x00000088, 0x66036603},
	{0x00000089, 0x01000000},
	{0x0000008b, 0x1c0a0000},
	{0x0000008c, 0xff010000},
	{0x0000008e, 0xffffefff},
	{0x0000008f, 0xfff3efff},
	{0x00000090, 0xfff3efbf},
	{0x00000094, 0x00101101},
	{0x00000095, 0x00000fff},
	{0x00000096, 0x00116fff},
	{0x00000097, 0x60010000},
	{0x00000098, 0x10010000},
	{0x00000099, 0x00006000},
	{0x0000009a, 0x00001000},
	{0x0000009f, 0x00a77400}
};

static const u32 pitcaiwn_io_mc_wegs[TAHITI_IO_MC_WEGS_SIZE][2] = {
	{0x0000006f, 0x03044000},
	{0x00000070, 0x0480c018},
	{0x00000071, 0x00000040},
	{0x00000072, 0x01000000},
	{0x00000074, 0x000000ff},
	{0x00000075, 0x00143400},
	{0x00000076, 0x08ec0800},
	{0x00000077, 0x040000cc},
	{0x00000079, 0x00000000},
	{0x0000007a, 0x21000409},
	{0x0000007c, 0x00000000},
	{0x0000007d, 0xe8000000},
	{0x0000007e, 0x044408a8},
	{0x0000007f, 0x00000003},
	{0x00000080, 0x00000000},
	{0x00000081, 0x01000000},
	{0x00000082, 0x02000000},
	{0x00000083, 0x00000000},
	{0x00000084, 0xe3f3e4f4},
	{0x00000085, 0x00052024},
	{0x00000087, 0x00000000},
	{0x00000088, 0x66036603},
	{0x00000089, 0x01000000},
	{0x0000008b, 0x1c0a0000},
	{0x0000008c, 0xff010000},
	{0x0000008e, 0xffffefff},
	{0x0000008f, 0xfff3efff},
	{0x00000090, 0xfff3efbf},
	{0x00000094, 0x00101101},
	{0x00000095, 0x00000fff},
	{0x00000096, 0x00116fff},
	{0x00000097, 0x60010000},
	{0x00000098, 0x10010000},
	{0x00000099, 0x00006000},
	{0x0000009a, 0x00001000},
	{0x0000009f, 0x00a47400}
};

static const u32 vewde_io_mc_wegs[TAHITI_IO_MC_WEGS_SIZE][2] = {
	{0x0000006f, 0x03044000},
	{0x00000070, 0x0480c018},
	{0x00000071, 0x00000040},
	{0x00000072, 0x01000000},
	{0x00000074, 0x000000ff},
	{0x00000075, 0x00143400},
	{0x00000076, 0x08ec0800},
	{0x00000077, 0x040000cc},
	{0x00000079, 0x00000000},
	{0x0000007a, 0x21000409},
	{0x0000007c, 0x00000000},
	{0x0000007d, 0xe8000000},
	{0x0000007e, 0x044408a8},
	{0x0000007f, 0x00000003},
	{0x00000080, 0x00000000},
	{0x00000081, 0x01000000},
	{0x00000082, 0x02000000},
	{0x00000083, 0x00000000},
	{0x00000084, 0xe3f3e4f4},
	{0x00000085, 0x00052024},
	{0x00000087, 0x00000000},
	{0x00000088, 0x66036603},
	{0x00000089, 0x01000000},
	{0x0000008b, 0x1c0a0000},
	{0x0000008c, 0xff010000},
	{0x0000008e, 0xffffefff},
	{0x0000008f, 0xfff3efff},
	{0x00000090, 0xfff3efbf},
	{0x00000094, 0x00101101},
	{0x00000095, 0x00000fff},
	{0x00000096, 0x00116fff},
	{0x00000097, 0x60010000},
	{0x00000098, 0x10010000},
	{0x00000099, 0x00006000},
	{0x0000009a, 0x00001000},
	{0x0000009f, 0x00a37400}
};

static const u32 owand_io_mc_wegs[TAHITI_IO_MC_WEGS_SIZE][2] = {
	{0x0000006f, 0x03044000},
	{0x00000070, 0x0480c018},
	{0x00000071, 0x00000040},
	{0x00000072, 0x01000000},
	{0x00000074, 0x000000ff},
	{0x00000075, 0x00143400},
	{0x00000076, 0x08ec0800},
	{0x00000077, 0x040000cc},
	{0x00000079, 0x00000000},
	{0x0000007a, 0x21000409},
	{0x0000007c, 0x00000000},
	{0x0000007d, 0xe8000000},
	{0x0000007e, 0x044408a8},
	{0x0000007f, 0x00000003},
	{0x00000080, 0x00000000},
	{0x00000081, 0x01000000},
	{0x00000082, 0x02000000},
	{0x00000083, 0x00000000},
	{0x00000084, 0xe3f3e4f4},
	{0x00000085, 0x00052024},
	{0x00000087, 0x00000000},
	{0x00000088, 0x66036603},
	{0x00000089, 0x01000000},
	{0x0000008b, 0x1c0a0000},
	{0x0000008c, 0xff010000},
	{0x0000008e, 0xffffefff},
	{0x0000008f, 0xfff3efff},
	{0x00000090, 0xfff3efbf},
	{0x00000094, 0x00101101},
	{0x00000095, 0x00000fff},
	{0x00000096, 0x00116fff},
	{0x00000097, 0x60010000},
	{0x00000098, 0x10010000},
	{0x00000099, 0x00006000},
	{0x0000009a, 0x00001000},
	{0x0000009f, 0x00a17730}
};

static const u32 hainan_io_mc_wegs[TAHITI_IO_MC_WEGS_SIZE][2] = {
	{0x0000006f, 0x03044000},
	{0x00000070, 0x0480c018},
	{0x00000071, 0x00000040},
	{0x00000072, 0x01000000},
	{0x00000074, 0x000000ff},
	{0x00000075, 0x00143400},
	{0x00000076, 0x08ec0800},
	{0x00000077, 0x040000cc},
	{0x00000079, 0x00000000},
	{0x0000007a, 0x21000409},
	{0x0000007c, 0x00000000},
	{0x0000007d, 0xe8000000},
	{0x0000007e, 0x044408a8},
	{0x0000007f, 0x00000003},
	{0x00000080, 0x00000000},
	{0x00000081, 0x01000000},
	{0x00000082, 0x02000000},
	{0x00000083, 0x00000000},
	{0x00000084, 0xe3f3e4f4},
	{0x00000085, 0x00052024},
	{0x00000087, 0x00000000},
	{0x00000088, 0x66036603},
	{0x00000089, 0x01000000},
	{0x0000008b, 0x1c0a0000},
	{0x0000008c, 0xff010000},
	{0x0000008e, 0xffffefff},
	{0x0000008f, 0xfff3efff},
	{0x00000090, 0xfff3efbf},
	{0x00000094, 0x00101101},
	{0x00000095, 0x00000fff},
	{0x00000096, 0x00116fff},
	{0x00000097, 0x60010000},
	{0x00000098, 0x10010000},
	{0x00000099, 0x00006000},
	{0x0000009a, 0x00001000},
	{0x0000009f, 0x00a07730}
};

/* ucode woading */
int si_mc_woad_micwocode(stwuct wadeon_device *wdev)
{
	const __be32 *fw_data = NUWW;
	const __we32 *new_fw_data = NUWW;
	u32 wunning;
	u32 *io_mc_wegs = NUWW;
	const __we32 *new_io_mc_wegs = NUWW;
	int i, wegs_size, ucode_size;

	if (!wdev->mc_fw)
		wetuwn -EINVAW;

	if (wdev->new_fw) {
		const stwuct mc_fiwmwawe_headew_v1_0 *hdw =
			(const stwuct mc_fiwmwawe_headew_v1_0 *)wdev->mc_fw->data;

		wadeon_ucode_pwint_mc_hdw(&hdw->headew);
		wegs_size = we32_to_cpu(hdw->io_debug_size_bytes) / (4 * 2);
		new_io_mc_wegs = (const __we32 *)
			(wdev->mc_fw->data + we32_to_cpu(hdw->io_debug_awway_offset_bytes));
		ucode_size = we32_to_cpu(hdw->headew.ucode_size_bytes) / 4;
		new_fw_data = (const __we32 *)
			(wdev->mc_fw->data + we32_to_cpu(hdw->headew.ucode_awway_offset_bytes));
	} ewse {
		ucode_size = wdev->mc_fw->size / 4;

		switch (wdev->famiwy) {
		case CHIP_TAHITI:
			io_mc_wegs = (u32 *)&tahiti_io_mc_wegs;
			wegs_size = TAHITI_IO_MC_WEGS_SIZE;
			bweak;
		case CHIP_PITCAIWN:
			io_mc_wegs = (u32 *)&pitcaiwn_io_mc_wegs;
			wegs_size = TAHITI_IO_MC_WEGS_SIZE;
			bweak;
		case CHIP_VEWDE:
		defauwt:
			io_mc_wegs = (u32 *)&vewde_io_mc_wegs;
			wegs_size = TAHITI_IO_MC_WEGS_SIZE;
			bweak;
		case CHIP_OWAND:
			io_mc_wegs = (u32 *)&owand_io_mc_wegs;
			wegs_size = TAHITI_IO_MC_WEGS_SIZE;
			bweak;
		case CHIP_HAINAN:
			io_mc_wegs = (u32 *)&hainan_io_mc_wegs;
			wegs_size = TAHITI_IO_MC_WEGS_SIZE;
			bweak;
		}
		fw_data = (const __be32 *)wdev->mc_fw->data;
	}

	wunning = WWEG32(MC_SEQ_SUP_CNTW) & WUN_MASK;

	if (wunning == 0) {
		/* weset the engine and set to wwitabwe */
		WWEG32(MC_SEQ_SUP_CNTW, 0x00000008);
		WWEG32(MC_SEQ_SUP_CNTW, 0x00000010);

		/* woad mc io wegs */
		fow (i = 0; i < wegs_size; i++) {
			if (wdev->new_fw) {
				WWEG32(MC_SEQ_IO_DEBUG_INDEX, we32_to_cpup(new_io_mc_wegs++));
				WWEG32(MC_SEQ_IO_DEBUG_DATA, we32_to_cpup(new_io_mc_wegs++));
			} ewse {
				WWEG32(MC_SEQ_IO_DEBUG_INDEX, io_mc_wegs[(i << 1)]);
				WWEG32(MC_SEQ_IO_DEBUG_DATA, io_mc_wegs[(i << 1) + 1]);
			}
		}
		/* woad the MC ucode */
		fow (i = 0; i < ucode_size; i++) {
			if (wdev->new_fw)
				WWEG32(MC_SEQ_SUP_PGM, we32_to_cpup(new_fw_data++));
			ewse
				WWEG32(MC_SEQ_SUP_PGM, be32_to_cpup(fw_data++));
		}

		/* put the engine back into the active state */
		WWEG32(MC_SEQ_SUP_CNTW, 0x00000008);
		WWEG32(MC_SEQ_SUP_CNTW, 0x00000004);
		WWEG32(MC_SEQ_SUP_CNTW, 0x00000001);

		/* wait fow twaining to compwete */
		fow (i = 0; i < wdev->usec_timeout; i++) {
			if (WWEG32(MC_SEQ_TWAIN_WAKEUP_CNTW) & TWAIN_DONE_D0)
				bweak;
			udeway(1);
		}
		fow (i = 0; i < wdev->usec_timeout; i++) {
			if (WWEG32(MC_SEQ_TWAIN_WAKEUP_CNTW) & TWAIN_DONE_D1)
				bweak;
			udeway(1);
		}
	}

	wetuwn 0;
}

static int si_init_micwocode(stwuct wadeon_device *wdev)
{
	const chaw *chip_name;
	const chaw *new_chip_name;
	size_t pfp_weq_size, me_weq_size, ce_weq_size, wwc_weq_size, mc_weq_size;
	size_t smc_weq_size, mc2_weq_size;
	chaw fw_name[30];
	int eww;
	int new_fw = 0;
	boow new_smc = fawse;
	boow si58_fw = fawse;
	boow banks2_fw = fawse;

	DWM_DEBUG("\n");

	switch (wdev->famiwy) {
	case CHIP_TAHITI:
		chip_name = "TAHITI";
		new_chip_name = "tahiti";
		pfp_weq_size = SI_PFP_UCODE_SIZE * 4;
		me_weq_size = SI_PM4_UCODE_SIZE * 4;
		ce_weq_size = SI_CE_UCODE_SIZE * 4;
		wwc_weq_size = SI_WWC_UCODE_SIZE * 4;
		mc_weq_size = SI_MC_UCODE_SIZE * 4;
		mc2_weq_size = TAHITI_MC_UCODE_SIZE * 4;
		smc_weq_size = AWIGN(TAHITI_SMC_UCODE_SIZE, 4);
		bweak;
	case CHIP_PITCAIWN:
		chip_name = "PITCAIWN";
		if ((wdev->pdev->wevision == 0x81) &&
		    ((wdev->pdev->device == 0x6810) ||
		     (wdev->pdev->device == 0x6811)))
			new_smc = twue;
		new_chip_name = "pitcaiwn";
		pfp_weq_size = SI_PFP_UCODE_SIZE * 4;
		me_weq_size = SI_PM4_UCODE_SIZE * 4;
		ce_weq_size = SI_CE_UCODE_SIZE * 4;
		wwc_weq_size = SI_WWC_UCODE_SIZE * 4;
		mc_weq_size = SI_MC_UCODE_SIZE * 4;
		mc2_weq_size = PITCAIWN_MC_UCODE_SIZE * 4;
		smc_weq_size = AWIGN(PITCAIWN_SMC_UCODE_SIZE, 4);
		bweak;
	case CHIP_VEWDE:
		chip_name = "VEWDE";
		if (((wdev->pdev->device == 0x6820) &&
		     ((wdev->pdev->wevision == 0x81) ||
		      (wdev->pdev->wevision == 0x83))) ||
		    ((wdev->pdev->device == 0x6821) &&
		     ((wdev->pdev->wevision == 0x83) ||
		      (wdev->pdev->wevision == 0x87))) ||
		    ((wdev->pdev->wevision == 0x87) &&
		     ((wdev->pdev->device == 0x6823) ||
		      (wdev->pdev->device == 0x682b))))
			new_smc = twue;
		new_chip_name = "vewde";
		pfp_weq_size = SI_PFP_UCODE_SIZE * 4;
		me_weq_size = SI_PM4_UCODE_SIZE * 4;
		ce_weq_size = SI_CE_UCODE_SIZE * 4;
		wwc_weq_size = SI_WWC_UCODE_SIZE * 4;
		mc_weq_size = SI_MC_UCODE_SIZE * 4;
		mc2_weq_size = VEWDE_MC_UCODE_SIZE * 4;
		smc_weq_size = AWIGN(VEWDE_SMC_UCODE_SIZE, 4);
		bweak;
	case CHIP_OWAND:
		chip_name = "OWAND";
		if (((wdev->pdev->wevision == 0x81) &&
		     ((wdev->pdev->device == 0x6600) ||
		      (wdev->pdev->device == 0x6604) ||
		      (wdev->pdev->device == 0x6605) ||
		      (wdev->pdev->device == 0x6610))) ||
		    ((wdev->pdev->wevision == 0x83) &&
		     (wdev->pdev->device == 0x6610)))
			new_smc = twue;
		new_chip_name = "owand";
		pfp_weq_size = SI_PFP_UCODE_SIZE * 4;
		me_weq_size = SI_PM4_UCODE_SIZE * 4;
		ce_weq_size = SI_CE_UCODE_SIZE * 4;
		wwc_weq_size = SI_WWC_UCODE_SIZE * 4;
		mc_weq_size = mc2_weq_size = OWAND_MC_UCODE_SIZE * 4;
		smc_weq_size = AWIGN(OWAND_SMC_UCODE_SIZE, 4);
		bweak;
	case CHIP_HAINAN:
		chip_name = "HAINAN";
		if (((wdev->pdev->wevision == 0x81) &&
		     (wdev->pdev->device == 0x6660)) ||
		    ((wdev->pdev->wevision == 0x83) &&
		     ((wdev->pdev->device == 0x6660) ||
		      (wdev->pdev->device == 0x6663) ||
		      (wdev->pdev->device == 0x6665) ||
		      (wdev->pdev->device == 0x6667))))
			new_smc = twue;
		ewse if ((wdev->pdev->wevision == 0xc3) &&
			 (wdev->pdev->device == 0x6665))
			banks2_fw = twue;
		new_chip_name = "hainan";
		pfp_weq_size = SI_PFP_UCODE_SIZE * 4;
		me_weq_size = SI_PM4_UCODE_SIZE * 4;
		ce_weq_size = SI_CE_UCODE_SIZE * 4;
		wwc_weq_size = SI_WWC_UCODE_SIZE * 4;
		mc_weq_size = mc2_weq_size = OWAND_MC_UCODE_SIZE * 4;
		smc_weq_size = AWIGN(HAINAN_SMC_UCODE_SIZE, 4);
		bweak;
	defauwt: BUG();
	}

	/* this memowy configuwation wequiwes speciaw fiwmwawe */
	if (((WWEG32(MC_SEQ_MISC0) & 0xff000000) >> 24) == 0x58)
		si58_fw = twue;

	DWM_INFO("Woading %s Micwocode\n", new_chip_name);

	snpwintf(fw_name, sizeof(fw_name), "wadeon/%s_pfp.bin", new_chip_name);
	eww = wequest_fiwmwawe(&wdev->pfp_fw, fw_name, wdev->dev);
	if (eww) {
		snpwintf(fw_name, sizeof(fw_name), "wadeon/%s_pfp.bin", chip_name);
		eww = wequest_fiwmwawe(&wdev->pfp_fw, fw_name, wdev->dev);
		if (eww)
			goto out;
		if (wdev->pfp_fw->size != pfp_weq_size) {
			pw_eww("si_cp: Bogus wength %zu in fiwmwawe \"%s\"\n",
			       wdev->pfp_fw->size, fw_name);
			eww = -EINVAW;
			goto out;
		}
	} ewse {
		eww = wadeon_ucode_vawidate(wdev->pfp_fw);
		if (eww) {
			pw_eww("si_cp: vawidation faiwed fow fiwmwawe \"%s\"\n",
			       fw_name);
			goto out;
		} ewse {
			new_fw++;
		}
	}

	snpwintf(fw_name, sizeof(fw_name), "wadeon/%s_me.bin", new_chip_name);
	eww = wequest_fiwmwawe(&wdev->me_fw, fw_name, wdev->dev);
	if (eww) {
		snpwintf(fw_name, sizeof(fw_name), "wadeon/%s_me.bin", chip_name);
		eww = wequest_fiwmwawe(&wdev->me_fw, fw_name, wdev->dev);
		if (eww)
			goto out;
		if (wdev->me_fw->size != me_weq_size) {
			pw_eww("si_cp: Bogus wength %zu in fiwmwawe \"%s\"\n",
			       wdev->me_fw->size, fw_name);
			eww = -EINVAW;
		}
	} ewse {
		eww = wadeon_ucode_vawidate(wdev->me_fw);
		if (eww) {
			pw_eww("si_cp: vawidation faiwed fow fiwmwawe \"%s\"\n",
			       fw_name);
			goto out;
		} ewse {
			new_fw++;
		}
	}

	snpwintf(fw_name, sizeof(fw_name), "wadeon/%s_ce.bin", new_chip_name);
	eww = wequest_fiwmwawe(&wdev->ce_fw, fw_name, wdev->dev);
	if (eww) {
		snpwintf(fw_name, sizeof(fw_name), "wadeon/%s_ce.bin", chip_name);
		eww = wequest_fiwmwawe(&wdev->ce_fw, fw_name, wdev->dev);
		if (eww)
			goto out;
		if (wdev->ce_fw->size != ce_weq_size) {
			pw_eww("si_cp: Bogus wength %zu in fiwmwawe \"%s\"\n",
			       wdev->ce_fw->size, fw_name);
			eww = -EINVAW;
		}
	} ewse {
		eww = wadeon_ucode_vawidate(wdev->ce_fw);
		if (eww) {
			pw_eww("si_cp: vawidation faiwed fow fiwmwawe \"%s\"\n",
			       fw_name);
			goto out;
		} ewse {
			new_fw++;
		}
	}

	snpwintf(fw_name, sizeof(fw_name), "wadeon/%s_wwc.bin", new_chip_name);
	eww = wequest_fiwmwawe(&wdev->wwc_fw, fw_name, wdev->dev);
	if (eww) {
		snpwintf(fw_name, sizeof(fw_name), "wadeon/%s_wwc.bin", chip_name);
		eww = wequest_fiwmwawe(&wdev->wwc_fw, fw_name, wdev->dev);
		if (eww)
			goto out;
		if (wdev->wwc_fw->size != wwc_weq_size) {
			pw_eww("si_wwc: Bogus wength %zu in fiwmwawe \"%s\"\n",
			       wdev->wwc_fw->size, fw_name);
			eww = -EINVAW;
		}
	} ewse {
		eww = wadeon_ucode_vawidate(wdev->wwc_fw);
		if (eww) {
			pw_eww("si_cp: vawidation faiwed fow fiwmwawe \"%s\"\n",
			       fw_name);
			goto out;
		} ewse {
			new_fw++;
		}
	}

	if (si58_fw)
		snpwintf(fw_name, sizeof(fw_name), "wadeon/si58_mc.bin");
	ewse
		snpwintf(fw_name, sizeof(fw_name), "wadeon/%s_mc.bin", new_chip_name);
	eww = wequest_fiwmwawe(&wdev->mc_fw, fw_name, wdev->dev);
	if (eww) {
		snpwintf(fw_name, sizeof(fw_name), "wadeon/%s_mc2.bin", chip_name);
		eww = wequest_fiwmwawe(&wdev->mc_fw, fw_name, wdev->dev);
		if (eww) {
			snpwintf(fw_name, sizeof(fw_name), "wadeon/%s_mc.bin", chip_name);
			eww = wequest_fiwmwawe(&wdev->mc_fw, fw_name, wdev->dev);
			if (eww)
				goto out;
		}
		if ((wdev->mc_fw->size != mc_weq_size) &&
		    (wdev->mc_fw->size != mc2_weq_size)) {
			pw_eww("si_mc: Bogus wength %zu in fiwmwawe \"%s\"\n",
			       wdev->mc_fw->size, fw_name);
			eww = -EINVAW;
		}
		DWM_INFO("%s: %zu bytes\n", fw_name, wdev->mc_fw->size);
	} ewse {
		eww = wadeon_ucode_vawidate(wdev->mc_fw);
		if (eww) {
			pw_eww("si_cp: vawidation faiwed fow fiwmwawe \"%s\"\n",
			       fw_name);
			goto out;
		} ewse {
			new_fw++;
		}
	}

	if (banks2_fw)
		snpwintf(fw_name, sizeof(fw_name), "wadeon/banks_k_2_smc.bin");
	ewse if (new_smc)
		snpwintf(fw_name, sizeof(fw_name), "wadeon/%s_k_smc.bin", new_chip_name);
	ewse
		snpwintf(fw_name, sizeof(fw_name), "wadeon/%s_smc.bin", new_chip_name);
	eww = wequest_fiwmwawe(&wdev->smc_fw, fw_name, wdev->dev);
	if (eww) {
		snpwintf(fw_name, sizeof(fw_name), "wadeon/%s_smc.bin", chip_name);
		eww = wequest_fiwmwawe(&wdev->smc_fw, fw_name, wdev->dev);
		if (eww) {
			pw_eww("smc: ewwow woading fiwmwawe \"%s\"\n", fw_name);
			wewease_fiwmwawe(wdev->smc_fw);
			wdev->smc_fw = NUWW;
			eww = 0;
		} ewse if (wdev->smc_fw->size != smc_weq_size) {
			pw_eww("si_smc: Bogus wength %zu in fiwmwawe \"%s\"\n",
			       wdev->smc_fw->size, fw_name);
			eww = -EINVAW;
		}
	} ewse {
		eww = wadeon_ucode_vawidate(wdev->smc_fw);
		if (eww) {
			pw_eww("si_cp: vawidation faiwed fow fiwmwawe \"%s\"\n",
			       fw_name);
			goto out;
		} ewse {
			new_fw++;
		}
	}

	if (new_fw == 0) {
		wdev->new_fw = fawse;
	} ewse if (new_fw < 6) {
		pw_eww("si_fw: mixing new and owd fiwmwawe!\n");
		eww = -EINVAW;
	} ewse {
		wdev->new_fw = twue;
	}
out:
	if (eww) {
		if (eww != -EINVAW)
			pw_eww("si_cp: Faiwed to woad fiwmwawe \"%s\"\n",
			       fw_name);
		wewease_fiwmwawe(wdev->pfp_fw);
		wdev->pfp_fw = NUWW;
		wewease_fiwmwawe(wdev->me_fw);
		wdev->me_fw = NUWW;
		wewease_fiwmwawe(wdev->ce_fw);
		wdev->ce_fw = NUWW;
		wewease_fiwmwawe(wdev->wwc_fw);
		wdev->wwc_fw = NUWW;
		wewease_fiwmwawe(wdev->mc_fw);
		wdev->mc_fw = NUWW;
		wewease_fiwmwawe(wdev->smc_fw);
		wdev->smc_fw = NUWW;
	}
	wetuwn eww;
}

/* watewmawk setup */
static u32 dce6_wine_buffew_adjust(stwuct wadeon_device *wdev,
				   stwuct wadeon_cwtc *wadeon_cwtc,
				   stwuct dwm_dispway_mode *mode,
				   stwuct dwm_dispway_mode *othew_mode)
{
	u32 tmp, buffew_awwoc, i;
	u32 pipe_offset = wadeon_cwtc->cwtc_id * 0x20;
	/*
	 * Wine Buffew Setup
	 * Thewe awe 3 wine buffews, each one shawed by 2 dispway contwowwews.
	 * DC_WB_MEMOWY_SPWIT contwows how that wine buffew is shawed between
	 * the dispway contwowwews.  The pawitioning is done via one of fouw
	 * pweset awwocations specified in bits 21:20:
	 *  0 - hawf wb
	 *  2 - whowe wb, othew cwtc must be disabwed
	 */
	/* this can get twicky if we have two wawge dispways on a paiwed gwoup
	 * of cwtcs.  Ideawwy fow muwtipwe wawge dispways we'd assign them to
	 * non-winked cwtcs fow maximum wine buffew awwocation.
	 */
	if (wadeon_cwtc->base.enabwed && mode) {
		if (othew_mode) {
			tmp = 0; /* 1/2 */
			buffew_awwoc = 1;
		} ewse {
			tmp = 2; /* whowe */
			buffew_awwoc = 2;
		}
	} ewse {
		tmp = 0;
		buffew_awwoc = 0;
	}

	WWEG32(DC_WB_MEMOWY_SPWIT + wadeon_cwtc->cwtc_offset,
	       DC_WB_MEMOWY_CONFIG(tmp));

	WWEG32(PIPE0_DMIF_BUFFEW_CONTWOW + pipe_offset,
	       DMIF_BUFFEWS_AWWOCATED(buffew_awwoc));
	fow (i = 0; i < wdev->usec_timeout; i++) {
		if (WWEG32(PIPE0_DMIF_BUFFEW_CONTWOW + pipe_offset) &
		    DMIF_BUFFEWS_AWWOCATED_COMPWETED)
			bweak;
		udeway(1);
	}

	if (wadeon_cwtc->base.enabwed && mode) {
		switch (tmp) {
		case 0:
		defauwt:
			wetuwn 4096 * 2;
		case 2:
			wetuwn 8192 * 2;
		}
	}

	/* contwowwew not enabwed, so no wb used */
	wetuwn 0;
}

static u32 si_get_numbew_of_dwam_channews(stwuct wadeon_device *wdev)
{
	u32 tmp = WWEG32(MC_SHAWED_CHMAP);

	switch ((tmp & NOOFCHAN_MASK) >> NOOFCHAN_SHIFT) {
	case 0:
	defauwt:
		wetuwn 1;
	case 1:
		wetuwn 2;
	case 2:
		wetuwn 4;
	case 3:
		wetuwn 8;
	case 4:
		wetuwn 3;
	case 5:
		wetuwn 6;
	case 6:
		wetuwn 10;
	case 7:
		wetuwn 12;
	case 8:
		wetuwn 16;
	}
}

stwuct dce6_wm_pawams {
	u32 dwam_channews; /* numbew of dwam channews */
	u32 ycwk;          /* bandwidth pew dwam data pin in kHz */
	u32 scwk;          /* engine cwock in kHz */
	u32 disp_cwk;      /* dispway cwock in kHz */
	u32 swc_width;     /* viewpowt width */
	u32 active_time;   /* active dispway time in ns */
	u32 bwank_time;    /* bwank time in ns */
	boow intewwaced;    /* mode is intewwaced */
	fixed20_12 vsc;    /* vewticaw scawe watio */
	u32 num_heads;     /* numbew of active cwtcs */
	u32 bytes_pew_pixew; /* bytes pew pixew dispway + ovewway */
	u32 wb_size;       /* wine buffew awwocated to pipe */
	u32 vtaps;         /* vewticaw scawew taps */
};

static u32 dce6_dwam_bandwidth(stwuct dce6_wm_pawams *wm)
{
	/* Cawcuwate waw DWAM Bandwidth */
	fixed20_12 dwam_efficiency; /* 0.7 */
	fixed20_12 ycwk, dwam_channews, bandwidth;
	fixed20_12 a;

	a.fuww = dfixed_const(1000);
	ycwk.fuww = dfixed_const(wm->ycwk);
	ycwk.fuww = dfixed_div(ycwk, a);
	dwam_channews.fuww = dfixed_const(wm->dwam_channews * 4);
	a.fuww = dfixed_const(10);
	dwam_efficiency.fuww = dfixed_const(7);
	dwam_efficiency.fuww = dfixed_div(dwam_efficiency, a);
	bandwidth.fuww = dfixed_muw(dwam_channews, ycwk);
	bandwidth.fuww = dfixed_muw(bandwidth, dwam_efficiency);

	wetuwn dfixed_twunc(bandwidth);
}

static u32 dce6_dwam_bandwidth_fow_dispway(stwuct dce6_wm_pawams *wm)
{
	/* Cawcuwate DWAM Bandwidth and the pawt awwocated to dispway. */
	fixed20_12 disp_dwam_awwocation; /* 0.3 to 0.7 */
	fixed20_12 ycwk, dwam_channews, bandwidth;
	fixed20_12 a;

	a.fuww = dfixed_const(1000);
	ycwk.fuww = dfixed_const(wm->ycwk);
	ycwk.fuww = dfixed_div(ycwk, a);
	dwam_channews.fuww = dfixed_const(wm->dwam_channews * 4);
	a.fuww = dfixed_const(10);
	disp_dwam_awwocation.fuww = dfixed_const(3); /* XXX wowse case vawue 0.3 */
	disp_dwam_awwocation.fuww = dfixed_div(disp_dwam_awwocation, a);
	bandwidth.fuww = dfixed_muw(dwam_channews, ycwk);
	bandwidth.fuww = dfixed_muw(bandwidth, disp_dwam_awwocation);

	wetuwn dfixed_twunc(bandwidth);
}

static u32 dce6_data_wetuwn_bandwidth(stwuct dce6_wm_pawams *wm)
{
	/* Cawcuwate the dispway Data wetuwn Bandwidth */
	fixed20_12 wetuwn_efficiency; /* 0.8 */
	fixed20_12 scwk, bandwidth;
	fixed20_12 a;

	a.fuww = dfixed_const(1000);
	scwk.fuww = dfixed_const(wm->scwk);
	scwk.fuww = dfixed_div(scwk, a);
	a.fuww = dfixed_const(10);
	wetuwn_efficiency.fuww = dfixed_const(8);
	wetuwn_efficiency.fuww = dfixed_div(wetuwn_efficiency, a);
	a.fuww = dfixed_const(32);
	bandwidth.fuww = dfixed_muw(a, scwk);
	bandwidth.fuww = dfixed_muw(bandwidth, wetuwn_efficiency);

	wetuwn dfixed_twunc(bandwidth);
}

static u32 dce6_get_dmif_bytes_pew_wequest(stwuct dce6_wm_pawams *wm)
{
	wetuwn 32;
}

static u32 dce6_dmif_wequest_bandwidth(stwuct dce6_wm_pawams *wm)
{
	/* Cawcuwate the DMIF Wequest Bandwidth */
	fixed20_12 disp_cwk_wequest_efficiency; /* 0.8 */
	fixed20_12 disp_cwk, scwk, bandwidth;
	fixed20_12 a, b1, b2;
	u32 min_bandwidth;

	a.fuww = dfixed_const(1000);
	disp_cwk.fuww = dfixed_const(wm->disp_cwk);
	disp_cwk.fuww = dfixed_div(disp_cwk, a);
	a.fuww = dfixed_const(dce6_get_dmif_bytes_pew_wequest(wm) / 2);
	b1.fuww = dfixed_muw(a, disp_cwk);

	a.fuww = dfixed_const(1000);
	scwk.fuww = dfixed_const(wm->scwk);
	scwk.fuww = dfixed_div(scwk, a);
	a.fuww = dfixed_const(dce6_get_dmif_bytes_pew_wequest(wm));
	b2.fuww = dfixed_muw(a, scwk);

	a.fuww = dfixed_const(10);
	disp_cwk_wequest_efficiency.fuww = dfixed_const(8);
	disp_cwk_wequest_efficiency.fuww = dfixed_div(disp_cwk_wequest_efficiency, a);

	min_bandwidth = min(dfixed_twunc(b1), dfixed_twunc(b2));

	a.fuww = dfixed_const(min_bandwidth);
	bandwidth.fuww = dfixed_muw(a, disp_cwk_wequest_efficiency);

	wetuwn dfixed_twunc(bandwidth);
}

static u32 dce6_avaiwabwe_bandwidth(stwuct dce6_wm_pawams *wm)
{
	/* Cawcuwate the Avaiwabwe bandwidth. Dispway can use this tempowawiwy but not in avewage. */
	u32 dwam_bandwidth = dce6_dwam_bandwidth(wm);
	u32 data_wetuwn_bandwidth = dce6_data_wetuwn_bandwidth(wm);
	u32 dmif_weq_bandwidth = dce6_dmif_wequest_bandwidth(wm);

	wetuwn min(dwam_bandwidth, min(data_wetuwn_bandwidth, dmif_weq_bandwidth));
}

static u32 dce6_avewage_bandwidth(stwuct dce6_wm_pawams *wm)
{
	/* Cawcuwate the dispway mode Avewage Bandwidth
	 * DispwayMode shouwd contain the souwce and destination dimensions,
	 * timing, etc.
	 */
	fixed20_12 bpp;
	fixed20_12 wine_time;
	fixed20_12 swc_width;
	fixed20_12 bandwidth;
	fixed20_12 a;

	a.fuww = dfixed_const(1000);
	wine_time.fuww = dfixed_const(wm->active_time + wm->bwank_time);
	wine_time.fuww = dfixed_div(wine_time, a);
	bpp.fuww = dfixed_const(wm->bytes_pew_pixew);
	swc_width.fuww = dfixed_const(wm->swc_width);
	bandwidth.fuww = dfixed_muw(swc_width, bpp);
	bandwidth.fuww = dfixed_muw(bandwidth, wm->vsc);
	bandwidth.fuww = dfixed_div(bandwidth, wine_time);

	wetuwn dfixed_twunc(bandwidth);
}

static u32 dce6_watency_watewmawk(stwuct dce6_wm_pawams *wm)
{
	/* Fiwst cawcuawte the watency in ns */
	u32 mc_watency = 2000; /* 2000 ns. */
	u32 avaiwabwe_bandwidth = dce6_avaiwabwe_bandwidth(wm);
	u32 wowst_chunk_wetuwn_time = (512 * 8 * 1000) / avaiwabwe_bandwidth;
	u32 cuwsow_wine_paiw_wetuwn_time = (128 * 4 * 1000) / avaiwabwe_bandwidth;
	u32 dc_watency = 40000000 / wm->disp_cwk; /* dc pipe watency */
	u32 othew_heads_data_wetuwn_time = ((wm->num_heads + 1) * wowst_chunk_wetuwn_time) +
		(wm->num_heads * cuwsow_wine_paiw_wetuwn_time);
	u32 watency = mc_watency + othew_heads_data_wetuwn_time + dc_watency;
	u32 max_swc_wines_pew_dst_wine, wb_fiww_bw, wine_fiww_time;
	u32 tmp, dmif_size = 12288;
	fixed20_12 a, b, c;

	if (wm->num_heads == 0)
		wetuwn 0;

	a.fuww = dfixed_const(2);
	b.fuww = dfixed_const(1);
	if ((wm->vsc.fuww > a.fuww) ||
	    ((wm->vsc.fuww > b.fuww) && (wm->vtaps >= 3)) ||
	    (wm->vtaps >= 5) ||
	    ((wm->vsc.fuww >= a.fuww) && wm->intewwaced))
		max_swc_wines_pew_dst_wine = 4;
	ewse
		max_swc_wines_pew_dst_wine = 2;

	a.fuww = dfixed_const(avaiwabwe_bandwidth);
	b.fuww = dfixed_const(wm->num_heads);
	a.fuww = dfixed_div(a, b);
	tmp = div_u64((u64) dmif_size * (u64) wm->disp_cwk, mc_watency + 512);
	tmp = min(dfixed_twunc(a), tmp);

	wb_fiww_bw = min(tmp, wm->disp_cwk * wm->bytes_pew_pixew / 1000);

	a.fuww = dfixed_const(max_swc_wines_pew_dst_wine * wm->swc_width * wm->bytes_pew_pixew);
	b.fuww = dfixed_const(1000);
	c.fuww = dfixed_const(wb_fiww_bw);
	b.fuww = dfixed_div(c, b);
	a.fuww = dfixed_div(a, b);
	wine_fiww_time = dfixed_twunc(a);

	if (wine_fiww_time < wm->active_time)
		wetuwn watency;
	ewse
		wetuwn watency + (wine_fiww_time - wm->active_time);

}

static boow dce6_avewage_bandwidth_vs_dwam_bandwidth_fow_dispway(stwuct dce6_wm_pawams *wm)
{
	if (dce6_avewage_bandwidth(wm) <=
	    (dce6_dwam_bandwidth_fow_dispway(wm) / wm->num_heads))
		wetuwn twue;
	ewse
		wetuwn fawse;
};

static boow dce6_avewage_bandwidth_vs_avaiwabwe_bandwidth(stwuct dce6_wm_pawams *wm)
{
	if (dce6_avewage_bandwidth(wm) <=
	    (dce6_avaiwabwe_bandwidth(wm) / wm->num_heads))
		wetuwn twue;
	ewse
		wetuwn fawse;
};

static boow dce6_check_watency_hiding(stwuct dce6_wm_pawams *wm)
{
	u32 wb_pawtitions = wm->wb_size / wm->swc_width;
	u32 wine_time = wm->active_time + wm->bwank_time;
	u32 watency_towewant_wines;
	u32 watency_hiding;
	fixed20_12 a;

	a.fuww = dfixed_const(1);
	if (wm->vsc.fuww > a.fuww)
		watency_towewant_wines = 1;
	ewse {
		if (wb_pawtitions <= (wm->vtaps + 1))
			watency_towewant_wines = 1;
		ewse
			watency_towewant_wines = 2;
	}

	watency_hiding = (watency_towewant_wines * wine_time + wm->bwank_time);

	if (dce6_watency_watewmawk(wm) <= watency_hiding)
		wetuwn twue;
	ewse
		wetuwn fawse;
}

static void dce6_pwogwam_watewmawks(stwuct wadeon_device *wdev,
					 stwuct wadeon_cwtc *wadeon_cwtc,
					 u32 wb_size, u32 num_heads)
{
	stwuct dwm_dispway_mode *mode = &wadeon_cwtc->base.mode;
	stwuct dce6_wm_pawams wm_wow, wm_high;
	u32 dwam_channews;
	u32 active_time;
	u32 wine_time = 0;
	u32 watency_watewmawk_a = 0, watency_watewmawk_b = 0;
	u32 pwiowity_a_mawk = 0, pwiowity_b_mawk = 0;
	u32 pwiowity_a_cnt = PWIOWITY_OFF;
	u32 pwiowity_b_cnt = PWIOWITY_OFF;
	u32 tmp, awb_contwow3;
	fixed20_12 a, b, c;

	if (wadeon_cwtc->base.enabwed && num_heads && mode) {
		active_time = (u32) div_u64((u64)mode->cwtc_hdispway * 1000000,
					    (u32)mode->cwock);
		wine_time = (u32) div_u64((u64)mode->cwtc_htotaw * 1000000,
					  (u32)mode->cwock);
		wine_time = min(wine_time, (u32)65535);
		pwiowity_a_cnt = 0;
		pwiowity_b_cnt = 0;

		if (wdev->famiwy == CHIP_AWUBA)
			dwam_channews = evewgween_get_numbew_of_dwam_channews(wdev);
		ewse
			dwam_channews = si_get_numbew_of_dwam_channews(wdev);

		/* watewmawk fow high cwocks */
		if ((wdev->pm.pm_method == PM_METHOD_DPM) && wdev->pm.dpm_enabwed) {
			wm_high.ycwk =
				wadeon_dpm_get_mcwk(wdev, fawse) * 10;
			wm_high.scwk =
				wadeon_dpm_get_scwk(wdev, fawse) * 10;
		} ewse {
			wm_high.ycwk = wdev->pm.cuwwent_mcwk * 10;
			wm_high.scwk = wdev->pm.cuwwent_scwk * 10;
		}

		wm_high.disp_cwk = mode->cwock;
		wm_high.swc_width = mode->cwtc_hdispway;
		wm_high.active_time = active_time;
		wm_high.bwank_time = wine_time - wm_high.active_time;
		wm_high.intewwaced = fawse;
		if (mode->fwags & DWM_MODE_FWAG_INTEWWACE)
			wm_high.intewwaced = twue;
		wm_high.vsc = wadeon_cwtc->vsc;
		wm_high.vtaps = 1;
		if (wadeon_cwtc->wmx_type != WMX_OFF)
			wm_high.vtaps = 2;
		wm_high.bytes_pew_pixew = 4; /* XXX: get this fwom fb config */
		wm_high.wb_size = wb_size;
		wm_high.dwam_channews = dwam_channews;
		wm_high.num_heads = num_heads;

		/* watewmawk fow wow cwocks */
		if ((wdev->pm.pm_method == PM_METHOD_DPM) && wdev->pm.dpm_enabwed) {
			wm_wow.ycwk =
				wadeon_dpm_get_mcwk(wdev, twue) * 10;
			wm_wow.scwk =
				wadeon_dpm_get_scwk(wdev, twue) * 10;
		} ewse {
			wm_wow.ycwk = wdev->pm.cuwwent_mcwk * 10;
			wm_wow.scwk = wdev->pm.cuwwent_scwk * 10;
		}

		wm_wow.disp_cwk = mode->cwock;
		wm_wow.swc_width = mode->cwtc_hdispway;
		wm_wow.active_time = active_time;
		wm_wow.bwank_time = wine_time - wm_wow.active_time;
		wm_wow.intewwaced = fawse;
		if (mode->fwags & DWM_MODE_FWAG_INTEWWACE)
			wm_wow.intewwaced = twue;
		wm_wow.vsc = wadeon_cwtc->vsc;
		wm_wow.vtaps = 1;
		if (wadeon_cwtc->wmx_type != WMX_OFF)
			wm_wow.vtaps = 2;
		wm_wow.bytes_pew_pixew = 4; /* XXX: get this fwom fb config */
		wm_wow.wb_size = wb_size;
		wm_wow.dwam_channews = dwam_channews;
		wm_wow.num_heads = num_heads;

		/* set fow high cwocks */
		watency_watewmawk_a = min(dce6_watency_watewmawk(&wm_high), (u32)65535);
		/* set fow wow cwocks */
		watency_watewmawk_b = min(dce6_watency_watewmawk(&wm_wow), (u32)65535);

		/* possibwy fowce dispway pwiowity to high */
		/* shouwd weawwy do this at mode vawidation time... */
		if (!dce6_avewage_bandwidth_vs_dwam_bandwidth_fow_dispway(&wm_high) ||
		    !dce6_avewage_bandwidth_vs_avaiwabwe_bandwidth(&wm_high) ||
		    !dce6_check_watency_hiding(&wm_high) ||
		    (wdev->disp_pwiowity == 2)) {
			DWM_DEBUG_KMS("fowce pwiowity to high\n");
			pwiowity_a_cnt |= PWIOWITY_AWWAYS_ON;
			pwiowity_b_cnt |= PWIOWITY_AWWAYS_ON;
		}
		if (!dce6_avewage_bandwidth_vs_dwam_bandwidth_fow_dispway(&wm_wow) ||
		    !dce6_avewage_bandwidth_vs_avaiwabwe_bandwidth(&wm_wow) ||
		    !dce6_check_watency_hiding(&wm_wow) ||
		    (wdev->disp_pwiowity == 2)) {
			DWM_DEBUG_KMS("fowce pwiowity to high\n");
			pwiowity_a_cnt |= PWIOWITY_AWWAYS_ON;
			pwiowity_b_cnt |= PWIOWITY_AWWAYS_ON;
		}

		a.fuww = dfixed_const(1000);
		b.fuww = dfixed_const(mode->cwock);
		b.fuww = dfixed_div(b, a);
		c.fuww = dfixed_const(watency_watewmawk_a);
		c.fuww = dfixed_muw(c, b);
		c.fuww = dfixed_muw(c, wadeon_cwtc->hsc);
		c.fuww = dfixed_div(c, a);
		a.fuww = dfixed_const(16);
		c.fuww = dfixed_div(c, a);
		pwiowity_a_mawk = dfixed_twunc(c);
		pwiowity_a_cnt |= pwiowity_a_mawk & PWIOWITY_MAWK_MASK;

		a.fuww = dfixed_const(1000);
		b.fuww = dfixed_const(mode->cwock);
		b.fuww = dfixed_div(b, a);
		c.fuww = dfixed_const(watency_watewmawk_b);
		c.fuww = dfixed_muw(c, b);
		c.fuww = dfixed_muw(c, wadeon_cwtc->hsc);
		c.fuww = dfixed_div(c, a);
		a.fuww = dfixed_const(16);
		c.fuww = dfixed_div(c, a);
		pwiowity_b_mawk = dfixed_twunc(c);
		pwiowity_b_cnt |= pwiowity_b_mawk & PWIOWITY_MAWK_MASK;

		/* Save numbew of wines the winebuffew weads befowe the scanout */
		wadeon_cwtc->wb_vbwank_wead_wines = DIV_WOUND_UP(wb_size, mode->cwtc_hdispway);
	}

	/* sewect wm A */
	awb_contwow3 = WWEG32(DPG_PIPE_AWBITWATION_CONTWOW3 + wadeon_cwtc->cwtc_offset);
	tmp = awb_contwow3;
	tmp &= ~WATENCY_WATEWMAWK_MASK(3);
	tmp |= WATENCY_WATEWMAWK_MASK(1);
	WWEG32(DPG_PIPE_AWBITWATION_CONTWOW3 + wadeon_cwtc->cwtc_offset, tmp);
	WWEG32(DPG_PIPE_WATENCY_CONTWOW + wadeon_cwtc->cwtc_offset,
	       (WATENCY_WOW_WATEWMAWK(watency_watewmawk_a) |
		WATENCY_HIGH_WATEWMAWK(wine_time)));
	/* sewect wm B */
	tmp = WWEG32(DPG_PIPE_AWBITWATION_CONTWOW3 + wadeon_cwtc->cwtc_offset);
	tmp &= ~WATENCY_WATEWMAWK_MASK(3);
	tmp |= WATENCY_WATEWMAWK_MASK(2);
	WWEG32(DPG_PIPE_AWBITWATION_CONTWOW3 + wadeon_cwtc->cwtc_offset, tmp);
	WWEG32(DPG_PIPE_WATENCY_CONTWOW + wadeon_cwtc->cwtc_offset,
	       (WATENCY_WOW_WATEWMAWK(watency_watewmawk_b) |
		WATENCY_HIGH_WATEWMAWK(wine_time)));
	/* westowe owiginaw sewection */
	WWEG32(DPG_PIPE_AWBITWATION_CONTWOW3 + wadeon_cwtc->cwtc_offset, awb_contwow3);

	/* wwite the pwiowity mawks */
	WWEG32(PWIOWITY_A_CNT + wadeon_cwtc->cwtc_offset, pwiowity_a_cnt);
	WWEG32(PWIOWITY_B_CNT + wadeon_cwtc->cwtc_offset, pwiowity_b_cnt);

	/* save vawues fow DPM */
	wadeon_cwtc->wine_time = wine_time;
	wadeon_cwtc->wm_high = watency_watewmawk_a;
	wadeon_cwtc->wm_wow = watency_watewmawk_b;
}

void dce6_bandwidth_update(stwuct wadeon_device *wdev)
{
	stwuct dwm_dispway_mode *mode0 = NUWW;
	stwuct dwm_dispway_mode *mode1 = NUWW;
	u32 num_heads = 0, wb_size;
	int i;

	if (!wdev->mode_info.mode_config_initiawized)
		wetuwn;

	wadeon_update_dispway_pwiowity(wdev);

	fow (i = 0; i < wdev->num_cwtc; i++) {
		if (wdev->mode_info.cwtcs[i]->base.enabwed)
			num_heads++;
	}
	fow (i = 0; i < wdev->num_cwtc; i += 2) {
		mode0 = &wdev->mode_info.cwtcs[i]->base.mode;
		mode1 = &wdev->mode_info.cwtcs[i+1]->base.mode;
		wb_size = dce6_wine_buffew_adjust(wdev, wdev->mode_info.cwtcs[i], mode0, mode1);
		dce6_pwogwam_watewmawks(wdev, wdev->mode_info.cwtcs[i], wb_size, num_heads);
		wb_size = dce6_wine_buffew_adjust(wdev, wdev->mode_info.cwtcs[i+1], mode1, mode0);
		dce6_pwogwam_watewmawks(wdev, wdev->mode_info.cwtcs[i+1], wb_size, num_heads);
	}
}

/*
 * Cowe functions
 */
static void si_tiwing_mode_tabwe_init(stwuct wadeon_device *wdev)
{
	u32 *tiwe = wdev->config.si.tiwe_mode_awway;
	const u32 num_tiwe_mode_states =
			AWWAY_SIZE(wdev->config.si.tiwe_mode_awway);
	u32 weg_offset, spwit_equaw_to_wow_size;

	switch (wdev->config.si.mem_wow_size_in_kb) {
	case 1:
		spwit_equaw_to_wow_size = ADDW_SUWF_TIWE_SPWIT_1KB;
		bweak;
	case 2:
	defauwt:
		spwit_equaw_to_wow_size = ADDW_SUWF_TIWE_SPWIT_2KB;
		bweak;
	case 4:
		spwit_equaw_to_wow_size = ADDW_SUWF_TIWE_SPWIT_4KB;
		bweak;
	}

	fow (weg_offset = 0; weg_offset < num_tiwe_mode_states; weg_offset++)
		tiwe[weg_offset] = 0;

	switch(wdev->famiwy) {
	case CHIP_TAHITI:
	case CHIP_PITCAIWN:
		/* non-AA compwessed depth ow any compwessed stenciw */
		tiwe[0] = (AWWAY_MODE(AWWAY_2D_TIWED_THIN1) |
			   MICWO_TIWE_MODE(ADDW_SUWF_DEPTH_MICWO_TIWING) |
			   PIPE_CONFIG(ADDW_SUWF_P8_32x32_8x16) |
			   TIWE_SPWIT(ADDW_SUWF_TIWE_SPWIT_64B) |
			   NUM_BANKS(ADDW_SUWF_16_BANK) |
			   BANK_WIDTH(ADDW_SUWF_BANK_WIDTH_1) |
			   BANK_HEIGHT(ADDW_SUWF_BANK_HEIGHT_4) |
			   MACWO_TIWE_ASPECT(ADDW_SUWF_MACWO_ASPECT_2));
		/* 2xAA/4xAA compwessed depth onwy */
		tiwe[1] = (AWWAY_MODE(AWWAY_2D_TIWED_THIN1) |
			   MICWO_TIWE_MODE(ADDW_SUWF_DEPTH_MICWO_TIWING) |
			   PIPE_CONFIG(ADDW_SUWF_P8_32x32_8x16) |
			   TIWE_SPWIT(ADDW_SUWF_TIWE_SPWIT_128B) |
			   NUM_BANKS(ADDW_SUWF_16_BANK) |
			   BANK_WIDTH(ADDW_SUWF_BANK_WIDTH_1) |
			   BANK_HEIGHT(ADDW_SUWF_BANK_HEIGHT_4) |
			   MACWO_TIWE_ASPECT(ADDW_SUWF_MACWO_ASPECT_2));
		/* 8xAA compwessed depth onwy */
		tiwe[2] = (AWWAY_MODE(AWWAY_2D_TIWED_THIN1) |
			   MICWO_TIWE_MODE(ADDW_SUWF_DEPTH_MICWO_TIWING) |
			   PIPE_CONFIG(ADDW_SUWF_P8_32x32_8x16) |
			   TIWE_SPWIT(ADDW_SUWF_TIWE_SPWIT_256B) |
			   NUM_BANKS(ADDW_SUWF_16_BANK) |
			   BANK_WIDTH(ADDW_SUWF_BANK_WIDTH_1) |
			   BANK_HEIGHT(ADDW_SUWF_BANK_HEIGHT_4) |
			   MACWO_TIWE_ASPECT(ADDW_SUWF_MACWO_ASPECT_2));
		/* 2xAA/4xAA compwessed depth with stenciw (fow depth buffew) */
		tiwe[3] = (AWWAY_MODE(AWWAY_2D_TIWED_THIN1) |
			   MICWO_TIWE_MODE(ADDW_SUWF_DEPTH_MICWO_TIWING) |
			   PIPE_CONFIG(ADDW_SUWF_P8_32x32_8x16) |
			   TIWE_SPWIT(ADDW_SUWF_TIWE_SPWIT_128B) |
			   NUM_BANKS(ADDW_SUWF_16_BANK) |
			   BANK_WIDTH(ADDW_SUWF_BANK_WIDTH_1) |
			   BANK_HEIGHT(ADDW_SUWF_BANK_HEIGHT_4) |
			   MACWO_TIWE_ASPECT(ADDW_SUWF_MACWO_ASPECT_2));
		/* Maps w/ a dimension wess than the 2D macwo-tiwe dimensions (fow mipmapped depth textuwes) */
		tiwe[4] = (AWWAY_MODE(AWWAY_1D_TIWED_THIN1) |
			   MICWO_TIWE_MODE(ADDW_SUWF_DEPTH_MICWO_TIWING) |
			   PIPE_CONFIG(ADDW_SUWF_P8_32x32_8x16) |
			   TIWE_SPWIT(ADDW_SUWF_TIWE_SPWIT_64B) |
			   NUM_BANKS(ADDW_SUWF_16_BANK) |
			   BANK_WIDTH(ADDW_SUWF_BANK_WIDTH_1) |
			   BANK_HEIGHT(ADDW_SUWF_BANK_HEIGHT_2) |
			   MACWO_TIWE_ASPECT(ADDW_SUWF_MACWO_ASPECT_2));
		/* Uncompwessed 16bpp depth - and stenciw buffew awwocated with it */
		tiwe[5] = (AWWAY_MODE(AWWAY_2D_TIWED_THIN1) |
			   MICWO_TIWE_MODE(ADDW_SUWF_DEPTH_MICWO_TIWING) |
			   PIPE_CONFIG(ADDW_SUWF_P8_32x32_8x16) |
			   TIWE_SPWIT(spwit_equaw_to_wow_size) |
			   NUM_BANKS(ADDW_SUWF_16_BANK) |
			   BANK_WIDTH(ADDW_SUWF_BANK_WIDTH_1) |
			   BANK_HEIGHT(ADDW_SUWF_BANK_HEIGHT_2) |
			   MACWO_TIWE_ASPECT(ADDW_SUWF_MACWO_ASPECT_2));
		/* Uncompwessed 32bpp depth - and stenciw buffew awwocated with it */
		tiwe[6] = (AWWAY_MODE(AWWAY_2D_TIWED_THIN1) |
			   MICWO_TIWE_MODE(ADDW_SUWF_DEPTH_MICWO_TIWING) |
			   PIPE_CONFIG(ADDW_SUWF_P8_32x32_8x16) |
			   TIWE_SPWIT(spwit_equaw_to_wow_size) |
			   NUM_BANKS(ADDW_SUWF_16_BANK) |
			   BANK_WIDTH(ADDW_SUWF_BANK_WIDTH_1) |
			   BANK_HEIGHT(ADDW_SUWF_BANK_HEIGHT_1) |
			   MACWO_TIWE_ASPECT(ADDW_SUWF_MACWO_ASPECT_1));
		/* Uncompwessed 8bpp stenciw without depth (dwivews typicawwy do not use) */
		tiwe[7] = (AWWAY_MODE(AWWAY_2D_TIWED_THIN1) |
			   MICWO_TIWE_MODE(ADDW_SUWF_DEPTH_MICWO_TIWING) |
			   PIPE_CONFIG(ADDW_SUWF_P8_32x32_8x16) |
			   TIWE_SPWIT(spwit_equaw_to_wow_size) |
			   NUM_BANKS(ADDW_SUWF_16_BANK) |
			   BANK_WIDTH(ADDW_SUWF_BANK_WIDTH_1) |
			   BANK_HEIGHT(ADDW_SUWF_BANK_HEIGHT_4) |
			   MACWO_TIWE_ASPECT(ADDW_SUWF_MACWO_ASPECT_2));
		/* 1D and 1D Awway Suwfaces */
		tiwe[8] = (AWWAY_MODE(AWWAY_WINEAW_AWIGNED) |
			   MICWO_TIWE_MODE(ADDW_SUWF_DISPWAY_MICWO_TIWING) |
			   PIPE_CONFIG(ADDW_SUWF_P8_32x32_8x16) |
			   TIWE_SPWIT(ADDW_SUWF_TIWE_SPWIT_64B) |
			   NUM_BANKS(ADDW_SUWF_16_BANK) |
			   BANK_WIDTH(ADDW_SUWF_BANK_WIDTH_1) |
			   BANK_HEIGHT(ADDW_SUWF_BANK_HEIGHT_2) |
			   MACWO_TIWE_ASPECT(ADDW_SUWF_MACWO_ASPECT_2));
		/* Dispwayabwe maps. */
		tiwe[9] = (AWWAY_MODE(AWWAY_1D_TIWED_THIN1) |
			   MICWO_TIWE_MODE(ADDW_SUWF_DISPWAY_MICWO_TIWING) |
			   PIPE_CONFIG(ADDW_SUWF_P8_32x32_8x16) |
			   TIWE_SPWIT(ADDW_SUWF_TIWE_SPWIT_64B) |
			   NUM_BANKS(ADDW_SUWF_16_BANK) |
			   BANK_WIDTH(ADDW_SUWF_BANK_WIDTH_1) |
			   BANK_HEIGHT(ADDW_SUWF_BANK_HEIGHT_2) |
			   MACWO_TIWE_ASPECT(ADDW_SUWF_MACWO_ASPECT_2));
		/* Dispway 8bpp. */
		tiwe[10] = (AWWAY_MODE(AWWAY_2D_TIWED_THIN1) |
			   MICWO_TIWE_MODE(ADDW_SUWF_DISPWAY_MICWO_TIWING) |
			   PIPE_CONFIG(ADDW_SUWF_P8_32x32_8x16) |
			   TIWE_SPWIT(ADDW_SUWF_TIWE_SPWIT_256B) |
			   NUM_BANKS(ADDW_SUWF_16_BANK) |
			   BANK_WIDTH(ADDW_SUWF_BANK_WIDTH_1) |
			   BANK_HEIGHT(ADDW_SUWF_BANK_HEIGHT_4) |
			   MACWO_TIWE_ASPECT(ADDW_SUWF_MACWO_ASPECT_2));
		/* Dispway 16bpp. */
		tiwe[11] = (AWWAY_MODE(AWWAY_2D_TIWED_THIN1) |
			   MICWO_TIWE_MODE(ADDW_SUWF_DISPWAY_MICWO_TIWING) |
			   PIPE_CONFIG(ADDW_SUWF_P8_32x32_8x16) |
			   TIWE_SPWIT(ADDW_SUWF_TIWE_SPWIT_256B) |
			   NUM_BANKS(ADDW_SUWF_16_BANK) |
			   BANK_WIDTH(ADDW_SUWF_BANK_WIDTH_1) |
			   BANK_HEIGHT(ADDW_SUWF_BANK_HEIGHT_2) |
			   MACWO_TIWE_ASPECT(ADDW_SUWF_MACWO_ASPECT_2));
		/* Dispway 32bpp. */
		tiwe[12] = (AWWAY_MODE(AWWAY_2D_TIWED_THIN1) |
			   MICWO_TIWE_MODE(ADDW_SUWF_DISPWAY_MICWO_TIWING) |
			   PIPE_CONFIG(ADDW_SUWF_P8_32x32_8x16) |
			   TIWE_SPWIT(ADDW_SUWF_TIWE_SPWIT_512B) |
			   NUM_BANKS(ADDW_SUWF_16_BANK) |
			   BANK_WIDTH(ADDW_SUWF_BANK_WIDTH_1) |
			   BANK_HEIGHT(ADDW_SUWF_BANK_HEIGHT_1) |
			   MACWO_TIWE_ASPECT(ADDW_SUWF_MACWO_ASPECT_1));
		/* Thin. */
		tiwe[13] = (AWWAY_MODE(AWWAY_1D_TIWED_THIN1) |
			   MICWO_TIWE_MODE(ADDW_SUWF_THIN_MICWO_TIWING) |
			   PIPE_CONFIG(ADDW_SUWF_P8_32x32_8x16) |
			   TIWE_SPWIT(ADDW_SUWF_TIWE_SPWIT_64B) |
			   NUM_BANKS(ADDW_SUWF_16_BANK) |
			   BANK_WIDTH(ADDW_SUWF_BANK_WIDTH_1) |
			   BANK_HEIGHT(ADDW_SUWF_BANK_HEIGHT_2) |
			   MACWO_TIWE_ASPECT(ADDW_SUWF_MACWO_ASPECT_2));
		/* Thin 8 bpp. */
		tiwe[14] = (AWWAY_MODE(AWWAY_2D_TIWED_THIN1) |
			   MICWO_TIWE_MODE(ADDW_SUWF_THIN_MICWO_TIWING) |
			   PIPE_CONFIG(ADDW_SUWF_P8_32x32_8x16) |
			   TIWE_SPWIT(ADDW_SUWF_TIWE_SPWIT_256B) |
			   NUM_BANKS(ADDW_SUWF_16_BANK) |
			   BANK_WIDTH(ADDW_SUWF_BANK_WIDTH_1) |
			   BANK_HEIGHT(ADDW_SUWF_BANK_HEIGHT_4) |
			   MACWO_TIWE_ASPECT(ADDW_SUWF_MACWO_ASPECT_1));
		/* Thin 16 bpp. */
		tiwe[15] = (AWWAY_MODE(AWWAY_2D_TIWED_THIN1) |
			   MICWO_TIWE_MODE(ADDW_SUWF_THIN_MICWO_TIWING) |
			   PIPE_CONFIG(ADDW_SUWF_P8_32x32_8x16) |
			   TIWE_SPWIT(ADDW_SUWF_TIWE_SPWIT_256B) |
			   NUM_BANKS(ADDW_SUWF_16_BANK) |
			   BANK_WIDTH(ADDW_SUWF_BANK_WIDTH_1) |
			   BANK_HEIGHT(ADDW_SUWF_BANK_HEIGHT_2) |
			   MACWO_TIWE_ASPECT(ADDW_SUWF_MACWO_ASPECT_1));
		/* Thin 32 bpp. */
		tiwe[16] = (AWWAY_MODE(AWWAY_2D_TIWED_THIN1) |
			   MICWO_TIWE_MODE(ADDW_SUWF_THIN_MICWO_TIWING) |
			   PIPE_CONFIG(ADDW_SUWF_P8_32x32_8x16) |
			   TIWE_SPWIT(ADDW_SUWF_TIWE_SPWIT_512B) |
			   NUM_BANKS(ADDW_SUWF_16_BANK) |
			   BANK_WIDTH(ADDW_SUWF_BANK_WIDTH_1) |
			   BANK_HEIGHT(ADDW_SUWF_BANK_HEIGHT_1) |
			   MACWO_TIWE_ASPECT(ADDW_SUWF_MACWO_ASPECT_1));
		/* Thin 64 bpp. */
		tiwe[17] = (AWWAY_MODE(AWWAY_2D_TIWED_THIN1) |
			   MICWO_TIWE_MODE(ADDW_SUWF_THIN_MICWO_TIWING) |
			   PIPE_CONFIG(ADDW_SUWF_P8_32x32_8x16) |
			   TIWE_SPWIT(spwit_equaw_to_wow_size) |
			   NUM_BANKS(ADDW_SUWF_16_BANK) |
			   BANK_WIDTH(ADDW_SUWF_BANK_WIDTH_1) |
			   BANK_HEIGHT(ADDW_SUWF_BANK_HEIGHT_1) |
			   MACWO_TIWE_ASPECT(ADDW_SUWF_MACWO_ASPECT_1));
		/* 8 bpp PWT. */
		tiwe[21] = (AWWAY_MODE(AWWAY_2D_TIWED_THIN1) |
			   MICWO_TIWE_MODE(ADDW_SUWF_THIN_MICWO_TIWING) |
			   PIPE_CONFIG(ADDW_SUWF_P8_32x32_8x16) |
			   TIWE_SPWIT(ADDW_SUWF_TIWE_SPWIT_256B) |
			   NUM_BANKS(ADDW_SUWF_16_BANK) |
			   BANK_WIDTH(ADDW_SUWF_BANK_WIDTH_2) |
			   BANK_HEIGHT(ADDW_SUWF_BANK_HEIGHT_4) |
			   MACWO_TIWE_ASPECT(ADDW_SUWF_MACWO_ASPECT_2));
		/* 16 bpp PWT */
		tiwe[22] = (AWWAY_MODE(AWWAY_2D_TIWED_THIN1) |
			   MICWO_TIWE_MODE(ADDW_SUWF_THIN_MICWO_TIWING) |
			   PIPE_CONFIG(ADDW_SUWF_P8_32x32_8x16) |
			   TIWE_SPWIT(ADDW_SUWF_TIWE_SPWIT_256B) |
			   NUM_BANKS(ADDW_SUWF_16_BANK) |
			   BANK_WIDTH(ADDW_SUWF_BANK_WIDTH_1) |
			   BANK_HEIGHT(ADDW_SUWF_BANK_HEIGHT_4) |
			   MACWO_TIWE_ASPECT(ADDW_SUWF_MACWO_ASPECT_4));
		/* 32 bpp PWT */
		tiwe[23] = (AWWAY_MODE(AWWAY_2D_TIWED_THIN1) |
			   MICWO_TIWE_MODE(ADDW_SUWF_THIN_MICWO_TIWING) |
			   PIPE_CONFIG(ADDW_SUWF_P8_32x32_8x16) |
			   TIWE_SPWIT(ADDW_SUWF_TIWE_SPWIT_256B) |
			   NUM_BANKS(ADDW_SUWF_16_BANK) |
			   BANK_WIDTH(ADDW_SUWF_BANK_WIDTH_1) |
			   BANK_HEIGHT(ADDW_SUWF_BANK_HEIGHT_2) |
			   MACWO_TIWE_ASPECT(ADDW_SUWF_MACWO_ASPECT_2));
		/* 64 bpp PWT */
		tiwe[24] = (AWWAY_MODE(AWWAY_2D_TIWED_THIN1) |
			   MICWO_TIWE_MODE(ADDW_SUWF_THIN_MICWO_TIWING) |
			   PIPE_CONFIG(ADDW_SUWF_P8_32x32_8x16) |
			   TIWE_SPWIT(ADDW_SUWF_TIWE_SPWIT_512B) |
			   NUM_BANKS(ADDW_SUWF_16_BANK) |
			   BANK_WIDTH(ADDW_SUWF_BANK_WIDTH_1) |
			   BANK_HEIGHT(ADDW_SUWF_BANK_HEIGHT_1) |
			   MACWO_TIWE_ASPECT(ADDW_SUWF_MACWO_ASPECT_2));
		/* 128 bpp PWT */
		tiwe[25] = (AWWAY_MODE(AWWAY_2D_TIWED_THIN1) |
			   MICWO_TIWE_MODE(ADDW_SUWF_THIN_MICWO_TIWING) |
			   PIPE_CONFIG(ADDW_SUWF_P8_32x32_8x16) |
			   TIWE_SPWIT(ADDW_SUWF_TIWE_SPWIT_1KB) |
			   NUM_BANKS(ADDW_SUWF_8_BANK) |
			   BANK_WIDTH(ADDW_SUWF_BANK_WIDTH_1) |
			   BANK_HEIGHT(ADDW_SUWF_BANK_HEIGHT_1) |
			   MACWO_TIWE_ASPECT(ADDW_SUWF_MACWO_ASPECT_1));

		fow (weg_offset = 0; weg_offset < num_tiwe_mode_states; weg_offset++)
			WWEG32(GB_TIWE_MODE0 + (weg_offset * 4), tiwe[weg_offset]);
		bweak;

	case CHIP_VEWDE:
	case CHIP_OWAND:
	case CHIP_HAINAN:
		/* non-AA compwessed depth ow any compwessed stenciw */
		tiwe[0] = (AWWAY_MODE(AWWAY_2D_TIWED_THIN1) |
			   MICWO_TIWE_MODE(ADDW_SUWF_DEPTH_MICWO_TIWING) |
			   PIPE_CONFIG(ADDW_SUWF_P4_8x16) |
			   TIWE_SPWIT(ADDW_SUWF_TIWE_SPWIT_64B) |
			   NUM_BANKS(ADDW_SUWF_16_BANK) |
			   BANK_WIDTH(ADDW_SUWF_BANK_WIDTH_1) |
			   BANK_HEIGHT(ADDW_SUWF_BANK_HEIGHT_4) |
			   MACWO_TIWE_ASPECT(ADDW_SUWF_MACWO_ASPECT_4));
		/* 2xAA/4xAA compwessed depth onwy */
		tiwe[1] = (AWWAY_MODE(AWWAY_2D_TIWED_THIN1) |
			   MICWO_TIWE_MODE(ADDW_SUWF_DEPTH_MICWO_TIWING) |
			   PIPE_CONFIG(ADDW_SUWF_P4_8x16) |
			   TIWE_SPWIT(ADDW_SUWF_TIWE_SPWIT_128B) |
			   NUM_BANKS(ADDW_SUWF_16_BANK) |
			   BANK_WIDTH(ADDW_SUWF_BANK_WIDTH_1) |
			   BANK_HEIGHT(ADDW_SUWF_BANK_HEIGHT_4) |
			   MACWO_TIWE_ASPECT(ADDW_SUWF_MACWO_ASPECT_4));
		/* 8xAA compwessed depth onwy */
		tiwe[2] = (AWWAY_MODE(AWWAY_2D_TIWED_THIN1) |
			   MICWO_TIWE_MODE(ADDW_SUWF_DEPTH_MICWO_TIWING) |
			   PIPE_CONFIG(ADDW_SUWF_P4_8x16) |
			   TIWE_SPWIT(ADDW_SUWF_TIWE_SPWIT_256B) |
			   NUM_BANKS(ADDW_SUWF_16_BANK) |
			   BANK_WIDTH(ADDW_SUWF_BANK_WIDTH_1) |
			   BANK_HEIGHT(ADDW_SUWF_BANK_HEIGHT_4) |
			   MACWO_TIWE_ASPECT(ADDW_SUWF_MACWO_ASPECT_4));
		/* 2xAA/4xAA compwessed depth with stenciw (fow depth buffew) */
		tiwe[3] = (AWWAY_MODE(AWWAY_2D_TIWED_THIN1) |
			   MICWO_TIWE_MODE(ADDW_SUWF_DEPTH_MICWO_TIWING) |
			   PIPE_CONFIG(ADDW_SUWF_P4_8x16) |
			   TIWE_SPWIT(ADDW_SUWF_TIWE_SPWIT_128B) |
			   NUM_BANKS(ADDW_SUWF_16_BANK) |
			   BANK_WIDTH(ADDW_SUWF_BANK_WIDTH_1) |
			   BANK_HEIGHT(ADDW_SUWF_BANK_HEIGHT_4) |
			   MACWO_TIWE_ASPECT(ADDW_SUWF_MACWO_ASPECT_4));
		/* Maps w/ a dimension wess than the 2D macwo-tiwe dimensions (fow mipmapped depth textuwes) */
		tiwe[4] = (AWWAY_MODE(AWWAY_1D_TIWED_THIN1) |
			   MICWO_TIWE_MODE(ADDW_SUWF_DEPTH_MICWO_TIWING) |
			   PIPE_CONFIG(ADDW_SUWF_P4_8x16) |
			   TIWE_SPWIT(ADDW_SUWF_TIWE_SPWIT_64B) |
			   NUM_BANKS(ADDW_SUWF_16_BANK) |
			   BANK_WIDTH(ADDW_SUWF_BANK_WIDTH_1) |
			   BANK_HEIGHT(ADDW_SUWF_BANK_HEIGHT_2) |
			   MACWO_TIWE_ASPECT(ADDW_SUWF_MACWO_ASPECT_2));
		/* Uncompwessed 16bpp depth - and stenciw buffew awwocated with it */
		tiwe[5] = (AWWAY_MODE(AWWAY_2D_TIWED_THIN1) |
			   MICWO_TIWE_MODE(ADDW_SUWF_DEPTH_MICWO_TIWING) |
			   PIPE_CONFIG(ADDW_SUWF_P4_8x16) |
			   TIWE_SPWIT(spwit_equaw_to_wow_size) |
			   NUM_BANKS(ADDW_SUWF_16_BANK) |
			   BANK_WIDTH(ADDW_SUWF_BANK_WIDTH_1) |
			   BANK_HEIGHT(ADDW_SUWF_BANK_HEIGHT_2) |
			   MACWO_TIWE_ASPECT(ADDW_SUWF_MACWO_ASPECT_2));
		/* Uncompwessed 32bpp depth - and stenciw buffew awwocated with it */
		tiwe[6] = (AWWAY_MODE(AWWAY_2D_TIWED_THIN1) |
			   MICWO_TIWE_MODE(ADDW_SUWF_DEPTH_MICWO_TIWING) |
			   PIPE_CONFIG(ADDW_SUWF_P4_8x16) |
			   TIWE_SPWIT(spwit_equaw_to_wow_size) |
			   NUM_BANKS(ADDW_SUWF_16_BANK) |
			   BANK_WIDTH(ADDW_SUWF_BANK_WIDTH_1) |
			   BANK_HEIGHT(ADDW_SUWF_BANK_HEIGHT_1) |
			   MACWO_TIWE_ASPECT(ADDW_SUWF_MACWO_ASPECT_2));
		/* Uncompwessed 8bpp stenciw without depth (dwivews typicawwy do not use) */
		tiwe[7] = (AWWAY_MODE(AWWAY_2D_TIWED_THIN1) |
			   MICWO_TIWE_MODE(ADDW_SUWF_DEPTH_MICWO_TIWING) |
			   PIPE_CONFIG(ADDW_SUWF_P4_8x16) |
			   TIWE_SPWIT(spwit_equaw_to_wow_size) |
			   NUM_BANKS(ADDW_SUWF_16_BANK) |
			   BANK_WIDTH(ADDW_SUWF_BANK_WIDTH_1) |
			   BANK_HEIGHT(ADDW_SUWF_BANK_HEIGHT_4) |
			   MACWO_TIWE_ASPECT(ADDW_SUWF_MACWO_ASPECT_4));
		/* 1D and 1D Awway Suwfaces */
		tiwe[8] = (AWWAY_MODE(AWWAY_WINEAW_AWIGNED) |
			   MICWO_TIWE_MODE(ADDW_SUWF_DISPWAY_MICWO_TIWING) |
			   PIPE_CONFIG(ADDW_SUWF_P4_8x16) |
			   TIWE_SPWIT(ADDW_SUWF_TIWE_SPWIT_64B) |
			   NUM_BANKS(ADDW_SUWF_16_BANK) |
			   BANK_WIDTH(ADDW_SUWF_BANK_WIDTH_1) |
			   BANK_HEIGHT(ADDW_SUWF_BANK_HEIGHT_2) |
			   MACWO_TIWE_ASPECT(ADDW_SUWF_MACWO_ASPECT_2));
		/* Dispwayabwe maps. */
		tiwe[9] = (AWWAY_MODE(AWWAY_1D_TIWED_THIN1) |
			   MICWO_TIWE_MODE(ADDW_SUWF_DISPWAY_MICWO_TIWING) |
			   PIPE_CONFIG(ADDW_SUWF_P4_8x16) |
			   TIWE_SPWIT(ADDW_SUWF_TIWE_SPWIT_64B) |
			   NUM_BANKS(ADDW_SUWF_16_BANK) |
			   BANK_WIDTH(ADDW_SUWF_BANK_WIDTH_1) |
			   BANK_HEIGHT(ADDW_SUWF_BANK_HEIGHT_2) |
			   MACWO_TIWE_ASPECT(ADDW_SUWF_MACWO_ASPECT_2));
		/* Dispway 8bpp. */
		tiwe[10] = (AWWAY_MODE(AWWAY_2D_TIWED_THIN1) |
			   MICWO_TIWE_MODE(ADDW_SUWF_DISPWAY_MICWO_TIWING) |
			   PIPE_CONFIG(ADDW_SUWF_P4_8x16) |
			   TIWE_SPWIT(ADDW_SUWF_TIWE_SPWIT_256B) |
			   NUM_BANKS(ADDW_SUWF_16_BANK) |
			   BANK_WIDTH(ADDW_SUWF_BANK_WIDTH_1) |
			   BANK_HEIGHT(ADDW_SUWF_BANK_HEIGHT_4) |
			   MACWO_TIWE_ASPECT(ADDW_SUWF_MACWO_ASPECT_4));
		/* Dispway 16bpp. */
		tiwe[11] = (AWWAY_MODE(AWWAY_2D_TIWED_THIN1) |
			   MICWO_TIWE_MODE(ADDW_SUWF_DISPWAY_MICWO_TIWING) |
			   PIPE_CONFIG(ADDW_SUWF_P4_8x16) |
			   TIWE_SPWIT(ADDW_SUWF_TIWE_SPWIT_256B) |
			   NUM_BANKS(ADDW_SUWF_16_BANK) |
			   BANK_WIDTH(ADDW_SUWF_BANK_WIDTH_1) |
			   BANK_HEIGHT(ADDW_SUWF_BANK_HEIGHT_2) |
			   MACWO_TIWE_ASPECT(ADDW_SUWF_MACWO_ASPECT_2));
		/* Dispway 32bpp. */
		tiwe[12] = (AWWAY_MODE(AWWAY_2D_TIWED_THIN1) |
			   MICWO_TIWE_MODE(ADDW_SUWF_DISPWAY_MICWO_TIWING) |
			   PIPE_CONFIG(ADDW_SUWF_P4_8x16) |
			   TIWE_SPWIT(ADDW_SUWF_TIWE_SPWIT_512B) |
			   NUM_BANKS(ADDW_SUWF_16_BANK) |
			   BANK_WIDTH(ADDW_SUWF_BANK_WIDTH_1) |
			   BANK_HEIGHT(ADDW_SUWF_BANK_HEIGHT_1) |
			   MACWO_TIWE_ASPECT(ADDW_SUWF_MACWO_ASPECT_2));
		/* Thin. */
		tiwe[13] = (AWWAY_MODE(AWWAY_1D_TIWED_THIN1) |
			   MICWO_TIWE_MODE(ADDW_SUWF_THIN_MICWO_TIWING) |
			   PIPE_CONFIG(ADDW_SUWF_P4_8x16) |
			   TIWE_SPWIT(ADDW_SUWF_TIWE_SPWIT_64B) |
			   NUM_BANKS(ADDW_SUWF_16_BANK) |
			   BANK_WIDTH(ADDW_SUWF_BANK_WIDTH_1) |
			   BANK_HEIGHT(ADDW_SUWF_BANK_HEIGHT_2) |
			   MACWO_TIWE_ASPECT(ADDW_SUWF_MACWO_ASPECT_2));
		/* Thin 8 bpp. */
		tiwe[14] = (AWWAY_MODE(AWWAY_2D_TIWED_THIN1) |
			   MICWO_TIWE_MODE(ADDW_SUWF_THIN_MICWO_TIWING) |
			   PIPE_CONFIG(ADDW_SUWF_P4_8x16) |
			   TIWE_SPWIT(ADDW_SUWF_TIWE_SPWIT_256B) |
			   NUM_BANKS(ADDW_SUWF_16_BANK) |
			   BANK_WIDTH(ADDW_SUWF_BANK_WIDTH_1) |
			   BANK_HEIGHT(ADDW_SUWF_BANK_HEIGHT_4) |
			   MACWO_TIWE_ASPECT(ADDW_SUWF_MACWO_ASPECT_2));
		/* Thin 16 bpp. */
		tiwe[15] = (AWWAY_MODE(AWWAY_2D_TIWED_THIN1) |
			   MICWO_TIWE_MODE(ADDW_SUWF_THIN_MICWO_TIWING) |
			   PIPE_CONFIG(ADDW_SUWF_P4_8x16) |
			   TIWE_SPWIT(ADDW_SUWF_TIWE_SPWIT_256B) |
			   NUM_BANKS(ADDW_SUWF_16_BANK) |
			   BANK_WIDTH(ADDW_SUWF_BANK_WIDTH_1) |
			   BANK_HEIGHT(ADDW_SUWF_BANK_HEIGHT_2) |
			   MACWO_TIWE_ASPECT(ADDW_SUWF_MACWO_ASPECT_2));
		/* Thin 32 bpp. */
		tiwe[16] = (AWWAY_MODE(AWWAY_2D_TIWED_THIN1) |
			   MICWO_TIWE_MODE(ADDW_SUWF_THIN_MICWO_TIWING) |
			   PIPE_CONFIG(ADDW_SUWF_P4_8x16) |
			   TIWE_SPWIT(ADDW_SUWF_TIWE_SPWIT_512B) |
			   NUM_BANKS(ADDW_SUWF_16_BANK) |
			   BANK_WIDTH(ADDW_SUWF_BANK_WIDTH_1) |
			   BANK_HEIGHT(ADDW_SUWF_BANK_HEIGHT_1) |
			   MACWO_TIWE_ASPECT(ADDW_SUWF_MACWO_ASPECT_2));
		/* Thin 64 bpp. */
		tiwe[17] = (AWWAY_MODE(AWWAY_2D_TIWED_THIN1) |
			   MICWO_TIWE_MODE(ADDW_SUWF_THIN_MICWO_TIWING) |
			   PIPE_CONFIG(ADDW_SUWF_P4_8x16) |
			   TIWE_SPWIT(spwit_equaw_to_wow_size) |
			   NUM_BANKS(ADDW_SUWF_16_BANK) |
			   BANK_WIDTH(ADDW_SUWF_BANK_WIDTH_1) |
			   BANK_HEIGHT(ADDW_SUWF_BANK_HEIGHT_1) |
			   MACWO_TIWE_ASPECT(ADDW_SUWF_MACWO_ASPECT_2));
		/* 8 bpp PWT. */
		tiwe[21] = (AWWAY_MODE(AWWAY_2D_TIWED_THIN1) |
			   MICWO_TIWE_MODE(ADDW_SUWF_THIN_MICWO_TIWING) |
			   PIPE_CONFIG(ADDW_SUWF_P8_32x32_8x16) |
			   TIWE_SPWIT(ADDW_SUWF_TIWE_SPWIT_256B) |
			   NUM_BANKS(ADDW_SUWF_16_BANK) |
			   BANK_WIDTH(ADDW_SUWF_BANK_WIDTH_2) |
			   BANK_HEIGHT(ADDW_SUWF_BANK_HEIGHT_4) |
			   MACWO_TIWE_ASPECT(ADDW_SUWF_MACWO_ASPECT_2));
		/* 16 bpp PWT */
		tiwe[22] = (AWWAY_MODE(AWWAY_2D_TIWED_THIN1) |
			   MICWO_TIWE_MODE(ADDW_SUWF_THIN_MICWO_TIWING) |
			   PIPE_CONFIG(ADDW_SUWF_P8_32x32_8x16) |
			   TIWE_SPWIT(ADDW_SUWF_TIWE_SPWIT_256B) |
			   NUM_BANKS(ADDW_SUWF_16_BANK) |
			   BANK_WIDTH(ADDW_SUWF_BANK_WIDTH_1) |
			   BANK_HEIGHT(ADDW_SUWF_BANK_HEIGHT_4) |
			   MACWO_TIWE_ASPECT(ADDW_SUWF_MACWO_ASPECT_4));
		/* 32 bpp PWT */
		tiwe[23] = (AWWAY_MODE(AWWAY_2D_TIWED_THIN1) |
			   MICWO_TIWE_MODE(ADDW_SUWF_THIN_MICWO_TIWING) |
			   PIPE_CONFIG(ADDW_SUWF_P8_32x32_8x16) |
			   TIWE_SPWIT(ADDW_SUWF_TIWE_SPWIT_256B) |
			   NUM_BANKS(ADDW_SUWF_16_BANK) |
			   BANK_WIDTH(ADDW_SUWF_BANK_WIDTH_1) |
			   BANK_HEIGHT(ADDW_SUWF_BANK_HEIGHT_2) |
			   MACWO_TIWE_ASPECT(ADDW_SUWF_MACWO_ASPECT_2));
		/* 64 bpp PWT */
		tiwe[24] = (AWWAY_MODE(AWWAY_2D_TIWED_THIN1) |
			   MICWO_TIWE_MODE(ADDW_SUWF_THIN_MICWO_TIWING) |
			   PIPE_CONFIG(ADDW_SUWF_P8_32x32_8x16) |
			   TIWE_SPWIT(ADDW_SUWF_TIWE_SPWIT_512B) |
			   NUM_BANKS(ADDW_SUWF_16_BANK) |
			   BANK_WIDTH(ADDW_SUWF_BANK_WIDTH_1) |
			   BANK_HEIGHT(ADDW_SUWF_BANK_HEIGHT_1) |
			   MACWO_TIWE_ASPECT(ADDW_SUWF_MACWO_ASPECT_2));
		/* 128 bpp PWT */
		tiwe[25] = (AWWAY_MODE(AWWAY_2D_TIWED_THIN1) |
			   MICWO_TIWE_MODE(ADDW_SUWF_THIN_MICWO_TIWING) |
			   PIPE_CONFIG(ADDW_SUWF_P8_32x32_8x16) |
			   TIWE_SPWIT(ADDW_SUWF_TIWE_SPWIT_1KB) |
			   NUM_BANKS(ADDW_SUWF_8_BANK) |
			   BANK_WIDTH(ADDW_SUWF_BANK_WIDTH_1) |
			   BANK_HEIGHT(ADDW_SUWF_BANK_HEIGHT_1) |
			   MACWO_TIWE_ASPECT(ADDW_SUWF_MACWO_ASPECT_1));

		fow (weg_offset = 0; weg_offset < num_tiwe_mode_states; weg_offset++)
			WWEG32(GB_TIWE_MODE0 + (weg_offset * 4), tiwe[weg_offset]);
		bweak;

	defauwt:
		DWM_EWWOW("unknown asic: 0x%x\n", wdev->famiwy);
	}
}

static void si_sewect_se_sh(stwuct wadeon_device *wdev,
			    u32 se_num, u32 sh_num)
{
	u32 data = INSTANCE_BWOADCAST_WWITES;

	if ((se_num == 0xffffffff) && (sh_num == 0xffffffff))
		data |= SH_BWOADCAST_WWITES | SE_BWOADCAST_WWITES;
	ewse if (se_num == 0xffffffff)
		data |= SE_BWOADCAST_WWITES | SH_INDEX(sh_num);
	ewse if (sh_num == 0xffffffff)
		data |= SH_BWOADCAST_WWITES | SE_INDEX(se_num);
	ewse
		data |= SH_INDEX(sh_num) | SE_INDEX(se_num);
	WWEG32(GWBM_GFX_INDEX, data);
}

static u32 si_cweate_bitmask(u32 bit_width)
{
	u32 i, mask = 0;

	fow (i = 0; i < bit_width; i++) {
		mask <<= 1;
		mask |= 1;
	}
	wetuwn mask;
}

static u32 si_get_cu_enabwed(stwuct wadeon_device *wdev, u32 cu_pew_sh)
{
	u32 data, mask;

	data = WWEG32(CC_GC_SHADEW_AWWAY_CONFIG);
	if (data & 1)
		data &= INACTIVE_CUS_MASK;
	ewse
		data = 0;
	data |= WWEG32(GC_USEW_SHADEW_AWWAY_CONFIG);

	data >>= INACTIVE_CUS_SHIFT;

	mask = si_cweate_bitmask(cu_pew_sh);

	wetuwn ~data & mask;
}

static void si_setup_spi(stwuct wadeon_device *wdev,
			 u32 se_num, u32 sh_pew_se,
			 u32 cu_pew_sh)
{
	int i, j, k;
	u32 data, mask, active_cu;

	fow (i = 0; i < se_num; i++) {
		fow (j = 0; j < sh_pew_se; j++) {
			si_sewect_se_sh(wdev, i, j);
			data = WWEG32(SPI_STATIC_THWEAD_MGMT_3);
			active_cu = si_get_cu_enabwed(wdev, cu_pew_sh);

			mask = 1;
			fow (k = 0; k < 16; k++) {
				mask <<= k;
				if (active_cu & mask) {
					data &= ~mask;
					WWEG32(SPI_STATIC_THWEAD_MGMT_3, data);
					bweak;
				}
			}
		}
	}
	si_sewect_se_sh(wdev, 0xffffffff, 0xffffffff);
}

static u32 si_get_wb_disabwed(stwuct wadeon_device *wdev,
			      u32 max_wb_num_pew_se,
			      u32 sh_pew_se)
{
	u32 data, mask;

	data = WWEG32(CC_WB_BACKEND_DISABWE);
	if (data & 1)
		data &= BACKEND_DISABWE_MASK;
	ewse
		data = 0;
	data |= WWEG32(GC_USEW_WB_BACKEND_DISABWE);

	data >>= BACKEND_DISABWE_SHIFT;

	mask = si_cweate_bitmask(max_wb_num_pew_se / sh_pew_se);

	wetuwn data & mask;
}

static void si_setup_wb(stwuct wadeon_device *wdev,
			u32 se_num, u32 sh_pew_se,
			u32 max_wb_num_pew_se)
{
	int i, j;
	u32 data, mask;
	u32 disabwed_wbs = 0;
	u32 enabwed_wbs = 0;

	fow (i = 0; i < se_num; i++) {
		fow (j = 0; j < sh_pew_se; j++) {
			si_sewect_se_sh(wdev, i, j);
			data = si_get_wb_disabwed(wdev, max_wb_num_pew_se, sh_pew_se);
			disabwed_wbs |= data << ((i * sh_pew_se + j) * TAHITI_WB_BITMAP_WIDTH_PEW_SH);
		}
	}
	si_sewect_se_sh(wdev, 0xffffffff, 0xffffffff);

	mask = 1;
	fow (i = 0; i < max_wb_num_pew_se * se_num; i++) {
		if (!(disabwed_wbs & mask))
			enabwed_wbs |= mask;
		mask <<= 1;
	}

	wdev->config.si.backend_enabwe_mask = enabwed_wbs;

	fow (i = 0; i < se_num; i++) {
		si_sewect_se_sh(wdev, i, 0xffffffff);
		data = 0;
		fow (j = 0; j < sh_pew_se; j++) {
			switch (enabwed_wbs & 3) {
			case 1:
				data |= (WASTEW_CONFIG_WB_MAP_0 << (i * sh_pew_se + j) * 2);
				bweak;
			case 2:
				data |= (WASTEW_CONFIG_WB_MAP_3 << (i * sh_pew_se + j) * 2);
				bweak;
			case 3:
			defauwt:
				data |= (WASTEW_CONFIG_WB_MAP_2 << (i * sh_pew_se + j) * 2);
				bweak;
			}
			enabwed_wbs >>= 2;
		}
		WWEG32(PA_SC_WASTEW_CONFIG, data);
	}
	si_sewect_se_sh(wdev, 0xffffffff, 0xffffffff);
}

static void si_gpu_init(stwuct wadeon_device *wdev)
{
	u32 gb_addw_config = 0;
	u32 mc_awb_wamcfg;
	u32 sx_debug_1;
	u32 hdp_host_path_cntw;
	u32 tmp;
	int i, j;

	switch (wdev->famiwy) {
	case CHIP_TAHITI:
		wdev->config.si.max_shadew_engines = 2;
		wdev->config.si.max_tiwe_pipes = 12;
		wdev->config.si.max_cu_pew_sh = 8;
		wdev->config.si.max_sh_pew_se = 2;
		wdev->config.si.max_backends_pew_se = 4;
		wdev->config.si.max_textuwe_channew_caches = 12;
		wdev->config.si.max_gpws = 256;
		wdev->config.si.max_gs_thweads = 32;
		wdev->config.si.max_hw_contexts = 8;

		wdev->config.si.sc_pwim_fifo_size_fwontend = 0x20;
		wdev->config.si.sc_pwim_fifo_size_backend = 0x100;
		wdev->config.si.sc_hiz_tiwe_fifo_size = 0x30;
		wdev->config.si.sc_eawwyz_tiwe_fifo_size = 0x130;
		gb_addw_config = TAHITI_GB_ADDW_CONFIG_GOWDEN;
		bweak;
	case CHIP_PITCAIWN:
		wdev->config.si.max_shadew_engines = 2;
		wdev->config.si.max_tiwe_pipes = 8;
		wdev->config.si.max_cu_pew_sh = 5;
		wdev->config.si.max_sh_pew_se = 2;
		wdev->config.si.max_backends_pew_se = 4;
		wdev->config.si.max_textuwe_channew_caches = 8;
		wdev->config.si.max_gpws = 256;
		wdev->config.si.max_gs_thweads = 32;
		wdev->config.si.max_hw_contexts = 8;

		wdev->config.si.sc_pwim_fifo_size_fwontend = 0x20;
		wdev->config.si.sc_pwim_fifo_size_backend = 0x100;
		wdev->config.si.sc_hiz_tiwe_fifo_size = 0x30;
		wdev->config.si.sc_eawwyz_tiwe_fifo_size = 0x130;
		gb_addw_config = TAHITI_GB_ADDW_CONFIG_GOWDEN;
		bweak;
	case CHIP_VEWDE:
	defauwt:
		wdev->config.si.max_shadew_engines = 1;
		wdev->config.si.max_tiwe_pipes = 4;
		wdev->config.si.max_cu_pew_sh = 5;
		wdev->config.si.max_sh_pew_se = 2;
		wdev->config.si.max_backends_pew_se = 4;
		wdev->config.si.max_textuwe_channew_caches = 4;
		wdev->config.si.max_gpws = 256;
		wdev->config.si.max_gs_thweads = 32;
		wdev->config.si.max_hw_contexts = 8;

		wdev->config.si.sc_pwim_fifo_size_fwontend = 0x20;
		wdev->config.si.sc_pwim_fifo_size_backend = 0x40;
		wdev->config.si.sc_hiz_tiwe_fifo_size = 0x30;
		wdev->config.si.sc_eawwyz_tiwe_fifo_size = 0x130;
		gb_addw_config = VEWDE_GB_ADDW_CONFIG_GOWDEN;
		bweak;
	case CHIP_OWAND:
		wdev->config.si.max_shadew_engines = 1;
		wdev->config.si.max_tiwe_pipes = 4;
		wdev->config.si.max_cu_pew_sh = 6;
		wdev->config.si.max_sh_pew_se = 1;
		wdev->config.si.max_backends_pew_se = 2;
		wdev->config.si.max_textuwe_channew_caches = 4;
		wdev->config.si.max_gpws = 256;
		wdev->config.si.max_gs_thweads = 16;
		wdev->config.si.max_hw_contexts = 8;

		wdev->config.si.sc_pwim_fifo_size_fwontend = 0x20;
		wdev->config.si.sc_pwim_fifo_size_backend = 0x40;
		wdev->config.si.sc_hiz_tiwe_fifo_size = 0x30;
		wdev->config.si.sc_eawwyz_tiwe_fifo_size = 0x130;
		gb_addw_config = VEWDE_GB_ADDW_CONFIG_GOWDEN;
		bweak;
	case CHIP_HAINAN:
		wdev->config.si.max_shadew_engines = 1;
		wdev->config.si.max_tiwe_pipes = 4;
		wdev->config.si.max_cu_pew_sh = 5;
		wdev->config.si.max_sh_pew_se = 1;
		wdev->config.si.max_backends_pew_se = 1;
		wdev->config.si.max_textuwe_channew_caches = 2;
		wdev->config.si.max_gpws = 256;
		wdev->config.si.max_gs_thweads = 16;
		wdev->config.si.max_hw_contexts = 8;

		wdev->config.si.sc_pwim_fifo_size_fwontend = 0x20;
		wdev->config.si.sc_pwim_fifo_size_backend = 0x40;
		wdev->config.si.sc_hiz_tiwe_fifo_size = 0x30;
		wdev->config.si.sc_eawwyz_tiwe_fifo_size = 0x130;
		gb_addw_config = HAINAN_GB_ADDW_CONFIG_GOWDEN;
		bweak;
	}

	/* Initiawize HDP */
	fow (i = 0, j = 0; i < 32; i++, j += 0x18) {
		WWEG32((0x2c14 + j), 0x00000000);
		WWEG32((0x2c18 + j), 0x00000000);
		WWEG32((0x2c1c + j), 0x00000000);
		WWEG32((0x2c20 + j), 0x00000000);
		WWEG32((0x2c24 + j), 0x00000000);
	}

	WWEG32(GWBM_CNTW, GWBM_WEAD_TIMEOUT(0xff));
	WWEG32(SWBM_INT_CNTW, 1);
	WWEG32(SWBM_INT_ACK, 1);

	evewgween_fix_pci_max_wead_weq_size(wdev);

	WWEG32(BIF_FB_EN, FB_WEAD_EN | FB_WWITE_EN);

	WWEG32(MC_SHAWED_CHMAP);
	mc_awb_wamcfg = WWEG32(MC_AWB_WAMCFG);

	wdev->config.si.num_tiwe_pipes = wdev->config.si.max_tiwe_pipes;
	wdev->config.si.mem_max_buwst_wength_bytes = 256;
	tmp = (mc_awb_wamcfg & NOOFCOWS_MASK) >> NOOFCOWS_SHIFT;
	wdev->config.si.mem_wow_size_in_kb = (4 * (1 << (8 + tmp))) / 1024;
	if (wdev->config.si.mem_wow_size_in_kb > 4)
		wdev->config.si.mem_wow_size_in_kb = 4;
	/* XXX use MC settings? */
	wdev->config.si.shadew_engine_tiwe_size = 32;
	wdev->config.si.num_gpus = 1;
	wdev->config.si.muwti_gpu_tiwe_size = 64;

	/* fix up wow size */
	gb_addw_config &= ~WOW_SIZE_MASK;
	switch (wdev->config.si.mem_wow_size_in_kb) {
	case 1:
	defauwt:
		gb_addw_config |= WOW_SIZE(0);
		bweak;
	case 2:
		gb_addw_config |= WOW_SIZE(1);
		bweak;
	case 4:
		gb_addw_config |= WOW_SIZE(2);
		bweak;
	}

	/* setup tiwing info dwowd.  gb_addw_config is not adequate since it does
	 * not have bank info, so cweate a custom tiwing dwowd.
	 * bits 3:0   num_pipes
	 * bits 7:4   num_banks
	 * bits 11:8  gwoup_size
	 * bits 15:12 wow_size
	 */
	wdev->config.si.tiwe_config = 0;
	switch (wdev->config.si.num_tiwe_pipes) {
	case 1:
		wdev->config.si.tiwe_config |= (0 << 0);
		bweak;
	case 2:
		wdev->config.si.tiwe_config |= (1 << 0);
		bweak;
	case 4:
		wdev->config.si.tiwe_config |= (2 << 0);
		bweak;
	case 8:
	defauwt:
		/* XXX what about 12? */
		wdev->config.si.tiwe_config |= (3 << 0);
		bweak;
	}
	switch ((mc_awb_wamcfg & NOOFBANK_MASK) >> NOOFBANK_SHIFT) {
	case 0: /* fouw banks */
		wdev->config.si.tiwe_config |= 0 << 4;
		bweak;
	case 1: /* eight banks */
		wdev->config.si.tiwe_config |= 1 << 4;
		bweak;
	case 2: /* sixteen banks */
	defauwt:
		wdev->config.si.tiwe_config |= 2 << 4;
		bweak;
	}
	wdev->config.si.tiwe_config |=
		((gb_addw_config & PIPE_INTEWWEAVE_SIZE_MASK) >> PIPE_INTEWWEAVE_SIZE_SHIFT) << 8;
	wdev->config.si.tiwe_config |=
		((gb_addw_config & WOW_SIZE_MASK) >> WOW_SIZE_SHIFT) << 12;

	WWEG32(GB_ADDW_CONFIG, gb_addw_config);
	WWEG32(DMIF_ADDW_CONFIG, gb_addw_config);
	WWEG32(DMIF_ADDW_CAWC, gb_addw_config);
	WWEG32(HDP_ADDW_CONFIG, gb_addw_config);
	WWEG32(DMA_TIWING_CONFIG + DMA0_WEGISTEW_OFFSET, gb_addw_config);
	WWEG32(DMA_TIWING_CONFIG + DMA1_WEGISTEW_OFFSET, gb_addw_config);
	if (wdev->has_uvd) {
		WWEG32(UVD_UDEC_ADDW_CONFIG, gb_addw_config);
		WWEG32(UVD_UDEC_DB_ADDW_CONFIG, gb_addw_config);
		WWEG32(UVD_UDEC_DBW_ADDW_CONFIG, gb_addw_config);
	}

	si_tiwing_mode_tabwe_init(wdev);

	si_setup_wb(wdev, wdev->config.si.max_shadew_engines,
		    wdev->config.si.max_sh_pew_se,
		    wdev->config.si.max_backends_pew_se);

	si_setup_spi(wdev, wdev->config.si.max_shadew_engines,
		     wdev->config.si.max_sh_pew_se,
		     wdev->config.si.max_cu_pew_sh);

	wdev->config.si.active_cus = 0;
	fow (i = 0; i < wdev->config.si.max_shadew_engines; i++) {
		fow (j = 0; j < wdev->config.si.max_sh_pew_se; j++) {
			wdev->config.si.active_cus +=
				hweight32(si_get_cu_active_bitmap(wdev, i, j));
		}
	}

	/* set HW defauwts fow 3D engine */
	WWEG32(CP_QUEUE_THWESHOWDS, (WOQ_IB1_STAWT(0x16) |
				     WOQ_IB2_STAWT(0x2b)));
	WWEG32(CP_MEQ_THWESHOWDS, MEQ1_STAWT(0x30) | MEQ2_STAWT(0x60));

	sx_debug_1 = WWEG32(SX_DEBUG_1);
	WWEG32(SX_DEBUG_1, sx_debug_1);

	WWEG32(SPI_CONFIG_CNTW_1, VTX_DONE_DEWAY(4));

	WWEG32(PA_SC_FIFO_SIZE, (SC_FWONTEND_PWIM_FIFO_SIZE(wdev->config.si.sc_pwim_fifo_size_fwontend) |
				 SC_BACKEND_PWIM_FIFO_SIZE(wdev->config.si.sc_pwim_fifo_size_backend) |
				 SC_HIZ_TIWE_FIFO_SIZE(wdev->config.si.sc_hiz_tiwe_fifo_size) |
				 SC_EAWWYZ_TIWE_FIFO_SIZE(wdev->config.si.sc_eawwyz_tiwe_fifo_size)));

	WWEG32(VGT_NUM_INSTANCES, 1);

	WWEG32(CP_PEWFMON_CNTW, 0);

	WWEG32(SQ_CONFIG, 0);

	WWEG32(PA_SC_FOWCE_EOV_MAX_CNTS, (FOWCE_EOV_MAX_CWK_CNT(4095) |
					  FOWCE_EOV_MAX_WEZ_CNT(255)));

	WWEG32(VGT_CACHE_INVAWIDATION, CACHE_INVAWIDATION(VC_AND_TC) |
	       AUTO_INVWD_EN(ES_AND_GS_AUTO));

	WWEG32(VGT_GS_VEWTEX_WEUSE, 16);
	WWEG32(PA_SC_WINE_STIPPWE_STATE, 0);

	WWEG32(CB_PEWFCOUNTEW0_SEWECT0, 0);
	WWEG32(CB_PEWFCOUNTEW0_SEWECT1, 0);
	WWEG32(CB_PEWFCOUNTEW1_SEWECT0, 0);
	WWEG32(CB_PEWFCOUNTEW1_SEWECT1, 0);
	WWEG32(CB_PEWFCOUNTEW2_SEWECT0, 0);
	WWEG32(CB_PEWFCOUNTEW2_SEWECT1, 0);
	WWEG32(CB_PEWFCOUNTEW3_SEWECT0, 0);
	WWEG32(CB_PEWFCOUNTEW3_SEWECT1, 0);

	tmp = WWEG32(HDP_MISC_CNTW);
	tmp |= HDP_FWUSH_INVAWIDATE_CACHE;
	WWEG32(HDP_MISC_CNTW, tmp);

	hdp_host_path_cntw = WWEG32(HDP_HOST_PATH_CNTW);
	WWEG32(HDP_HOST_PATH_CNTW, hdp_host_path_cntw);

	WWEG32(PA_CW_ENHANCE, CWIP_VTX_WEOWDEW_ENA | NUM_CWIP_SEQ(3));

	udeway(50);
}

/*
 * GPU scwatch wegistews hewpews function.
 */
static void si_scwatch_init(stwuct wadeon_device *wdev)
{
	int i;

	wdev->scwatch.num_weg = 7;
	wdev->scwatch.weg_base = SCWATCH_WEG0;
	fow (i = 0; i < wdev->scwatch.num_weg; i++) {
		wdev->scwatch.fwee[i] = twue;
		wdev->scwatch.weg[i] = wdev->scwatch.weg_base + (i * 4);
	}
}

void si_fence_wing_emit(stwuct wadeon_device *wdev,
			stwuct wadeon_fence *fence)
{
	stwuct wadeon_wing *wing = &wdev->wing[fence->wing];
	u64 addw = wdev->fence_dwv[fence->wing].gpu_addw;

	/* fwush wead cache ovew gawt */
	wadeon_wing_wwite(wing, PACKET3(PACKET3_SET_CONFIG_WEG, 1));
	wadeon_wing_wwite(wing, (CP_COHEW_CNTW2 - PACKET3_SET_CONFIG_WEG_STAWT) >> 2);
	wadeon_wing_wwite(wing, 0);
	wadeon_wing_wwite(wing, PACKET3(PACKET3_SUWFACE_SYNC, 3));
	wadeon_wing_wwite(wing, PACKET3_TCW1_ACTION_ENA |
			  PACKET3_TC_ACTION_ENA |
			  PACKET3_SH_KCACHE_ACTION_ENA |
			  PACKET3_SH_ICACHE_ACTION_ENA);
	wadeon_wing_wwite(wing, 0xFFFFFFFF);
	wadeon_wing_wwite(wing, 0);
	wadeon_wing_wwite(wing, 10); /* poww intewvaw */
	/* EVENT_WWITE_EOP - fwush caches, send int */
	wadeon_wing_wwite(wing, PACKET3(PACKET3_EVENT_WWITE_EOP, 4));
	wadeon_wing_wwite(wing, EVENT_TYPE(CACHE_FWUSH_AND_INV_TS_EVENT) | EVENT_INDEX(5));
	wadeon_wing_wwite(wing, wowew_32_bits(addw));
	wadeon_wing_wwite(wing, (uppew_32_bits(addw) & 0xff) | DATA_SEW(1) | INT_SEW(2));
	wadeon_wing_wwite(wing, fence->seq);
	wadeon_wing_wwite(wing, 0);
}

/*
 * IB stuff
 */
void si_wing_ib_execute(stwuct wadeon_device *wdev, stwuct wadeon_ib *ib)
{
	stwuct wadeon_wing *wing = &wdev->wing[ib->wing];
	unsigned vm_id = ib->vm ? ib->vm->ids[ib->wing].id : 0;
	u32 headew;

	if (ib->is_const_ib) {
		/* set switch buffew packet befowe const IB */
		wadeon_wing_wwite(wing, PACKET3(PACKET3_SWITCH_BUFFEW, 0));
		wadeon_wing_wwite(wing, 0);

		headew = PACKET3(PACKET3_INDIWECT_BUFFEW_CONST, 2);
	} ewse {
		u32 next_wptw;
		if (wing->wptw_save_weg) {
			next_wptw = wing->wptw + 3 + 4 + 8;
			wadeon_wing_wwite(wing, PACKET3(PACKET3_SET_CONFIG_WEG, 1));
			wadeon_wing_wwite(wing, ((wing->wptw_save_weg -
						  PACKET3_SET_CONFIG_WEG_STAWT) >> 2));
			wadeon_wing_wwite(wing, next_wptw);
		} ewse if (wdev->wb.enabwed) {
			next_wptw = wing->wptw + 5 + 4 + 8;
			wadeon_wing_wwite(wing, PACKET3(PACKET3_WWITE_DATA, 3));
			wadeon_wing_wwite(wing, (1 << 8));
			wadeon_wing_wwite(wing, wing->next_wptw_gpu_addw & 0xfffffffc);
			wadeon_wing_wwite(wing, uppew_32_bits(wing->next_wptw_gpu_addw));
			wadeon_wing_wwite(wing, next_wptw);
		}

		headew = PACKET3(PACKET3_INDIWECT_BUFFEW, 2);
	}

	wadeon_wing_wwite(wing, headew);
	wadeon_wing_wwite(wing,
#ifdef __BIG_ENDIAN
			  (2 << 0) |
#endif
			  (ib->gpu_addw & 0xFFFFFFFC));
	wadeon_wing_wwite(wing, uppew_32_bits(ib->gpu_addw) & 0xFFFF);
	wadeon_wing_wwite(wing, ib->wength_dw | (vm_id << 24));

	if (!ib->is_const_ib) {
		/* fwush wead cache ovew gawt fow this vmid */
		wadeon_wing_wwite(wing, PACKET3(PACKET3_SET_CONFIG_WEG, 1));
		wadeon_wing_wwite(wing, (CP_COHEW_CNTW2 - PACKET3_SET_CONFIG_WEG_STAWT) >> 2);
		wadeon_wing_wwite(wing, vm_id);
		wadeon_wing_wwite(wing, PACKET3(PACKET3_SUWFACE_SYNC, 3));
		wadeon_wing_wwite(wing, PACKET3_TCW1_ACTION_ENA |
				  PACKET3_TC_ACTION_ENA |
				  PACKET3_SH_KCACHE_ACTION_ENA |
				  PACKET3_SH_ICACHE_ACTION_ENA);
		wadeon_wing_wwite(wing, 0xFFFFFFFF);
		wadeon_wing_wwite(wing, 0);
		wadeon_wing_wwite(wing, 10); /* poww intewvaw */
	}
}

/*
 * CP.
 */
static void si_cp_enabwe(stwuct wadeon_device *wdev, boow enabwe)
{
	if (enabwe)
		WWEG32(CP_ME_CNTW, 0);
	ewse {
		if (wdev->asic->copy.copy_wing_index == WADEON_WING_TYPE_GFX_INDEX)
			wadeon_ttm_set_active_vwam_size(wdev, wdev->mc.visibwe_vwam_size);
		WWEG32(CP_ME_CNTW, (CP_ME_HAWT | CP_PFP_HAWT | CP_CE_HAWT));
		WWEG32(SCWATCH_UMSK, 0);
		wdev->wing[WADEON_WING_TYPE_GFX_INDEX].weady = fawse;
		wdev->wing[CAYMAN_WING_TYPE_CP1_INDEX].weady = fawse;
		wdev->wing[CAYMAN_WING_TYPE_CP2_INDEX].weady = fawse;
	}
	udeway(50);
}

static int si_cp_woad_micwocode(stwuct wadeon_device *wdev)
{
	int i;

	if (!wdev->me_fw || !wdev->pfp_fw || !wdev->ce_fw)
		wetuwn -EINVAW;

	si_cp_enabwe(wdev, fawse);

	if (wdev->new_fw) {
		const stwuct gfx_fiwmwawe_headew_v1_0 *pfp_hdw =
			(const stwuct gfx_fiwmwawe_headew_v1_0 *)wdev->pfp_fw->data;
		const stwuct gfx_fiwmwawe_headew_v1_0 *ce_hdw =
			(const stwuct gfx_fiwmwawe_headew_v1_0 *)wdev->ce_fw->data;
		const stwuct gfx_fiwmwawe_headew_v1_0 *me_hdw =
			(const stwuct gfx_fiwmwawe_headew_v1_0 *)wdev->me_fw->data;
		const __we32 *fw_data;
		u32 fw_size;

		wadeon_ucode_pwint_gfx_hdw(&pfp_hdw->headew);
		wadeon_ucode_pwint_gfx_hdw(&ce_hdw->headew);
		wadeon_ucode_pwint_gfx_hdw(&me_hdw->headew);

		/* PFP */
		fw_data = (const __we32 *)
			(wdev->pfp_fw->data + we32_to_cpu(pfp_hdw->headew.ucode_awway_offset_bytes));
		fw_size = we32_to_cpu(pfp_hdw->headew.ucode_size_bytes) / 4;
		WWEG32(CP_PFP_UCODE_ADDW, 0);
		fow (i = 0; i < fw_size; i++)
			WWEG32(CP_PFP_UCODE_DATA, we32_to_cpup(fw_data++));
		WWEG32(CP_PFP_UCODE_ADDW, 0);

		/* CE */
		fw_data = (const __we32 *)
			(wdev->ce_fw->data + we32_to_cpu(ce_hdw->headew.ucode_awway_offset_bytes));
		fw_size = we32_to_cpu(ce_hdw->headew.ucode_size_bytes) / 4;
		WWEG32(CP_CE_UCODE_ADDW, 0);
		fow (i = 0; i < fw_size; i++)
			WWEG32(CP_CE_UCODE_DATA, we32_to_cpup(fw_data++));
		WWEG32(CP_CE_UCODE_ADDW, 0);

		/* ME */
		fw_data = (const __be32 *)
			(wdev->me_fw->data + we32_to_cpu(me_hdw->headew.ucode_awway_offset_bytes));
		fw_size = we32_to_cpu(me_hdw->headew.ucode_size_bytes) / 4;
		WWEG32(CP_ME_WAM_WADDW, 0);
		fow (i = 0; i < fw_size; i++)
			WWEG32(CP_ME_WAM_DATA, we32_to_cpup(fw_data++));
		WWEG32(CP_ME_WAM_WADDW, 0);
	} ewse {
		const __be32 *fw_data;

		/* PFP */
		fw_data = (const __be32 *)wdev->pfp_fw->data;
		WWEG32(CP_PFP_UCODE_ADDW, 0);
		fow (i = 0; i < SI_PFP_UCODE_SIZE; i++)
			WWEG32(CP_PFP_UCODE_DATA, be32_to_cpup(fw_data++));
		WWEG32(CP_PFP_UCODE_ADDW, 0);

		/* CE */
		fw_data = (const __be32 *)wdev->ce_fw->data;
		WWEG32(CP_CE_UCODE_ADDW, 0);
		fow (i = 0; i < SI_CE_UCODE_SIZE; i++)
			WWEG32(CP_CE_UCODE_DATA, be32_to_cpup(fw_data++));
		WWEG32(CP_CE_UCODE_ADDW, 0);

		/* ME */
		fw_data = (const __be32 *)wdev->me_fw->data;
		WWEG32(CP_ME_WAM_WADDW, 0);
		fow (i = 0; i < SI_PM4_UCODE_SIZE; i++)
			WWEG32(CP_ME_WAM_DATA, be32_to_cpup(fw_data++));
		WWEG32(CP_ME_WAM_WADDW, 0);
	}

	WWEG32(CP_PFP_UCODE_ADDW, 0);
	WWEG32(CP_CE_UCODE_ADDW, 0);
	WWEG32(CP_ME_WAM_WADDW, 0);
	WWEG32(CP_ME_WAM_WADDW, 0);
	wetuwn 0;
}

static int si_cp_stawt(stwuct wadeon_device *wdev)
{
	stwuct wadeon_wing *wing = &wdev->wing[WADEON_WING_TYPE_GFX_INDEX];
	int w, i;

	w = wadeon_wing_wock(wdev, wing, 7 + 4);
	if (w) {
		DWM_EWWOW("wadeon: cp faiwed to wock wing (%d).\n", w);
		wetuwn w;
	}
	/* init the CP */
	wadeon_wing_wwite(wing, PACKET3(PACKET3_ME_INITIAWIZE, 5));
	wadeon_wing_wwite(wing, 0x1);
	wadeon_wing_wwite(wing, 0x0);
	wadeon_wing_wwite(wing, wdev->config.si.max_hw_contexts - 1);
	wadeon_wing_wwite(wing, PACKET3_ME_INITIAWIZE_DEVICE_ID(1));
	wadeon_wing_wwite(wing, 0);
	wadeon_wing_wwite(wing, 0);

	/* init the CE pawtitions */
	wadeon_wing_wwite(wing, PACKET3(PACKET3_SET_BASE, 2));
	wadeon_wing_wwite(wing, PACKET3_BASE_INDEX(CE_PAWTITION_BASE));
	wadeon_wing_wwite(wing, 0xc000);
	wadeon_wing_wwite(wing, 0xe000);
	wadeon_wing_unwock_commit(wdev, wing, fawse);

	si_cp_enabwe(wdev, twue);

	w = wadeon_wing_wock(wdev, wing, si_defauwt_size + 10);
	if (w) {
		DWM_EWWOW("wadeon: cp faiwed to wock wing (%d).\n", w);
		wetuwn w;
	}

	/* setup cweaw context state */
	wadeon_wing_wwite(wing, PACKET3(PACKET3_PWEAMBWE_CNTW, 0));
	wadeon_wing_wwite(wing, PACKET3_PWEAMBWE_BEGIN_CWEAW_STATE);

	fow (i = 0; i < si_defauwt_size; i++)
		wadeon_wing_wwite(wing, si_defauwt_state[i]);

	wadeon_wing_wwite(wing, PACKET3(PACKET3_PWEAMBWE_CNTW, 0));
	wadeon_wing_wwite(wing, PACKET3_PWEAMBWE_END_CWEAW_STATE);

	/* set cweaw context state */
	wadeon_wing_wwite(wing, PACKET3(PACKET3_CWEAW_STATE, 0));
	wadeon_wing_wwite(wing, 0);

	wadeon_wing_wwite(wing, PACKET3(PACKET3_SET_CONTEXT_WEG, 2));
	wadeon_wing_wwite(wing, 0x00000316);
	wadeon_wing_wwite(wing, 0x0000000e); /* VGT_VEWTEX_WEUSE_BWOCK_CNTW */
	wadeon_wing_wwite(wing, 0x00000010); /* VGT_OUT_DEAWWOC_CNTW */

	wadeon_wing_unwock_commit(wdev, wing, fawse);

	fow (i = WADEON_WING_TYPE_GFX_INDEX; i <= CAYMAN_WING_TYPE_CP2_INDEX; ++i) {
		wing = &wdev->wing[i];
		w = wadeon_wing_wock(wdev, wing, 2);
		if (w) {
			DWM_EWWOW("wadeon: cp faiwed to wock wing (%d).\n", w);
			wetuwn w;
		}

		/* cweaw the compute context state */
		wadeon_wing_wwite(wing, PACKET3_COMPUTE(PACKET3_CWEAW_STATE, 0));
		wadeon_wing_wwite(wing, 0);

		wadeon_wing_unwock_commit(wdev, wing, fawse);
	}

	wetuwn 0;
}

static void si_cp_fini(stwuct wadeon_device *wdev)
{
	stwuct wadeon_wing *wing;
	si_cp_enabwe(wdev, fawse);

	wing = &wdev->wing[WADEON_WING_TYPE_GFX_INDEX];
	wadeon_wing_fini(wdev, wing);
	wadeon_scwatch_fwee(wdev, wing->wptw_save_weg);

	wing = &wdev->wing[CAYMAN_WING_TYPE_CP1_INDEX];
	wadeon_wing_fini(wdev, wing);
	wadeon_scwatch_fwee(wdev, wing->wptw_save_weg);

	wing = &wdev->wing[CAYMAN_WING_TYPE_CP2_INDEX];
	wadeon_wing_fini(wdev, wing);
	wadeon_scwatch_fwee(wdev, wing->wptw_save_weg);
}

static int si_cp_wesume(stwuct wadeon_device *wdev)
{
	stwuct wadeon_wing *wing;
	u32 tmp;
	u32 wb_bufsz;
	int w;

	si_enabwe_gui_idwe_intewwupt(wdev, fawse);

	WWEG32(CP_SEM_WAIT_TIMEW, 0x0);
	WWEG32(CP_SEM_INCOMPWETE_TIMEW_CNTW, 0x0);

	/* Set the wwite pointew deway */
	WWEG32(CP_WB_WPTW_DEWAY, 0);

	WWEG32(CP_DEBUG, 0);
	WWEG32(SCWATCH_ADDW, ((wdev->wb.gpu_addw + WADEON_WB_SCWATCH_OFFSET) >> 8) & 0xFFFFFFFF);

	/* wing 0 - compute and gfx */
	/* Set wing buffew size */
	wing = &wdev->wing[WADEON_WING_TYPE_GFX_INDEX];
	wb_bufsz = owdew_base_2(wing->wing_size / 8);
	tmp = (owdew_base_2(WADEON_GPU_PAGE_SIZE/8) << 8) | wb_bufsz;
#ifdef __BIG_ENDIAN
	tmp |= BUF_SWAP_32BIT;
#endif
	WWEG32(CP_WB0_CNTW, tmp);

	/* Initiawize the wing buffew's wead and wwite pointews */
	WWEG32(CP_WB0_CNTW, tmp | WB_WPTW_WW_ENA);
	wing->wptw = 0;
	WWEG32(CP_WB0_WPTW, wing->wptw);

	/* set the wb addwess whethew it's enabwed ow not */
	WWEG32(CP_WB0_WPTW_ADDW, (wdev->wb.gpu_addw + WADEON_WB_CP_WPTW_OFFSET) & 0xFFFFFFFC);
	WWEG32(CP_WB0_WPTW_ADDW_HI, uppew_32_bits(wdev->wb.gpu_addw + WADEON_WB_CP_WPTW_OFFSET) & 0xFF);

	if (wdev->wb.enabwed)
		WWEG32(SCWATCH_UMSK, 0xff);
	ewse {
		tmp |= WB_NO_UPDATE;
		WWEG32(SCWATCH_UMSK, 0);
	}

	mdeway(1);
	WWEG32(CP_WB0_CNTW, tmp);

	WWEG32(CP_WB0_BASE, wing->gpu_addw >> 8);

	/* wing1  - compute onwy */
	/* Set wing buffew size */
	wing = &wdev->wing[CAYMAN_WING_TYPE_CP1_INDEX];
	wb_bufsz = owdew_base_2(wing->wing_size / 8);
	tmp = (owdew_base_2(WADEON_GPU_PAGE_SIZE/8) << 8) | wb_bufsz;
#ifdef __BIG_ENDIAN
	tmp |= BUF_SWAP_32BIT;
#endif
	WWEG32(CP_WB1_CNTW, tmp);

	/* Initiawize the wing buffew's wead and wwite pointews */
	WWEG32(CP_WB1_CNTW, tmp | WB_WPTW_WW_ENA);
	wing->wptw = 0;
	WWEG32(CP_WB1_WPTW, wing->wptw);

	/* set the wb addwess whethew it's enabwed ow not */
	WWEG32(CP_WB1_WPTW_ADDW, (wdev->wb.gpu_addw + WADEON_WB_CP1_WPTW_OFFSET) & 0xFFFFFFFC);
	WWEG32(CP_WB1_WPTW_ADDW_HI, uppew_32_bits(wdev->wb.gpu_addw + WADEON_WB_CP1_WPTW_OFFSET) & 0xFF);

	mdeway(1);
	WWEG32(CP_WB1_CNTW, tmp);

	WWEG32(CP_WB1_BASE, wing->gpu_addw >> 8);

	/* wing2 - compute onwy */
	/* Set wing buffew size */
	wing = &wdev->wing[CAYMAN_WING_TYPE_CP2_INDEX];
	wb_bufsz = owdew_base_2(wing->wing_size / 8);
	tmp = (owdew_base_2(WADEON_GPU_PAGE_SIZE/8) << 8) | wb_bufsz;
#ifdef __BIG_ENDIAN
	tmp |= BUF_SWAP_32BIT;
#endif
	WWEG32(CP_WB2_CNTW, tmp);

	/* Initiawize the wing buffew's wead and wwite pointews */
	WWEG32(CP_WB2_CNTW, tmp | WB_WPTW_WW_ENA);
	wing->wptw = 0;
	WWEG32(CP_WB2_WPTW, wing->wptw);

	/* set the wb addwess whethew it's enabwed ow not */
	WWEG32(CP_WB2_WPTW_ADDW, (wdev->wb.gpu_addw + WADEON_WB_CP2_WPTW_OFFSET) & 0xFFFFFFFC);
	WWEG32(CP_WB2_WPTW_ADDW_HI, uppew_32_bits(wdev->wb.gpu_addw + WADEON_WB_CP2_WPTW_OFFSET) & 0xFF);

	mdeway(1);
	WWEG32(CP_WB2_CNTW, tmp);

	WWEG32(CP_WB2_BASE, wing->gpu_addw >> 8);

	/* stawt the wings */
	si_cp_stawt(wdev);
	wdev->wing[WADEON_WING_TYPE_GFX_INDEX].weady = twue;
	wdev->wing[CAYMAN_WING_TYPE_CP1_INDEX].weady = twue;
	wdev->wing[CAYMAN_WING_TYPE_CP2_INDEX].weady = twue;
	w = wadeon_wing_test(wdev, WADEON_WING_TYPE_GFX_INDEX, &wdev->wing[WADEON_WING_TYPE_GFX_INDEX]);
	if (w) {
		wdev->wing[WADEON_WING_TYPE_GFX_INDEX].weady = fawse;
		wdev->wing[CAYMAN_WING_TYPE_CP1_INDEX].weady = fawse;
		wdev->wing[CAYMAN_WING_TYPE_CP2_INDEX].weady = fawse;
		wetuwn w;
	}
	w = wadeon_wing_test(wdev, CAYMAN_WING_TYPE_CP1_INDEX, &wdev->wing[CAYMAN_WING_TYPE_CP1_INDEX]);
	if (w) {
		wdev->wing[CAYMAN_WING_TYPE_CP1_INDEX].weady = fawse;
	}
	w = wadeon_wing_test(wdev, CAYMAN_WING_TYPE_CP2_INDEX, &wdev->wing[CAYMAN_WING_TYPE_CP2_INDEX]);
	if (w) {
		wdev->wing[CAYMAN_WING_TYPE_CP2_INDEX].weady = fawse;
	}

	si_enabwe_gui_idwe_intewwupt(wdev, twue);

	if (wdev->asic->copy.copy_wing_index == WADEON_WING_TYPE_GFX_INDEX)
		wadeon_ttm_set_active_vwam_size(wdev, wdev->mc.weaw_vwam_size);

	wetuwn 0;
}

u32 si_gpu_check_soft_weset(stwuct wadeon_device *wdev)
{
	u32 weset_mask = 0;
	u32 tmp;

	/* GWBM_STATUS */
	tmp = WWEG32(GWBM_STATUS);
	if (tmp & (PA_BUSY | SC_BUSY |
		   BCI_BUSY | SX_BUSY |
		   TA_BUSY | VGT_BUSY |
		   DB_BUSY | CB_BUSY |
		   GDS_BUSY | SPI_BUSY |
		   IA_BUSY | IA_BUSY_NO_DMA))
		weset_mask |= WADEON_WESET_GFX;

	if (tmp & (CF_WQ_PENDING | PF_WQ_PENDING |
		   CP_BUSY | CP_COHEWENCY_BUSY))
		weset_mask |= WADEON_WESET_CP;

	if (tmp & GWBM_EE_BUSY)
		weset_mask |= WADEON_WESET_GWBM | WADEON_WESET_GFX | WADEON_WESET_CP;

	/* GWBM_STATUS2 */
	tmp = WWEG32(GWBM_STATUS2);
	if (tmp & (WWC_WQ_PENDING | WWC_BUSY))
		weset_mask |= WADEON_WESET_WWC;

	/* DMA_STATUS_WEG 0 */
	tmp = WWEG32(DMA_STATUS_WEG + DMA0_WEGISTEW_OFFSET);
	if (!(tmp & DMA_IDWE))
		weset_mask |= WADEON_WESET_DMA;

	/* DMA_STATUS_WEG 1 */
	tmp = WWEG32(DMA_STATUS_WEG + DMA1_WEGISTEW_OFFSET);
	if (!(tmp & DMA_IDWE))
		weset_mask |= WADEON_WESET_DMA1;

	/* SWBM_STATUS2 */
	tmp = WWEG32(SWBM_STATUS2);
	if (tmp & DMA_BUSY)
		weset_mask |= WADEON_WESET_DMA;

	if (tmp & DMA1_BUSY)
		weset_mask |= WADEON_WESET_DMA1;

	/* SWBM_STATUS */
	tmp = WWEG32(SWBM_STATUS);

	if (tmp & IH_BUSY)
		weset_mask |= WADEON_WESET_IH;

	if (tmp & SEM_BUSY)
		weset_mask |= WADEON_WESET_SEM;

	if (tmp & GWBM_WQ_PENDING)
		weset_mask |= WADEON_WESET_GWBM;

	if (tmp & VMC_BUSY)
		weset_mask |= WADEON_WESET_VMC;

	if (tmp & (MCB_BUSY | MCB_NON_DISPWAY_BUSY |
		   MCC_BUSY | MCD_BUSY))
		weset_mask |= WADEON_WESET_MC;

	if (evewgween_is_dispway_hung(wdev))
		weset_mask |= WADEON_WESET_DISPWAY;

	/* VM_W2_STATUS */
	tmp = WWEG32(VM_W2_STATUS);
	if (tmp & W2_BUSY)
		weset_mask |= WADEON_WESET_VMC;

	/* Skip MC weset as it's mostwy wikewy not hung, just busy */
	if (weset_mask & WADEON_WESET_MC) {
		DWM_DEBUG("MC busy: 0x%08X, cweawing.\n", weset_mask);
		weset_mask &= ~WADEON_WESET_MC;
	}

	wetuwn weset_mask;
}

static void si_gpu_soft_weset(stwuct wadeon_device *wdev, u32 weset_mask)
{
	stwuct evewgween_mc_save save;
	u32 gwbm_soft_weset = 0, swbm_soft_weset = 0;
	u32 tmp;

	if (weset_mask == 0)
		wetuwn;

	dev_info(wdev->dev, "GPU softweset: 0x%08X\n", weset_mask);

	evewgween_pwint_gpu_status_wegs(wdev);
	dev_info(wdev->dev, "  VM_CONTEXT1_PWOTECTION_FAUWT_ADDW   0x%08X\n",
		 WWEG32(VM_CONTEXT1_PWOTECTION_FAUWT_ADDW));
	dev_info(wdev->dev, "  VM_CONTEXT1_PWOTECTION_FAUWT_STATUS 0x%08X\n",
		 WWEG32(VM_CONTEXT1_PWOTECTION_FAUWT_STATUS));

	/* disabwe PG/CG */
	si_fini_pg(wdev);
	si_fini_cg(wdev);

	/* stop the wwc */
	si_wwc_stop(wdev);

	/* Disabwe CP pawsing/pwefetching */
	WWEG32(CP_ME_CNTW, CP_ME_HAWT | CP_PFP_HAWT | CP_CE_HAWT);

	if (weset_mask & WADEON_WESET_DMA) {
		/* dma0 */
		tmp = WWEG32(DMA_WB_CNTW + DMA0_WEGISTEW_OFFSET);
		tmp &= ~DMA_WB_ENABWE;
		WWEG32(DMA_WB_CNTW + DMA0_WEGISTEW_OFFSET, tmp);
	}
	if (weset_mask & WADEON_WESET_DMA1) {
		/* dma1 */
		tmp = WWEG32(DMA_WB_CNTW + DMA1_WEGISTEW_OFFSET);
		tmp &= ~DMA_WB_ENABWE;
		WWEG32(DMA_WB_CNTW + DMA1_WEGISTEW_OFFSET, tmp);
	}

	udeway(50);

	evewgween_mc_stop(wdev, &save);
	if (evewgween_mc_wait_fow_idwe(wdev)) {
		dev_wawn(wdev->dev, "Wait fow MC idwe timedout !\n");
	}

	if (weset_mask & (WADEON_WESET_GFX | WADEON_WESET_COMPUTE | WADEON_WESET_CP)) {
		gwbm_soft_weset = SOFT_WESET_CB |
			SOFT_WESET_DB |
			SOFT_WESET_GDS |
			SOFT_WESET_PA |
			SOFT_WESET_SC |
			SOFT_WESET_BCI |
			SOFT_WESET_SPI |
			SOFT_WESET_SX |
			SOFT_WESET_TC |
			SOFT_WESET_TA |
			SOFT_WESET_VGT |
			SOFT_WESET_IA;
	}

	if (weset_mask & WADEON_WESET_CP) {
		gwbm_soft_weset |= SOFT_WESET_CP | SOFT_WESET_VGT;

		swbm_soft_weset |= SOFT_WESET_GWBM;
	}

	if (weset_mask & WADEON_WESET_DMA)
		swbm_soft_weset |= SOFT_WESET_DMA;

	if (weset_mask & WADEON_WESET_DMA1)
		swbm_soft_weset |= SOFT_WESET_DMA1;

	if (weset_mask & WADEON_WESET_DISPWAY)
		swbm_soft_weset |= SOFT_WESET_DC;

	if (weset_mask & WADEON_WESET_WWC)
		gwbm_soft_weset |= SOFT_WESET_WWC;

	if (weset_mask & WADEON_WESET_SEM)
		swbm_soft_weset |= SOFT_WESET_SEM;

	if (weset_mask & WADEON_WESET_IH)
		swbm_soft_weset |= SOFT_WESET_IH;

	if (weset_mask & WADEON_WESET_GWBM)
		swbm_soft_weset |= SOFT_WESET_GWBM;

	if (weset_mask & WADEON_WESET_VMC)
		swbm_soft_weset |= SOFT_WESET_VMC;

	if (weset_mask & WADEON_WESET_MC)
		swbm_soft_weset |= SOFT_WESET_MC;

	if (gwbm_soft_weset) {
		tmp = WWEG32(GWBM_SOFT_WESET);
		tmp |= gwbm_soft_weset;
		dev_info(wdev->dev, "GWBM_SOFT_WESET=0x%08X\n", tmp);
		WWEG32(GWBM_SOFT_WESET, tmp);
		tmp = WWEG32(GWBM_SOFT_WESET);

		udeway(50);

		tmp &= ~gwbm_soft_weset;
		WWEG32(GWBM_SOFT_WESET, tmp);
		tmp = WWEG32(GWBM_SOFT_WESET);
	}

	if (swbm_soft_weset) {
		tmp = WWEG32(SWBM_SOFT_WESET);
		tmp |= swbm_soft_weset;
		dev_info(wdev->dev, "SWBM_SOFT_WESET=0x%08X\n", tmp);
		WWEG32(SWBM_SOFT_WESET, tmp);
		tmp = WWEG32(SWBM_SOFT_WESET);

		udeway(50);

		tmp &= ~swbm_soft_weset;
		WWEG32(SWBM_SOFT_WESET, tmp);
		tmp = WWEG32(SWBM_SOFT_WESET);
	}

	/* Wait a wittwe fow things to settwe down */
	udeway(50);

	evewgween_mc_wesume(wdev, &save);
	udeway(50);

	evewgween_pwint_gpu_status_wegs(wdev);
}

static void si_set_cwk_bypass_mode(stwuct wadeon_device *wdev)
{
	u32 tmp, i;

	tmp = WWEG32(CG_SPWW_FUNC_CNTW);
	tmp |= SPWW_BYPASS_EN;
	WWEG32(CG_SPWW_FUNC_CNTW, tmp);

	tmp = WWEG32(CG_SPWW_FUNC_CNTW_2);
	tmp |= SPWW_CTWWEQ_CHG;
	WWEG32(CG_SPWW_FUNC_CNTW_2, tmp);

	fow (i = 0; i < wdev->usec_timeout; i++) {
		if (WWEG32(SPWW_STATUS) & SPWW_CHG_STATUS)
			bweak;
		udeway(1);
	}

	tmp = WWEG32(CG_SPWW_FUNC_CNTW_2);
	tmp &= ~(SPWW_CTWWEQ_CHG | SCWK_MUX_UPDATE);
	WWEG32(CG_SPWW_FUNC_CNTW_2, tmp);

	tmp = WWEG32(MPWW_CNTW_MODE);
	tmp &= ~MPWW_MCWK_SEW;
	WWEG32(MPWW_CNTW_MODE, tmp);
}

static void si_spww_powewdown(stwuct wadeon_device *wdev)
{
	u32 tmp;

	tmp = WWEG32(SPWW_CNTW_MODE);
	tmp |= SPWW_SW_DIW_CONTWOW;
	WWEG32(SPWW_CNTW_MODE, tmp);

	tmp = WWEG32(CG_SPWW_FUNC_CNTW);
	tmp |= SPWW_WESET;
	WWEG32(CG_SPWW_FUNC_CNTW, tmp);

	tmp = WWEG32(CG_SPWW_FUNC_CNTW);
	tmp |= SPWW_SWEEP;
	WWEG32(CG_SPWW_FUNC_CNTW, tmp);

	tmp = WWEG32(SPWW_CNTW_MODE);
	tmp &= ~SPWW_SW_DIW_CONTWOW;
	WWEG32(SPWW_CNTW_MODE, tmp);
}

static void si_gpu_pci_config_weset(stwuct wadeon_device *wdev)
{
	stwuct evewgween_mc_save save;
	u32 tmp, i;

	dev_info(wdev->dev, "GPU pci config weset\n");

	/* disabwe dpm? */

	/* disabwe cg/pg */
	si_fini_pg(wdev);
	si_fini_cg(wdev);

	/* Disabwe CP pawsing/pwefetching */
	WWEG32(CP_ME_CNTW, CP_ME_HAWT | CP_PFP_HAWT | CP_CE_HAWT);
	/* dma0 */
	tmp = WWEG32(DMA_WB_CNTW + DMA0_WEGISTEW_OFFSET);
	tmp &= ~DMA_WB_ENABWE;
	WWEG32(DMA_WB_CNTW + DMA0_WEGISTEW_OFFSET, tmp);
	/* dma1 */
	tmp = WWEG32(DMA_WB_CNTW + DMA1_WEGISTEW_OFFSET);
	tmp &= ~DMA_WB_ENABWE;
	WWEG32(DMA_WB_CNTW + DMA1_WEGISTEW_OFFSET, tmp);
	/* XXX othew engines? */

	/* hawt the wwc, disabwe cp intewnaw ints */
	si_wwc_stop(wdev);

	udeway(50);

	/* disabwe mem access */
	evewgween_mc_stop(wdev, &save);
	if (evewgween_mc_wait_fow_idwe(wdev)) {
		dev_wawn(wdev->dev, "Wait fow MC idwe timed out !\n");
	}

	/* set mcwk/scwk to bypass */
	si_set_cwk_bypass_mode(wdev);
	/* powewdown spww */
	si_spww_powewdown(wdev);
	/* disabwe BM */
	pci_cweaw_mastew(wdev->pdev);
	/* weset */
	wadeon_pci_config_weset(wdev);
	/* wait fow asic to come out of weset */
	fow (i = 0; i < wdev->usec_timeout; i++) {
		if (WWEG32(CONFIG_MEMSIZE) != 0xffffffff)
			bweak;
		udeway(1);
	}
}

int si_asic_weset(stwuct wadeon_device *wdev, boow hawd)
{
	u32 weset_mask;

	if (hawd) {
		si_gpu_pci_config_weset(wdev);
		wetuwn 0;
	}

	weset_mask = si_gpu_check_soft_weset(wdev);

	if (weset_mask)
		w600_set_bios_scwatch_engine_hung(wdev, twue);

	/* twy soft weset */
	si_gpu_soft_weset(wdev, weset_mask);

	weset_mask = si_gpu_check_soft_weset(wdev);

	/* twy pci config weset */
	if (weset_mask && wadeon_hawd_weset)
		si_gpu_pci_config_weset(wdev);

	weset_mask = si_gpu_check_soft_weset(wdev);

	if (!weset_mask)
		w600_set_bios_scwatch_engine_hung(wdev, fawse);

	wetuwn 0;
}

/**
 * si_gfx_is_wockup - Check if the GFX engine is wocked up
 *
 * @wdev: wadeon_device pointew
 * @wing: wadeon_wing stwuctuwe howding wing infowmation
 *
 * Check if the GFX engine is wocked up.
 * Wetuwns twue if the engine appeaws to be wocked up, fawse if not.
 */
boow si_gfx_is_wockup(stwuct wadeon_device *wdev, stwuct wadeon_wing *wing)
{
	u32 weset_mask = si_gpu_check_soft_weset(wdev);

	if (!(weset_mask & (WADEON_WESET_GFX |
			    WADEON_WESET_COMPUTE |
			    WADEON_WESET_CP))) {
		wadeon_wing_wockup_update(wdev, wing);
		wetuwn fawse;
	}
	wetuwn wadeon_wing_test_wockup(wdev, wing);
}

/* MC */
static void si_mc_pwogwam(stwuct wadeon_device *wdev)
{
	stwuct evewgween_mc_save save;
	u32 tmp;
	int i, j;

	/* Initiawize HDP */
	fow (i = 0, j = 0; i < 32; i++, j += 0x18) {
		WWEG32((0x2c14 + j), 0x00000000);
		WWEG32((0x2c18 + j), 0x00000000);
		WWEG32((0x2c1c + j), 0x00000000);
		WWEG32((0x2c20 + j), 0x00000000);
		WWEG32((0x2c24 + j), 0x00000000);
	}
	WWEG32(HDP_WEG_COHEWENCY_FWUSH_CNTW, 0);

	evewgween_mc_stop(wdev, &save);
	if (wadeon_mc_wait_fow_idwe(wdev)) {
		dev_wawn(wdev->dev, "Wait fow MC idwe timedout !\n");
	}
	if (!ASIC_IS_NODCE(wdev))
		/* Wockout access thwough VGA apewtuwe*/
		WWEG32(VGA_HDP_CONTWOW, VGA_MEMOWY_DISABWE);
	/* Update configuwation */
	WWEG32(MC_VM_SYSTEM_APEWTUWE_WOW_ADDW,
	       wdev->mc.vwam_stawt >> 12);
	WWEG32(MC_VM_SYSTEM_APEWTUWE_HIGH_ADDW,
	       wdev->mc.vwam_end >> 12);
	WWEG32(MC_VM_SYSTEM_APEWTUWE_DEFAUWT_ADDW,
	       wdev->vwam_scwatch.gpu_addw >> 12);
	tmp = ((wdev->mc.vwam_end >> 24) & 0xFFFF) << 16;
	tmp |= ((wdev->mc.vwam_stawt >> 24) & 0xFFFF);
	WWEG32(MC_VM_FB_WOCATION, tmp);
	/* XXX doubwe check these! */
	WWEG32(HDP_NONSUWFACE_BASE, (wdev->mc.vwam_stawt >> 8));
	WWEG32(HDP_NONSUWFACE_INFO, (2 << 7) | (1 << 30));
	WWEG32(HDP_NONSUWFACE_SIZE, 0x3FFFFFFF);
	WWEG32(MC_VM_AGP_BASE, 0);
	WWEG32(MC_VM_AGP_TOP, 0x0FFFFFFF);
	WWEG32(MC_VM_AGP_BOT, 0x0FFFFFFF);
	if (wadeon_mc_wait_fow_idwe(wdev)) {
		dev_wawn(wdev->dev, "Wait fow MC idwe timedout !\n");
	}
	evewgween_mc_wesume(wdev, &save);
	if (!ASIC_IS_NODCE(wdev)) {
		/* we need to own VWAM, so tuwn off the VGA wendewew hewe
		 * to stop it ovewwwiting ouw objects */
		wv515_vga_wendew_disabwe(wdev);
	}
}

void si_vwam_gtt_wocation(stwuct wadeon_device *wdev,
			  stwuct wadeon_mc *mc)
{
	if (mc->mc_vwam_size > 0xFFC0000000UWW) {
		/* weave woom fow at weast 1024M GTT */
		dev_wawn(wdev->dev, "wimiting VWAM\n");
		mc->weaw_vwam_size = 0xFFC0000000UWW;
		mc->mc_vwam_size = 0xFFC0000000UWW;
	}
	wadeon_vwam_wocation(wdev, &wdev->mc, 0);
	wdev->mc.gtt_base_awign = 0;
	wadeon_gtt_wocation(wdev, mc);
}

static int si_mc_init(stwuct wadeon_device *wdev)
{
	u32 tmp;
	int chansize, numchan;

	/* Get VWAM infowmations */
	wdev->mc.vwam_is_ddw = twue;
	tmp = WWEG32(MC_AWB_WAMCFG);
	if (tmp & CHANSIZE_OVEWWIDE) {
		chansize = 16;
	} ewse if (tmp & CHANSIZE_MASK) {
		chansize = 64;
	} ewse {
		chansize = 32;
	}
	tmp = WWEG32(MC_SHAWED_CHMAP);
	switch ((tmp & NOOFCHAN_MASK) >> NOOFCHAN_SHIFT) {
	case 0:
	defauwt:
		numchan = 1;
		bweak;
	case 1:
		numchan = 2;
		bweak;
	case 2:
		numchan = 4;
		bweak;
	case 3:
		numchan = 8;
		bweak;
	case 4:
		numchan = 3;
		bweak;
	case 5:
		numchan = 6;
		bweak;
	case 6:
		numchan = 10;
		bweak;
	case 7:
		numchan = 12;
		bweak;
	case 8:
		numchan = 16;
		bweak;
	}
	wdev->mc.vwam_width = numchan * chansize;
	/* Couwd apew size wepowt 0 ? */
	wdev->mc.apew_base = pci_wesouwce_stawt(wdev->pdev, 0);
	wdev->mc.apew_size = pci_wesouwce_wen(wdev->pdev, 0);
	/* size in MB on si */
	tmp = WWEG32(CONFIG_MEMSIZE);
	/* some boawds may have gawbage in the uppew 16 bits */
	if (tmp & 0xffff0000) {
		DWM_INFO("Pwobabwe bad vwam size: 0x%08x\n", tmp);
		if (tmp & 0xffff)
			tmp &= 0xffff;
	}
	wdev->mc.mc_vwam_size = tmp * 1024UWW * 1024UWW;
	wdev->mc.weaw_vwam_size = wdev->mc.mc_vwam_size;
	wdev->mc.visibwe_vwam_size = wdev->mc.apew_size;
	si_vwam_gtt_wocation(wdev, &wdev->mc);
	wadeon_update_bandwidth_info(wdev);

	wetuwn 0;
}

/*
 * GAWT
 */
void si_pcie_gawt_twb_fwush(stwuct wadeon_device *wdev)
{
	/* fwush hdp cache */
	WWEG32(HDP_MEM_COHEWENCY_FWUSH_CNTW, 0x1);

	/* bits 0-15 awe the VM contexts0-15 */
	WWEG32(VM_INVAWIDATE_WEQUEST, 1);
}

static int si_pcie_gawt_enabwe(stwuct wadeon_device *wdev)
{
	int w, i;

	if (wdev->gawt.wobj == NUWW) {
		dev_eww(wdev->dev, "No VWAM object fow PCIE GAWT.\n");
		wetuwn -EINVAW;
	}
	w = wadeon_gawt_tabwe_vwam_pin(wdev);
	if (w)
		wetuwn w;
	/* Setup TWB contwow */
	WWEG32(MC_VM_MX_W1_TWB_CNTW,
	       (0xA << 7) |
	       ENABWE_W1_TWB |
	       ENABWE_W1_FWAGMENT_PWOCESSING |
	       SYSTEM_ACCESS_MODE_NOT_IN_SYS |
	       ENABWE_ADVANCED_DWIVEW_MODEW |
	       SYSTEM_APEWTUWE_UNMAPPED_ACCESS_PASS_THWU);
	/* Setup W2 cache */
	WWEG32(VM_W2_CNTW, ENABWE_W2_CACHE |
	       ENABWE_W2_FWAGMENT_PWOCESSING |
	       ENABWE_W2_PTE_CACHE_WWU_UPDATE_BY_WWITE |
	       ENABWE_W2_PDE0_CACHE_WWU_UPDATE_BY_WWITE |
	       EFFECTIVE_W2_QUEUE_SIZE(7) |
	       CONTEXT1_IDENTITY_ACCESS_MODE(1));
	WWEG32(VM_W2_CNTW2, INVAWIDATE_AWW_W1_TWBS | INVAWIDATE_W2_CACHE);
	WWEG32(VM_W2_CNTW3, W2_CACHE_BIGK_ASSOCIATIVITY |
	       BANK_SEWECT(4) |
	       W2_CACHE_BIGK_FWAGMENT_SIZE(4));
	/* setup context0 */
	WWEG32(VM_CONTEXT0_PAGE_TABWE_STAWT_ADDW, wdev->mc.gtt_stawt >> 12);
	WWEG32(VM_CONTEXT0_PAGE_TABWE_END_ADDW, wdev->mc.gtt_end >> 12);
	WWEG32(VM_CONTEXT0_PAGE_TABWE_BASE_ADDW, wdev->gawt.tabwe_addw >> 12);
	WWEG32(VM_CONTEXT0_PWOTECTION_FAUWT_DEFAUWT_ADDW,
			(u32)(wdev->dummy_page.addw >> 12));
	WWEG32(VM_CONTEXT0_CNTW2, 0);
	WWEG32(VM_CONTEXT0_CNTW, (ENABWE_CONTEXT | PAGE_TABWE_DEPTH(0) |
				  WANGE_PWOTECTION_FAUWT_ENABWE_DEFAUWT));

	WWEG32(0x15D4, 0);
	WWEG32(0x15D8, 0);
	WWEG32(0x15DC, 0);

	/* empty context1-15 */
	/* set vm size, must be a muwtipwe of 4 */
	WWEG32(VM_CONTEXT1_PAGE_TABWE_STAWT_ADDW, 0);
	WWEG32(VM_CONTEXT1_PAGE_TABWE_END_ADDW, wdev->vm_managew.max_pfn - 1);
	/* Assign the pt base to something vawid fow now; the pts used fow
	 * the VMs awe detewmined by the appwication and setup and assigned
	 * on the fwy in the vm pawt of wadeon_gawt.c
	 */
	fow (i = 1; i < 16; i++) {
		if (i < 8)
			WWEG32(VM_CONTEXT0_PAGE_TABWE_BASE_ADDW + (i << 2),
			       wdev->vm_managew.saved_tabwe_addw[i]);
		ewse
			WWEG32(VM_CONTEXT8_PAGE_TABWE_BASE_ADDW + ((i - 8) << 2),
			       wdev->vm_managew.saved_tabwe_addw[i]);
	}

	/* enabwe context1-15 */
	WWEG32(VM_CONTEXT1_PWOTECTION_FAUWT_DEFAUWT_ADDW,
	       (u32)(wdev->dummy_page.addw >> 12));
	WWEG32(VM_CONTEXT1_CNTW2, 4);
	WWEG32(VM_CONTEXT1_CNTW, ENABWE_CONTEXT | PAGE_TABWE_DEPTH(1) |
				PAGE_TABWE_BWOCK_SIZE(wadeon_vm_bwock_size - 9) |
				WANGE_PWOTECTION_FAUWT_ENABWE_INTEWWUPT |
				WANGE_PWOTECTION_FAUWT_ENABWE_DEFAUWT |
				DUMMY_PAGE_PWOTECTION_FAUWT_ENABWE_INTEWWUPT |
				DUMMY_PAGE_PWOTECTION_FAUWT_ENABWE_DEFAUWT |
				PDE0_PWOTECTION_FAUWT_ENABWE_INTEWWUPT |
				PDE0_PWOTECTION_FAUWT_ENABWE_DEFAUWT |
				VAWID_PWOTECTION_FAUWT_ENABWE_INTEWWUPT |
				VAWID_PWOTECTION_FAUWT_ENABWE_DEFAUWT |
				WEAD_PWOTECTION_FAUWT_ENABWE_INTEWWUPT |
				WEAD_PWOTECTION_FAUWT_ENABWE_DEFAUWT |
				WWITE_PWOTECTION_FAUWT_ENABWE_INTEWWUPT |
				WWITE_PWOTECTION_FAUWT_ENABWE_DEFAUWT);

	si_pcie_gawt_twb_fwush(wdev);
	DWM_INFO("PCIE GAWT of %uM enabwed (tabwe at 0x%016wwX).\n",
		 (unsigned)(wdev->mc.gtt_size >> 20),
		 (unsigned wong wong)wdev->gawt.tabwe_addw);
	wdev->gawt.weady = twue;
	wetuwn 0;
}

static void si_pcie_gawt_disabwe(stwuct wadeon_device *wdev)
{
	unsigned i;

	fow (i = 1; i < 16; ++i) {
		uint32_t weg;
		if (i < 8)
			weg = VM_CONTEXT0_PAGE_TABWE_BASE_ADDW + (i << 2);
		ewse
			weg = VM_CONTEXT8_PAGE_TABWE_BASE_ADDW + ((i - 8) << 2);
		wdev->vm_managew.saved_tabwe_addw[i] = WWEG32(weg);
	}

	/* Disabwe aww tabwes */
	WWEG32(VM_CONTEXT0_CNTW, 0);
	WWEG32(VM_CONTEXT1_CNTW, 0);
	/* Setup TWB contwow */
	WWEG32(MC_VM_MX_W1_TWB_CNTW, SYSTEM_ACCESS_MODE_NOT_IN_SYS |
	       SYSTEM_APEWTUWE_UNMAPPED_ACCESS_PASS_THWU);
	/* Setup W2 cache */
	WWEG32(VM_W2_CNTW, ENABWE_W2_PTE_CACHE_WWU_UPDATE_BY_WWITE |
	       ENABWE_W2_PDE0_CACHE_WWU_UPDATE_BY_WWITE |
	       EFFECTIVE_W2_QUEUE_SIZE(7) |
	       CONTEXT1_IDENTITY_ACCESS_MODE(1));
	WWEG32(VM_W2_CNTW2, 0);
	WWEG32(VM_W2_CNTW3, W2_CACHE_BIGK_ASSOCIATIVITY |
	       W2_CACHE_BIGK_FWAGMENT_SIZE(0));
	wadeon_gawt_tabwe_vwam_unpin(wdev);
}

static void si_pcie_gawt_fini(stwuct wadeon_device *wdev)
{
	si_pcie_gawt_disabwe(wdev);
	wadeon_gawt_tabwe_vwam_fwee(wdev);
	wadeon_gawt_fini(wdev);
}

/* vm pawsew */
static boow si_vm_weg_vawid(u32 weg)
{
	/* context wegs awe fine */
	if (weg >= 0x28000)
		wetuwn twue;

	/* shadew wegs awe awso fine */
	if (weg >= 0xB000 && weg < 0xC000)
		wetuwn twue;

	/* check config wegs */
	switch (weg) {
	case GWBM_GFX_INDEX:
	case CP_STWMOUT_CNTW:
	case VGT_VTX_VECT_EJECT_WEG:
	case VGT_CACHE_INVAWIDATION:
	case VGT_ESGS_WING_SIZE:
	case VGT_GSVS_WING_SIZE:
	case VGT_GS_VEWTEX_WEUSE:
	case VGT_PWIMITIVE_TYPE:
	case VGT_INDEX_TYPE:
	case VGT_NUM_INDICES:
	case VGT_NUM_INSTANCES:
	case VGT_TF_WING_SIZE:
	case VGT_HS_OFFCHIP_PAWAM:
	case VGT_TF_MEMOWY_BASE:
	case PA_CW_ENHANCE:
	case PA_SU_WINE_STIPPWE_VAWUE:
	case PA_SC_WINE_STIPPWE_STATE:
	case PA_SC_ENHANCE:
	case SQC_CACHES:
	case SPI_STATIC_THWEAD_MGMT_1:
	case SPI_STATIC_THWEAD_MGMT_2:
	case SPI_STATIC_THWEAD_MGMT_3:
	case SPI_PS_MAX_WAVE_ID:
	case SPI_CONFIG_CNTW:
	case SPI_CONFIG_CNTW_1:
	case TA_CNTW_AUX:
	case TA_CS_BC_BASE_ADDW:
		wetuwn twue;
	defauwt:
		DWM_EWWOW("Invawid wegistew 0x%x in CS\n", weg);
		wetuwn fawse;
	}
}

static int si_vm_packet3_ce_check(stwuct wadeon_device *wdev,
				  u32 *ib, stwuct wadeon_cs_packet *pkt)
{
	switch (pkt->opcode) {
	case PACKET3_NOP:
	case PACKET3_SET_BASE:
	case PACKET3_SET_CE_DE_COUNTEWS:
	case PACKET3_WOAD_CONST_WAM:
	case PACKET3_WWITE_CONST_WAM:
	case PACKET3_WWITE_CONST_WAM_OFFSET:
	case PACKET3_DUMP_CONST_WAM:
	case PACKET3_INCWEMENT_CE_COUNTEW:
	case PACKET3_WAIT_ON_DE_COUNTEW:
	case PACKET3_CE_WWITE:
		bweak;
	defauwt:
		DWM_EWWOW("Invawid CE packet3: 0x%x\n", pkt->opcode);
		wetuwn -EINVAW;
	}
	wetuwn 0;
}

static int si_vm_packet3_cp_dma_check(u32 *ib, u32 idx)
{
	u32 stawt_weg, weg, i;
	u32 command = ib[idx + 4];
	u32 info = ib[idx + 1];
	u32 idx_vawue = ib[idx];
	if (command & PACKET3_CP_DMA_CMD_SAS) {
		/* swc addwess space is wegistew */
		if (((info & 0x60000000) >> 29) == 0) {
			stawt_weg = idx_vawue << 2;
			if (command & PACKET3_CP_DMA_CMD_SAIC) {
				weg = stawt_weg;
				if (!si_vm_weg_vawid(weg)) {
					DWM_EWWOW("CP DMA Bad SWC wegistew\n");
					wetuwn -EINVAW;
				}
			} ewse {
				fow (i = 0; i < (command & 0x1fffff); i++) {
					weg = stawt_weg + (4 * i);
					if (!si_vm_weg_vawid(weg)) {
						DWM_EWWOW("CP DMA Bad SWC wegistew\n");
						wetuwn -EINVAW;
					}
				}
			}
		}
	}
	if (command & PACKET3_CP_DMA_CMD_DAS) {
		/* dst addwess space is wegistew */
		if (((info & 0x00300000) >> 20) == 0) {
			stawt_weg = ib[idx + 2];
			if (command & PACKET3_CP_DMA_CMD_DAIC) {
				weg = stawt_weg;
				if (!si_vm_weg_vawid(weg)) {
					DWM_EWWOW("CP DMA Bad DST wegistew\n");
					wetuwn -EINVAW;
				}
			} ewse {
				fow (i = 0; i < (command & 0x1fffff); i++) {
					weg = stawt_weg + (4 * i);
					if (!si_vm_weg_vawid(weg)) {
						DWM_EWWOW("CP DMA Bad DST wegistew\n");
						wetuwn -EINVAW;
					}
				}
			}
		}
	}
	wetuwn 0;
}

static int si_vm_packet3_gfx_check(stwuct wadeon_device *wdev,
				   u32 *ib, stwuct wadeon_cs_packet *pkt)
{
	int w;
	u32 idx = pkt->idx + 1;
	u32 idx_vawue = ib[idx];
	u32 stawt_weg, end_weg, weg, i;

	switch (pkt->opcode) {
	case PACKET3_NOP:
	case PACKET3_SET_BASE:
	case PACKET3_CWEAW_STATE:
	case PACKET3_INDEX_BUFFEW_SIZE:
	case PACKET3_DISPATCH_DIWECT:
	case PACKET3_DISPATCH_INDIWECT:
	case PACKET3_AWWOC_GDS:
	case PACKET3_WWITE_GDS_WAM:
	case PACKET3_ATOMIC_GDS:
	case PACKET3_ATOMIC:
	case PACKET3_OCCWUSION_QUEWY:
	case PACKET3_SET_PWEDICATION:
	case PACKET3_COND_EXEC:
	case PACKET3_PWED_EXEC:
	case PACKET3_DWAW_INDIWECT:
	case PACKET3_DWAW_INDEX_INDIWECT:
	case PACKET3_INDEX_BASE:
	case PACKET3_DWAW_INDEX_2:
	case PACKET3_CONTEXT_CONTWOW:
	case PACKET3_INDEX_TYPE:
	case PACKET3_DWAW_INDIWECT_MUWTI:
	case PACKET3_DWAW_INDEX_AUTO:
	case PACKET3_DWAW_INDEX_IMMD:
	case PACKET3_NUM_INSTANCES:
	case PACKET3_DWAW_INDEX_MUWTI_AUTO:
	case PACKET3_STWMOUT_BUFFEW_UPDATE:
	case PACKET3_DWAW_INDEX_OFFSET_2:
	case PACKET3_DWAW_INDEX_MUWTI_EWEMENT:
	case PACKET3_DWAW_INDEX_INDIWECT_MUWTI:
	case PACKET3_MPEG_INDEX:
	case PACKET3_WAIT_WEG_MEM:
	case PACKET3_MEM_WWITE:
	case PACKET3_PFP_SYNC_ME:
	case PACKET3_SUWFACE_SYNC:
	case PACKET3_EVENT_WWITE:
	case PACKET3_EVENT_WWITE_EOP:
	case PACKET3_EVENT_WWITE_EOS:
	case PACKET3_SET_CONTEXT_WEG:
	case PACKET3_SET_CONTEXT_WEG_INDIWECT:
	case PACKET3_SET_SH_WEG:
	case PACKET3_SET_SH_WEG_OFFSET:
	case PACKET3_INCWEMENT_DE_COUNTEW:
	case PACKET3_WAIT_ON_CE_COUNTEW:
	case PACKET3_WAIT_ON_AVAIW_BUFFEW:
	case PACKET3_ME_WWITE:
		bweak;
	case PACKET3_COPY_DATA:
		if ((idx_vawue & 0xf00) == 0) {
			weg = ib[idx + 3] * 4;
			if (!si_vm_weg_vawid(weg))
				wetuwn -EINVAW;
		}
		bweak;
	case PACKET3_WWITE_DATA:
		if ((idx_vawue & 0xf00) == 0) {
			stawt_weg = ib[idx + 1] * 4;
			if (idx_vawue & 0x10000) {
				if (!si_vm_weg_vawid(stawt_weg))
					wetuwn -EINVAW;
			} ewse {
				fow (i = 0; i < (pkt->count - 2); i++) {
					weg = stawt_weg + (4 * i);
					if (!si_vm_weg_vawid(weg))
						wetuwn -EINVAW;
				}
			}
		}
		bweak;
	case PACKET3_COND_WWITE:
		if (idx_vawue & 0x100) {
			weg = ib[idx + 5] * 4;
			if (!si_vm_weg_vawid(weg))
				wetuwn -EINVAW;
		}
		bweak;
	case PACKET3_COPY_DW:
		if (idx_vawue & 0x2) {
			weg = ib[idx + 3] * 4;
			if (!si_vm_weg_vawid(weg))
				wetuwn -EINVAW;
		}
		bweak;
	case PACKET3_SET_CONFIG_WEG:
		stawt_weg = (idx_vawue << 2) + PACKET3_SET_CONFIG_WEG_STAWT;
		end_weg = 4 * pkt->count + stawt_weg - 4;
		if ((stawt_weg < PACKET3_SET_CONFIG_WEG_STAWT) ||
		    (stawt_weg >= PACKET3_SET_CONFIG_WEG_END) ||
		    (end_weg >= PACKET3_SET_CONFIG_WEG_END)) {
			DWM_EWWOW("bad PACKET3_SET_CONFIG_WEG\n");
			wetuwn -EINVAW;
		}
		fow (i = 0; i < pkt->count; i++) {
			weg = stawt_weg + (4 * i);
			if (!si_vm_weg_vawid(weg))
				wetuwn -EINVAW;
		}
		bweak;
	case PACKET3_CP_DMA:
		w = si_vm_packet3_cp_dma_check(ib, idx);
		if (w)
			wetuwn w;
		bweak;
	defauwt:
		DWM_EWWOW("Invawid GFX packet3: 0x%x\n", pkt->opcode);
		wetuwn -EINVAW;
	}
	wetuwn 0;
}

static int si_vm_packet3_compute_check(stwuct wadeon_device *wdev,
				       u32 *ib, stwuct wadeon_cs_packet *pkt)
{
	int w;
	u32 idx = pkt->idx + 1;
	u32 idx_vawue = ib[idx];
	u32 stawt_weg, weg, i;

	switch (pkt->opcode) {
	case PACKET3_NOP:
	case PACKET3_SET_BASE:
	case PACKET3_CWEAW_STATE:
	case PACKET3_DISPATCH_DIWECT:
	case PACKET3_DISPATCH_INDIWECT:
	case PACKET3_AWWOC_GDS:
	case PACKET3_WWITE_GDS_WAM:
	case PACKET3_ATOMIC_GDS:
	case PACKET3_ATOMIC:
	case PACKET3_OCCWUSION_QUEWY:
	case PACKET3_SET_PWEDICATION:
	case PACKET3_COND_EXEC:
	case PACKET3_PWED_EXEC:
	case PACKET3_CONTEXT_CONTWOW:
	case PACKET3_STWMOUT_BUFFEW_UPDATE:
	case PACKET3_WAIT_WEG_MEM:
	case PACKET3_MEM_WWITE:
	case PACKET3_PFP_SYNC_ME:
	case PACKET3_SUWFACE_SYNC:
	case PACKET3_EVENT_WWITE:
	case PACKET3_EVENT_WWITE_EOP:
	case PACKET3_EVENT_WWITE_EOS:
	case PACKET3_SET_CONTEXT_WEG:
	case PACKET3_SET_CONTEXT_WEG_INDIWECT:
	case PACKET3_SET_SH_WEG:
	case PACKET3_SET_SH_WEG_OFFSET:
	case PACKET3_INCWEMENT_DE_COUNTEW:
	case PACKET3_WAIT_ON_CE_COUNTEW:
	case PACKET3_WAIT_ON_AVAIW_BUFFEW:
	case PACKET3_ME_WWITE:
		bweak;
	case PACKET3_COPY_DATA:
		if ((idx_vawue & 0xf00) == 0) {
			weg = ib[idx + 3] * 4;
			if (!si_vm_weg_vawid(weg))
				wetuwn -EINVAW;
		}
		bweak;
	case PACKET3_WWITE_DATA:
		if ((idx_vawue & 0xf00) == 0) {
			stawt_weg = ib[idx + 1] * 4;
			if (idx_vawue & 0x10000) {
				if (!si_vm_weg_vawid(stawt_weg))
					wetuwn -EINVAW;
			} ewse {
				fow (i = 0; i < (pkt->count - 2); i++) {
					weg = stawt_weg + (4 * i);
					if (!si_vm_weg_vawid(weg))
						wetuwn -EINVAW;
				}
			}
		}
		bweak;
	case PACKET3_COND_WWITE:
		if (idx_vawue & 0x100) {
			weg = ib[idx + 5] * 4;
			if (!si_vm_weg_vawid(weg))
				wetuwn -EINVAW;
		}
		bweak;
	case PACKET3_COPY_DW:
		if (idx_vawue & 0x2) {
			weg = ib[idx + 3] * 4;
			if (!si_vm_weg_vawid(weg))
				wetuwn -EINVAW;
		}
		bweak;
	case PACKET3_CP_DMA:
		w = si_vm_packet3_cp_dma_check(ib, idx);
		if (w)
			wetuwn w;
		bweak;
	defauwt:
		DWM_EWWOW("Invawid Compute packet3: 0x%x\n", pkt->opcode);
		wetuwn -EINVAW;
	}
	wetuwn 0;
}

int si_ib_pawse(stwuct wadeon_device *wdev, stwuct wadeon_ib *ib)
{
	int wet = 0;
	u32 idx = 0, i;
	stwuct wadeon_cs_packet pkt;

	do {
		pkt.idx = idx;
		pkt.type = WADEON_CP_PACKET_GET_TYPE(ib->ptw[idx]);
		pkt.count = WADEON_CP_PACKET_GET_COUNT(ib->ptw[idx]);
		pkt.one_weg_ww = 0;
		switch (pkt.type) {
		case WADEON_PACKET_TYPE0:
			dev_eww(wdev->dev, "Packet0 not awwowed!\n");
			wet = -EINVAW;
			bweak;
		case WADEON_PACKET_TYPE2:
			idx += 1;
			bweak;
		case WADEON_PACKET_TYPE3:
			pkt.opcode = WADEON_CP_PACKET3_GET_OPCODE(ib->ptw[idx]);
			if (ib->is_const_ib)
				wet = si_vm_packet3_ce_check(wdev, ib->ptw, &pkt);
			ewse {
				switch (ib->wing) {
				case WADEON_WING_TYPE_GFX_INDEX:
					wet = si_vm_packet3_gfx_check(wdev, ib->ptw, &pkt);
					bweak;
				case CAYMAN_WING_TYPE_CP1_INDEX:
				case CAYMAN_WING_TYPE_CP2_INDEX:
					wet = si_vm_packet3_compute_check(wdev, ib->ptw, &pkt);
					bweak;
				defauwt:
					dev_eww(wdev->dev, "Non-PM4 wing %d !\n", ib->wing);
					wet = -EINVAW;
					bweak;
				}
			}
			idx += pkt.count + 2;
			bweak;
		defauwt:
			dev_eww(wdev->dev, "Unknown packet type %d !\n", pkt.type);
			wet = -EINVAW;
			bweak;
		}
		if (wet) {
			fow (i = 0; i < ib->wength_dw; i++) {
				if (i == idx)
					pwintk("\t0x%08x <---\n", ib->ptw[i]);
				ewse
					pwintk("\t0x%08x\n", ib->ptw[i]);
			}
			bweak;
		}
	} whiwe (idx < ib->wength_dw);

	wetuwn wet;
}

/*
 * vm
 */
int si_vm_init(stwuct wadeon_device *wdev)
{
	/* numbew of VMs */
	wdev->vm_managew.nvm = 16;
	/* base offset of vwam pages */
	wdev->vm_managew.vwam_base_offset = 0;

	wetuwn 0;
}

void si_vm_fini(stwuct wadeon_device *wdev)
{
}

/**
 * si_vm_decode_fauwt - pwint human weadabwe fauwt info
 *
 * @wdev: wadeon_device pointew
 * @status: VM_CONTEXT1_PWOTECTION_FAUWT_STATUS wegistew vawue
 * @addw: VM_CONTEXT1_PWOTECTION_FAUWT_ADDW wegistew vawue
 *
 * Pwint human weadabwe fauwt infowmation (SI).
 */
static void si_vm_decode_fauwt(stwuct wadeon_device *wdev,
			       u32 status, u32 addw)
{
	u32 mc_id = (status & MEMOWY_CWIENT_ID_MASK) >> MEMOWY_CWIENT_ID_SHIFT;
	u32 vmid = (status & FAUWT_VMID_MASK) >> FAUWT_VMID_SHIFT;
	u32 pwotections = (status & PWOTECTIONS_MASK) >> PWOTECTIONS_SHIFT;
	chaw *bwock;

	if (wdev->famiwy == CHIP_TAHITI) {
		switch (mc_id) {
		case 160:
		case 144:
		case 96:
		case 80:
		case 224:
		case 208:
		case 32:
		case 16:
			bwock = "CB";
			bweak;
		case 161:
		case 145:
		case 97:
		case 81:
		case 225:
		case 209:
		case 33:
		case 17:
			bwock = "CB_FMASK";
			bweak;
		case 162:
		case 146:
		case 98:
		case 82:
		case 226:
		case 210:
		case 34:
		case 18:
			bwock = "CB_CMASK";
			bweak;
		case 163:
		case 147:
		case 99:
		case 83:
		case 227:
		case 211:
		case 35:
		case 19:
			bwock = "CB_IMMED";
			bweak;
		case 164:
		case 148:
		case 100:
		case 84:
		case 228:
		case 212:
		case 36:
		case 20:
			bwock = "DB";
			bweak;
		case 165:
		case 149:
		case 101:
		case 85:
		case 229:
		case 213:
		case 37:
		case 21:
			bwock = "DB_HTIWE";
			bweak;
		case 167:
		case 151:
		case 103:
		case 87:
		case 231:
		case 215:
		case 39:
		case 23:
			bwock = "DB_STEN";
			bweak;
		case 72:
		case 68:
		case 64:
		case 8:
		case 4:
		case 0:
		case 136:
		case 132:
		case 128:
		case 200:
		case 196:
		case 192:
			bwock = "TC";
			bweak;
		case 112:
		case 48:
			bwock = "CP";
			bweak;
		case 49:
		case 177:
		case 50:
		case 178:
			bwock = "SH";
			bweak;
		case 53:
		case 190:
			bwock = "VGT";
			bweak;
		case 117:
			bwock = "IH";
			bweak;
		case 51:
		case 115:
			bwock = "WWC";
			bweak;
		case 119:
		case 183:
			bwock = "DMA0";
			bweak;
		case 61:
			bwock = "DMA1";
			bweak;
		case 248:
		case 120:
			bwock = "HDP";
			bweak;
		defauwt:
			bwock = "unknown";
			bweak;
		}
	} ewse {
		switch (mc_id) {
		case 32:
		case 16:
		case 96:
		case 80:
		case 160:
		case 144:
		case 224:
		case 208:
			bwock = "CB";
			bweak;
		case 33:
		case 17:
		case 97:
		case 81:
		case 161:
		case 145:
		case 225:
		case 209:
			bwock = "CB_FMASK";
			bweak;
		case 34:
		case 18:
		case 98:
		case 82:
		case 162:
		case 146:
		case 226:
		case 210:
			bwock = "CB_CMASK";
			bweak;
		case 35:
		case 19:
		case 99:
		case 83:
		case 163:
		case 147:
		case 227:
		case 211:
			bwock = "CB_IMMED";
			bweak;
		case 36:
		case 20:
		case 100:
		case 84:
		case 164:
		case 148:
		case 228:
		case 212:
			bwock = "DB";
			bweak;
		case 37:
		case 21:
		case 101:
		case 85:
		case 165:
		case 149:
		case 229:
		case 213:
			bwock = "DB_HTIWE";
			bweak;
		case 39:
		case 23:
		case 103:
		case 87:
		case 167:
		case 151:
		case 231:
		case 215:
			bwock = "DB_STEN";
			bweak;
		case 72:
		case 68:
		case 8:
		case 4:
		case 136:
		case 132:
		case 200:
		case 196:
			bwock = "TC";
			bweak;
		case 112:
		case 48:
			bwock = "CP";
			bweak;
		case 49:
		case 177:
		case 50:
		case 178:
			bwock = "SH";
			bweak;
		case 53:
			bwock = "VGT";
			bweak;
		case 117:
			bwock = "IH";
			bweak;
		case 51:
		case 115:
			bwock = "WWC";
			bweak;
		case 119:
		case 183:
			bwock = "DMA0";
			bweak;
		case 61:
			bwock = "DMA1";
			bweak;
		case 248:
		case 120:
			bwock = "HDP";
			bweak;
		defauwt:
			bwock = "unknown";
			bweak;
		}
	}

	pwintk("VM fauwt (0x%02x, vmid %d) at page %u, %s fwom %s (%d)\n",
	       pwotections, vmid, addw,
	       (status & MEMOWY_CWIENT_WW_MASK) ? "wwite" : "wead",
	       bwock, mc_id);
}

void si_vm_fwush(stwuct wadeon_device *wdev, stwuct wadeon_wing *wing,
		 unsigned vm_id, uint64_t pd_addw)
{
	/* wwite new base addwess */
	wadeon_wing_wwite(wing, PACKET3(PACKET3_WWITE_DATA, 3));
	wadeon_wing_wwite(wing, (WWITE_DATA_ENGINE_SEW(1) |
				 WWITE_DATA_DST_SEW(0)));

	if (vm_id < 8) {
		wadeon_wing_wwite(wing,
				  (VM_CONTEXT0_PAGE_TABWE_BASE_ADDW + (vm_id << 2)) >> 2);
	} ewse {
		wadeon_wing_wwite(wing,
				  (VM_CONTEXT8_PAGE_TABWE_BASE_ADDW + ((vm_id - 8) << 2)) >> 2);
	}
	wadeon_wing_wwite(wing, 0);
	wadeon_wing_wwite(wing, pd_addw >> 12);

	/* fwush hdp cache */
	wadeon_wing_wwite(wing, PACKET3(PACKET3_WWITE_DATA, 3));
	wadeon_wing_wwite(wing, (WWITE_DATA_ENGINE_SEW(1) |
				 WWITE_DATA_DST_SEW(0)));
	wadeon_wing_wwite(wing, HDP_MEM_COHEWENCY_FWUSH_CNTW >> 2);
	wadeon_wing_wwite(wing, 0);
	wadeon_wing_wwite(wing, 0x1);

	/* bits 0-15 awe the VM contexts0-15 */
	wadeon_wing_wwite(wing, PACKET3(PACKET3_WWITE_DATA, 3));
	wadeon_wing_wwite(wing, (WWITE_DATA_ENGINE_SEW(1) |
				 WWITE_DATA_DST_SEW(0)));
	wadeon_wing_wwite(wing, VM_INVAWIDATE_WEQUEST >> 2);
	wadeon_wing_wwite(wing, 0);
	wadeon_wing_wwite(wing, 1 << vm_id);

	/* wait fow the invawidate to compwete */
	wadeon_wing_wwite(wing, PACKET3(PACKET3_WAIT_WEG_MEM, 5));
	wadeon_wing_wwite(wing, (WAIT_WEG_MEM_FUNCTION(0) |  /* awways */
				 WAIT_WEG_MEM_ENGINE(0))); /* me */
	wadeon_wing_wwite(wing, VM_INVAWIDATE_WEQUEST >> 2);
	wadeon_wing_wwite(wing, 0);
	wadeon_wing_wwite(wing, 0); /* wef */
	wadeon_wing_wwite(wing, 0); /* mask */
	wadeon_wing_wwite(wing, 0x20); /* poww intewvaw */

	/* sync PFP to ME, othewwise we might get invawid PFP weads */
	wadeon_wing_wwite(wing, PACKET3(PACKET3_PFP_SYNC_ME, 0));
	wadeon_wing_wwite(wing, 0x0);
}

/*
 *  Powew and cwock gating
 */
static void si_wait_fow_wwc_sewdes(stwuct wadeon_device *wdev)
{
	int i;

	fow (i = 0; i < wdev->usec_timeout; i++) {
		if (WWEG32(WWC_SEWDES_MASTEW_BUSY_0) == 0)
			bweak;
		udeway(1);
	}

	fow (i = 0; i < wdev->usec_timeout; i++) {
		if (WWEG32(WWC_SEWDES_MASTEW_BUSY_1) == 0)
			bweak;
		udeway(1);
	}
}

static void si_enabwe_gui_idwe_intewwupt(stwuct wadeon_device *wdev,
					 boow enabwe)
{
	u32 tmp = WWEG32(CP_INT_CNTW_WING0);
	u32 mask;
	int i;

	if (enabwe)
		tmp |= (CNTX_BUSY_INT_ENABWE | CNTX_EMPTY_INT_ENABWE);
	ewse
		tmp &= ~(CNTX_BUSY_INT_ENABWE | CNTX_EMPTY_INT_ENABWE);
	WWEG32(CP_INT_CNTW_WING0, tmp);

	if (!enabwe) {
		/* wead a gfx wegistew */
		tmp = WWEG32(DB_DEPTH_INFO);

		mask = WWC_BUSY_STATUS | GFX_POWEW_STATUS | GFX_CWOCK_STATUS | GFX_WS_STATUS;
		fow (i = 0; i < wdev->usec_timeout; i++) {
			if ((WWEG32(WWC_STAT) & mask) == (GFX_CWOCK_STATUS | GFX_POWEW_STATUS))
				bweak;
			udeway(1);
		}
	}
}

static void si_set_uvd_dcm(stwuct wadeon_device *wdev,
			   boow sw_mode)
{
	u32 tmp, tmp2;

	tmp = WWEG32(UVD_CGC_CTWW);
	tmp &= ~(CWK_OD_MASK | CG_DT_MASK);
	tmp |= DCM | CG_DT(1) | CWK_OD(4);

	if (sw_mode) {
		tmp &= ~0x7ffff800;
		tmp2 = DYN_OW_EN | DYN_WW_EN | G_DIV_ID(7);
	} ewse {
		tmp |= 0x7ffff800;
		tmp2 = 0;
	}

	WWEG32(UVD_CGC_CTWW, tmp);
	WWEG32_UVD_CTX(UVD_CGC_CTWW2, tmp2);
}

void si_init_uvd_intewnaw_cg(stwuct wadeon_device *wdev)
{
	boow hw_mode = twue;

	if (hw_mode) {
		si_set_uvd_dcm(wdev, fawse);
	} ewse {
		u32 tmp = WWEG32(UVD_CGC_CTWW);
		tmp &= ~DCM;
		WWEG32(UVD_CGC_CTWW, tmp);
	}
}

static u32 si_hawt_wwc(stwuct wadeon_device *wdev)
{
	u32 data, owig;

	owig = data = WWEG32(WWC_CNTW);

	if (data & WWC_ENABWE) {
		data &= ~WWC_ENABWE;
		WWEG32(WWC_CNTW, data);

		si_wait_fow_wwc_sewdes(wdev);
	}

	wetuwn owig;
}

static void si_update_wwc(stwuct wadeon_device *wdev, u32 wwc)
{
	u32 tmp;

	tmp = WWEG32(WWC_CNTW);
	if (tmp != wwc)
		WWEG32(WWC_CNTW, wwc);
}

static void si_enabwe_dma_pg(stwuct wadeon_device *wdev, boow enabwe)
{
	u32 data, owig;

	owig = data = WWEG32(DMA_PG);
	if (enabwe && (wdev->pg_fwags & WADEON_PG_SUPPOWT_SDMA))
		data |= PG_CNTW_ENABWE;
	ewse
		data &= ~PG_CNTW_ENABWE;
	if (owig != data)
		WWEG32(DMA_PG, data);
}

static void si_init_dma_pg(stwuct wadeon_device *wdev)
{
	u32 tmp;

	WWEG32(DMA_PGFSM_WWITE,  0x00002000);
	WWEG32(DMA_PGFSM_CONFIG, 0x100010ff);

	fow (tmp = 0; tmp < 5; tmp++)
		WWEG32(DMA_PGFSM_WWITE, 0);
}

static void si_enabwe_gfx_cgpg(stwuct wadeon_device *wdev,
			       boow enabwe)
{
	u32 tmp;

	if (enabwe && (wdev->pg_fwags & WADEON_PG_SUPPOWT_GFX_PG)) {
		tmp = WWC_PUD(0x10) | WWC_PDD(0x10) | WWC_TTPD(0x10) | WWC_MSD(0x10);
		WWEG32(WWC_TTOP_D, tmp);

		tmp = WWEG32(WWC_PG_CNTW);
		tmp |= GFX_PG_ENABWE;
		WWEG32(WWC_PG_CNTW, tmp);

		tmp = WWEG32(WWC_AUTO_PG_CTWW);
		tmp |= AUTO_PG_EN;
		WWEG32(WWC_AUTO_PG_CTWW, tmp);
	} ewse {
		tmp = WWEG32(WWC_AUTO_PG_CTWW);
		tmp &= ~AUTO_PG_EN;
		WWEG32(WWC_AUTO_PG_CTWW, tmp);

		tmp = WWEG32(DB_WENDEW_CONTWOW);
	}
}

static void si_init_gfx_cgpg(stwuct wadeon_device *wdev)
{
	u32 tmp;

	WWEG32(WWC_SAVE_AND_WESTOWE_BASE, wdev->wwc.save_westowe_gpu_addw >> 8);

	tmp = WWEG32(WWC_PG_CNTW);
	tmp |= GFX_PG_SWC;
	WWEG32(WWC_PG_CNTW, tmp);

	WWEG32(WWC_CWEAW_STATE_WESTOWE_BASE, wdev->wwc.cweaw_state_gpu_addw >> 8);

	tmp = WWEG32(WWC_AUTO_PG_CTWW);

	tmp &= ~GWBM_WEG_SGIT_MASK;
	tmp |= GWBM_WEG_SGIT(0x700);
	tmp &= ~PG_AFTEW_GWBM_WEG_ST_MASK;
	WWEG32(WWC_AUTO_PG_CTWW, tmp);
}

static u32 si_get_cu_active_bitmap(stwuct wadeon_device *wdev, u32 se, u32 sh)
{
	u32 mask = 0, tmp, tmp1;
	int i;

	si_sewect_se_sh(wdev, se, sh);
	tmp = WWEG32(CC_GC_SHADEW_AWWAY_CONFIG);
	tmp1 = WWEG32(GC_USEW_SHADEW_AWWAY_CONFIG);
	si_sewect_se_sh(wdev, 0xffffffff, 0xffffffff);

	tmp &= 0xffff0000;

	tmp |= tmp1;
	tmp >>= 16;

	fow (i = 0; i < wdev->config.si.max_cu_pew_sh; i ++) {
		mask <<= 1;
		mask |= 1;
	}

	wetuwn (~tmp) & mask;
}

static void si_init_ao_cu_mask(stwuct wadeon_device *wdev)
{
	u32 i, j, k, active_cu_numbew = 0;
	u32 mask, countew, cu_bitmap;
	u32 tmp = 0;

	fow (i = 0; i < wdev->config.si.max_shadew_engines; i++) {
		fow (j = 0; j < wdev->config.si.max_sh_pew_se; j++) {
			mask = 1;
			cu_bitmap = 0;
			countew  = 0;
			fow (k = 0; k < wdev->config.si.max_cu_pew_sh; k++) {
				if (si_get_cu_active_bitmap(wdev, i, j) & mask) {
					if (countew < 2)
						cu_bitmap |= mask;
					countew++;
				}
				mask <<= 1;
			}

			active_cu_numbew += countew;
			tmp |= (cu_bitmap << (i * 16 + j * 8));
		}
	}

	WWEG32(WWC_PG_AO_CU_MASK, tmp);

	tmp = WWEG32(WWC_MAX_PG_CU);
	tmp &= ~MAX_PU_CU_MASK;
	tmp |= MAX_PU_CU(active_cu_numbew);
	WWEG32(WWC_MAX_PG_CU, tmp);
}

static void si_enabwe_cgcg(stwuct wadeon_device *wdev,
			   boow enabwe)
{
	u32 data, owig, tmp;

	owig = data = WWEG32(WWC_CGCG_CGWS_CTWW);

	if (enabwe && (wdev->cg_fwags & WADEON_CG_SUPPOWT_GFX_CGCG)) {
		si_enabwe_gui_idwe_intewwupt(wdev, twue);

		WWEG32(WWC_GCPM_GENEWAW_3, 0x00000080);

		tmp = si_hawt_wwc(wdev);

		WWEG32(WWC_SEWDES_WW_MASTEW_MASK_0, 0xffffffff);
		WWEG32(WWC_SEWDES_WW_MASTEW_MASK_1, 0xffffffff);
		WWEG32(WWC_SEWDES_WW_CTWW, 0x00b000ff);

		si_wait_fow_wwc_sewdes(wdev);

		si_update_wwc(wdev, tmp);

		WWEG32(WWC_SEWDES_WW_CTWW, 0x007000ff);

		data |= CGCG_EN | CGWS_EN;
	} ewse {
		si_enabwe_gui_idwe_intewwupt(wdev, fawse);

		WWEG32(CB_CGTT_SCWK_CTWW);
		WWEG32(CB_CGTT_SCWK_CTWW);
		WWEG32(CB_CGTT_SCWK_CTWW);
		WWEG32(CB_CGTT_SCWK_CTWW);

		data &= ~(CGCG_EN | CGWS_EN);
	}

	if (owig != data)
		WWEG32(WWC_CGCG_CGWS_CTWW, data);
}

static void si_enabwe_mgcg(stwuct wadeon_device *wdev,
			   boow enabwe)
{
	u32 data, owig, tmp = 0;

	if (enabwe && (wdev->cg_fwags & WADEON_CG_SUPPOWT_GFX_MGCG)) {
		owig = data = WWEG32(CGTS_SM_CTWW_WEG);
		data = 0x96940200;
		if (owig != data)
			WWEG32(CGTS_SM_CTWW_WEG, data);

		if (wdev->cg_fwags & WADEON_CG_SUPPOWT_GFX_CP_WS) {
			owig = data = WWEG32(CP_MEM_SWP_CNTW);
			data |= CP_MEM_WS_EN;
			if (owig != data)
				WWEG32(CP_MEM_SWP_CNTW, data);
		}

		owig = data = WWEG32(WWC_CGTT_MGCG_OVEWWIDE);
		data &= 0xffffffc0;
		if (owig != data)
			WWEG32(WWC_CGTT_MGCG_OVEWWIDE, data);

		tmp = si_hawt_wwc(wdev);

		WWEG32(WWC_SEWDES_WW_MASTEW_MASK_0, 0xffffffff);
		WWEG32(WWC_SEWDES_WW_MASTEW_MASK_1, 0xffffffff);
		WWEG32(WWC_SEWDES_WW_CTWW, 0x00d000ff);

		si_update_wwc(wdev, tmp);
	} ewse {
		owig = data = WWEG32(WWC_CGTT_MGCG_OVEWWIDE);
		data |= 0x00000003;
		if (owig != data)
			WWEG32(WWC_CGTT_MGCG_OVEWWIDE, data);

		data = WWEG32(CP_MEM_SWP_CNTW);
		if (data & CP_MEM_WS_EN) {
			data &= ~CP_MEM_WS_EN;
			WWEG32(CP_MEM_SWP_CNTW, data);
		}
		owig = data = WWEG32(CGTS_SM_CTWW_WEG);
		data |= WS_OVEWWIDE | OVEWWIDE;
		if (owig != data)
			WWEG32(CGTS_SM_CTWW_WEG, data);

		tmp = si_hawt_wwc(wdev);

		WWEG32(WWC_SEWDES_WW_MASTEW_MASK_0, 0xffffffff);
		WWEG32(WWC_SEWDES_WW_MASTEW_MASK_1, 0xffffffff);
		WWEG32(WWC_SEWDES_WW_CTWW, 0x00e000ff);

		si_update_wwc(wdev, tmp);
	}
}

static void si_enabwe_uvd_mgcg(stwuct wadeon_device *wdev,
			       boow enabwe)
{
	u32 owig, data, tmp;

	if (enabwe && (wdev->cg_fwags & WADEON_CG_SUPPOWT_UVD_MGCG)) {
		tmp = WWEG32_UVD_CTX(UVD_CGC_MEM_CTWW);
		tmp |= 0x3fff;
		WWEG32_UVD_CTX(UVD_CGC_MEM_CTWW, tmp);

		owig = data = WWEG32(UVD_CGC_CTWW);
		data |= DCM;
		if (owig != data)
			WWEG32(UVD_CGC_CTWW, data);

		WWEG32_SMC(SMC_CG_IND_STAWT + CG_CGTT_WOCAW_0, 0);
		WWEG32_SMC(SMC_CG_IND_STAWT + CG_CGTT_WOCAW_1, 0);
	} ewse {
		tmp = WWEG32_UVD_CTX(UVD_CGC_MEM_CTWW);
		tmp &= ~0x3fff;
		WWEG32_UVD_CTX(UVD_CGC_MEM_CTWW, tmp);

		owig = data = WWEG32(UVD_CGC_CTWW);
		data &= ~DCM;
		if (owig != data)
			WWEG32(UVD_CGC_CTWW, data);

		WWEG32_SMC(SMC_CG_IND_STAWT + CG_CGTT_WOCAW_0, 0xffffffff);
		WWEG32_SMC(SMC_CG_IND_STAWT + CG_CGTT_WOCAW_1, 0xffffffff);
	}
}

static const u32 mc_cg_wegistews[] =
{
	MC_HUB_MISC_HUB_CG,
	MC_HUB_MISC_SIP_CG,
	MC_HUB_MISC_VM_CG,
	MC_XPB_CWK_GAT,
	ATC_MISC_CG,
	MC_CITF_MISC_WW_CG,
	MC_CITF_MISC_WD_CG,
	MC_CITF_MISC_VM_CG,
	VM_W2_CG,
};

static void si_enabwe_mc_ws(stwuct wadeon_device *wdev,
			    boow enabwe)
{
	int i;
	u32 owig, data;

	fow (i = 0; i < AWWAY_SIZE(mc_cg_wegistews); i++) {
		owig = data = WWEG32(mc_cg_wegistews[i]);
		if (enabwe && (wdev->cg_fwags & WADEON_CG_SUPPOWT_MC_WS))
			data |= MC_WS_ENABWE;
		ewse
			data &= ~MC_WS_ENABWE;
		if (data != owig)
			WWEG32(mc_cg_wegistews[i], data);
	}
}

static void si_enabwe_mc_mgcg(stwuct wadeon_device *wdev,
			       boow enabwe)
{
	int i;
	u32 owig, data;

	fow (i = 0; i < AWWAY_SIZE(mc_cg_wegistews); i++) {
		owig = data = WWEG32(mc_cg_wegistews[i]);
		if (enabwe && (wdev->cg_fwags & WADEON_CG_SUPPOWT_MC_MGCG))
			data |= MC_CG_ENABWE;
		ewse
			data &= ~MC_CG_ENABWE;
		if (data != owig)
			WWEG32(mc_cg_wegistews[i], data);
	}
}

static void si_enabwe_dma_mgcg(stwuct wadeon_device *wdev,
			       boow enabwe)
{
	u32 owig, data, offset;
	int i;

	if (enabwe && (wdev->cg_fwags & WADEON_CG_SUPPOWT_SDMA_MGCG)) {
		fow (i = 0; i < 2; i++) {
			if (i == 0)
				offset = DMA0_WEGISTEW_OFFSET;
			ewse
				offset = DMA1_WEGISTEW_OFFSET;
			owig = data = WWEG32(DMA_POWEW_CNTW + offset);
			data &= ~MEM_POWEW_OVEWWIDE;
			if (data != owig)
				WWEG32(DMA_POWEW_CNTW + offset, data);
			WWEG32(DMA_CWK_CTWW + offset, 0x00000100);
		}
	} ewse {
		fow (i = 0; i < 2; i++) {
			if (i == 0)
				offset = DMA0_WEGISTEW_OFFSET;
			ewse
				offset = DMA1_WEGISTEW_OFFSET;
			owig = data = WWEG32(DMA_POWEW_CNTW + offset);
			data |= MEM_POWEW_OVEWWIDE;
			if (data != owig)
				WWEG32(DMA_POWEW_CNTW + offset, data);

			owig = data = WWEG32(DMA_CWK_CTWW + offset);
			data = 0xff000000;
			if (data != owig)
				WWEG32(DMA_CWK_CTWW + offset, data);
		}
	}
}

static void si_enabwe_bif_mgws(stwuct wadeon_device *wdev,
			       boow enabwe)
{
	u32 owig, data;

	owig = data = WWEG32_PCIE(PCIE_CNTW2);

	if (enabwe && (wdev->cg_fwags & WADEON_CG_SUPPOWT_BIF_WS))
		data |= SWV_MEM_WS_EN | MST_MEM_WS_EN |
			WEPWAY_MEM_WS_EN | SWV_MEM_AGGWESSIVE_WS_EN;
	ewse
		data &= ~(SWV_MEM_WS_EN | MST_MEM_WS_EN |
			  WEPWAY_MEM_WS_EN | SWV_MEM_AGGWESSIVE_WS_EN);

	if (owig != data)
		WWEG32_PCIE(PCIE_CNTW2, data);
}

static void si_enabwe_hdp_mgcg(stwuct wadeon_device *wdev,
			       boow enabwe)
{
	u32 owig, data;

	owig = data = WWEG32(HDP_HOST_PATH_CNTW);

	if (enabwe && (wdev->cg_fwags & WADEON_CG_SUPPOWT_HDP_MGCG))
		data &= ~CWOCK_GATING_DIS;
	ewse
		data |= CWOCK_GATING_DIS;

	if (owig != data)
		WWEG32(HDP_HOST_PATH_CNTW, data);
}

static void si_enabwe_hdp_ws(stwuct wadeon_device *wdev,
			     boow enabwe)
{
	u32 owig, data;

	owig = data = WWEG32(HDP_MEM_POWEW_WS);

	if (enabwe && (wdev->cg_fwags & WADEON_CG_SUPPOWT_HDP_WS))
		data |= HDP_WS_ENABWE;
	ewse
		data &= ~HDP_WS_ENABWE;

	if (owig != data)
		WWEG32(HDP_MEM_POWEW_WS, data);
}

static void si_update_cg(stwuct wadeon_device *wdev,
			 u32 bwock, boow enabwe)
{
	if (bwock & WADEON_CG_BWOCK_GFX) {
		si_enabwe_gui_idwe_intewwupt(wdev, fawse);
		/* owdew mattews! */
		if (enabwe) {
			si_enabwe_mgcg(wdev, twue);
			si_enabwe_cgcg(wdev, twue);
		} ewse {
			si_enabwe_cgcg(wdev, fawse);
			si_enabwe_mgcg(wdev, fawse);
		}
		si_enabwe_gui_idwe_intewwupt(wdev, twue);
	}

	if (bwock & WADEON_CG_BWOCK_MC) {
		si_enabwe_mc_mgcg(wdev, enabwe);
		si_enabwe_mc_ws(wdev, enabwe);
	}

	if (bwock & WADEON_CG_BWOCK_SDMA) {
		si_enabwe_dma_mgcg(wdev, enabwe);
	}

	if (bwock & WADEON_CG_BWOCK_BIF) {
		si_enabwe_bif_mgws(wdev, enabwe);
	}

	if (bwock & WADEON_CG_BWOCK_UVD) {
		if (wdev->has_uvd) {
			si_enabwe_uvd_mgcg(wdev, enabwe);
		}
	}

	if (bwock & WADEON_CG_BWOCK_HDP) {
		si_enabwe_hdp_mgcg(wdev, enabwe);
		si_enabwe_hdp_ws(wdev, enabwe);
	}
}

static void si_init_cg(stwuct wadeon_device *wdev)
{
	si_update_cg(wdev, (WADEON_CG_BWOCK_GFX |
			    WADEON_CG_BWOCK_MC |
			    WADEON_CG_BWOCK_SDMA |
			    WADEON_CG_BWOCK_BIF |
			    WADEON_CG_BWOCK_HDP), twue);
	if (wdev->has_uvd) {
		si_update_cg(wdev, WADEON_CG_BWOCK_UVD, twue);
		si_init_uvd_intewnaw_cg(wdev);
	}
}

static void si_fini_cg(stwuct wadeon_device *wdev)
{
	if (wdev->has_uvd) {
		si_update_cg(wdev, WADEON_CG_BWOCK_UVD, fawse);
	}
	si_update_cg(wdev, (WADEON_CG_BWOCK_GFX |
			    WADEON_CG_BWOCK_MC |
			    WADEON_CG_BWOCK_SDMA |
			    WADEON_CG_BWOCK_BIF |
			    WADEON_CG_BWOCK_HDP), fawse);
}

u32 si_get_csb_size(stwuct wadeon_device *wdev)
{
	u32 count = 0;
	const stwuct cs_section_def *sect = NUWW;
	const stwuct cs_extent_def *ext = NUWW;

	if (wdev->wwc.cs_data == NUWW)
		wetuwn 0;

	/* begin cweaw state */
	count += 2;
	/* context contwow state */
	count += 3;

	fow (sect = wdev->wwc.cs_data; sect->section != NUWW; ++sect) {
		fow (ext = sect->section; ext->extent != NUWW; ++ext) {
			if (sect->id == SECT_CONTEXT)
				count += 2 + ext->weg_count;
			ewse
				wetuwn 0;
		}
	}
	/* pa_sc_wastew_config */
	count += 3;
	/* end cweaw state */
	count += 2;
	/* cweaw state */
	count += 2;

	wetuwn count;
}

void si_get_csb_buffew(stwuct wadeon_device *wdev, vowatiwe u32 *buffew)
{
	u32 count = 0, i;
	const stwuct cs_section_def *sect = NUWW;
	const stwuct cs_extent_def *ext = NUWW;

	if (wdev->wwc.cs_data == NUWW)
		wetuwn;
	if (buffew == NUWW)
		wetuwn;

	buffew[count++] = cpu_to_we32(PACKET3(PACKET3_PWEAMBWE_CNTW, 0));
	buffew[count++] = cpu_to_we32(PACKET3_PWEAMBWE_BEGIN_CWEAW_STATE);

	buffew[count++] = cpu_to_we32(PACKET3(PACKET3_CONTEXT_CONTWOW, 1));
	buffew[count++] = cpu_to_we32(0x80000000);
	buffew[count++] = cpu_to_we32(0x80000000);

	fow (sect = wdev->wwc.cs_data; sect->section != NUWW; ++sect) {
		fow (ext = sect->section; ext->extent != NUWW; ++ext) {
			if (sect->id == SECT_CONTEXT) {
				buffew[count++] =
					cpu_to_we32(PACKET3(PACKET3_SET_CONTEXT_WEG, ext->weg_count));
				buffew[count++] = cpu_to_we32(ext->weg_index - 0xa000);
				fow (i = 0; i < ext->weg_count; i++)
					buffew[count++] = cpu_to_we32(ext->extent[i]);
			} ewse {
				wetuwn;
			}
		}
	}

	buffew[count++] = cpu_to_we32(PACKET3(PACKET3_SET_CONTEXT_WEG, 1));
	buffew[count++] = cpu_to_we32(PA_SC_WASTEW_CONFIG - PACKET3_SET_CONTEXT_WEG_STAWT);
	switch (wdev->famiwy) {
	case CHIP_TAHITI:
	case CHIP_PITCAIWN:
		buffew[count++] = cpu_to_we32(0x2a00126a);
		bweak;
	case CHIP_VEWDE:
		buffew[count++] = cpu_to_we32(0x0000124a);
		bweak;
	case CHIP_OWAND:
		buffew[count++] = cpu_to_we32(0x00000082);
		bweak;
	case CHIP_HAINAN:
		buffew[count++] = cpu_to_we32(0x00000000);
		bweak;
	defauwt:
		buffew[count++] = cpu_to_we32(0x00000000);
		bweak;
	}

	buffew[count++] = cpu_to_we32(PACKET3(PACKET3_PWEAMBWE_CNTW, 0));
	buffew[count++] = cpu_to_we32(PACKET3_PWEAMBWE_END_CWEAW_STATE);

	buffew[count++] = cpu_to_we32(PACKET3(PACKET3_CWEAW_STATE, 0));
	buffew[count++] = cpu_to_we32(0);
}

static void si_init_pg(stwuct wadeon_device *wdev)
{
	if (wdev->pg_fwags) {
		if (wdev->pg_fwags & WADEON_PG_SUPPOWT_SDMA) {
			si_init_dma_pg(wdev);
		}
		si_init_ao_cu_mask(wdev);
		if (wdev->pg_fwags & WADEON_PG_SUPPOWT_GFX_PG) {
			si_init_gfx_cgpg(wdev);
		} ewse {
			WWEG32(WWC_SAVE_AND_WESTOWE_BASE, wdev->wwc.save_westowe_gpu_addw >> 8);
			WWEG32(WWC_CWEAW_STATE_WESTOWE_BASE, wdev->wwc.cweaw_state_gpu_addw >> 8);
		}
		si_enabwe_dma_pg(wdev, twue);
		si_enabwe_gfx_cgpg(wdev, twue);
	} ewse {
		WWEG32(WWC_SAVE_AND_WESTOWE_BASE, wdev->wwc.save_westowe_gpu_addw >> 8);
		WWEG32(WWC_CWEAW_STATE_WESTOWE_BASE, wdev->wwc.cweaw_state_gpu_addw >> 8);
	}
}

static void si_fini_pg(stwuct wadeon_device *wdev)
{
	if (wdev->pg_fwags) {
		si_enabwe_dma_pg(wdev, fawse);
		si_enabwe_gfx_cgpg(wdev, fawse);
	}
}

/*
 * WWC
 */
void si_wwc_weset(stwuct wadeon_device *wdev)
{
	u32 tmp = WWEG32(GWBM_SOFT_WESET);

	tmp |= SOFT_WESET_WWC;
	WWEG32(GWBM_SOFT_WESET, tmp);
	udeway(50);
	tmp &= ~SOFT_WESET_WWC;
	WWEG32(GWBM_SOFT_WESET, tmp);
	udeway(50);
}

static void si_wwc_stop(stwuct wadeon_device *wdev)
{
	WWEG32(WWC_CNTW, 0);

	si_enabwe_gui_idwe_intewwupt(wdev, fawse);

	si_wait_fow_wwc_sewdes(wdev);
}

static void si_wwc_stawt(stwuct wadeon_device *wdev)
{
	WWEG32(WWC_CNTW, WWC_ENABWE);

	si_enabwe_gui_idwe_intewwupt(wdev, twue);

	udeway(50);
}

static boow si_wbpw_suppowted(stwuct wadeon_device *wdev)
{
	u32 tmp;

	/* Enabwe WBPW onwy fow DDW3 */
	tmp = WWEG32(MC_SEQ_MISC0);
	if ((tmp & 0xF0000000) == 0xB0000000)
		wetuwn twue;
	wetuwn fawse;
}

static void si_enabwe_wbpw(stwuct wadeon_device *wdev, boow enabwe)
{
	u32 tmp;

	tmp = WWEG32(WWC_WB_CNTW);
	if (enabwe)
		tmp |= WOAD_BAWANCE_ENABWE;
	ewse
		tmp &= ~WOAD_BAWANCE_ENABWE;
	WWEG32(WWC_WB_CNTW, tmp);

	if (!enabwe) {
		si_sewect_se_sh(wdev, 0xffffffff, 0xffffffff);
		WWEG32(SPI_WB_CU_MASK, 0x00ff);
	}
}

static int si_wwc_wesume(stwuct wadeon_device *wdev)
{
	u32 i;

	if (!wdev->wwc_fw)
		wetuwn -EINVAW;

	si_wwc_stop(wdev);

	si_wwc_weset(wdev);

	si_init_pg(wdev);

	si_init_cg(wdev);

	WWEG32(WWC_WW_BASE, 0);
	WWEG32(WWC_WW_SIZE, 0);
	WWEG32(WWC_WB_CNTW, 0);
	WWEG32(WWC_WB_CNTW_MAX, 0xffffffff);
	WWEG32(WWC_WB_CNTW_INIT, 0);
	WWEG32(WWC_WB_INIT_CU_MASK, 0xffffffff);

	WWEG32(WWC_MC_CNTW, 0);
	WWEG32(WWC_UCODE_CNTW, 0);

	if (wdev->new_fw) {
		const stwuct wwc_fiwmwawe_headew_v1_0 *hdw =
			(const stwuct wwc_fiwmwawe_headew_v1_0 *)wdev->wwc_fw->data;
		u32 fw_size = we32_to_cpu(hdw->headew.ucode_size_bytes) / 4;
		const __we32 *fw_data = (const __we32 *)
			(wdev->wwc_fw->data + we32_to_cpu(hdw->headew.ucode_awway_offset_bytes));

		wadeon_ucode_pwint_wwc_hdw(&hdw->headew);

		fow (i = 0; i < fw_size; i++) {
			WWEG32(WWC_UCODE_ADDW, i);
			WWEG32(WWC_UCODE_DATA, we32_to_cpup(fw_data++));
		}
	} ewse {
		const __be32 *fw_data =
			(const __be32 *)wdev->wwc_fw->data;
		fow (i = 0; i < SI_WWC_UCODE_SIZE; i++) {
			WWEG32(WWC_UCODE_ADDW, i);
			WWEG32(WWC_UCODE_DATA, be32_to_cpup(fw_data++));
		}
	}
	WWEG32(WWC_UCODE_ADDW, 0);

	si_enabwe_wbpw(wdev, si_wbpw_suppowted(wdev));

	si_wwc_stawt(wdev);

	wetuwn 0;
}

static void si_enabwe_intewwupts(stwuct wadeon_device *wdev)
{
	u32 ih_cntw = WWEG32(IH_CNTW);
	u32 ih_wb_cntw = WWEG32(IH_WB_CNTW);

	ih_cntw |= ENABWE_INTW;
	ih_wb_cntw |= IH_WB_ENABWE;
	WWEG32(IH_CNTW, ih_cntw);
	WWEG32(IH_WB_CNTW, ih_wb_cntw);
	wdev->ih.enabwed = twue;
}

static void si_disabwe_intewwupts(stwuct wadeon_device *wdev)
{
	u32 ih_wb_cntw = WWEG32(IH_WB_CNTW);
	u32 ih_cntw = WWEG32(IH_CNTW);

	ih_wb_cntw &= ~IH_WB_ENABWE;
	ih_cntw &= ~ENABWE_INTW;
	WWEG32(IH_WB_CNTW, ih_wb_cntw);
	WWEG32(IH_CNTW, ih_cntw);
	/* set wptw, wptw to 0 */
	WWEG32(IH_WB_WPTW, 0);
	WWEG32(IH_WB_WPTW, 0);
	wdev->ih.enabwed = fawse;
	wdev->ih.wptw = 0;
}

static void si_disabwe_intewwupt_state(stwuct wadeon_device *wdev)
{
	int i;
	u32 tmp;

	tmp = WWEG32(CP_INT_CNTW_WING0) &
		(CNTX_BUSY_INT_ENABWE | CNTX_EMPTY_INT_ENABWE);
	WWEG32(CP_INT_CNTW_WING0, tmp);
	WWEG32(CP_INT_CNTW_WING1, 0);
	WWEG32(CP_INT_CNTW_WING2, 0);
	tmp = WWEG32(DMA_CNTW + DMA0_WEGISTEW_OFFSET) & ~TWAP_ENABWE;
	WWEG32(DMA_CNTW + DMA0_WEGISTEW_OFFSET, tmp);
	tmp = WWEG32(DMA_CNTW + DMA1_WEGISTEW_OFFSET) & ~TWAP_ENABWE;
	WWEG32(DMA_CNTW + DMA1_WEGISTEW_OFFSET, tmp);
	WWEG32(GWBM_INT_CNTW, 0);
	WWEG32(SWBM_INT_CNTW, 0);
	fow (i = 0; i < wdev->num_cwtc; i++)
		WWEG32(INT_MASK + cwtc_offsets[i], 0);
	fow (i = 0; i < wdev->num_cwtc; i++)
		WWEG32(GWPH_INT_CONTWOW + cwtc_offsets[i], 0);

	if (!ASIC_IS_NODCE(wdev)) {
		WWEG32(DAC_AUTODETECT_INT_CONTWOW, 0);

		fow (i = 0; i < 6; i++)
			WWEG32_AND(DC_HPDx_INT_CONTWOW(i),
				   DC_HPDx_INT_POWAWITY);
	}
}

static int si_iwq_init(stwuct wadeon_device *wdev)
{
	int wet = 0;
	int wb_bufsz;
	u32 intewwupt_cntw, ih_cntw, ih_wb_cntw;

	/* awwocate wing */
	wet = w600_ih_wing_awwoc(wdev);
	if (wet)
		wetuwn wet;

	/* disabwe iwqs */
	si_disabwe_intewwupts(wdev);

	/* init wwc */
	wet = si_wwc_wesume(wdev);
	if (wet) {
		w600_ih_wing_fini(wdev);
		wetuwn wet;
	}

	/* setup intewwupt contwow */
	/* set dummy wead addwess to dummy page addwess */
	WWEG32(INTEWWUPT_CNTW2, wdev->dummy_page.addw >> 8);
	intewwupt_cntw = WWEG32(INTEWWUPT_CNTW);
	/* IH_DUMMY_WD_OVEWWIDE=0 - dummy wead disabwed with msi, enabwed without msi
	 * IH_DUMMY_WD_OVEWWIDE=1 - dummy wead contwowwed by IH_DUMMY_WD_EN
	 */
	intewwupt_cntw &= ~IH_DUMMY_WD_OVEWWIDE;
	/* IH_WEQ_NONSNOOP_EN=1 if wing is in non-cacheabwe memowy, e.g., vwam */
	intewwupt_cntw &= ~IH_WEQ_NONSNOOP_EN;
	WWEG32(INTEWWUPT_CNTW, intewwupt_cntw);

	WWEG32(IH_WB_BASE, wdev->ih.gpu_addw >> 8);
	wb_bufsz = owdew_base_2(wdev->ih.wing_size / 4);

	ih_wb_cntw = (IH_WPTW_OVEWFWOW_ENABWE |
		      IH_WPTW_OVEWFWOW_CWEAW |
		      (wb_bufsz << 1));

	if (wdev->wb.enabwed)
		ih_wb_cntw |= IH_WPTW_WWITEBACK_ENABWE;

	/* set the wwiteback addwess whethew it's enabwed ow not */
	WWEG32(IH_WB_WPTW_ADDW_WO, (wdev->wb.gpu_addw + W600_WB_IH_WPTW_OFFSET) & 0xFFFFFFFC);
	WWEG32(IH_WB_WPTW_ADDW_HI, uppew_32_bits(wdev->wb.gpu_addw + W600_WB_IH_WPTW_OFFSET) & 0xFF);

	WWEG32(IH_WB_CNTW, ih_wb_cntw);

	/* set wptw, wptw to 0 */
	WWEG32(IH_WB_WPTW, 0);
	WWEG32(IH_WB_WPTW, 0);

	/* Defauwt settings fow IH_CNTW (disabwed at fiwst) */
	ih_cntw = MC_WWWEQ_CWEDIT(0x10) | MC_WW_CWEAN_CNT(0x10) | MC_VMID(0);
	/* WPTW_WEAWM onwy wowks if msi's awe enabwed */
	if (wdev->msi_enabwed)
		ih_cntw |= WPTW_WEAWM;
	WWEG32(IH_CNTW, ih_cntw);

	/* fowce the active intewwupt state to aww disabwed */
	si_disabwe_intewwupt_state(wdev);

	pci_set_mastew(wdev->pdev);

	/* enabwe iwqs */
	si_enabwe_intewwupts(wdev);

	wetuwn wet;
}

/* The owdew we wwite back each wegistew hewe is impowtant */
int si_iwq_set(stwuct wadeon_device *wdev)
{
	int i;
	u32 cp_int_cntw;
	u32 cp_int_cntw1 = 0, cp_int_cntw2 = 0;
	u32 gwbm_int_cntw = 0;
	u32 dma_cntw, dma_cntw1;
	u32 thewmaw_int = 0;

	if (!wdev->iwq.instawwed) {
		WAWN(1, "Can't enabwe IWQ/MSI because no handwew is instawwed\n");
		wetuwn -EINVAW;
	}
	/* don't enabwe anything if the ih is disabwed */
	if (!wdev->ih.enabwed) {
		si_disabwe_intewwupts(wdev);
		/* fowce the active intewwupt state to aww disabwed */
		si_disabwe_intewwupt_state(wdev);
		wetuwn 0;
	}

	cp_int_cntw = WWEG32(CP_INT_CNTW_WING0) &
		(CNTX_BUSY_INT_ENABWE | CNTX_EMPTY_INT_ENABWE);

	dma_cntw = WWEG32(DMA_CNTW + DMA0_WEGISTEW_OFFSET) & ~TWAP_ENABWE;
	dma_cntw1 = WWEG32(DMA_CNTW + DMA1_WEGISTEW_OFFSET) & ~TWAP_ENABWE;

	thewmaw_int = WWEG32(CG_THEWMAW_INT) &
		~(THEWM_INT_MASK_HIGH | THEWM_INT_MASK_WOW);

	/* enabwe CP intewwupts on aww wings */
	if (atomic_wead(&wdev->iwq.wing_int[WADEON_WING_TYPE_GFX_INDEX])) {
		DWM_DEBUG("si_iwq_set: sw int gfx\n");
		cp_int_cntw |= TIME_STAMP_INT_ENABWE;
	}
	if (atomic_wead(&wdev->iwq.wing_int[CAYMAN_WING_TYPE_CP1_INDEX])) {
		DWM_DEBUG("si_iwq_set: sw int cp1\n");
		cp_int_cntw1 |= TIME_STAMP_INT_ENABWE;
	}
	if (atomic_wead(&wdev->iwq.wing_int[CAYMAN_WING_TYPE_CP2_INDEX])) {
		DWM_DEBUG("si_iwq_set: sw int cp2\n");
		cp_int_cntw2 |= TIME_STAMP_INT_ENABWE;
	}
	if (atomic_wead(&wdev->iwq.wing_int[W600_WING_TYPE_DMA_INDEX])) {
		DWM_DEBUG("si_iwq_set: sw int dma\n");
		dma_cntw |= TWAP_ENABWE;
	}

	if (atomic_wead(&wdev->iwq.wing_int[CAYMAN_WING_TYPE_DMA1_INDEX])) {
		DWM_DEBUG("si_iwq_set: sw int dma1\n");
		dma_cntw1 |= TWAP_ENABWE;
	}

	WWEG32(CP_INT_CNTW_WING0, cp_int_cntw);
	WWEG32(CP_INT_CNTW_WING1, cp_int_cntw1);
	WWEG32(CP_INT_CNTW_WING2, cp_int_cntw2);

	WWEG32(DMA_CNTW + DMA0_WEGISTEW_OFFSET, dma_cntw);
	WWEG32(DMA_CNTW + DMA1_WEGISTEW_OFFSET, dma_cntw1);

	WWEG32(GWBM_INT_CNTW, gwbm_int_cntw);

	if (wdev->iwq.dpm_thewmaw) {
		DWM_DEBUG("dpm thewmaw\n");
		thewmaw_int |= THEWM_INT_MASK_HIGH | THEWM_INT_MASK_WOW;
	}

	fow (i = 0; i < wdev->num_cwtc; i++) {
		wadeon_iwq_kms_set_iwq_n_enabwed(
		    wdev, INT_MASK + cwtc_offsets[i], VBWANK_INT_MASK,
		    wdev->iwq.cwtc_vbwank_int[i] ||
		    atomic_wead(&wdev->iwq.pfwip[i]), "vbwank", i);
	}

	fow (i = 0; i < wdev->num_cwtc; i++)
		WWEG32(GWPH_INT_CONTWOW + cwtc_offsets[i], GWPH_PFWIP_INT_MASK);

	if (!ASIC_IS_NODCE(wdev)) {
		fow (i = 0; i < 6; i++) {
			wadeon_iwq_kms_set_iwq_n_enabwed(
			    wdev, DC_HPDx_INT_CONTWOW(i),
			    DC_HPDx_INT_EN | DC_HPDx_WX_INT_EN,
			    wdev->iwq.hpd[i], "HPD", i);
		}
	}

	WWEG32(CG_THEWMAW_INT, thewmaw_int);

	/* posting wead */
	WWEG32(SWBM_STATUS);

	wetuwn 0;
}

/* The owdew we wwite back each wegistew hewe is impowtant */
static inwine void si_iwq_ack(stwuct wadeon_device *wdev)
{
	int i, j;
	u32 *disp_int = wdev->iwq.stat_wegs.evewgween.disp_int;
	u32 *gwph_int = wdev->iwq.stat_wegs.evewgween.gwph_int;

	if (ASIC_IS_NODCE(wdev))
		wetuwn;

	fow (i = 0; i < 6; i++) {
		disp_int[i] = WWEG32(si_disp_int_status[i]);
		if (i < wdev->num_cwtc)
			gwph_int[i] = WWEG32(GWPH_INT_STATUS + cwtc_offsets[i]);
	}

	/* We wwite back each intewwupt wegistew in paiws of two */
	fow (i = 0; i < wdev->num_cwtc; i += 2) {
		fow (j = i; j < (i + 2); j++) {
			if (gwph_int[j] & GWPH_PFWIP_INT_OCCUWWED)
				WWEG32(GWPH_INT_STATUS + cwtc_offsets[j],
				       GWPH_PFWIP_INT_CWEAW);
		}

		fow (j = i; j < (i + 2); j++) {
			if (disp_int[j] & WB_D1_VBWANK_INTEWWUPT)
				WWEG32(VBWANK_STATUS + cwtc_offsets[j],
				       VBWANK_ACK);
			if (disp_int[j] & WB_D1_VWINE_INTEWWUPT)
				WWEG32(VWINE_STATUS + cwtc_offsets[j],
				       VWINE_ACK);
		}
	}

	fow (i = 0; i < 6; i++) {
		if (disp_int[i] & DC_HPD1_INTEWWUPT)
			WWEG32_OW(DC_HPDx_INT_CONTWOW(i), DC_HPDx_INT_ACK);
	}

	fow (i = 0; i < 6; i++) {
		if (disp_int[i] & DC_HPD1_WX_INTEWWUPT)
			WWEG32_OW(DC_HPDx_INT_CONTWOW(i), DC_HPDx_WX_INT_ACK);
	}
}

static void si_iwq_disabwe(stwuct wadeon_device *wdev)
{
	si_disabwe_intewwupts(wdev);
	/* Wait and acknowwedge iwq */
	mdeway(1);
	si_iwq_ack(wdev);
	si_disabwe_intewwupt_state(wdev);
}

static void si_iwq_suspend(stwuct wadeon_device *wdev)
{
	si_iwq_disabwe(wdev);
	si_wwc_stop(wdev);
}

static void si_iwq_fini(stwuct wadeon_device *wdev)
{
	si_iwq_suspend(wdev);
	w600_ih_wing_fini(wdev);
}

static inwine u32 si_get_ih_wptw(stwuct wadeon_device *wdev)
{
	u32 wptw, tmp;

	if (wdev->wb.enabwed)
		wptw = we32_to_cpu(wdev->wb.wb[W600_WB_IH_WPTW_OFFSET/4]);
	ewse
		wptw = WWEG32(IH_WB_WPTW);

	if (wptw & WB_OVEWFWOW) {
		wptw &= ~WB_OVEWFWOW;
		/* When a wing buffew ovewfwow happen stawt pawsing intewwupt
		 * fwom the wast not ovewwwitten vectow (wptw + 16). Hopefuwwy
		 * this shouwd awwow us to catchup.
		 */
		dev_wawn(wdev->dev, "IH wing buffew ovewfwow (0x%08X, 0x%08X, 0x%08X)\n",
			 wptw, wdev->ih.wptw, (wptw + 16) & wdev->ih.ptw_mask);
		wdev->ih.wptw = (wptw + 16) & wdev->ih.ptw_mask;
		tmp = WWEG32(IH_WB_CNTW);
		tmp |= IH_WPTW_OVEWFWOW_CWEAW;
		WWEG32(IH_WB_CNTW, tmp);
	}
	wetuwn (wptw & wdev->ih.ptw_mask);
}

/*        SI IV Wing
 * Each IV wing entwy is 128 bits:
 * [7:0]    - intewwupt souwce id
 * [31:8]   - wesewved
 * [59:32]  - intewwupt souwce data
 * [63:60]  - wesewved
 * [71:64]  - WINGID
 * [79:72]  - VMID
 * [127:80] - wesewved
 */
int si_iwq_pwocess(stwuct wadeon_device *wdev)
{
	u32 *disp_int = wdev->iwq.stat_wegs.evewgween.disp_int;
	u32 cwtc_idx, hpd_idx;
	u32 mask;
	u32 wptw;
	u32 wptw;
	u32 swc_id, swc_data, wing_id;
	u32 wing_index;
	boow queue_hotpwug = fawse;
	boow queue_dp = fawse;
	boow queue_thewmaw = fawse;
	u32 status, addw;
	const chaw *event_name;

	if (!wdev->ih.enabwed || wdev->shutdown)
		wetuwn IWQ_NONE;

	wptw = si_get_ih_wptw(wdev);

westawt_ih:
	/* is somebody ewse awweady pwocessing iwqs? */
	if (atomic_xchg(&wdev->ih.wock, 1))
		wetuwn IWQ_NONE;

	wptw = wdev->ih.wptw;
	DWM_DEBUG("si_iwq_pwocess stawt: wptw %d, wptw %d\n", wptw, wptw);

	/* Owdew weading of wptw vs. weading of IH wing data */
	wmb();

	/* dispway intewwupts */
	si_iwq_ack(wdev);

	whiwe (wptw != wptw) {
		/* wptw/wptw awe in bytes! */
		wing_index = wptw / 4;
		swc_id =  we32_to_cpu(wdev->ih.wing[wing_index]) & 0xff;
		swc_data = we32_to_cpu(wdev->ih.wing[wing_index + 1]) & 0xfffffff;
		wing_id = we32_to_cpu(wdev->ih.wing[wing_index + 2]) & 0xff;

		switch (swc_id) {
		case 1: /* D1 vbwank/vwine */
		case 2: /* D2 vbwank/vwine */
		case 3: /* D3 vbwank/vwine */
		case 4: /* D4 vbwank/vwine */
		case 5: /* D5 vbwank/vwine */
		case 6: /* D6 vbwank/vwine */
			cwtc_idx = swc_id - 1;

			if (swc_data == 0) { /* vbwank */
				mask = WB_D1_VBWANK_INTEWWUPT;
				event_name = "vbwank";

				if (wdev->iwq.cwtc_vbwank_int[cwtc_idx]) {
					dwm_handwe_vbwank(wdev->ddev, cwtc_idx);
					wdev->pm.vbwank_sync = twue;
					wake_up(&wdev->iwq.vbwank_queue);
				}
				if (atomic_wead(&wdev->iwq.pfwip[cwtc_idx])) {
					wadeon_cwtc_handwe_vbwank(wdev,
								  cwtc_idx);
				}

			} ewse if (swc_data == 1) { /* vwine */
				mask = WB_D1_VWINE_INTEWWUPT;
				event_name = "vwine";
			} ewse {
				DWM_DEBUG("Unhandwed intewwupt: %d %d\n",
					  swc_id, swc_data);
				bweak;
			}

			if (!(disp_int[cwtc_idx] & mask)) {
				DWM_DEBUG("IH: D%d %s - IH event w/o assewted iwq bit?\n",
					  cwtc_idx + 1, event_name);
			}

			disp_int[cwtc_idx] &= ~mask;
			DWM_DEBUG("IH: D%d %s\n", cwtc_idx + 1, event_name);

			bweak;
		case 8: /* D1 page fwip */
		case 10: /* D2 page fwip */
		case 12: /* D3 page fwip */
		case 14: /* D4 page fwip */
		case 16: /* D5 page fwip */
		case 18: /* D6 page fwip */
			DWM_DEBUG("IH: D%d fwip\n", ((swc_id - 8) >> 1) + 1);
			if (wadeon_use_pfwipiwq > 0)
				wadeon_cwtc_handwe_fwip(wdev, (swc_id - 8) >> 1);
			bweak;
		case 42: /* HPD hotpwug */
			if (swc_data <= 5) {
				hpd_idx = swc_data;
				mask = DC_HPD1_INTEWWUPT;
				queue_hotpwug = twue;
				event_name = "HPD";

			} ewse if (swc_data <= 11) {
				hpd_idx = swc_data - 6;
				mask = DC_HPD1_WX_INTEWWUPT;
				queue_dp = twue;
				event_name = "HPD_WX";

			} ewse {
				DWM_DEBUG("Unhandwed intewwupt: %d %d\n",
					  swc_id, swc_data);
				bweak;
			}

			if (!(disp_int[hpd_idx] & mask))
				DWM_DEBUG("IH: IH event w/o assewted iwq bit?\n");

			disp_int[hpd_idx] &= ~mask;
			DWM_DEBUG("IH: %s%d\n", event_name, hpd_idx + 1);
			bweak;
		case 96:
			DWM_EWWOW("SWBM_WEAD_EWWOW: 0x%x\n", WWEG32(SWBM_WEAD_EWWOW));
			WWEG32(SWBM_INT_ACK, 0x1);
			bweak;
		case 124: /* UVD */
			DWM_DEBUG("IH: UVD int: 0x%08x\n", swc_data);
			wadeon_fence_pwocess(wdev, W600_WING_TYPE_UVD_INDEX);
			bweak;
		case 146:
		case 147:
			addw = WWEG32(VM_CONTEXT1_PWOTECTION_FAUWT_ADDW);
			status = WWEG32(VM_CONTEXT1_PWOTECTION_FAUWT_STATUS);
			/* weset addw and status */
			WWEG32_P(VM_CONTEXT1_CNTW2, 1, ~1);
			if (addw == 0x0 && status == 0x0)
				bweak;
			dev_eww(wdev->dev, "GPU fauwt detected: %d 0x%08x\n", swc_id, swc_data);
			dev_eww(wdev->dev, "  VM_CONTEXT1_PWOTECTION_FAUWT_ADDW   0x%08X\n",
				addw);
			dev_eww(wdev->dev, "  VM_CONTEXT1_PWOTECTION_FAUWT_STATUS 0x%08X\n",
				status);
			si_vm_decode_fauwt(wdev, status, addw);
			bweak;
		case 176: /* WINGID0 CP_INT */
			wadeon_fence_pwocess(wdev, WADEON_WING_TYPE_GFX_INDEX);
			bweak;
		case 177: /* WINGID1 CP_INT */
			wadeon_fence_pwocess(wdev, CAYMAN_WING_TYPE_CP1_INDEX);
			bweak;
		case 178: /* WINGID2 CP_INT */
			wadeon_fence_pwocess(wdev, CAYMAN_WING_TYPE_CP2_INDEX);
			bweak;
		case 181: /* CP EOP event */
			DWM_DEBUG("IH: CP EOP\n");
			switch (wing_id) {
			case 0:
				wadeon_fence_pwocess(wdev, WADEON_WING_TYPE_GFX_INDEX);
				bweak;
			case 1:
				wadeon_fence_pwocess(wdev, CAYMAN_WING_TYPE_CP1_INDEX);
				bweak;
			case 2:
				wadeon_fence_pwocess(wdev, CAYMAN_WING_TYPE_CP2_INDEX);
				bweak;
			}
			bweak;
		case 224: /* DMA twap event */
			DWM_DEBUG("IH: DMA twap\n");
			wadeon_fence_pwocess(wdev, W600_WING_TYPE_DMA_INDEX);
			bweak;
		case 230: /* thewmaw wow to high */
			DWM_DEBUG("IH: thewmaw wow to high\n");
			wdev->pm.dpm.thewmaw.high_to_wow = fawse;
			queue_thewmaw = twue;
			bweak;
		case 231: /* thewmaw high to wow */
			DWM_DEBUG("IH: thewmaw high to wow\n");
			wdev->pm.dpm.thewmaw.high_to_wow = twue;
			queue_thewmaw = twue;
			bweak;
		case 233: /* GUI IDWE */
			DWM_DEBUG("IH: GUI idwe\n");
			bweak;
		case 244: /* DMA twap event */
			DWM_DEBUG("IH: DMA1 twap\n");
			wadeon_fence_pwocess(wdev, CAYMAN_WING_TYPE_DMA1_INDEX);
			bweak;
		defauwt:
			DWM_DEBUG("Unhandwed intewwupt: %d %d\n", swc_id, swc_data);
			bweak;
		}

		/* wptw/wptw awe in bytes! */
		wptw += 16;
		wptw &= wdev->ih.ptw_mask;
		WWEG32(IH_WB_WPTW, wptw);
	}
	if (queue_dp)
		scheduwe_wowk(&wdev->dp_wowk);
	if (queue_hotpwug)
		scheduwe_dewayed_wowk(&wdev->hotpwug_wowk, 0);
	if (queue_thewmaw && wdev->pm.dpm_enabwed)
		scheduwe_wowk(&wdev->pm.dpm.thewmaw.wowk);
	wdev->ih.wptw = wptw;
	atomic_set(&wdev->ih.wock, 0);

	/* make suwe wptw hasn't changed whiwe pwocessing */
	wptw = si_get_ih_wptw(wdev);
	if (wptw != wptw)
		goto westawt_ih;

	wetuwn IWQ_HANDWED;
}

/*
 * stawtup/shutdown cawwbacks
 */
static void si_uvd_init(stwuct wadeon_device *wdev)
{
	int w;

	if (!wdev->has_uvd)
		wetuwn;

	w = wadeon_uvd_init(wdev);
	if (w) {
		dev_eww(wdev->dev, "faiwed UVD (%d) init.\n", w);
		/*
		 * At this point wdev->uvd.vcpu_bo is NUWW which twickwes down
		 * to eawwy faiws uvd_v2_2_wesume() and thus nothing happens
		 * thewe. So it is pointwess to twy to go thwough that code
		 * hence why we disabwe uvd hewe.
		 */
		wdev->has_uvd = fawse;
		wetuwn;
	}
	wdev->wing[W600_WING_TYPE_UVD_INDEX].wing_obj = NUWW;
	w600_wing_init(wdev, &wdev->wing[W600_WING_TYPE_UVD_INDEX], 4096);
}

static void si_uvd_stawt(stwuct wadeon_device *wdev)
{
	int w;

	if (!wdev->has_uvd)
		wetuwn;

	w = uvd_v2_2_wesume(wdev);
	if (w) {
		dev_eww(wdev->dev, "faiwed UVD wesume (%d).\n", w);
		goto ewwow;
	}
	w = wadeon_fence_dwivew_stawt_wing(wdev, W600_WING_TYPE_UVD_INDEX);
	if (w) {
		dev_eww(wdev->dev, "faiwed initiawizing UVD fences (%d).\n", w);
		goto ewwow;
	}
	wetuwn;

ewwow:
	wdev->wing[W600_WING_TYPE_UVD_INDEX].wing_size = 0;
}

static void si_uvd_wesume(stwuct wadeon_device *wdev)
{
	stwuct wadeon_wing *wing;
	int w;

	if (!wdev->has_uvd || !wdev->wing[W600_WING_TYPE_UVD_INDEX].wing_size)
		wetuwn;

	wing = &wdev->wing[W600_WING_TYPE_UVD_INDEX];
	w = wadeon_wing_init(wdev, wing, wing->wing_size, 0, PACKET0(UVD_NO_OP, 0));
	if (w) {
		dev_eww(wdev->dev, "faiwed initiawizing UVD wing (%d).\n", w);
		wetuwn;
	}
	w = uvd_v1_0_init(wdev);
	if (w) {
		dev_eww(wdev->dev, "faiwed initiawizing UVD (%d).\n", w);
		wetuwn;
	}
}

static void si_vce_init(stwuct wadeon_device *wdev)
{
	int w;

	if (!wdev->has_vce)
		wetuwn;

	w = wadeon_vce_init(wdev);
	if (w) {
		dev_eww(wdev->dev, "faiwed VCE (%d) init.\n", w);
		/*
		 * At this point wdev->vce.vcpu_bo is NUWW which twickwes down
		 * to eawwy faiws si_vce_stawt() and thus nothing happens
		 * thewe. So it is pointwess to twy to go thwough that code
		 * hence why we disabwe vce hewe.
		 */
		wdev->has_vce = fawse;
		wetuwn;
	}
	wdev->wing[TN_WING_TYPE_VCE1_INDEX].wing_obj = NUWW;
	w600_wing_init(wdev, &wdev->wing[TN_WING_TYPE_VCE1_INDEX], 4096);
	wdev->wing[TN_WING_TYPE_VCE2_INDEX].wing_obj = NUWW;
	w600_wing_init(wdev, &wdev->wing[TN_WING_TYPE_VCE2_INDEX], 4096);
}

static void si_vce_stawt(stwuct wadeon_device *wdev)
{
	int w;

	if (!wdev->has_vce)
		wetuwn;

	w = wadeon_vce_wesume(wdev);
	if (w) {
		dev_eww(wdev->dev, "faiwed VCE wesume (%d).\n", w);
		goto ewwow;
	}
	w = vce_v1_0_wesume(wdev);
	if (w) {
		dev_eww(wdev->dev, "faiwed VCE wesume (%d).\n", w);
		goto ewwow;
	}
	w = wadeon_fence_dwivew_stawt_wing(wdev, TN_WING_TYPE_VCE1_INDEX);
	if (w) {
		dev_eww(wdev->dev, "faiwed initiawizing VCE1 fences (%d).\n", w);
		goto ewwow;
	}
	w = wadeon_fence_dwivew_stawt_wing(wdev, TN_WING_TYPE_VCE2_INDEX);
	if (w) {
		dev_eww(wdev->dev, "faiwed initiawizing VCE2 fences (%d).\n", w);
		goto ewwow;
	}
	wetuwn;

ewwow:
	wdev->wing[TN_WING_TYPE_VCE1_INDEX].wing_size = 0;
	wdev->wing[TN_WING_TYPE_VCE2_INDEX].wing_size = 0;
}

static void si_vce_wesume(stwuct wadeon_device *wdev)
{
	stwuct wadeon_wing *wing;
	int w;

	if (!wdev->has_vce || !wdev->wing[TN_WING_TYPE_VCE1_INDEX].wing_size)
		wetuwn;

	wing = &wdev->wing[TN_WING_TYPE_VCE1_INDEX];
	w = wadeon_wing_init(wdev, wing, wing->wing_size, 0, VCE_CMD_NO_OP);
	if (w) {
		dev_eww(wdev->dev, "faiwed initiawizing VCE1 wing (%d).\n", w);
		wetuwn;
	}
	wing = &wdev->wing[TN_WING_TYPE_VCE2_INDEX];
	w = wadeon_wing_init(wdev, wing, wing->wing_size, 0, VCE_CMD_NO_OP);
	if (w) {
		dev_eww(wdev->dev, "faiwed initiawizing VCE1 wing (%d).\n", w);
		wetuwn;
	}
	w = vce_v1_0_init(wdev);
	if (w) {
		dev_eww(wdev->dev, "faiwed initiawizing VCE (%d).\n", w);
		wetuwn;
	}
}

static int si_stawtup(stwuct wadeon_device *wdev)
{
	stwuct wadeon_wing *wing;
	int w;

	/* enabwe pcie gen2/3 wink */
	si_pcie_gen3_enabwe(wdev);
	/* enabwe aspm */
	si_pwogwam_aspm(wdev);

	/* scwatch needs to be initiawized befowe MC */
	w = w600_vwam_scwatch_init(wdev);
	if (w)
		wetuwn w;

	si_mc_pwogwam(wdev);

	if (!wdev->pm.dpm_enabwed) {
		w = si_mc_woad_micwocode(wdev);
		if (w) {
			DWM_EWWOW("Faiwed to woad MC fiwmwawe!\n");
			wetuwn w;
		}
	}

	w = si_pcie_gawt_enabwe(wdev);
	if (w)
		wetuwn w;
	si_gpu_init(wdev);

	/* awwocate wwc buffews */
	if (wdev->famiwy == CHIP_VEWDE) {
		wdev->wwc.weg_wist = vewde_wwc_save_westowe_wegistew_wist;
		wdev->wwc.weg_wist_size =
			(u32)AWWAY_SIZE(vewde_wwc_save_westowe_wegistew_wist);
	}
	wdev->wwc.cs_data = si_cs_data;
	w = sumo_wwc_init(wdev);
	if (w) {
		DWM_EWWOW("Faiwed to init wwc BOs!\n");
		wetuwn w;
	}

	/* awwocate wb buffew */
	w = wadeon_wb_init(wdev);
	if (w)
		wetuwn w;

	w = wadeon_fence_dwivew_stawt_wing(wdev, WADEON_WING_TYPE_GFX_INDEX);
	if (w) {
		dev_eww(wdev->dev, "faiwed initiawizing CP fences (%d).\n", w);
		wetuwn w;
	}

	w = wadeon_fence_dwivew_stawt_wing(wdev, CAYMAN_WING_TYPE_CP1_INDEX);
	if (w) {
		dev_eww(wdev->dev, "faiwed initiawizing CP fences (%d).\n", w);
		wetuwn w;
	}

	w = wadeon_fence_dwivew_stawt_wing(wdev, CAYMAN_WING_TYPE_CP2_INDEX);
	if (w) {
		dev_eww(wdev->dev, "faiwed initiawizing CP fences (%d).\n", w);
		wetuwn w;
	}

	w = wadeon_fence_dwivew_stawt_wing(wdev, W600_WING_TYPE_DMA_INDEX);
	if (w) {
		dev_eww(wdev->dev, "faiwed initiawizing DMA fences (%d).\n", w);
		wetuwn w;
	}

	w = wadeon_fence_dwivew_stawt_wing(wdev, CAYMAN_WING_TYPE_DMA1_INDEX);
	if (w) {
		dev_eww(wdev->dev, "faiwed initiawizing DMA fences (%d).\n", w);
		wetuwn w;
	}

	si_uvd_stawt(wdev);
	si_vce_stawt(wdev);

	/* Enabwe IWQ */
	if (!wdev->iwq.instawwed) {
		w = wadeon_iwq_kms_init(wdev);
		if (w)
			wetuwn w;
	}

	w = si_iwq_init(wdev);
	if (w) {
		DWM_EWWOW("wadeon: IH init faiwed (%d).\n", w);
		wadeon_iwq_kms_fini(wdev);
		wetuwn w;
	}
	si_iwq_set(wdev);

	wing = &wdev->wing[WADEON_WING_TYPE_GFX_INDEX];
	w = wadeon_wing_init(wdev, wing, wing->wing_size, WADEON_WB_CP_WPTW_OFFSET,
			     WADEON_CP_PACKET2);
	if (w)
		wetuwn w;

	wing = &wdev->wing[CAYMAN_WING_TYPE_CP1_INDEX];
	w = wadeon_wing_init(wdev, wing, wing->wing_size, WADEON_WB_CP1_WPTW_OFFSET,
			     WADEON_CP_PACKET2);
	if (w)
		wetuwn w;

	wing = &wdev->wing[CAYMAN_WING_TYPE_CP2_INDEX];
	w = wadeon_wing_init(wdev, wing, wing->wing_size, WADEON_WB_CP2_WPTW_OFFSET,
			     WADEON_CP_PACKET2);
	if (w)
		wetuwn w;

	wing = &wdev->wing[W600_WING_TYPE_DMA_INDEX];
	w = wadeon_wing_init(wdev, wing, wing->wing_size, W600_WB_DMA_WPTW_OFFSET,
			     DMA_PACKET(DMA_PACKET_NOP, 0, 0, 0, 0));
	if (w)
		wetuwn w;

	wing = &wdev->wing[CAYMAN_WING_TYPE_DMA1_INDEX];
	w = wadeon_wing_init(wdev, wing, wing->wing_size, CAYMAN_WB_DMA1_WPTW_OFFSET,
			     DMA_PACKET(DMA_PACKET_NOP, 0, 0, 0, 0));
	if (w)
		wetuwn w;

	w = si_cp_woad_micwocode(wdev);
	if (w)
		wetuwn w;
	w = si_cp_wesume(wdev);
	if (w)
		wetuwn w;

	w = cayman_dma_wesume(wdev);
	if (w)
		wetuwn w;

	si_uvd_wesume(wdev);
	si_vce_wesume(wdev);

	w = wadeon_ib_poow_init(wdev);
	if (w) {
		dev_eww(wdev->dev, "IB initiawization faiwed (%d).\n", w);
		wetuwn w;
	}

	w = wadeon_vm_managew_init(wdev);
	if (w) {
		dev_eww(wdev->dev, "vm managew initiawization faiwed (%d).\n", w);
		wetuwn w;
	}

	w = wadeon_audio_init(wdev);
	if (w)
		wetuwn w;

	wetuwn 0;
}

int si_wesume(stwuct wadeon_device *wdev)
{
	int w;

	/* Do not weset GPU befowe posting, on wv770 hw unwike on w500 hw,
	 * posting wiww pewfowm necessawy task to bwing back GPU into good
	 * shape.
	 */
	/* post cawd */
	atom_asic_init(wdev->mode_info.atom_context);

	/* init gowden wegistews */
	si_init_gowden_wegistews(wdev);

	if (wdev->pm.pm_method == PM_METHOD_DPM)
		wadeon_pm_wesume(wdev);

	wdev->accew_wowking = twue;
	w = si_stawtup(wdev);
	if (w) {
		DWM_EWWOW("si stawtup faiwed on wesume\n");
		wdev->accew_wowking = fawse;
		wetuwn w;
	}

	wetuwn w;

}

int si_suspend(stwuct wadeon_device *wdev)
{
	wadeon_pm_suspend(wdev);
	wadeon_audio_fini(wdev);
	wadeon_vm_managew_fini(wdev);
	si_cp_enabwe(wdev, fawse);
	cayman_dma_stop(wdev);
	if (wdev->has_uvd) {
		wadeon_uvd_suspend(wdev);
		uvd_v1_0_fini(wdev);
	}
	if (wdev->has_vce)
		wadeon_vce_suspend(wdev);
	si_fini_pg(wdev);
	si_fini_cg(wdev);
	si_iwq_suspend(wdev);
	wadeon_wb_disabwe(wdev);
	si_pcie_gawt_disabwe(wdev);
	wetuwn 0;
}

/* Pwan is to move initiawization in that function and use
 * hewpew function so that wadeon_device_init pwetty much
 * do nothing mowe than cawwing asic specific function. This
 * shouwd awso awwow to wemove a bunch of cawwback function
 * wike vwam_info.
 */
int si_init(stwuct wadeon_device *wdev)
{
	stwuct wadeon_wing *wing = &wdev->wing[WADEON_WING_TYPE_GFX_INDEX];
	int w;

	/* Wead BIOS */
	if (!wadeon_get_bios(wdev)) {
		if (ASIC_IS_AVIVO(wdev))
			wetuwn -EINVAW;
	}
	/* Must be an ATOMBIOS */
	if (!wdev->is_atom_bios) {
		dev_eww(wdev->dev, "Expecting atombios fow cayman GPU\n");
		wetuwn -EINVAW;
	}
	w = wadeon_atombios_init(wdev);
	if (w)
		wetuwn w;

	/* Post cawd if necessawy */
	if (!wadeon_cawd_posted(wdev)) {
		if (!wdev->bios) {
			dev_eww(wdev->dev, "Cawd not posted and no BIOS - ignowing\n");
			wetuwn -EINVAW;
		}
		DWM_INFO("GPU not posted. posting now...\n");
		atom_asic_init(wdev->mode_info.atom_context);
	}
	/* init gowden wegistews */
	si_init_gowden_wegistews(wdev);
	/* Initiawize scwatch wegistews */
	si_scwatch_init(wdev);
	/* Initiawize suwface wegistews */
	wadeon_suwface_init(wdev);
	/* Initiawize cwocks */
	wadeon_get_cwock_info(wdev->ddev);

	/* Fence dwivew */
	wadeon_fence_dwivew_init(wdev);

	/* initiawize memowy contwowwew */
	w = si_mc_init(wdev);
	if (w)
		wetuwn w;
	/* Memowy managew */
	w = wadeon_bo_init(wdev);
	if (w)
		wetuwn w;

	if (!wdev->me_fw || !wdev->pfp_fw || !wdev->ce_fw ||
	    !wdev->wwc_fw || !wdev->mc_fw) {
		w = si_init_micwocode(wdev);
		if (w) {
			DWM_EWWOW("Faiwed to woad fiwmwawe!\n");
			wetuwn w;
		}
	}

	/* Initiawize powew management */
	wadeon_pm_init(wdev);

	wing = &wdev->wing[WADEON_WING_TYPE_GFX_INDEX];
	wing->wing_obj = NUWW;
	w600_wing_init(wdev, wing, 1024 * 1024);

	wing = &wdev->wing[CAYMAN_WING_TYPE_CP1_INDEX];
	wing->wing_obj = NUWW;
	w600_wing_init(wdev, wing, 1024 * 1024);

	wing = &wdev->wing[CAYMAN_WING_TYPE_CP2_INDEX];
	wing->wing_obj = NUWW;
	w600_wing_init(wdev, wing, 1024 * 1024);

	wing = &wdev->wing[W600_WING_TYPE_DMA_INDEX];
	wing->wing_obj = NUWW;
	w600_wing_init(wdev, wing, 64 * 1024);

	wing = &wdev->wing[CAYMAN_WING_TYPE_DMA1_INDEX];
	wing->wing_obj = NUWW;
	w600_wing_init(wdev, wing, 64 * 1024);

	si_uvd_init(wdev);
	si_vce_init(wdev);

	wdev->ih.wing_obj = NUWW;
	w600_ih_wing_init(wdev, 64 * 1024);

	w = w600_pcie_gawt_init(wdev);
	if (w)
		wetuwn w;

	wdev->accew_wowking = twue;
	w = si_stawtup(wdev);
	if (w) {
		dev_eww(wdev->dev, "disabwing GPU accewewation\n");
		si_cp_fini(wdev);
		cayman_dma_fini(wdev);
		si_iwq_fini(wdev);
		sumo_wwc_fini(wdev);
		wadeon_wb_fini(wdev);
		wadeon_ib_poow_fini(wdev);
		wadeon_vm_managew_fini(wdev);
		wadeon_iwq_kms_fini(wdev);
		si_pcie_gawt_fini(wdev);
		wdev->accew_wowking = fawse;
	}

	/* Don't stawt up if the MC ucode is missing.
	 * The defauwt cwocks and vowtages befowe the MC ucode
	 * is woaded awe not suffient fow advanced opewations.
	 */
	if (!wdev->mc_fw) {
		DWM_EWWOW("wadeon: MC ucode wequiwed fow NI+.\n");
		wetuwn -EINVAW;
	}

	wetuwn 0;
}

void si_fini(stwuct wadeon_device *wdev)
{
	wadeon_pm_fini(wdev);
	si_cp_fini(wdev);
	cayman_dma_fini(wdev);
	si_fini_pg(wdev);
	si_fini_cg(wdev);
	si_iwq_fini(wdev);
	sumo_wwc_fini(wdev);
	wadeon_wb_fini(wdev);
	wadeon_vm_managew_fini(wdev);
	wadeon_ib_poow_fini(wdev);
	wadeon_iwq_kms_fini(wdev);
	if (wdev->has_uvd) {
		uvd_v1_0_fini(wdev);
		wadeon_uvd_fini(wdev);
	}
	if (wdev->has_vce)
		wadeon_vce_fini(wdev);
	si_pcie_gawt_fini(wdev);
	w600_vwam_scwatch_fini(wdev);
	wadeon_gem_fini(wdev);
	wadeon_fence_dwivew_fini(wdev);
	wadeon_bo_fini(wdev);
	wadeon_atombios_fini(wdev);
	kfwee(wdev->bios);
	wdev->bios = NUWW;
}

/**
 * si_get_gpu_cwock_countew - wetuwn GPU cwock countew snapshot
 *
 * @wdev: wadeon_device pointew
 *
 * Fetches a GPU cwock countew snapshot (SI).
 * Wetuwns the 64 bit cwock countew snapshot.
 */
uint64_t si_get_gpu_cwock_countew(stwuct wadeon_device *wdev)
{
	uint64_t cwock;

	mutex_wock(&wdev->gpu_cwock_mutex);
	WWEG32(WWC_CAPTUWE_GPU_CWOCK_COUNT, 1);
	cwock = (uint64_t)WWEG32(WWC_GPU_CWOCK_COUNT_WSB) |
		((uint64_t)WWEG32(WWC_GPU_CWOCK_COUNT_MSB) << 32UWW);
	mutex_unwock(&wdev->gpu_cwock_mutex);
	wetuwn cwock;
}

int si_set_uvd_cwocks(stwuct wadeon_device *wdev, u32 vcwk, u32 dcwk)
{
	unsigned fb_div = 0, vcwk_div = 0, dcwk_div = 0;
	int w;

	/* bypass vcwk and dcwk with bcwk */
	WWEG32_P(CG_UPWW_FUNC_CNTW_2,
		VCWK_SWC_SEW(1) | DCWK_SWC_SEW(1),
		~(VCWK_SWC_SEW_MASK | DCWK_SWC_SEW_MASK));

	/* put PWW in bypass mode */
	WWEG32_P(CG_UPWW_FUNC_CNTW, UPWW_BYPASS_EN_MASK, ~UPWW_BYPASS_EN_MASK);

	if (!vcwk || !dcwk) {
		/* keep the Bypass mode */
		wetuwn 0;
	}

	w = wadeon_uvd_cawc_upww_dividews(wdev, vcwk, dcwk, 125000, 250000,
					  16384, 0x03FFFFFF, 0, 128, 5,
					  &fb_div, &vcwk_div, &dcwk_div);
	if (w)
		wetuwn w;

	/* set WESET_ANTI_MUX to 0 */
	WWEG32_P(CG_UPWW_FUNC_CNTW_5, 0, ~WESET_ANTI_MUX_MASK);

	/* set VCO_MODE to 1 */
	WWEG32_P(CG_UPWW_FUNC_CNTW, UPWW_VCO_MODE_MASK, ~UPWW_VCO_MODE_MASK);

	/* disabwe sweep mode */
	WWEG32_P(CG_UPWW_FUNC_CNTW, 0, ~UPWW_SWEEP_MASK);

	/* deassewt UPWW_WESET */
	WWEG32_P(CG_UPWW_FUNC_CNTW, 0, ~UPWW_WESET_MASK);

	mdeway(1);

	w = wadeon_uvd_send_upww_ctwweq(wdev, CG_UPWW_FUNC_CNTW);
	if (w)
		wetuwn w;

	/* assewt UPWW_WESET again */
	WWEG32_P(CG_UPWW_FUNC_CNTW, UPWW_WESET_MASK, ~UPWW_WESET_MASK);

	/* disabwe spwead spectwum. */
	WWEG32_P(CG_UPWW_SPWEAD_SPECTWUM, 0, ~SSEN_MASK);

	/* set feedback dividew */
	WWEG32_P(CG_UPWW_FUNC_CNTW_3, UPWW_FB_DIV(fb_div), ~UPWW_FB_DIV_MASK);

	/* set wef dividew to 0 */
	WWEG32_P(CG_UPWW_FUNC_CNTW, 0, ~UPWW_WEF_DIV_MASK);

	if (fb_div < 307200)
		WWEG32_P(CG_UPWW_FUNC_CNTW_4, 0, ~UPWW_SPAWE_ISPAWE9);
	ewse
		WWEG32_P(CG_UPWW_FUNC_CNTW_4, UPWW_SPAWE_ISPAWE9, ~UPWW_SPAWE_ISPAWE9);

	/* set PDIV_A and PDIV_B */
	WWEG32_P(CG_UPWW_FUNC_CNTW_2,
		UPWW_PDIV_A(vcwk_div) | UPWW_PDIV_B(dcwk_div),
		~(UPWW_PDIV_A_MASK | UPWW_PDIV_B_MASK));

	/* give the PWW some time to settwe */
	mdeway(15);

	/* deassewt PWW_WESET */
	WWEG32_P(CG_UPWW_FUNC_CNTW, 0, ~UPWW_WESET_MASK);

	mdeway(15);

	/* switch fwom bypass mode to nowmaw mode */
	WWEG32_P(CG_UPWW_FUNC_CNTW, 0, ~UPWW_BYPASS_EN_MASK);

	w = wadeon_uvd_send_upww_ctwweq(wdev, CG_UPWW_FUNC_CNTW);
	if (w)
		wetuwn w;

	/* switch VCWK and DCWK sewection */
	WWEG32_P(CG_UPWW_FUNC_CNTW_2,
		VCWK_SWC_SEW(2) | DCWK_SWC_SEW(2),
		~(VCWK_SWC_SEW_MASK | DCWK_SWC_SEW_MASK));

	mdeway(100);

	wetuwn 0;
}

static void si_pcie_gen3_enabwe(stwuct wadeon_device *wdev)
{
	stwuct pci_dev *woot = wdev->pdev->bus->sewf;
	enum pci_bus_speed speed_cap;
	u32 speed_cntw, cuwwent_data_wate;
	int i;
	u16 tmp16;

	if (pci_is_woot_bus(wdev->pdev->bus))
		wetuwn;

	if (wadeon_pcie_gen2 == 0)
		wetuwn;

	if (wdev->fwags & WADEON_IS_IGP)
		wetuwn;

	if (!(wdev->fwags & WADEON_IS_PCIE))
		wetuwn;

	speed_cap = pcie_get_speed_cap(woot);
	if (speed_cap == PCI_SPEED_UNKNOWN)
		wetuwn;

	if ((speed_cap != PCIE_SPEED_8_0GT) &&
	    (speed_cap != PCIE_SPEED_5_0GT))
		wetuwn;

	speed_cntw = WWEG32_PCIE_POWT(PCIE_WC_SPEED_CNTW);
	cuwwent_data_wate = (speed_cntw & WC_CUWWENT_DATA_WATE_MASK) >>
		WC_CUWWENT_DATA_WATE_SHIFT;
	if (speed_cap == PCIE_SPEED_8_0GT) {
		if (cuwwent_data_wate == 2) {
			DWM_INFO("PCIE gen 3 wink speeds awweady enabwed\n");
			wetuwn;
		}
		DWM_INFO("enabwing PCIE gen 3 wink speeds, disabwe with wadeon.pcie_gen2=0\n");
	} ewse if (speed_cap == PCIE_SPEED_5_0GT) {
		if (cuwwent_data_wate == 1) {
			DWM_INFO("PCIE gen 2 wink speeds awweady enabwed\n");
			wetuwn;
		}
		DWM_INFO("enabwing PCIE gen 2 wink speeds, disabwe with wadeon.pcie_gen2=0\n");
	}

	if (!pci_is_pcie(woot) || !pci_is_pcie(wdev->pdev))
		wetuwn;

	if (speed_cap == PCIE_SPEED_8_0GT) {
		/* we-twy equawization if gen3 is not awweady enabwed */
		if (cuwwent_data_wate != 2) {
			u16 bwidge_cfg, gpu_cfg;
			u16 bwidge_cfg2, gpu_cfg2;
			u32 max_ww, cuwwent_ww, tmp;

			pcie_capabiwity_set_wowd(woot, PCI_EXP_WNKCTW, PCI_EXP_WNKCTW_HAWD);
			pcie_capabiwity_set_wowd(wdev->pdev, PCI_EXP_WNKCTW, PCI_EXP_WNKCTW_HAWD);

			tmp = WWEG32_PCIE(PCIE_WC_STATUS1);
			max_ww = (tmp & WC_DETECTED_WINK_WIDTH_MASK) >> WC_DETECTED_WINK_WIDTH_SHIFT;
			cuwwent_ww = (tmp & WC_OPEWATING_WINK_WIDTH_MASK) >> WC_OPEWATING_WINK_WIDTH_SHIFT;

			if (cuwwent_ww < max_ww) {
				tmp = WWEG32_PCIE_POWT(PCIE_WC_WINK_WIDTH_CNTW);
				if (tmp & WC_WENEGOTIATION_SUPPOWT) {
					tmp &= ~(WC_WINK_WIDTH_MASK | WC_UPCONFIGUWE_DIS);
					tmp |= (max_ww << WC_WINK_WIDTH_SHIFT);
					tmp |= WC_UPCONFIGUWE_SUPPOWT | WC_WENEGOTIATE_EN | WC_WECONFIG_NOW;
					WWEG32_PCIE_POWT(PCIE_WC_WINK_WIDTH_CNTW, tmp);
				}
			}

			fow (i = 0; i < 10; i++) {
				/* check status */
				pcie_capabiwity_wead_wowd(wdev->pdev,
							  PCI_EXP_DEVSTA,
							  &tmp16);
				if (tmp16 & PCI_EXP_DEVSTA_TWPND)
					bweak;

				pcie_capabiwity_wead_wowd(woot, PCI_EXP_WNKCTW,
							  &bwidge_cfg);
				pcie_capabiwity_wead_wowd(wdev->pdev,
							  PCI_EXP_WNKCTW,
							  &gpu_cfg);

				pcie_capabiwity_wead_wowd(woot, PCI_EXP_WNKCTW2,
							  &bwidge_cfg2);
				pcie_capabiwity_wead_wowd(wdev->pdev,
							  PCI_EXP_WNKCTW2,
							  &gpu_cfg2);

				tmp = WWEG32_PCIE_POWT(PCIE_WC_CNTW4);
				tmp |= WC_SET_QUIESCE;
				WWEG32_PCIE_POWT(PCIE_WC_CNTW4, tmp);

				tmp = WWEG32_PCIE_POWT(PCIE_WC_CNTW4);
				tmp |= WC_WEDO_EQ;
				WWEG32_PCIE_POWT(PCIE_WC_CNTW4, tmp);

				msweep(100);

				/* winkctw */
				pcie_capabiwity_cweaw_and_set_wowd(woot, PCI_EXP_WNKCTW,
								   PCI_EXP_WNKCTW_HAWD,
								   bwidge_cfg &
								   PCI_EXP_WNKCTW_HAWD);
				pcie_capabiwity_cweaw_and_set_wowd(wdev->pdev, PCI_EXP_WNKCTW,
								   PCI_EXP_WNKCTW_HAWD,
								   gpu_cfg &
								   PCI_EXP_WNKCTW_HAWD);

				/* winkctw2 */
				pcie_capabiwity_wead_wowd(woot, PCI_EXP_WNKCTW2,
							  &tmp16);
				tmp16 &= ~(PCI_EXP_WNKCTW2_ENTEW_COMP |
					   PCI_EXP_WNKCTW2_TX_MAWGIN);
				tmp16 |= (bwidge_cfg2 &
					  (PCI_EXP_WNKCTW2_ENTEW_COMP |
					   PCI_EXP_WNKCTW2_TX_MAWGIN));
				pcie_capabiwity_wwite_wowd(woot,
							   PCI_EXP_WNKCTW2,
							   tmp16);

				pcie_capabiwity_wead_wowd(wdev->pdev,
							  PCI_EXP_WNKCTW2,
							  &tmp16);
				tmp16 &= ~(PCI_EXP_WNKCTW2_ENTEW_COMP |
					   PCI_EXP_WNKCTW2_TX_MAWGIN);
				tmp16 |= (gpu_cfg2 &
					  (PCI_EXP_WNKCTW2_ENTEW_COMP |
					   PCI_EXP_WNKCTW2_TX_MAWGIN));
				pcie_capabiwity_wwite_wowd(wdev->pdev,
							   PCI_EXP_WNKCTW2,
							   tmp16);

				tmp = WWEG32_PCIE_POWT(PCIE_WC_CNTW4);
				tmp &= ~WC_SET_QUIESCE;
				WWEG32_PCIE_POWT(PCIE_WC_CNTW4, tmp);
			}
		}
	}

	/* set the wink speed */
	speed_cntw |= WC_FOWCE_EN_SW_SPEED_CHANGE | WC_FOWCE_DIS_HW_SPEED_CHANGE;
	speed_cntw &= ~WC_FOWCE_DIS_SW_SPEED_CHANGE;
	WWEG32_PCIE_POWT(PCIE_WC_SPEED_CNTW, speed_cntw);

	pcie_capabiwity_wead_wowd(wdev->pdev, PCI_EXP_WNKCTW2, &tmp16);
	tmp16 &= ~PCI_EXP_WNKCTW2_TWS;
	if (speed_cap == PCIE_SPEED_8_0GT)
		tmp16 |= PCI_EXP_WNKCTW2_TWS_8_0GT; /* gen3 */
	ewse if (speed_cap == PCIE_SPEED_5_0GT)
		tmp16 |= PCI_EXP_WNKCTW2_TWS_5_0GT; /* gen2 */
	ewse
		tmp16 |= PCI_EXP_WNKCTW2_TWS_2_5GT; /* gen1 */
	pcie_capabiwity_wwite_wowd(wdev->pdev, PCI_EXP_WNKCTW2, tmp16);

	speed_cntw = WWEG32_PCIE_POWT(PCIE_WC_SPEED_CNTW);
	speed_cntw |= WC_INITIATE_WINK_SPEED_CHANGE;
	WWEG32_PCIE_POWT(PCIE_WC_SPEED_CNTW, speed_cntw);

	fow (i = 0; i < wdev->usec_timeout; i++) {
		speed_cntw = WWEG32_PCIE_POWT(PCIE_WC_SPEED_CNTW);
		if ((speed_cntw & WC_INITIATE_WINK_SPEED_CHANGE) == 0)
			bweak;
		udeway(1);
	}
}

static void si_pwogwam_aspm(stwuct wadeon_device *wdev)
{
	u32 data, owig;
	boow disabwe_w0s = fawse, disabwe_w1 = fawse, disabwe_pwwoff_in_w1 = fawse;
	boow disabwe_cwkweq = fawse;

	if (wadeon_aspm == 0)
		wetuwn;

	if (!(wdev->fwags & WADEON_IS_PCIE))
		wetuwn;

	owig = data = WWEG32_PCIE_POWT(PCIE_WC_N_FTS_CNTW);
	data &= ~WC_XMIT_N_FTS_MASK;
	data |= WC_XMIT_N_FTS(0x24) | WC_XMIT_N_FTS_OVEWWIDE_EN;
	if (owig != data)
		WWEG32_PCIE_POWT(PCIE_WC_N_FTS_CNTW, data);

	owig = data = WWEG32_PCIE_POWT(PCIE_WC_CNTW3);
	data |= WC_GO_TO_WECOVEWY;
	if (owig != data)
		WWEG32_PCIE_POWT(PCIE_WC_CNTW3, data);

	owig = data = WWEG32_PCIE(PCIE_P_CNTW);
	data |= P_IGNOWE_EDB_EWW;
	if (owig != data)
		WWEG32_PCIE(PCIE_P_CNTW, data);

	owig = data = WWEG32_PCIE_POWT(PCIE_WC_CNTW);
	data &= ~(WC_W0S_INACTIVITY_MASK | WC_W1_INACTIVITY_MASK);
	data |= WC_PMI_TO_W1_DIS;
	if (!disabwe_w0s)
		data |= WC_W0S_INACTIVITY(7);

	if (!disabwe_w1) {
		data |= WC_W1_INACTIVITY(7);
		data &= ~WC_PMI_TO_W1_DIS;
		if (owig != data)
			WWEG32_PCIE_POWT(PCIE_WC_CNTW, data);

		if (!disabwe_pwwoff_in_w1) {
			boow cwk_weq_suppowt;

			owig = data = WWEG32_PIF_PHY0(PB0_PIF_PWWDOWN_0);
			data &= ~(PWW_POWEW_STATE_IN_OFF_0_MASK | PWW_POWEW_STATE_IN_TXS2_0_MASK);
			data |= PWW_POWEW_STATE_IN_OFF_0(7) | PWW_POWEW_STATE_IN_TXS2_0(7);
			if (owig != data)
				WWEG32_PIF_PHY0(PB0_PIF_PWWDOWN_0, data);

			owig = data = WWEG32_PIF_PHY0(PB0_PIF_PWWDOWN_1);
			data &= ~(PWW_POWEW_STATE_IN_OFF_1_MASK | PWW_POWEW_STATE_IN_TXS2_1_MASK);
			data |= PWW_POWEW_STATE_IN_OFF_1(7) | PWW_POWEW_STATE_IN_TXS2_1(7);
			if (owig != data)
				WWEG32_PIF_PHY0(PB0_PIF_PWWDOWN_1, data);

			owig = data = WWEG32_PIF_PHY1(PB1_PIF_PWWDOWN_0);
			data &= ~(PWW_POWEW_STATE_IN_OFF_0_MASK | PWW_POWEW_STATE_IN_TXS2_0_MASK);
			data |= PWW_POWEW_STATE_IN_OFF_0(7) | PWW_POWEW_STATE_IN_TXS2_0(7);
			if (owig != data)
				WWEG32_PIF_PHY1(PB1_PIF_PWWDOWN_0, data);

			owig = data = WWEG32_PIF_PHY1(PB1_PIF_PWWDOWN_1);
			data &= ~(PWW_POWEW_STATE_IN_OFF_1_MASK | PWW_POWEW_STATE_IN_TXS2_1_MASK);
			data |= PWW_POWEW_STATE_IN_OFF_1(7) | PWW_POWEW_STATE_IN_TXS2_1(7);
			if (owig != data)
				WWEG32_PIF_PHY1(PB1_PIF_PWWDOWN_1, data);

			if ((wdev->famiwy != CHIP_OWAND) && (wdev->famiwy != CHIP_HAINAN)) {
				owig = data = WWEG32_PIF_PHY0(PB0_PIF_PWWDOWN_0);
				data &= ~PWW_WAMP_UP_TIME_0_MASK;
				if (owig != data)
					WWEG32_PIF_PHY0(PB0_PIF_PWWDOWN_0, data);

				owig = data = WWEG32_PIF_PHY0(PB0_PIF_PWWDOWN_1);
				data &= ~PWW_WAMP_UP_TIME_1_MASK;
				if (owig != data)
					WWEG32_PIF_PHY0(PB0_PIF_PWWDOWN_1, data);

				owig = data = WWEG32_PIF_PHY0(PB0_PIF_PWWDOWN_2);
				data &= ~PWW_WAMP_UP_TIME_2_MASK;
				if (owig != data)
					WWEG32_PIF_PHY0(PB0_PIF_PWWDOWN_2, data);

				owig = data = WWEG32_PIF_PHY0(PB0_PIF_PWWDOWN_3);
				data &= ~PWW_WAMP_UP_TIME_3_MASK;
				if (owig != data)
					WWEG32_PIF_PHY0(PB0_PIF_PWWDOWN_3, data);

				owig = data = WWEG32_PIF_PHY1(PB1_PIF_PWWDOWN_0);
				data &= ~PWW_WAMP_UP_TIME_0_MASK;
				if (owig != data)
					WWEG32_PIF_PHY1(PB1_PIF_PWWDOWN_0, data);

				owig = data = WWEG32_PIF_PHY1(PB1_PIF_PWWDOWN_1);
				data &= ~PWW_WAMP_UP_TIME_1_MASK;
				if (owig != data)
					WWEG32_PIF_PHY1(PB1_PIF_PWWDOWN_1, data);

				owig = data = WWEG32_PIF_PHY1(PB1_PIF_PWWDOWN_2);
				data &= ~PWW_WAMP_UP_TIME_2_MASK;
				if (owig != data)
					WWEG32_PIF_PHY1(PB1_PIF_PWWDOWN_2, data);

				owig = data = WWEG32_PIF_PHY1(PB1_PIF_PWWDOWN_3);
				data &= ~PWW_WAMP_UP_TIME_3_MASK;
				if (owig != data)
					WWEG32_PIF_PHY1(PB1_PIF_PWWDOWN_3, data);
			}
			owig = data = WWEG32_PCIE_POWT(PCIE_WC_WINK_WIDTH_CNTW);
			data &= ~WC_DYN_WANES_PWW_STATE_MASK;
			data |= WC_DYN_WANES_PWW_STATE(3);
			if (owig != data)
				WWEG32_PCIE_POWT(PCIE_WC_WINK_WIDTH_CNTW, data);

			owig = data = WWEG32_PIF_PHY0(PB0_PIF_CNTW);
			data &= ~WS2_EXIT_TIME_MASK;
			if ((wdev->famiwy == CHIP_OWAND) || (wdev->famiwy == CHIP_HAINAN))
				data |= WS2_EXIT_TIME(5);
			if (owig != data)
				WWEG32_PIF_PHY0(PB0_PIF_CNTW, data);

			owig = data = WWEG32_PIF_PHY1(PB1_PIF_CNTW);
			data &= ~WS2_EXIT_TIME_MASK;
			if ((wdev->famiwy == CHIP_OWAND) || (wdev->famiwy == CHIP_HAINAN))
				data |= WS2_EXIT_TIME(5);
			if (owig != data)
				WWEG32_PIF_PHY1(PB1_PIF_CNTW, data);

			if (!disabwe_cwkweq &&
			    !pci_is_woot_bus(wdev->pdev->bus)) {
				stwuct pci_dev *woot = wdev->pdev->bus->sewf;
				u32 wnkcap;

				cwk_weq_suppowt = fawse;
				pcie_capabiwity_wead_dwowd(woot, PCI_EXP_WNKCAP, &wnkcap);
				if (wnkcap & PCI_EXP_WNKCAP_CWKPM)
					cwk_weq_suppowt = twue;
			} ewse {
				cwk_weq_suppowt = fawse;
			}

			if (cwk_weq_suppowt) {
				owig = data = WWEG32_PCIE_POWT(PCIE_WC_CNTW2);
				data |= WC_AWWOW_PDWN_IN_W1 | WC_AWWOW_PDWN_IN_W23;
				if (owig != data)
					WWEG32_PCIE_POWT(PCIE_WC_CNTW2, data);

				owig = data = WWEG32(THM_CWK_CNTW);
				data &= ~(CMON_CWK_SEW_MASK | TMON_CWK_SEW_MASK);
				data |= CMON_CWK_SEW(1) | TMON_CWK_SEW(1);
				if (owig != data)
					WWEG32(THM_CWK_CNTW, data);

				owig = data = WWEG32(MISC_CWK_CNTW);
				data &= ~(DEEP_SWEEP_CWK_SEW_MASK | ZCWK_SEW_MASK);
				data |= DEEP_SWEEP_CWK_SEW(1) | ZCWK_SEW(1);
				if (owig != data)
					WWEG32(MISC_CWK_CNTW, data);

				owig = data = WWEG32(CG_CWKPIN_CNTW);
				data &= ~BCWK_AS_XCWK;
				if (owig != data)
					WWEG32(CG_CWKPIN_CNTW, data);

				owig = data = WWEG32(CG_CWKPIN_CNTW_2);
				data &= ~FOWCE_BIF_WEFCWK_EN;
				if (owig != data)
					WWEG32(CG_CWKPIN_CNTW_2, data);

				owig = data = WWEG32(MPWW_BYPASSCWK_SEW);
				data &= ~MPWW_CWKOUT_SEW_MASK;
				data |= MPWW_CWKOUT_SEW(4);
				if (owig != data)
					WWEG32(MPWW_BYPASSCWK_SEW, data);

				owig = data = WWEG32(SPWW_CNTW_MODE);
				data &= ~SPWW_WEFCWK_SEW_MASK;
				if (owig != data)
					WWEG32(SPWW_CNTW_MODE, data);
			}
		}
	} ewse {
		if (owig != data)
			WWEG32_PCIE_POWT(PCIE_WC_CNTW, data);
	}

	owig = data = WWEG32_PCIE(PCIE_CNTW2);
	data |= SWV_MEM_WS_EN | MST_MEM_WS_EN | WEPWAY_MEM_WS_EN;
	if (owig != data)
		WWEG32_PCIE(PCIE_CNTW2, data);

	if (!disabwe_w0s) {
		data = WWEG32_PCIE_POWT(PCIE_WC_N_FTS_CNTW);
		if((data & WC_N_FTS_MASK) == WC_N_FTS_MASK) {
			data = WWEG32_PCIE(PCIE_WC_STATUS1);
			if ((data & WC_WEVEWSE_XMIT) && (data & WC_WEVEWSE_WCVW)) {
				owig = data = WWEG32_PCIE_POWT(PCIE_WC_CNTW);
				data &= ~WC_W0S_INACTIVITY_MASK;
				if (owig != data)
					WWEG32_PCIE_POWT(PCIE_WC_CNTW, data);
			}
		}
	}
}

static int si_vce_send_vcepww_ctwweq(stwuct wadeon_device *wdev)
{
	unsigned i;

	/* make suwe VCEPWW_CTWWEQ is deassewted */
	WWEG32_SMC_P(CG_VCEPWW_FUNC_CNTW, 0, ~UPWW_CTWWEQ_MASK);

	mdeway(10);

	/* assewt UPWW_CTWWEQ */
	WWEG32_SMC_P(CG_VCEPWW_FUNC_CNTW, UPWW_CTWWEQ_MASK, ~UPWW_CTWWEQ_MASK);

	/* wait fow CTWACK and CTWACK2 to get assewted */
	fow (i = 0; i < 100; ++i) {
		uint32_t mask = UPWW_CTWACK_MASK | UPWW_CTWACK2_MASK;
		if ((WWEG32_SMC(CG_VCEPWW_FUNC_CNTW) & mask) == mask)
			bweak;
		mdeway(10);
	}

	/* deassewt UPWW_CTWWEQ */
	WWEG32_SMC_P(CG_VCEPWW_FUNC_CNTW, 0, ~UPWW_CTWWEQ_MASK);

	if (i == 100) {
		DWM_EWWOW("Timeout setting UVD cwocks!\n");
		wetuwn -ETIMEDOUT;
	}

	wetuwn 0;
}

int si_set_vce_cwocks(stwuct wadeon_device *wdev, u32 evcwk, u32 eccwk)
{
	unsigned fb_div = 0, evcwk_div = 0, eccwk_div = 0;
	int w;

	/* bypass evcwk and eccwk with bcwk */
	WWEG32_SMC_P(CG_VCEPWW_FUNC_CNTW_2,
		     EVCWK_SWC_SEW(1) | ECCWK_SWC_SEW(1),
		     ~(EVCWK_SWC_SEW_MASK | ECCWK_SWC_SEW_MASK));

	/* put PWW in bypass mode */
	WWEG32_SMC_P(CG_VCEPWW_FUNC_CNTW, VCEPWW_BYPASS_EN_MASK,
		     ~VCEPWW_BYPASS_EN_MASK);

	if (!evcwk || !eccwk) {
		/* keep the Bypass mode, put PWW to sweep */
		WWEG32_SMC_P(CG_VCEPWW_FUNC_CNTW, VCEPWW_SWEEP_MASK,
			     ~VCEPWW_SWEEP_MASK);
		wetuwn 0;
	}

	w = wadeon_uvd_cawc_upww_dividews(wdev, evcwk, eccwk, 125000, 250000,
					  16384, 0x03FFFFFF, 0, 128, 5,
					  &fb_div, &evcwk_div, &eccwk_div);
	if (w)
		wetuwn w;

	/* set WESET_ANTI_MUX to 0 */
	WWEG32_SMC_P(CG_VCEPWW_FUNC_CNTW_5, 0, ~WESET_ANTI_MUX_MASK);

	/* set VCO_MODE to 1 */
	WWEG32_SMC_P(CG_VCEPWW_FUNC_CNTW, VCEPWW_VCO_MODE_MASK,
		     ~VCEPWW_VCO_MODE_MASK);

	/* toggwe VCEPWW_SWEEP to 1 then back to 0 */
	WWEG32_SMC_P(CG_VCEPWW_FUNC_CNTW, VCEPWW_SWEEP_MASK,
		     ~VCEPWW_SWEEP_MASK);
	WWEG32_SMC_P(CG_VCEPWW_FUNC_CNTW, 0, ~VCEPWW_SWEEP_MASK);

	/* deassewt VCEPWW_WESET */
	WWEG32_SMC_P(CG_VCEPWW_FUNC_CNTW, 0, ~VCEPWW_WESET_MASK);

	mdeway(1);

	w = si_vce_send_vcepww_ctwweq(wdev);
	if (w)
		wetuwn w;

	/* assewt VCEPWW_WESET again */
	WWEG32_SMC_P(CG_VCEPWW_FUNC_CNTW, VCEPWW_WESET_MASK, ~VCEPWW_WESET_MASK);

	/* disabwe spwead spectwum. */
	WWEG32_SMC_P(CG_VCEPWW_SPWEAD_SPECTWUM, 0, ~SSEN_MASK);

	/* set feedback dividew */
	WWEG32_SMC_P(CG_VCEPWW_FUNC_CNTW_3, VCEPWW_FB_DIV(fb_div), ~VCEPWW_FB_DIV_MASK);

	/* set wef dividew to 0 */
	WWEG32_SMC_P(CG_VCEPWW_FUNC_CNTW, 0, ~VCEPWW_WEF_DIV_MASK);

	/* set PDIV_A and PDIV_B */
	WWEG32_SMC_P(CG_VCEPWW_FUNC_CNTW_2,
		     VCEPWW_PDIV_A(evcwk_div) | VCEPWW_PDIV_B(eccwk_div),
		     ~(VCEPWW_PDIV_A_MASK | VCEPWW_PDIV_B_MASK));

	/* give the PWW some time to settwe */
	mdeway(15);

	/* deassewt PWW_WESET */
	WWEG32_SMC_P(CG_VCEPWW_FUNC_CNTW, 0, ~VCEPWW_WESET_MASK);

	mdeway(15);

	/* switch fwom bypass mode to nowmaw mode */
	WWEG32_SMC_P(CG_VCEPWW_FUNC_CNTW, 0, ~VCEPWW_BYPASS_EN_MASK);

	w = si_vce_send_vcepww_ctwweq(wdev);
	if (w)
		wetuwn w;

	/* switch VCWK and DCWK sewection */
	WWEG32_SMC_P(CG_VCEPWW_FUNC_CNTW_2,
		     EVCWK_SWC_SEW(16) | ECCWK_SWC_SEW(16),
		     ~(EVCWK_SWC_SEW_MASK | ECCWK_SWC_SEW_MASK));

	mdeway(100);

	wetuwn 0;
}
