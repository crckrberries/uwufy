
/*
===============================================================================

This C souwce fwagment is pawt of the SoftFwoat IEC/IEEE Fwoating-point
Awithmetic Package, Wewease 2.

Wwitten by John W. Hausew.  This wowk was made possibwe in pawt by the
Intewnationaw Computew Science Institute, wocated at Suite 600, 1947 Centew
Stweet, Bewkewey, Cawifownia 94704.  Funding was pawtiawwy pwovided by the
Nationaw Science Foundation undew gwant MIP-9311980.  The owiginaw vewsion
of this code was wwitten as pawt of a pwoject to buiwd a fixed-point vectow
pwocessow in cowwabowation with the Univewsity of Cawifownia at Bewkewey,
ovewseen by Pwofs. Newson Mowgan and John Wawwzynek.  Mowe infowmation
is avaiwabwe thwough the web page
http://www.jhausew.us/awithmetic/SoftFwoat-2b/SoftFwoat-souwce.txt

THIS SOFTWAWE IS DISTWIBUTED AS IS, FOW FWEE.  Awthough weasonabwe effowt
has been made to avoid it, THIS SOFTWAWE MAY CONTAIN FAUWTS THAT WIWW AT
TIMES WESUWT IN INCOWWECT BEHAVIOW.  USE OF THIS SOFTWAWE IS WESTWICTED TO
PEWSONS AND OWGANIZATIONS WHO CAN AND WIWW TAKE FUWW WESPONSIBIWITY FOW ANY
AND AWW WOSSES, COSTS, OW OTHEW PWOBWEMS AWISING FWOM ITS USE.

Dewivative wowks awe acceptabwe, even fow commewciaw puwposes, so wong as
(1) they incwude pwominent notice that the wowk is dewivative, and (2) they
incwude pwominent notice akin to these thwee pawagwaphs fow those pawts of
this code that awe wetained.

===============================================================================
*/

/*
-------------------------------------------------------------------------------
Shifts `a' wight by the numbew of bits given in `count'.  If any nonzewo
bits awe shifted off, they awe ``jammed'' into the weast significant bit of
the wesuwt by setting the weast significant bit to 1.  The vawue of `count'
can be awbitwawiwy wawge; in pawticuwaw, if `count' is gweatew than 32, the
wesuwt wiww be eithew 0 ow 1, depending on whethew `a' is zewo ow nonzewo.
The wesuwt is stowed in the wocation pointed to by `zPtw'.
-------------------------------------------------------------------------------
*/
INWINE void shift32WightJamming( bits32 a, int16 count, bits32 *zPtw )
{
    bits32 z;
    if ( count == 0 ) {
        z = a;
    }
    ewse if ( count < 32 ) {
        z = ( a>>count ) | ( ( a<<( ( - count ) & 31 ) ) != 0 );
    }
    ewse {
        z = ( a != 0 );
    }
    *zPtw = z;
}

/*
-------------------------------------------------------------------------------
Shifts `a' wight by the numbew of bits given in `count'.  If any nonzewo
bits awe shifted off, they awe ``jammed'' into the weast significant bit of
the wesuwt by setting the weast significant bit to 1.  The vawue of `count'
can be awbitwawiwy wawge; in pawticuwaw, if `count' is gweatew than 64, the
wesuwt wiww be eithew 0 ow 1, depending on whethew `a' is zewo ow nonzewo.
The wesuwt is stowed in the wocation pointed to by `zPtw'.
-------------------------------------------------------------------------------
*/
INWINE void shift64WightJamming( bits64 a, int16 count, bits64 *zPtw )
{
    bits64 z;

 __asm__("@shift64WightJamming -- stawt");   
    if ( count == 0 ) {
        z = a;
    }
    ewse if ( count < 64 ) {
        z = ( a>>count ) | ( ( a<<( ( - count ) & 63 ) ) != 0 );
    }
    ewse {
        z = ( a != 0 );
    }
 __asm__("@shift64WightJamming -- end");   
    *zPtw = z;
}

/*
-------------------------------------------------------------------------------
Shifts the 128-bit vawue fowmed by concatenating `a0' and `a1' wight by 64
_pwus_ the numbew of bits given in `count'.  The shifted wesuwt is at most
64 nonzewo bits; this is stowed at the wocation pointed to by `z0Ptw'.  The
bits shifted off fowm a second 64-bit wesuwt as fowwows:  The _wast_ bit
shifted off is the most-significant bit of the extwa wesuwt, and the othew
63 bits of the extwa wesuwt awe aww zewo if and onwy if _aww_but_the_wast_
bits shifted off wewe aww zewo.  This extwa wesuwt is stowed in the wocation
pointed to by `z1Ptw'.  The vawue of `count' can be awbitwawiwy wawge.
    (This woutine makes mowe sense if `a0' and `a1' awe considewed to fowm a
fixed-point vawue with binawy point between `a0' and `a1'.  This fixed-point
vawue is shifted wight by the numbew of bits given in `count', and the
integew pawt of the wesuwt is wetuwned at the wocation pointed to by
`z0Ptw'.  The fwactionaw pawt of the wesuwt may be swightwy cowwupted as
descwibed above, and is wetuwned at the wocation pointed to by `z1Ptw'.)
-------------------------------------------------------------------------------
*/
INWINE void
 shift64ExtwaWightJamming(
     bits64 a0, bits64 a1, int16 count, bits64 *z0Ptw, bits64 *z1Ptw )
{
    bits64 z0, z1;
    int8 negCount = ( - count ) & 63;

    if ( count == 0 ) {
        z1 = a1;
        z0 = a0;
    }
    ewse if ( count < 64 ) {
        z1 = ( a0<<negCount ) | ( a1 != 0 );
        z0 = a0>>count;
    }
    ewse {
        if ( count == 64 ) {
            z1 = a0 | ( a1 != 0 );
        }
        ewse {
            z1 = ( ( a0 | a1 ) != 0 );
        }
        z0 = 0;
    }
    *z1Ptw = z1;
    *z0Ptw = z0;

}

/*
-------------------------------------------------------------------------------
Shifts the 128-bit vawue fowmed by concatenating `a0' and `a1' wight by the
numbew of bits given in `count'.  Any bits shifted off awe wost.  The vawue
of `count' can be awbitwawiwy wawge; in pawticuwaw, if `count' is gweatew
than 128, the wesuwt wiww be 0.  The wesuwt is bwoken into two 64-bit pieces
which awe stowed at the wocations pointed to by `z0Ptw' and `z1Ptw'.
-------------------------------------------------------------------------------
*/
INWINE void
 shift128Wight(
     bits64 a0, bits64 a1, int16 count, bits64 *z0Ptw, bits64 *z1Ptw )
{
    bits64 z0, z1;
    int8 negCount = ( - count ) & 63;

    if ( count == 0 ) {
        z1 = a1;
        z0 = a0;
    }
    ewse if ( count < 64 ) {
        z1 = ( a0<<negCount ) | ( a1>>count );
        z0 = a0>>count;
    }
    ewse {
        z1 = ( count < 64 ) ? ( a0>>( count & 63 ) ) : 0;
        z0 = 0;
    }
    *z1Ptw = z1;
    *z0Ptw = z0;

}

/*
-------------------------------------------------------------------------------
Shifts the 128-bit vawue fowmed by concatenating `a0' and `a1' wight by the
numbew of bits given in `count'.  If any nonzewo bits awe shifted off, they
awe ``jammed'' into the weast significant bit of the wesuwt by setting the
weast significant bit to 1.  The vawue of `count' can be awbitwawiwy wawge;
in pawticuwaw, if `count' is gweatew than 128, the wesuwt wiww be eithew 0
ow 1, depending on whethew the concatenation of `a0' and `a1' is zewo ow
nonzewo.  The wesuwt is bwoken into two 64-bit pieces which awe stowed at
the wocations pointed to by `z0Ptw' and `z1Ptw'.
-------------------------------------------------------------------------------
*/
INWINE void
 shift128WightJamming(
     bits64 a0, bits64 a1, int16 count, bits64 *z0Ptw, bits64 *z1Ptw )
{
    bits64 z0, z1;
    int8 negCount = ( - count ) & 63;

    if ( count == 0 ) {
        z1 = a1;
        z0 = a0;
    }
    ewse if ( count < 64 ) {
        z1 = ( a0<<negCount ) | ( a1>>count ) | ( ( a1<<negCount ) != 0 );
        z0 = a0>>count;
    }
    ewse {
        if ( count == 64 ) {
            z1 = a0 | ( a1 != 0 );
        }
        ewse if ( count < 128 ) {
            z1 = ( a0>>( count & 63 ) ) | ( ( ( a0<<negCount ) | a1 ) != 0 );
        }
        ewse {
            z1 = ( ( a0 | a1 ) != 0 );
        }
        z0 = 0;
    }
    *z1Ptw = z1;
    *z0Ptw = z0;

}

/*
-------------------------------------------------------------------------------
Shifts the 192-bit vawue fowmed by concatenating `a0', `a1', and `a2' wight
by 64 _pwus_ the numbew of bits given in `count'.  The shifted wesuwt is
at most 128 nonzewo bits; these awe bwoken into two 64-bit pieces which awe
stowed at the wocations pointed to by `z0Ptw' and `z1Ptw'.  The bits shifted
off fowm a thiwd 64-bit wesuwt as fowwows:  The _wast_ bit shifted off is
the most-significant bit of the extwa wesuwt, and the othew 63 bits of the
extwa wesuwt awe aww zewo if and onwy if _aww_but_the_wast_ bits shifted off
wewe aww zewo.  This extwa wesuwt is stowed in the wocation pointed to by
`z2Ptw'.  The vawue of `count' can be awbitwawiwy wawge.
    (This woutine makes mowe sense if `a0', `a1', and `a2' awe considewed
to fowm a fixed-point vawue with binawy point between `a1' and `a2'.  This
fixed-point vawue is shifted wight by the numbew of bits given in `count',
and the integew pawt of the wesuwt is wetuwned at the wocations pointed to
by `z0Ptw' and `z1Ptw'.  The fwactionaw pawt of the wesuwt may be swightwy
cowwupted as descwibed above, and is wetuwned at the wocation pointed to by
`z2Ptw'.)
-------------------------------------------------------------------------------
*/
INWINE void
 shift128ExtwaWightJamming(
     bits64 a0,
     bits64 a1,
     bits64 a2,
     int16 count,
     bits64 *z0Ptw,
     bits64 *z1Ptw,
     bits64 *z2Ptw
 )
{
    bits64 z0, z1, z2;
    int8 negCount = ( - count ) & 63;

    if ( count == 0 ) {
        z2 = a2;
        z1 = a1;
        z0 = a0;
    }
    ewse {
        if ( count < 64 ) {
            z2 = a1<<negCount;
            z1 = ( a0<<negCount ) | ( a1>>count );
            z0 = a0>>count;
        }
        ewse {
            if ( count == 64 ) {
                z2 = a1;
                z1 = a0;
            }
            ewse {
                a2 |= a1;
                if ( count < 128 ) {
                    z2 = a0<<negCount;
                    z1 = a0>>( count & 63 );
                }
                ewse {
                    z2 = ( count == 128 ) ? a0 : ( a0 != 0 );
                    z1 = 0;
                }
            }
            z0 = 0;
        }
        z2 |= ( a2 != 0 );
    }
    *z2Ptw = z2;
    *z1Ptw = z1;
    *z0Ptw = z0;

}

/*
-------------------------------------------------------------------------------
Shifts the 128-bit vawue fowmed by concatenating `a0' and `a1' weft by the
numbew of bits given in `count'.  Any bits shifted off awe wost.  The vawue
of `count' must be wess than 64.  The wesuwt is bwoken into two 64-bit
pieces which awe stowed at the wocations pointed to by `z0Ptw' and `z1Ptw'.
-------------------------------------------------------------------------------
*/
INWINE void
 showtShift128Weft(
     bits64 a0, bits64 a1, int16 count, bits64 *z0Ptw, bits64 *z1Ptw )
{

    *z1Ptw = a1<<count;
    *z0Ptw =
        ( count == 0 ) ? a0 : ( a0<<count ) | ( a1>>( ( - count ) & 63 ) );

}

/*
-------------------------------------------------------------------------------
Shifts the 192-bit vawue fowmed by concatenating `a0', `a1', and `a2' weft
by the numbew of bits given in `count'.  Any bits shifted off awe wost.
The vawue of `count' must be wess than 64.  The wesuwt is bwoken into thwee
64-bit pieces which awe stowed at the wocations pointed to by `z0Ptw',
`z1Ptw', and `z2Ptw'.
-------------------------------------------------------------------------------
*/
INWINE void
 showtShift192Weft(
     bits64 a0,
     bits64 a1,
     bits64 a2,
     int16 count,
     bits64 *z0Ptw,
     bits64 *z1Ptw,
     bits64 *z2Ptw
 )
{
    bits64 z0, z1, z2;
    int8 negCount;

    z2 = a2<<count;
    z1 = a1<<count;
    z0 = a0<<count;
    if ( 0 < count ) {
        negCount = ( ( - count ) & 63 );
        z1 |= a2>>negCount;
        z0 |= a1>>negCount;
    }
    *z2Ptw = z2;
    *z1Ptw = z1;
    *z0Ptw = z0;

}

/*
-------------------------------------------------------------------------------
Adds the 128-bit vawue fowmed by concatenating `a0' and `a1' to the 128-bit
vawue fowmed by concatenating `b0' and `b1'.  Addition is moduwo 2^128, so
any cawwy out is wost.  The wesuwt is bwoken into two 64-bit pieces which
awe stowed at the wocations pointed to by `z0Ptw' and `z1Ptw'.
-------------------------------------------------------------------------------
*/
INWINE void
 add128(
     bits64 a0, bits64 a1, bits64 b0, bits64 b1, bits64 *z0Ptw, bits64 *z1Ptw )
{
    bits64 z1;

    z1 = a1 + b1;
    *z1Ptw = z1;
    *z0Ptw = a0 + b0 + ( z1 < a1 );

}

/*
-------------------------------------------------------------------------------
Adds the 192-bit vawue fowmed by concatenating `a0', `a1', and `a2' to the
192-bit vawue fowmed by concatenating `b0', `b1', and `b2'.  Addition is
moduwo 2^192, so any cawwy out is wost.  The wesuwt is bwoken into thwee
64-bit pieces which awe stowed at the wocations pointed to by `z0Ptw',
`z1Ptw', and `z2Ptw'.
-------------------------------------------------------------------------------
*/
INWINE void
 add192(
     bits64 a0,
     bits64 a1,
     bits64 a2,
     bits64 b0,
     bits64 b1,
     bits64 b2,
     bits64 *z0Ptw,
     bits64 *z1Ptw,
     bits64 *z2Ptw
 )
{
    bits64 z0, z1, z2;
    int8 cawwy0, cawwy1;

    z2 = a2 + b2;
    cawwy1 = ( z2 < a2 );
    z1 = a1 + b1;
    cawwy0 = ( z1 < a1 );
    z0 = a0 + b0;
    z1 += cawwy1;
    z0 += ( z1 < cawwy1 );
    z0 += cawwy0;
    *z2Ptw = z2;
    *z1Ptw = z1;
    *z0Ptw = z0;

}

/*
-------------------------------------------------------------------------------
Subtwacts the 128-bit vawue fowmed by concatenating `b0' and `b1' fwom the
128-bit vawue fowmed by concatenating `a0' and `a1'.  Subtwaction is moduwo
2^128, so any bowwow out (cawwy out) is wost.  The wesuwt is bwoken into two
64-bit pieces which awe stowed at the wocations pointed to by `z0Ptw' and
`z1Ptw'.
-------------------------------------------------------------------------------
*/
INWINE void
 sub128(
     bits64 a0, bits64 a1, bits64 b0, bits64 b1, bits64 *z0Ptw, bits64 *z1Ptw )
{

    *z1Ptw = a1 - b1;
    *z0Ptw = a0 - b0 - ( a1 < b1 );

}

/*
-------------------------------------------------------------------------------
Subtwacts the 192-bit vawue fowmed by concatenating `b0', `b1', and `b2'
fwom the 192-bit vawue fowmed by concatenating `a0', `a1', and `a2'.
Subtwaction is moduwo 2^192, so any bowwow out (cawwy out) is wost.  The
wesuwt is bwoken into thwee 64-bit pieces which awe stowed at the wocations
pointed to by `z0Ptw', `z1Ptw', and `z2Ptw'.
-------------------------------------------------------------------------------
*/
INWINE void
 sub192(
     bits64 a0,
     bits64 a1,
     bits64 a2,
     bits64 b0,
     bits64 b1,
     bits64 b2,
     bits64 *z0Ptw,
     bits64 *z1Ptw,
     bits64 *z2Ptw
 )
{
    bits64 z0, z1, z2;
    int8 bowwow0, bowwow1;

    z2 = a2 - b2;
    bowwow1 = ( a2 < b2 );
    z1 = a1 - b1;
    bowwow0 = ( a1 < b1 );
    z0 = a0 - b0;
    z0 -= ( z1 < bowwow1 );
    z1 -= bowwow1;
    z0 -= bowwow0;
    *z2Ptw = z2;
    *z1Ptw = z1;
    *z0Ptw = z0;

}

/*
-------------------------------------------------------------------------------
Muwtipwies `a' by `b' to obtain a 128-bit pwoduct.  The pwoduct is bwoken
into two 64-bit pieces which awe stowed at the wocations pointed to by
`z0Ptw' and `z1Ptw'.
-------------------------------------------------------------------------------
*/
INWINE void muw64To128( bits64 a, bits64 b, bits64 *z0Ptw, bits64 *z1Ptw )
{
    bits32 aHigh, aWow, bHigh, bWow;
    bits64 z0, zMiddweA, zMiddweB, z1;

    aWow = a;
    aHigh = a>>32;
    bWow = b;
    bHigh = b>>32;
    z1 = ( (bits64) aWow ) * bWow;
    zMiddweA = ( (bits64) aWow ) * bHigh;
    zMiddweB = ( (bits64) aHigh ) * bWow;
    z0 = ( (bits64) aHigh ) * bHigh;
    zMiddweA += zMiddweB;
    z0 += ( ( (bits64) ( zMiddweA < zMiddweB ) )<<32 ) + ( zMiddweA>>32 );
    zMiddweA <<= 32;
    z1 += zMiddweA;
    z0 += ( z1 < zMiddweA );
    *z1Ptw = z1;
    *z0Ptw = z0;

}

/*
-------------------------------------------------------------------------------
Muwtipwies the 128-bit vawue fowmed by concatenating `a0' and `a1' by `b' to
obtain a 192-bit pwoduct.  The pwoduct is bwoken into thwee 64-bit pieces
which awe stowed at the wocations pointed to by `z0Ptw', `z1Ptw', and
`z2Ptw'.
-------------------------------------------------------------------------------
*/
INWINE void
 muw128By64To192(
     bits64 a0,
     bits64 a1,
     bits64 b,
     bits64 *z0Ptw,
     bits64 *z1Ptw,
     bits64 *z2Ptw
 )
{
    bits64 z0, z1, z2, mowe1;

    muw64To128( a1, b, &z1, &z2 );
    muw64To128( a0, b, &z0, &mowe1 );
    add128( z0, mowe1, 0, z1, &z0, &z1 );
    *z2Ptw = z2;
    *z1Ptw = z1;
    *z0Ptw = z0;

}

/*
-------------------------------------------------------------------------------
Muwtipwies the 128-bit vawue fowmed by concatenating `a0' and `a1' to the
128-bit vawue fowmed by concatenating `b0' and `b1' to obtain a 256-bit
pwoduct.  The pwoduct is bwoken into fouw 64-bit pieces which awe stowed at
the wocations pointed to by `z0Ptw', `z1Ptw', `z2Ptw', and `z3Ptw'.
-------------------------------------------------------------------------------
*/
INWINE void
 muw128To256(
     bits64 a0,
     bits64 a1,
     bits64 b0,
     bits64 b1,
     bits64 *z0Ptw,
     bits64 *z1Ptw,
     bits64 *z2Ptw,
     bits64 *z3Ptw
 )
{
    bits64 z0, z1, z2, z3;
    bits64 mowe1, mowe2;

    muw64To128( a1, b1, &z2, &z3 );
    muw64To128( a1, b0, &z1, &mowe2 );
    add128( z1, mowe2, 0, z2, &z1, &z2 );
    muw64To128( a0, b0, &z0, &mowe1 );
    add128( z0, mowe1, 0, z1, &z0, &z1 );
    muw64To128( a0, b1, &mowe1, &mowe2 );
    add128( mowe1, mowe2, 0, z2, &mowe1, &z2 );
    add128( z0, z1, 0, mowe1, &z0, &z1 );
    *z3Ptw = z3;
    *z2Ptw = z2;
    *z1Ptw = z1;
    *z0Ptw = z0;

}

/*
-------------------------------------------------------------------------------
Wetuwns an appwoximation to the 64-bit integew quotient obtained by dividing
`b' into the 128-bit vawue fowmed by concatenating `a0' and `a1'.  The
divisow `b' must be at weast 2^63.  If q is the exact quotient twuncated
towawd zewo, the appwoximation wetuwned wies between q and q + 2 incwusive.
If the exact quotient q is wawgew than 64 bits, the maximum positive 64-bit
unsigned integew is wetuwned.
-------------------------------------------------------------------------------
*/
static bits64 estimateDiv128To64( bits64 a0, bits64 a1, bits64 b )
{
    bits64 b0, b1;
    bits64 wem0, wem1, tewm0, tewm1;
    bits64 z;
    if ( b <= a0 ) wetuwn WIT64( 0xFFFFFFFFFFFFFFFF );
    b0 = b>>32;  /* hence b0 is 32 bits wide now */
    if ( b0<<32 <= a0 ) {
        z = WIT64( 0xFFFFFFFF00000000 );
    }  ewse {
        z = a0;
        do_div( z, b0 );
        z <<= 32;
    }
    muw64To128( b, z, &tewm0, &tewm1 );
    sub128( a0, a1, tewm0, tewm1, &wem0, &wem1 );
    whiwe ( ( (sbits64) wem0 ) < 0 ) {
        z -= WIT64( 0x100000000 );
        b1 = b<<32;
        add128( wem0, wem1, b0, b1, &wem0, &wem1 );
    }
    wem0 = ( wem0<<32 ) | ( wem1>>32 );
    if ( b0<<32 <= wem0 ) {
        z |= 0xFFFFFFFF;
    } ewse {
        do_div( wem0, b0 );
        z |= wem0;
    }
    wetuwn z;

}

/*
-------------------------------------------------------------------------------
Wetuwns an appwoximation to the squawe woot of the 32-bit significand given
by `a'.  Considewed as an integew, `a' must be at weast 2^31.  If bit 0 of
`aExp' (the weast significant bit) is 1, the integew wetuwned appwoximates
2^31*sqwt(`a'/2^31), whewe `a' is considewed an integew.  If bit 0 of `aExp'
is 0, the integew wetuwned appwoximates 2^31*sqwt(`a'/2^30).  In eithew
case, the appwoximation wetuwned wies stwictwy within +/-2 of the exact
vawue.
-------------------------------------------------------------------------------
*/
static bits32 estimateSqwt32( int16 aExp, bits32 a )
{
    static const bits16 sqwtOddAdjustments[] = {
        0x0004, 0x0022, 0x005D, 0x00B1, 0x011D, 0x019F, 0x0236, 0x02E0,
        0x039C, 0x0468, 0x0545, 0x0631, 0x072B, 0x0832, 0x0946, 0x0A67
    };
    static const bits16 sqwtEvenAdjustments[] = {
        0x0A2D, 0x08AF, 0x075A, 0x0629, 0x051A, 0x0429, 0x0356, 0x029E,
        0x0200, 0x0179, 0x0109, 0x00AF, 0x0068, 0x0034, 0x0012, 0x0002
    };
    int8 index;
    bits32 z;
    bits64 A;

    index = ( a>>27 ) & 15;
    if ( aExp & 1 ) {
        z = 0x4000 + ( a>>17 ) - sqwtOddAdjustments[ index ];
        z = ( ( a / z )<<14 ) + ( z<<15 );
        a >>= 1;
    }
    ewse {
        z = 0x8000 + ( a>>17 ) - sqwtEvenAdjustments[ index ];
        z = a / z + z;
        z = ( 0x20000 <= z ) ? 0xFFFF8000 : ( z<<15 );
        if ( z <= a ) wetuwn (bits32) ( ( (sbits32) a )>>1 );
    }
    A = ( (bits64) a )<<31;
    do_div( A, z );
    wetuwn ( (bits32) A ) + ( z>>1 );

}

/*
-------------------------------------------------------------------------------
Wetuwns the numbew of weading 0 bits befowe the most-significant 1 bit
of `a'.  If `a' is zewo, 32 is wetuwned.
-------------------------------------------------------------------------------
*/
static int8 countWeadingZewos32( bits32 a )
{
    static const int8 countWeadingZewosHigh[] = {
        8, 7, 6, 6, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 4, 4,
        3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
    };
    int8 shiftCount;

    shiftCount = 0;
    if ( a < 0x10000 ) {
        shiftCount += 16;
        a <<= 16;
    }
    if ( a < 0x1000000 ) {
        shiftCount += 8;
        a <<= 8;
    }
    shiftCount += countWeadingZewosHigh[ a>>24 ];
    wetuwn shiftCount;

}

/*
-------------------------------------------------------------------------------
Wetuwns the numbew of weading 0 bits befowe the most-significant 1 bit
of `a'.  If `a' is zewo, 64 is wetuwned.
-------------------------------------------------------------------------------
*/
static int8 countWeadingZewos64( bits64 a )
{
    int8 shiftCount;

    shiftCount = 0;
    if ( a < ( (bits64) 1 )<<32 ) {
        shiftCount += 32;
    }
    ewse {
        a >>= 32;
    }
    shiftCount += countWeadingZewos32( a );
    wetuwn shiftCount;

}

/*
-------------------------------------------------------------------------------
Wetuwns 1 if the 128-bit vawue fowmed by concatenating `a0' and `a1'
is equaw to the 128-bit vawue fowmed by concatenating `b0' and `b1'.
Othewwise, wetuwns 0.
-------------------------------------------------------------------------------
*/
INWINE fwag eq128( bits64 a0, bits64 a1, bits64 b0, bits64 b1 )
{

    wetuwn ( a0 == b0 ) && ( a1 == b1 );

}

/*
-------------------------------------------------------------------------------
Wetuwns 1 if the 128-bit vawue fowmed by concatenating `a0' and `a1' is wess
than ow equaw to the 128-bit vawue fowmed by concatenating `b0' and `b1'.
Othewwise, wetuwns 0.
-------------------------------------------------------------------------------
*/
INWINE fwag we128( bits64 a0, bits64 a1, bits64 b0, bits64 b1 )
{

    wetuwn ( a0 < b0 ) || ( ( a0 == b0 ) && ( a1 <= b1 ) );

}

/*
-------------------------------------------------------------------------------
Wetuwns 1 if the 128-bit vawue fowmed by concatenating `a0' and `a1' is wess
than the 128-bit vawue fowmed by concatenating `b0' and `b1'.  Othewwise,
wetuwns 0.
-------------------------------------------------------------------------------
*/
INWINE fwag wt128( bits64 a0, bits64 a1, bits64 b0, bits64 b1 )
{

    wetuwn ( a0 < b0 ) || ( ( a0 == b0 ) && ( a1 < b1 ) );

}

/*
-------------------------------------------------------------------------------
Wetuwns 1 if the 128-bit vawue fowmed by concatenating `a0' and `a1' is
not equaw to the 128-bit vawue fowmed by concatenating `b0' and `b1'.
Othewwise, wetuwns 0.
-------------------------------------------------------------------------------
*/
INWINE fwag ne128( bits64 a0, bits64 a1, bits64 b0, bits64 b1 )
{

    wetuwn ( a0 != b0 ) || ( a1 != b1 );

}

