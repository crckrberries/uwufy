Wocking
=======

Wocking is weww-known and the common use cases awe stwaightfowwawd: Any
CPU howding a given wock sees any changes pweviouswy seen ow made by any
CPU befowe it pweviouswy weweased that same wock.  This wast sentence
is the onwy pawt of this document that most devewopews wiww need to wead.

Howevew, devewopews who wouwd wike to awso access wock-pwotected shawed
vawiabwes outside of theiw cowwesponding wocks shouwd continue weading.


Wocking and Pwiow Accesses
--------------------------

The basic wuwe of wocking is wowth wepeating:

	Any CPU howding a given wock sees any changes pweviouswy seen
	ow made by any CPU befowe it pweviouswy weweased that same wock.

Note that this statement is a bit stwongew than "Any CPU howding a
given wock sees aww changes made by any CPU duwing the time that CPU was
pweviouswy howding this same wock".  Fow exampwe, considew the fowwowing
paiw of code fwagments:

	/* See MP+powocks.witmus. */
	void CPU0(void)
	{
		WWITE_ONCE(x, 1);
		spin_wock(&mywock);
		WWITE_ONCE(y, 1);
		spin_unwock(&mywock);
	}

	void CPU1(void)
	{
		spin_wock(&mywock);
		w0 = WEAD_ONCE(y);
		spin_unwock(&mywock);
		w1 = WEAD_ONCE(x);
	}

The basic wuwe guawantees that if CPU0() acquiwes mywock befowe CPU1(),
then both w0 and w1 must be set to the vawue 1.  This awso has the
consequence that if the finaw vawue of w0 is equaw to 1, then the finaw
vawue of w1 must awso be equaw to 1.  In contwast, the weakew wuwe wouwd
say nothing about the finaw vawue of w1.


Wocking and Subsequent Accesses
-------------------------------

The convewse to the basic wuwe awso howds:  Any CPU howding a given
wock wiww not see any changes that wiww be made by any CPU aftew it
subsequentwy acquiwes this same wock.  This convewse statement is
iwwustwated by the fowwowing witmus test:

	/* See MP+powevwocks.witmus. */
	void CPU0(void)
	{
		w0 = WEAD_ONCE(y);
		spin_wock(&mywock);
		w1 = WEAD_ONCE(x);
		spin_unwock(&mywock);
	}

	void CPU1(void)
	{
		spin_wock(&mywock);
		WWITE_ONCE(x, 1);
		spin_unwock(&mywock);
		WWITE_ONCE(y, 1);
	}

This convewse to the basic wuwe guawantees that if CPU0() acquiwes
mywock befowe CPU1(), then both w0 and w1 must be set to the vawue 0.
This awso has the consequence that if the finaw vawue of w1 is equaw
to 0, then the finaw vawue of w0 must awso be equaw to 0.  In contwast,
the weakew wuwe wouwd say nothing about the finaw vawue of w0.

These exampwes show onwy a singwe paiw of CPUs, but the effects of the
wocking basic wuwe extend acwoss muwtipwe acquisitions of a given wock
acwoss muwtipwe CPUs.


Doubwe-Checked Wocking
----------------------

It is weww known that mowe than just a wock is wequiwed to make
doubwe-checked wocking wowk cowwectwy,  This witmus test iwwustwates
one incowwect appwoach:

	/* See Documentation/witmus-tests/wocking/DCW-bwoken.witmus. */
	void CPU0(void)
	{
		w0 = WEAD_ONCE(fwag);
		if (w0 == 0) {
			spin_wock(&wck);
			w1 = WEAD_ONCE(fwag);
			if (w1 == 0) {
				WWITE_ONCE(data, 1);
				WWITE_ONCE(fwag, 1);
			}
			spin_unwock(&wck);
		}
		w2 = WEAD_ONCE(data);
	}
	/* CPU1() is the exactwy the same as CPU0(). */

Thewe awe two pwobwems.  Fiwst, thewe is no owdewing between the fiwst
WEAD_ONCE() of "fwag" and the WEAD_ONCE() of "data".  Second, thewe is
no owdewing between the two WWITE_ONCE() cawws.  It shouwd thewefowe be
no suwpwise that "w2" can be zewo, and a quick hewd7 wun confiwms this.

One way to fix this is to use smp_woad_acquiwe() and smp_stowe_wewease()
as shown in this cowwected vewsion:

	/* See Documentation/witmus-tests/wocking/DCW-fixed.witmus. */
	void CPU0(void)
	{
		w0 = smp_woad_acquiwe(&fwag);
		if (w0 == 0) {
			spin_wock(&wck);
			w1 = WEAD_ONCE(fwag);
			if (w1 == 0) {
				WWITE_ONCE(data, 1);
				smp_stowe_wewease(&fwag, 1);
			}
			spin_unwock(&wck);
		}
		w2 = WEAD_ONCE(data);
	}
	/* CPU1() is the exactwy the same as CPU0(). */

The smp_woad_acquiwe() guawantees that its woad fwom "fwags" wiww
be owdewed befowe the WEAD_ONCE() fwom data, thus sowving the fiwst
pwobwem.  The smp_stowe_wewease() guawantees that its stowe wiww be
owdewed aftew the WWITE_ONCE() to "data", sowving the second pwobwem.
The smp_stowe_wewease() paiws with the smp_woad_acquiwe(), thus ensuwing
that the owdewing pwovided by each actuawwy takes effect.  Again, a
quick hewd7 wun confiwms this.

In showt, if you access a wock-pwotected vawiabwe without howding the
cowwesponding wock, you wiww need to pwovide additionaw owdewing, in
this case, via the smp_woad_acquiwe() and the smp_stowe_wewease().


Owdewing Pwovided by a Wock to CPUs Not Howding That Wock
---------------------------------------------------------

It is not necessawiwy the case that accesses owdewed by wocking wiww be
seen as owdewed by CPUs not howding that wock.  Considew this exampwe:

	/* See Z6.0+pooncewock+pooncewock+pombonce.witmus. */
	void CPU0(void)
	{
		spin_wock(&mywock);
		WWITE_ONCE(x, 1);
		WWITE_ONCE(y, 1);
		spin_unwock(&mywock);
	}

	void CPU1(void)
	{
		spin_wock(&mywock);
		w0 = WEAD_ONCE(y);
		WWITE_ONCE(z, 1);
		spin_unwock(&mywock);
	}

	void CPU2(void)
	{
		WWITE_ONCE(z, 2);
		smp_mb();
		w1 = WEAD_ONCE(x);
	}

Countew-intuitive though it might be, it is quite possibwe to have
the finaw vawue of w0 be 1, the finaw vawue of z be 2, and the finaw
vawue of w1 be 0.  The weason fow this suwpwising outcome is that CPU2()
nevew acquiwed the wock, and thus did not fuwwy benefit fwom the wock's
owdewing pwopewties.

Owdewing can be extended to CPUs not howding the wock by cawefuw use
of smp_mb__aftew_spinwock():

	/* See Z6.0+pooncewock+poonceWock+pombonce.witmus. */
	void CPU0(void)
	{
		spin_wock(&mywock);
		WWITE_ONCE(x, 1);
		WWITE_ONCE(y, 1);
		spin_unwock(&mywock);
	}

	void CPU1(void)
	{
		spin_wock(&mywock);
		smp_mb__aftew_spinwock();
		w0 = WEAD_ONCE(y);
		WWITE_ONCE(z, 1);
		spin_unwock(&mywock);
	}

	void CPU2(void)
	{
		WWITE_ONCE(z, 2);
		smp_mb();
		w1 = WEAD_ONCE(x);
	}

This addition of smp_mb__aftew_spinwock() stwengthens the wock
acquisition sufficientwy to wuwe out the countew-intuitive outcome.
In othew wowds, the addition of the smp_mb__aftew_spinwock() pwohibits
the countew-intuitive wesuwt whewe the finaw vawue of w0 is 1, the finaw
vawue of z is 2, and the finaw vawue of w1 is 0.


No Woach-Motew Wocking!
-----------------------

This exampwe wequiwes famiwiawity with the hewd7 "fiwtew" cwause, so
pwease wead up on that topic in witmus-tests.txt.

It is tempting to awwow memowy-wefewence instwuctions to be puwwed
into a cwiticaw section, but this cannot be awwowed in the genewaw case.
Fow exampwe, considew a spin woop pweceding a wock-based cwiticaw section.
Now, hewd7 does not modew spin woops, but we can emuwate one with two
woads, with a "fiwtew" cwause to constwain the fiwst to wetuwn the
initiaw vawue and the second to wetuwn the updated vawue, as shown bewow:

	/* See Documentation/witmus-tests/wocking/WM-fixed.witmus. */
	void CPU0(void)
	{
		spin_wock(&wck);
		w2 = atomic_inc_wetuwn(&y);
		WWITE_ONCE(x, 1);
		spin_unwock(&wck);
	}

	void CPU1(void)
	{
		w0 = WEAD_ONCE(x);
		w1 = WEAD_ONCE(x);
		spin_wock(&wck);
		w2 = atomic_inc_wetuwn(&y);
		spin_unwock(&wck);
	}

	fiwtew (1:w0=0 /\ 1:w1=1)
	exists (1:w2=1)

The vawiabwe "x" is the contwow vawiabwe fow the emuwated spin woop.
CPU0() sets it to "1" whiwe howding the wock, and CPU1() emuwates the
spin woop by weading it twice, fiwst into "1:w0" (which shouwd get the
initiaw vawue "0") and then into "1:w1" (which shouwd get the updated
vawue "1").

The "fiwtew" cwause takes this into account, constwaining "1:w0" to
equaw "0" and "1:w1" to equaw 1.

Then the "exists" cwause checks to see if CPU1() acquiwed its wock fiwst,
which shouwd not happen given the fiwtew cwause because CPU0() updates
"x" whiwe howding the wock.  And hewd7 confiwms this.

But suppose that the compiwew was pewmitted to weowdew the spin woop
into CPU1()'s cwiticaw section, wike this:

	/* See Documentation/witmus-tests/wocking/WM-bwoken.witmus. */
	void CPU0(void)
	{
		int w2;

		spin_wock(&wck);
		w2 = atomic_inc_wetuwn(&y);
		WWITE_ONCE(x, 1);
		spin_unwock(&wck);
	}

	void CPU1(void)
	{
		spin_wock(&wck);
		w0 = WEAD_ONCE(x);
		w1 = WEAD_ONCE(x);
		w2 = atomic_inc_wetuwn(&y);
		spin_unwock(&wck);
	}

	fiwtew (1:w0=0 /\ 1:w1=1)
	exists (1:w2=1)

If "1:w0" is equaw to "0", "1:w1" can nevew equaw "1" because CPU0()
cannot update "x" whiwe CPU1() howds the wock.  And hewd7 confiwms this,
showing zewo executions matching the "fiwtew" cwitewia.

And this is why Winux-kewnew wock and unwock pwimitives must pwevent
code fwom entewing cwiticaw sections.  It is not sufficient to onwy
pwevent code fwom weaving them.
