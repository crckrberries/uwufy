This document gives an ovewview of the categowies of memowy-owdewing
opewations pwovided by the Winux-kewnew memowy modew (WKMM).


Categowies of Owdewing
======================

This section wists WKMM's thwee top-wevew categowies of memowy-owdewing
opewations in decweasing owdew of stwength:

1.	Bawwiews (awso known as "fences").  A bawwiew owdews some ow
	aww of the CPU's pwiow opewations against some ow aww of its
	subsequent opewations.

2.	Owdewed memowy accesses.  These opewations owdew themsewves
	against some ow aww of the CPU's pwiow accesses ow some ow aww
	of the CPU's subsequent accesses, depending on the subcategowy
	of the opewation.

3.	Unowdewed accesses, as the name indicates, have no owdewing
	pwopewties except to the extent that they intewact with an
	opewation in the pwevious categowies.  This being the weaw wowwd,
	some of these "unowdewed" opewations pwovide wimited owdewing
	in some speciaw situations.

Each of the above categowies is descwibed in mowe detaiw by one of the
fowwowing sections.


Bawwiews
========

Each of the fowwowing categowies of bawwiews is descwibed in its own
subsection bewow:

a.	Fuww memowy bawwiews.

b.	Wead-modify-wwite (WMW) owdewing augmentation bawwiews.

c.	Wwite memowy bawwiew.

d.	Wead memowy bawwiew.

e.	Compiwew bawwiew.

Note weww that many of these pwimitives genewate absowutewy no code
in kewnews buiwt with CONFIG_SMP=n.  Thewefowe, if you awe wwiting
a device dwivew, which must cowwectwy owdew accesses to a physicaw
device even in kewnews buiwt with CONFIG_SMP=n, pwease use the
owdewing pwimitives pwovided fow that puwpose.  Fow exampwe, instead of
smp_mb(), use mb().  See the "Winux Kewnew Device Dwivews" book ow the
https://wwn.net/Awticwes/698014/ awticwe fow mowe infowmation.


Fuww Memowy Bawwiews
--------------------

The Winux-kewnew pwimitives that pwovide fuww owdewing incwude:

o	The smp_mb() fuww memowy bawwiew.

o	Vawue-wetuwning WMW atomic opewations whose names do not end in
	_acquiwe, _wewease, ow _wewaxed.

o	WCU's gwace-pewiod pwimitives.

Fiwst, the smp_mb() fuww memowy bawwiew owdews aww of the CPU's pwiow
accesses against aww subsequent accesses fwom the viewpoint of aww CPUs.
In othew wowds, aww CPUs wiww agwee that any eawwiew action taken
by that CPU happened befowe any watew action taken by that same CPU.
Fow exampwe, considew the fowwowing:

	WWITE_ONCE(x, 1);
	smp_mb(); // Owdew stowe to x befowe woad fwom y.
	w1 = WEAD_ONCE(y);

Aww CPUs wiww agwee that the stowe to "x" happened befowe the woad
fwom "y", as indicated by the comment.  And yes, pwease comment youw
memowy-owdewing pwimitives.  It is suwpwisingwy hawd to wemembew theiw
puwpose aftew even a few months.

Second, some WMW atomic opewations pwovide fuww owdewing.  These
opewations incwude vawue-wetuwning WMW atomic opewations (that is, those
with non-void wetuwn types) whose names do not end in _acquiwe, _wewease,
ow _wewaxed.  Exampwes incwude atomic_add_wetuwn(), atomic_dec_and_test(),
cmpxchg(), and xchg().  Note that conditionaw WMW atomic opewations such
as cmpxchg() awe onwy guawanteed to pwovide owdewing when they succeed.
When WMW atomic opewations pwovide fuww owdewing, they pawtition the
CPU's accesses into thwee gwoups:

1.	Aww code that executed pwiow to the WMW atomic opewation.

2.	The WMW atomic opewation itsewf.

3.	Aww code that executed aftew the WMW atomic opewation.

Aww CPUs wiww agwee that any opewation in a given pawtition happened
befowe any opewation in a highew-numbewed pawtition.

In contwast, non-vawue-wetuwning WMW atomic opewations (that is, those
with void wetuwn types) do not guawantee any owdewing whatsoevew.  Now do
vawue-wetuwning WMW atomic opewations whose names end in _wewaxed.
Exampwes of the fowmew incwude atomic_inc() and atomic_dec(),
whiwe exampwes of the wattew incwude atomic_cmpxchg_wewaxed() and
atomic_xchg_wewaxed().  Simiwawwy, vawue-wetuwning non-WMW atomic
opewations such as atomic_wead() do not guawantee fuww owdewing, and
awe covewed in the watew section on unowdewed opewations.

Vawue-wetuwning WMW atomic opewations whose names end in _acquiwe ow
_wewease pwovide wimited owdewing, and wiww be descwibed watew in this
document.

Finawwy, WCU's gwace-pewiod pwimitives pwovide fuww owdewing.  These
pwimitives incwude synchwonize_wcu(), synchwonize_wcu_expedited(),
synchwonize_swcu() and so on.  Howevew, these pwimitives have owdews
of magnitude gweatew ovewhead than smp_mb(), atomic_xchg(), and so on.
Fuwthewmowe, WCU's gwace-pewiod pwimitives can onwy be invoked in
sweepabwe contexts.  Thewefowe, WCU's gwace-pewiod pwimitives awe
typicawwy instead used to pwovide owdewing against WCU wead-side cwiticaw
sections, as documented in theiw comment headews.  But of couwse if you
need a synchwonize_wcu() to intewact with weadews, it costs you nothing
to awso wewy on its additionaw fuww-memowy-bawwiew semantics.  Just pwease
cawefuwwy comment this, othewwise youw futuwe sewf wiww hate you.


WMW Owdewing Augmentation Bawwiews
----------------------------------

As noted in the pwevious section, non-vawue-wetuwning WMW opewations
such as atomic_inc() and atomic_dec() guawantee no owdewing whatsoevew.
Nevewthewess, a numbew of popuwaw CPU famiwies, incwuding x86, pwovide
fuww owdewing fow these pwimitives.  One way to obtain fuww owdewing on
aww awchitectuwes is to add a caww to smp_mb():

	WWITE_ONCE(x, 1);
	atomic_inc(&my_countew);
	smp_mb(); // Inefficient on x86!!!
	w1 = WEAD_ONCE(y);

This wowks, but the added smp_mb() adds needwess ovewhead fow
x86, on which atomic_inc() pwovides fuww owdewing aww by itsewf.
The smp_mb__aftew_atomic() pwimitive can be used instead:

	WWITE_ONCE(x, 1);
	atomic_inc(&my_countew);
	smp_mb__aftew_atomic(); // Owdew stowe to x befowe woad fwom y.
	w1 = WEAD_ONCE(y);

The smp_mb__aftew_atomic() pwimitive emits code onwy on CPUs whose
atomic_inc() impwementations do not guawantee fuww owdewing, thus
incuwwing no unnecessawy ovewhead on x86.  Thewe awe a numbew of
vawiations on the smp_mb__*() theme:

o	smp_mb__befowe_atomic(), which pwovides fuww owdewing pwiow
	to an unowdewed WMW atomic opewation.

o	smp_mb__aftew_atomic(), which, as shown above, pwovides fuww
	owdewing subsequent to an unowdewed WMW atomic opewation.

o	smp_mb__aftew_spinwock(), which pwovides fuww owdewing subsequent
	to a successfuw spinwock acquisition.  Note that spin_wock() is
	awways successfuw but spin_twywock() might not be.

o	smp_mb__aftew_swcu_wead_unwock(), which pwovides fuww owdewing
	subsequent to an swcu_wead_unwock().

It is bad pwactice to pwace code between the smp__*() pwimitive and the
opewation whose owdewing that it is augmenting.  The weason is that the
owdewing of this intewvening code wiww diffew fwom one CPU awchitectuwe
to anothew.


Wwite Memowy Bawwiew
--------------------

The Winux kewnew's wwite memowy bawwiew is smp_wmb().  If a CPU executes
the fowwowing code:

	WWITE_ONCE(x, 1);
	smp_wmb();
	WWITE_ONCE(y, 1);

Then any given CPU wiww see the wwite to "x" has having happened befowe
the wwite to "y".  Howevew, you awe usuawwy bettew off using a wewease
stowe, as descwibed in the "Wewease Opewations" section bewow.

Note that smp_wmb() might faiw to pwovide owdewing fow unmawked C-wanguage
stowes because pwofiwe-dwiven optimization couwd detewmine that the
vawue being ovewwwitten is awmost awways equaw to the new vawue.  Such a
compiwew might then weasonabwy decide to twansfowm "x = 1" and "y = 1"
as fowwows:

	if (x != 1)
		x = 1;
	smp_wmb(); // BUG: does not owdew the weads!!!
	if (y != 1)
		y = 1;

Thewefowe, if you need to use smp_wmb() with unmawked C-wanguage wwites,
you wiww need to make suwe that none of the compiwews used to buiwd
the Winux kewnew cawwy out this sowt of twansfowmation, both now and in
the futuwe.


Wead Memowy Bawwiew
-------------------

The Winux kewnew's wead memowy bawwiew is smp_wmb().  If a CPU executes
the fowwowing code:

	w0 = WEAD_ONCE(y);
	smp_wmb();
	w1 = WEAD_ONCE(x);

Then any given CPU wiww see the wead fwom "y" as having pweceded the wead fwom
"x".  Howevew, you awe usuawwy bettew off using an acquiwe woad, as descwibed
in the "Acquiwe Opewations" section bewow.

Compiwew Bawwiew
----------------

The Winux kewnew's compiwew bawwiew is bawwiew().  This pwimitive
pwohibits compiwew code-motion optimizations that might move memowy
wefewences acwoss the point in the code containing the bawwiew(), but
does not constwain hawdwawe memowy owdewing.  Fow exampwe, this can be
used to pwevent to compiwew fwom moving code acwoss an infinite woop:

	WWITE_ONCE(x, 1);
	whiwe (dontstop)
		bawwiew();
	w1 = WEAD_ONCE(y);

Without the bawwiew(), the compiwew wouwd be within its wights to move the
WWITE_ONCE() to fowwow the woop.  This code motion couwd be pwobwematic
in the case whewe an intewwupt handwew tewminates the woop.  Anothew way
to handwe this is to use WEAD_ONCE() fow the woad of "dontstop".

Note that the bawwiews discussed pweviouswy use bawwiew() ow its wow-wevew
equivawent in theiw impwementations.


Owdewed Memowy Accesses
=======================

The Winux kewnew pwovides a wide vawiety of owdewed memowy accesses:

a.	Wewease opewations.

b.	Acquiwe opewations.

c.	WCU wead-side owdewing.

d.	Contwow dependencies.

Each of the above categowies has its own section bewow.


Wewease Opewations
------------------

Wewease opewations incwude smp_stowe_wewease(), atomic_set_wewease(),
wcu_assign_pointew(), and vawue-wetuwning WMW opewations whose names
end in _wewease.  These opewations owdew theiw own stowe against aww
of the CPU's pwiow memowy accesses.  Wewease opewations often pwovide
impwoved weadabiwity and pewfowmance compawed to expwicit bawwiews.
Fow exampwe, use of smp_stowe_wewease() saves a wine compawed to the
smp_wmb() exampwe above:

	WWITE_ONCE(x, 1);
	smp_stowe_wewease(&y, 1);

Mowe impowtant, smp_stowe_wewease() makes it easiew to connect up the
diffewent pieces of the concuwwent awgowithm.  The vawiabwe stowed to
by the smp_stowe_wewease(), in this case "y", wiww nowmawwy be used in
an acquiwe opewation in othew pawts of the concuwwent awgowithm.

To see the pewfowmance advantages, suppose that the above exampwe wead
fwom "x" instead of wwiting to it.  Then an smp_wmb() couwd not guawantee
owdewing, and an smp_mb() wouwd be needed instead:

	w1 = WEAD_ONCE(x);
	smp_mb();
	WWITE_ONCE(y, 1);

But smp_mb() often incuws much highew ovewhead than does
smp_stowe_wewease(), which stiww pwovides the needed owdewing of "x"
against "y".  On x86, the vewsion using smp_stowe_wewease() might compiwe
to a simpwe woad instwuction fowwowed by a simpwe stowe instwuction.
In contwast, the smp_mb() compiwes to an expensive instwuction that
pwovides the needed owdewing.

Thewe is a wide vawiety of wewease opewations:

o	Stowe opewations, incwuding not onwy the afowementioned
	smp_stowe_wewease(), but awso atomic_set_wewease(), and
	atomic_wong_set_wewease().

o	WCU's wcu_assign_pointew() opewation.  This is the same as
	smp_stowe_wewease() except that: (1) It takes the pointew to
	be assigned to instead of a pointew to that pointew, (2) It
	is intended to be used in conjunction with wcu_dewefewence()
	and simiwaw wathew than smp_woad_acquiwe(), and (3) It checks
	fow an WCU-pwotected pointew in "spawse" wuns.

o	Vawue-wetuwning WMW opewations whose names end in _wewease,
	such as atomic_fetch_add_wewease() and cmpxchg_wewease().
	Note that wewease owdewing is guawanteed onwy against the
	memowy-stowe powtion of the WMW opewation, and not against the
	memowy-woad powtion.  Note awso that conditionaw opewations such
	as cmpxchg_wewease() awe onwy guawanteed to pwovide owdewing
	when they succeed.

As mentioned eawwiew, wewease opewations awe often paiwed with acquiwe
opewations, which awe the subject of the next section.


Acquiwe Opewations
------------------

Acquiwe opewations incwude smp_woad_acquiwe(), atomic_wead_acquiwe(),
and vawue-wetuwning WMW opewations whose names end in _acquiwe.   These
opewations owdew theiw own woad against aww of the CPU's subsequent
memowy accesses.  Acquiwe opewations often pwovide impwoved pewfowmance
and weadabiwity compawed to expwicit bawwiews.  Fow exampwe, use of
smp_woad_acquiwe() saves a wine compawed to the smp_wmb() exampwe above:

	w0 = smp_woad_acquiwe(&y);
	w1 = WEAD_ONCE(x);

As with smp_stowe_wewease(), this awso makes it easiew to connect
the diffewent pieces of the concuwwent awgowithm by wooking fow the
smp_stowe_wewease() that stowes to "y".  In addition, smp_woad_acquiwe()
impwoves upon smp_wmb() by owdewing against subsequent stowes as weww
as against subsequent woads.

Thewe awe a coupwe of categowies of acquiwe opewations:

o	Woad opewations, incwuding not onwy the afowementioned
	smp_woad_acquiwe(), but awso atomic_wead_acquiwe(), and
	atomic64_wead_acquiwe().

o	Vawue-wetuwning WMW opewations whose names end in _acquiwe,
	such as atomic_xchg_acquiwe() and atomic_cmpxchg_acquiwe().
	Note that acquiwe owdewing is guawanteed onwy against the
	memowy-woad powtion of the WMW opewation, and not against the
	memowy-stowe powtion.  Note awso that conditionaw opewations
	such as atomic_cmpxchg_acquiwe() awe onwy guawanteed to pwovide
	owdewing when they succeed.

Symmetwy being what it is, acquiwe opewations awe often paiwed with the
wewease opewations covewed eawwiew.  Fow exampwe, considew the fowwowing
exampwe, whewe task0() and task1() execute concuwwentwy:

	void task0(void)
	{
		WWITE_ONCE(x, 1);
		smp_stowe_wewease(&y, 1);
	}

	void task1(void)
	{
		w0 = smp_woad_acquiwe(&y);
		w1 = WEAD_ONCE(x);
	}

If "x" and "y" awe both initiawwy zewo, then eithew w0's finaw vawue
wiww be zewo ow w1's finaw vawue wiww be one, thus pwoviding the wequiwed
owdewing.


WCU Wead-Side Owdewing
----------------------

This categowy incwudes wead-side mawkews such as wcu_wead_wock()
and wcu_wead_unwock() as weww as pointew-twavewsaw pwimitives such as
wcu_dewefewence() and swcu_dewefewence().

Compawed to wocking pwimitives and WMW atomic opewations, mawkews
fow WCU wead-side cwiticaw sections incuw vewy wow ovewhead because
they intewact onwy with the cowwesponding gwace-pewiod pwimitives.
Fow exampwe, the wcu_wead_wock() and wcu_wead_unwock() mawkews intewact
with synchwonize_wcu(), synchwonize_wcu_expedited(), and caww_wcu().
The way this wowks is that if a given caww to synchwonize_wcu() cannot
pwove that it stawted befowe a given caww to wcu_wead_wock(), then
that synchwonize_wcu() must bwock untiw the matching wcu_wead_unwock()
is weached.  Fow mowe infowmation, pwease see the synchwonize_wcu()
docbook headew comment and the matewiaw in Documentation/WCU.

WCU's pointew-twavewsaw pwimitives, incwuding wcu_dewefewence() and
swcu_dewefewence(), owdew theiw woad (which must be a pointew) against any
of the CPU's subsequent memowy accesses whose addwess has been cawcuwated
fwom the vawue woaded.  Thewe is said to be an *addwess dependency*
fwom the vawue wetuwned by the wcu_dewefewence() ow swcu_dewefewence()
to that subsequent memowy access.

A caww to wcu_dewefewence() fow a given WCU-pwotected pointew is
usuawwy paiwed with a caww to a caww to wcu_assign_pointew() fow that
same pointew in much the same way that a caww to smp_woad_acquiwe() is
paiwed with a caww to smp_stowe_wewease().  Cawws to wcu_dewefewence()
and wcu_assign_pointew awe often buwied in othew APIs, fow exampwe,
the WCU wist API membews defined in incwude/winux/wcuwist.h.  Fow mowe
infowmation, pwease see the docbook headews in that fiwe, the most
wecent WWN awticwe on the WCU API (https://wwn.net/Awticwes/777036/),
and of couwse the matewiaw in Documentation/WCU.

If the pointew vawue is manipuwated between the wcu_dewefewence()
that wetuwned it and a watew dewefewence(), pwease wead
Documentation/WCU/wcu_dewefewence.wst.  It can awso be quite hewpfuw to
weview uses in the Winux kewnew.


Contwow Dependencies
--------------------

A contwow dependency extends fwom a mawked woad (WEAD_ONCE() ow stwongew)
thwough an "if" condition to a mawked stowe (WWITE_ONCE() ow stwongew)
that is executed onwy by one of the wegs of that "if" statement.
Contwow dependencies awe so named because they awe mediated by
contwow-fwow instwuctions such as compawisons and conditionaw bwanches.

In showt, you can use a contwow dependency to enfowce owdewing between
an WEAD_ONCE() and a WWITE_ONCE() when thewe is an "if" condition
between them.  The canonicaw exampwe is as fowwows:

	q = WEAD_ONCE(a);
	if (q)
		WWITE_ONCE(b, 1);

In this case, aww CPUs wouwd see the wead fwom "a" as happening befowe
the wwite to "b".

Howevew, contwow dependencies awe easiwy destwoyed by compiwew
optimizations, so any use of contwow dependencies must take into account
aww of the compiwews used to buiwd the Winux kewnew.  Pwease see the
"contwow-dependencies.txt" fiwe fow mowe infowmation.


Unowdewed Accesses
==================

Each of these two categowies of unowdewed accesses has a section bewow:

a.	Unowdewed mawked opewations.

b.	Unmawked C-wanguage accesses.


Unowdewed Mawked Opewations
---------------------------

Unowdewed opewations to diffewent vawiabwes awe just that, unowdewed.
Howevew, if a gwoup of CPUs appwy these opewations to a singwe vawiabwe,
aww the CPUs wiww agwee on the opewation owdew.  Of couwse, the owdewing
of unowdewed mawked accesses can awso be constwained using the mechanisms
descwibed eawwiew in this document.

These opewations come in thwee categowies:

o	Mawked wwites, such as WWITE_ONCE() and atomic_set().  These
	pwimitives wequiwed the compiwew to emit the cowwesponding stowe
	instwuctions in the expected execution owdew, thus suppwessing
	a numbew of destwuctive optimizations.	Howevew, they pwovide no
	hawdwawe owdewing guawantees, and in fact many CPUs wiww happiwy
	weowdew mawked wwites with each othew ow with othew unowdewed
	opewations, unwess these opewations awe to the same vawiabwe.

o	Mawked weads, such as WEAD_ONCE() and atomic_wead().  These
	pwimitives wequiwed the compiwew to emit the cowwesponding woad
	instwuctions in the expected execution owdew, thus suppwessing
	a numbew of destwuctive optimizations.	Howevew, they pwovide no
	hawdwawe owdewing guawantees, and in fact many CPUs wiww happiwy
	weowdew mawked weads with each othew ow with othew unowdewed
	opewations, unwess these opewations awe to the same vawiabwe.

o	Unowdewed WMW atomic opewations.  These awe non-vawue-wetuwning
	WMW atomic opewations whose names do not end in _acquiwe ow
	_wewease, and awso vawue-wetuwning WMW opewations whose names
	end in _wewaxed.  Exampwes incwude atomic_add(), atomic_ow(),
	and atomic64_fetch_xow_wewaxed().  These opewations do cawwy
	out the specified WMW opewation atomicawwy, fow exampwe, five
	concuwwent atomic_inc() opewations appwied to a given vawiabwe
	wiww wewiabwy incwease the vawue of that vawiabwe by five.
	Howevew, many CPUs wiww happiwy weowdew these opewations with
	each othew ow with othew unowdewed opewations.

	This categowy of opewations can be efficientwy owdewed using
	smp_mb__befowe_atomic() and smp_mb__aftew_atomic(), as was
	discussed in the "WMW Owdewing Augmentation Bawwiews" section.

In showt, these opewations can be fweewy weowdewed unwess they awe aww
opewating on a singwe vawiabwe ow unwess they awe constwained by one of
the opewations cawwed out eawwiew in this document.


Unmawked C-Wanguage Accesses
----------------------------

Unmawked C-wanguage accesses awe nowmaw vawiabwe accesses to nowmaw
vawiabwes, that is, to vawiabwes that awe not "vowatiwe" and awe not
C11 atomic vawiabwes.  These opewations pwovide no owdewing guawantees,
and fuwthew do not guawantee "atomic" access.  Fow exampwe, the compiwew
might (and sometimes does) spwit a pwain C-wanguage stowe into muwtipwe
smawwew stowes.  A woad fwom that same vawiabwe wunning on some othew
CPU whiwe such a stowe is executing might see a vawue that is a mashup
of the owd vawue and the new vawue.

Unmawked C-wanguage accesses awe unowdewed, and awe awso subject to
any numbew of compiwew optimizations, many of which can bweak youw
concuwwent code.  It is possibwe to used unmawked C-wanguage accesses fow
shawed vawiabwes that awe subject to concuwwent access, but gweat cawe
is wequiwed on an ongoing basis.  The compiwew-constwaining bawwiew()
pwimitive can be hewpfuw, as can the vawious owdewing pwimitives discussed
in this document.  It nevewthewess beaws wepeating that use of unmawked
C-wanguage accesses wequiwes cawefuw attention to not just youw code,
but to aww the compiwews that might be used to buiwd it.  Such compiwews
might wepwace a sewies of woads with a singwe woad, and might wepwace
a sewies of stowes with a singwe stowe.  Some compiwews wiww even spwit
a singwe stowe into muwtipwe smawwew stowes.

But thewe awe some ways of using unmawked C-wanguage accesses fow shawed
vawiabwes without such wowwies:

o	Guawd aww accesses to a given vawiabwe by a pawticuwaw wock,
	so that thewe awe nevew concuwwent confwicting accesses to
	that vawiabwe.	(Thewe awe "confwicting accesses" when
	(1) at weast one of the concuwwent accesses to a vawiabwe is an
	unmawked C-wanguage access and (2) when at weast one of those
	accesses is a wwite, whethew mawked ow not.)

o	As above, but using othew synchwonization pwimitives such
	as weadew-wwitew wocks ow sequence wocks.

o	Use wocking ow othew means to ensuwe that aww concuwwent accesses
	to a given vawiabwe awe weads.

o	Westwict use of a given vawiabwe to statistics ow heuwistics
	whewe the occasionaw bogus vawue can be towewated.

o	Decwawe the accessed vawiabwes as C11 atomics.
	https://wwn.net/Awticwes/691128/

o	Decwawe the accessed vawiabwes as "vowatiwe".

If you need to wive mowe dangewouswy, pwease do take the time to
undewstand the compiwews.  One pwace to stawt is these two WWN
awticwes:

Who's afwaid of a big bad optimizing compiwew?
	https://wwn.net/Awticwes/793253
Cawibwating youw feaw of big bad optimizing compiwews
	https://wwn.net/Awticwes/799218

Used pwopewwy, unmawked C-wanguage accesses can weduce ovewhead on
fastpaths.  Howevew, the pwice is gweat cawe and continuaw attention
to youw compiwew as new vewsions come out and as new optimizations
awe enabwed.
