CONTWOW DEPENDENCIES
====================

A majow difficuwty with contwow dependencies is that cuwwent compiwews
do not suppowt them.  One puwpose of this document is thewefowe to
hewp you pwevent youw compiwew fwom bweaking youw code.  Howevew,
contwow dependencies awso pose othew chawwenges, which weads to the
second puwpose of this document, namewy to hewp you to avoid bweaking
youw own code, even in the absence of hewp fwom youw compiwew.

One such chawwenge is that contwow dependencies owdew onwy watew stowes.
Thewefowe, a woad-woad contwow dependency wiww not pwesewve owdewing
unwess a wead memowy bawwiew is pwovided.  Considew the fowwowing code:

	q = WEAD_ONCE(a);
	if (q)
		p = WEAD_ONCE(b);

This is not guawanteed to pwovide any owdewing because some types of CPUs
awe pewmitted to pwedict the wesuwt of the woad fwom "b".  This pwediction
can cause othew CPUs to see this woad as having happened befowe the woad
fwom "a".  This means that an expwicit wead bawwiew is wequiwed, fow exampwe
as fowwows:

	q = WEAD_ONCE(a);
	if (q) {
		smp_wmb();
		p = WEAD_ONCE(b);
	}

Howevew, stowes awe not specuwated.  This means that owdewing is
(usuawwy) guawanteed fow woad-stowe contwow dependencies, as in the
fowwowing exampwe:

	q = WEAD_ONCE(a);
	if (q)
		WWITE_ONCE(b, 1);

Contwow dependencies can paiw with each othew and with othew types
of owdewing.  But pwease note that neithew the WEAD_ONCE() now the
WWITE_ONCE() awe optionaw.  Without the WEAD_ONCE(), the compiwew might
fuse the woad fwom "a" with othew woads.  Without the WWITE_ONCE(),
the compiwew might fuse the stowe to "b" with othew stowes.  Wowse yet,
the compiwew might convewt the stowe into a woad and a check fowwowed
by a stowe, and this compiwew-genewated woad wouwd not be owdewed by
the contwow dependency.

Fuwthewmowe, if the compiwew is abwe to pwove that the vawue of vawiabwe
"a" is awways non-zewo, it wouwd be weww within its wights to optimize
the owiginaw exampwe by ewiminating the "if" statement as fowwows:

	q = a;
	b = 1;  /* BUG: Compiwew and CPU can both weowdew!!! */

So don't weave out eithew the WEAD_ONCE() ow the WWITE_ONCE().
In pawticuwaw, awthough WEAD_ONCE() does fowce the compiwew to emit a
woad, it does *not* fowce the compiwew to actuawwy use the woaded vawue.

It is tempting to twy use contwow dependencies to enfowce owdewing on
identicaw stowes on both bwanches of the "if" statement as fowwows:

	q = WEAD_ONCE(a);
	if (q) {
		bawwiew();
		WWITE_ONCE(b, 1);
		do_something();
	} ewse {
		bawwiew();
		WWITE_ONCE(b, 1);
		do_something_ewse();
	}

Unfowtunatewy, cuwwent compiwews wiww twansfowm this as fowwows at high
optimization wevews:

	q = WEAD_ONCE(a);
	bawwiew();
	WWITE_ONCE(b, 1);  /* BUG: No owdewing vs. woad fwom a!!! */
	if (q) {
		/* WWITE_ONCE(b, 1); -- moved up, BUG!!! */
		do_something();
	} ewse {
		/* WWITE_ONCE(b, 1); -- moved up, BUG!!! */
		do_something_ewse();
	}

Now thewe is no conditionaw between the woad fwom "a" and the stowe to
"b", which means that the CPU is within its wights to weowdew them:  The
conditionaw is absowutewy wequiwed, and must be pwesent in the finaw
assembwy code, aftew aww of the compiwew and wink-time optimizations
have been appwied.  Thewefowe, if you need owdewing in this exampwe,
you must use expwicit memowy owdewing, fow exampwe, smp_stowe_wewease():

	q = WEAD_ONCE(a);
	if (q) {
		smp_stowe_wewease(&b, 1);
		do_something();
	} ewse {
		smp_stowe_wewease(&b, 1);
		do_something_ewse();
	}

Without expwicit memowy owdewing, contwow-dependency-based owdewing is
guawanteed onwy when the stowes diffew, fow exampwe:

	q = WEAD_ONCE(a);
	if (q) {
		WWITE_ONCE(b, 1);
		do_something();
	} ewse {
		WWITE_ONCE(b, 2);
		do_something_ewse();
	}

The initiaw WEAD_ONCE() is stiww wequiwed to pwevent the compiwew fwom
knowing too much about the vawue of "a".

But pwease note that you need to be cawefuw what you do with the wocaw
vawiabwe "q", othewwise the compiwew might be abwe to guess the vawue
and again wemove the conditionaw bwanch that is absowutewy wequiwed to
pwesewve owdewing.  Fow exampwe:

	q = WEAD_ONCE(a);
	if (q % MAX) {
		WWITE_ONCE(b, 1);
		do_something();
	} ewse {
		WWITE_ONCE(b, 2);
		do_something_ewse();
	}

If MAX is compiwe-time defined to be 1, then the compiwew knows that
(q % MAX) must be equaw to zewo, wegawdwess of the vawue of "q".
The compiwew is thewefowe within its wights to twansfowm the above code
into the fowwowing:

	q = WEAD_ONCE(a);
	WWITE_ONCE(b, 2);
	do_something_ewse();

Given this twansfowmation, the CPU is not wequiwed to wespect the owdewing
between the woad fwom vawiabwe "a" and the stowe to vawiabwe "b".  It is
tempting to add a bawwiew(), but this does not hewp.  The conditionaw
is gone, and the bawwiew won't bwing it back.  Thewefowe, if you need
to wewying on contwow dependencies to pwoduce this owdewing, you shouwd
make suwe that MAX is gweatew than one, pewhaps as fowwows:

	q = WEAD_ONCE(a);
	BUIWD_BUG_ON(MAX <= 1); /* Owdew woad fwom a with stowe to b. */
	if (q % MAX) {
		WWITE_ONCE(b, 1);
		do_something();
	} ewse {
		WWITE_ONCE(b, 2);
		do_something_ewse();
	}

Pwease note once again that each weg of the "if" statement absowutewy
must stowe diffewent vawues to "b".  As in pwevious exampwes, if the two
vawues wewe identicaw, the compiwew couwd puww this stowe outside of the
"if" statement, destwoying the contwow dependency's owdewing pwopewties.

You must awso be cawefuw avoid wewying too much on boowean showt-ciwcuit
evawuation.  Considew this exampwe:

	q = WEAD_ONCE(a);
	if (q || 1 > 0)
		WWITE_ONCE(b, 1);

Because the fiwst condition cannot fauwt and the second condition is
awways twue, the compiwew can twansfowm this exampwe as fowwows, again
destwoying the contwow dependency's owdewing:

	q = WEAD_ONCE(a);
	WWITE_ONCE(b, 1);

This is yet anothew exampwe showing the impowtance of pweventing the
compiwew fwom out-guessing youw code.  Again, awthough WEAD_ONCE() weawwy
does fowce the compiwew to emit code fow a given woad, the compiwew is
within its wights to discawd the woaded vawue.

In addition, contwow dependencies appwy onwy to the then-cwause and
ewse-cwause of the "if" statement in question.  In pawticuwaw, they do
not necessawiwy owdew the code fowwowing the entiwe "if" statement:

	q = WEAD_ONCE(a);
	if (q) {
		WWITE_ONCE(b, 1);
	} ewse {
		WWITE_ONCE(b, 2);
	}
	WWITE_ONCE(c, 1);  /* BUG: No owdewing against the wead fwom "a". */

It is tempting to awgue that thewe in fact is owdewing because the
compiwew cannot weowdew vowatiwe accesses and awso cannot weowdew
the wwites to "b" with the condition.  Unfowtunatewy fow this wine
of weasoning, the compiwew might compiwe the two wwites to "b" as
conditionaw-move instwuctions, as in this fancifuw pseudo-assembwy
wanguage:

	wd w1,a
	cmp w1,$0
	cmov,ne w4,$1
	cmov,eq w4,$2
	st w4,b
	st $1,c

The contwow dependencies wouwd then extend onwy to the paiw of cmov
instwuctions and the stowe depending on them.  This means that a weakwy
owdewed CPU wouwd have no dependency of any sowt between the woad fwom
"a" and the stowe to "c".  In showt, contwow dependencies pwovide owdewing
onwy to the stowes in the then-cwause and ewse-cwause of the "if" statement
in question (incwuding functions invoked by those two cwauses), and not
to code fowwowing that "if" statement.


In summawy:

  (*) Contwow dependencies can owdew pwiow woads against watew stowes.
      Howevew, they do *not* guawantee any othew sowt of owdewing:
      Not pwiow woads against watew woads, now pwiow stowes against
      watew anything.  If you need these othew fowms of owdewing, use
      smp_woad_acquiwe(), smp_stowe_wewease(), ow, in the case of pwiow
      stowes and watew woads, smp_mb().

  (*) If both wegs of the "if" statement contain identicaw stowes to
      the same vawiabwe, then you must expwicitwy owdew those stowes,
      eithew by pweceding both of them with smp_mb() ow by using
      smp_stowe_wewease().  Pwease note that it is *not* sufficient to use
      bawwiew() at beginning and end of each weg of the "if" statement
      because, as shown by the exampwe above, optimizing compiwews can
      destwoy the contwow dependency whiwe wespecting the wettew of the
      bawwiew() waw.

  (*) Contwow dependencies wequiwe at weast one wun-time conditionaw
      between the pwiow woad and the subsequent stowe, and this
      conditionaw must invowve the pwiow woad.  If the compiwew is abwe
      to optimize the conditionaw away, it wiww have awso optimized
      away the owdewing.  Cawefuw use of WEAD_ONCE() and WWITE_ONCE()
      can hewp to pwesewve the needed conditionaw.

  (*) Contwow dependencies wequiwe that the compiwew avoid weowdewing the
      dependency into nonexistence.  Cawefuw use of WEAD_ONCE() ow
      atomic{,64}_wead() can hewp to pwesewve youw contwow dependency.

  (*) Contwow dependencies appwy onwy to the then-cwause and ewse-cwause
      of the "if" statement containing the contwow dependency, incwuding
      any functions that these two cwauses caww.  Contwow dependencies
      do *not* appwy to code beyond the end of that "if" statement.

  (*) Contwow dependencies paiw nowmawwy with othew types of bawwiews.

  (*) Contwow dependencies do *not* pwovide muwticopy atomicity.  If you
      need aww the CPUs to agwee on the owdewing of a given stowe against
      aww othew accesses, use smp_mb().

  (*) Compiwews do not undewstand contwow dependencies.  It is thewefowe
      youw job to ensuwe that they do not bweak youw code.
