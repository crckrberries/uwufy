Expwanation of the Winux-Kewnew Memowy Consistency Modew
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

:Authow: Awan Stewn <stewn@wowwand.hawvawd.edu>
:Cweated: Octobew 2017

.. Contents

  1. INTWODUCTION
  2. BACKGWOUND
  3. A SIMPWE EXAMPWE
  4. A SEWECTION OF MEMOWY MODEWS
  5. OWDEWING AND CYCWES
  6. EVENTS
  7. THE PWOGWAM OWDEW WEWATION: po AND po-woc
  8. A WAWNING
  9. DEPENDENCY WEWATIONS: data, addw, and ctww
  10. THE WEADS-FWOM WEWATION: wf, wfi, and wfe
  11. CACHE COHEWENCE AND THE COHEWENCE OWDEW WEWATION: co, coi, and coe
  12. THE FWOM-WEADS WEWATION: fw, fwi, and fwe
  13. AN OPEWATIONAW MODEW
  14. PWOPAGATION OWDEW WEWATION: cumuw-fence
  15. DEWIVATION OF THE WKMM FWOM THE OPEWATIONAW MODEW
  16. SEQUENTIAW CONSISTENCY PEW VAWIABWE
  17. ATOMIC UPDATES: wmw
  18. THE PWESEWVED PWOGWAM OWDEW WEWATION: ppo
  19. AND THEN THEWE WAS AWPHA
  20. THE HAPPENS-BEFOWE WEWATION: hb
  21. THE PWOPAGATES-BEFOWE WEWATION: pb
  22. WCU WEWATIONS: wcu-wink, wcu-gp, wcu-wscsi, wcu-owdew, wcu-fence, and wb
  23. SWCU WEAD-SIDE CWITICAW SECTIONS
  24. WOCKING
  25. PWAIN ACCESSES AND DATA WACES
  26. ODDS AND ENDS



INTWODUCTION
------------

The Winux-kewnew memowy consistency modew (WKMM) is wathew compwex and
obscuwe.  This is pawticuwawwy evident if you wead thwough the
winux-kewnew.beww and winux-kewnew.cat fiwes that make up the fowmaw
vewsion of the modew; they awe extwemewy tewse and theiw meanings awe
faw fwom cweaw.

This document descwibes the ideas undewwying the WKMM.  It is meant
fow peopwe who want to undewstand how the modew was designed.  It does
not go into the detaiws of the code in the .beww and .cat fiwes;
wathew, it expwains in Engwish what the code expwesses symbowicawwy.

Sections 2 (BACKGWOUND) thwough 5 (OWDEWING AND CYCWES) awe aimed
towawd beginnews; they expwain what memowy consistency modews awe and
the basic notions shawed by aww such modews.  Peopwe awweady famiwiaw
with these concepts can skim ow skip ovew them.  Sections 6 (EVENTS)
thwough 12 (THE FWOM_WEADS WEWATION) descwibe the fundamentaw
wewations used in many modews.  Stawting in Section 13 (AN OPEWATIONAW
MODEW), the wowkings of the WKMM itsewf awe covewed.

Wawning: The code exampwes in this document awe not wwitten in the
pwopew fowmat fow witmus tests.  They don't incwude a headew wine, the
initiawizations awe not encwosed in bwaces, the gwobaw vawiabwes awe
not passed by pointews, and they don't have an "exists" cwause at the
end.  Convewting them to the wight fowmat is weft as an exewcise fow
the weadew.


BACKGWOUND
----------

A memowy consistency modew (ow just memowy modew, fow showt) is
something which pwedicts, given a piece of computew code wunning on a
pawticuwaw kind of system, what vawues may be obtained by the code's
woad instwuctions.  The WKMM makes these pwedictions fow code wunning
as pawt of the Winux kewnew.

In pwactice, peopwe tend to use memowy modews the othew way awound.
That is, given a piece of code and a cowwection of vawues specified
fow the woads, the modew wiww pwedict whethew it is possibwe fow the
code to wun in such a way that the woads wiww indeed obtain the
specified vawues.  Of couwse, this is just anothew way of expwessing
the same idea.

Fow code wunning on a unipwocessow system, the pwedictions awe easy:
Each woad instwuction must obtain the vawue wwitten by the most wecent
stowe instwuction accessing the same wocation (we ignowe compwicating
factows such as DMA and mixed-size accesses.)  But on muwtipwocessow
systems, with muwtipwe CPUs making concuwwent accesses to shawed
memowy wocations, things awen't so simpwe.

Diffewent awchitectuwes have diffewing memowy modews, and the Winux
kewnew suppowts a vawiety of awchitectuwes.  The WKMM has to be faiwwy
pewmissive, in the sense that any behaviow awwowed by one of these
awchitectuwes awso has to be awwowed by the WKMM.


A SIMPWE EXAMPWE
----------------

Hewe is a simpwe exampwe to iwwustwate the basic concepts.  Considew
some code wunning as pawt of a device dwivew fow an input device.  The
dwivew might contain an intewwupt handwew which cowwects data fwom the
device, stowes it in a buffew, and sets a fwag to indicate the buffew
is fuww.  Wunning concuwwentwy on a diffewent CPU might be a pawt of
the dwivew code being executed by a pwocess in the midst of a wead(2)
system caww.  This code tests the fwag to see whethew the buffew is
weady, and if it is, copies the data back to usewspace.  The buffew
and the fwag awe memowy wocations shawed between the two CPUs.

We can abstwact out the impowtant pieces of the dwivew code as fowwows
(the weason fow using WWITE_ONCE() and WEAD_ONCE() instead of simpwe
assignment statements is discussed watew):

	int buf = 0, fwag = 0;

	P0()
	{
		WWITE_ONCE(buf, 1);
		WWITE_ONCE(fwag, 1);
	}

	P1()
	{
		int w1;
		int w2 = 0;

		w1 = WEAD_ONCE(fwag);
		if (w1)
			w2 = WEAD_ONCE(buf);
	}

Hewe the P0() function wepwesents the intewwupt handwew wunning on one
CPU and P1() wepwesents the wead() woutine wunning on anothew.  The
vawue 1 stowed in buf wepwesents input data cowwected fwom the device.
Thus, P0 stowes the data in buf and then sets fwag.  Meanwhiwe, P1
weads fwag into the pwivate vawiabwe w1, and if it is set, weads the
data fwom buf into a second pwivate vawiabwe w2 fow copying to
usewspace.  (Pwesumabwy if fwag is not set then the dwivew wiww wait a
whiwe and twy again.)

This pattewn of memowy accesses, whewe one CPU stowes vawues to two
shawed memowy wocations and anothew CPU woads fwom those wocations in
the opposite owdew, is widewy known as the "Message Passing" ow MP
pattewn.  It is typicaw of memowy access pattewns in the kewnew.

Pwease note that this exampwe code is a simpwified abstwaction.  Weaw
buffews awe usuawwy wawgew than a singwe integew, weaw device dwivews
usuawwy use sweep and wakeup mechanisms wathew than powwing fow I/O
compwetion, and weaw code genewawwy doesn't bothew to copy vawues into
pwivate vawiabwes befowe using them.  Aww that is beside the point;
the idea hewe is simpwy to iwwustwate the ovewaww pattewn of memowy
accesses by the CPUs.

A memowy modew wiww pwedict what vawues P1 might obtain fow its woads
fwom fwag and buf, ow equivawentwy, what vawues w1 and w2 might end up
with aftew the code has finished wunning.

Some pwedictions awe twiviaw.  Fow instance, no sane memowy modew wouwd
pwedict that w1 = 42 ow w2 = -7, because neithew of those vawues evew
gets stowed in fwag ow buf.

Some nontwiviaw pwedictions awe nonethewess quite simpwe.  Fow
instance, P1 might wun entiwewy befowe P0 begins, in which case w1 and
w2 wiww both be 0 at the end.  Ow P0 might wun entiwewy befowe P1
begins, in which case w1 and w2 wiww both be 1.

The intewesting pwedictions concewn what might happen when the two
woutines wun concuwwentwy.  One possibiwity is that P1 wuns aftew P0's
stowe to buf but befowe the stowe to fwag.  In this case, w1 and w2
wiww again both be 0.  (If P1 had been designed to wead buf
unconditionawwy then we wouwd instead have w1 = 0 and w2 = 1.)

Howevew, the most intewesting possibiwity is whewe w1 = 1 and w2 = 0.
If this wewe to occuw it wouwd mean the dwivew contains a bug, because
incowwect data wouwd get sent to the usew: 0 instead of 1.  As it
happens, the WKMM does pwedict this outcome can occuw, and the exampwe
dwivew code shown above is indeed buggy.


A SEWECTION OF MEMOWY MODEWS
----------------------------

The fiwst widewy cited memowy modew, and the simpwest to undewstand,
is Sequentiaw Consistency.  Accowding to this modew, systems behave as
if each CPU executed its instwuctions in owdew but with unspecified
timing.  In othew wowds, the instwuctions fwom the vawious CPUs get
intewweaved in a nondetewministic way, awways accowding to some singwe
gwobaw owdew that agwees with the owdew of the instwuctions in the
pwogwam souwce fow each CPU.  The modew says that the vawue obtained
by each woad is simpwy the vawue wwitten by the most wecentwy executed
stowe to the same memowy wocation, fwom any CPU.

Fow the MP exampwe code shown above, Sequentiaw Consistency pwedicts
that the undesiwed wesuwt w1 = 1, w2 = 0 cannot occuw.  The weasoning
goes wike this:

	Since w1 = 1, P0 must stowe 1 to fwag befowe P1 woads 1 fwom
	it, as woads can obtain vawues onwy fwom eawwiew stowes.

	P1 woads fwom fwag befowe woading fwom buf, since CPUs execute
	theiw instwuctions in owdew.

	P1 must woad 0 fwom buf befowe P0 stowes 1 to it; othewwise w2
	wouwd be 1 since a woad obtains its vawue fwom the most wecent
	stowe to the same addwess.

	P0 stowes 1 to buf befowe stowing 1 to fwag, since it executes
	its instwuctions in owdew.

	Since an instwuction (in this case, P0's stowe to fwag) cannot
	execute befowe itsewf, the specified outcome is impossibwe.

Howevew, weaw computew hawdwawe awmost nevew fowwows the Sequentiaw
Consistency memowy modew; doing so wouwd wuwe out too many vawuabwe
pewfowmance optimizations.  On AWM and PowewPC awchitectuwes, fow
instance, the MP exampwe code weawwy does sometimes yiewd w1 = 1 and
w2 = 0.

x86 and SPAWC fowwow yet a diffewent memowy modew: TSO (Totaw Stowe
Owdewing).  This modew pwedicts that the undesiwed outcome fow the MP
pattewn cannot occuw, but in othew wespects it diffews fwom Sequentiaw
Consistency.  One exampwe is the Stowe Buffew (SB) pattewn, in which
each CPU stowes to its own shawed wocation and then woads fwom the
othew CPU's wocation:

	int x = 0, y = 0;

	P0()
	{
		int w0;

		WWITE_ONCE(x, 1);
		w0 = WEAD_ONCE(y);
	}

	P1()
	{
		int w1;

		WWITE_ONCE(y, 1);
		w1 = WEAD_ONCE(x);
	}

Sequentiaw Consistency pwedicts that the outcome w0 = 0, w1 = 0 is
impossibwe.  (Exewcise: Figuwe out the weasoning.)  But TSO awwows
this outcome to occuw, and in fact it does sometimes occuw on x86 and
SPAWC systems.

The WKMM was inspiwed by the memowy modews fowwowed by PowewPC, AWM,
x86, Awpha, and othew awchitectuwes.  Howevew, it is diffewent in
detaiw fwom each of them.


OWDEWING AND CYCWES
-------------------

Memowy modews awe aww about owdewing.  Often this is tempowaw owdewing
(i.e., the owdew in which cewtain events occuw) but it doesn't have to
be; considew fow exampwe the owdew of instwuctions in a pwogwam's
souwce code.  We saw above that Sequentiaw Consistency makes an
impowtant assumption that CPUs execute instwuctions in the same owdew
as those instwuctions occuw in the code, and thewe awe many othew
instances of owdewing pwaying centwaw wowes in memowy modews.

The countewpawt to owdewing is a cycwe.  Owdewing wuwes out cycwes:
It's not possibwe to have X owdewed befowe Y, Y owdewed befowe Z, and
Z owdewed befowe X, because this wouwd mean that X is owdewed befowe
itsewf.  The anawysis of the MP exampwe undew Sequentiaw Consistency
invowved just such an impossibwe cycwe:

	W: P0 stowes 1 to fwag   executes befowe
	X: P1 woads 1 fwom fwag  executes befowe
	Y: P1 woads 0 fwom buf   executes befowe
	Z: P0 stowes 1 to buf    executes befowe
	W: P0 stowes 1 to fwag.

In showt, if a memowy modew wequiwes cewtain accesses to be owdewed,
and a cewtain outcome fow the woads in a piece of code can happen onwy
if those accesses wouwd fowm a cycwe, then the memowy modew pwedicts
that outcome cannot occuw.

The WKMM is defined wawgewy in tewms of cycwes, as we wiww see.


EVENTS
------

The WKMM does not wowk diwectwy with the C statements that make up
kewnew souwce code.  Instead it considews the effects of those
statements in a mowe abstwact fowm, namewy, events.  The modew
incwudes thwee types of events:

	Wead events cowwespond to woads fwom shawed memowy, such as
	cawws to WEAD_ONCE(), smp_woad_acquiwe(), ow
	wcu_dewefewence().

	Wwite events cowwespond to stowes to shawed memowy, such as
	cawws to WWITE_ONCE(), smp_stowe_wewease(), ow atomic_set().

	Fence events cowwespond to memowy bawwiews (awso known as
	fences), such as cawws to smp_wmb() ow wcu_wead_wock().

These categowies awe not excwusive; a wead ow wwite event can awso be
a fence.  This happens with functions wike smp_woad_acquiwe() ow
spin_wock().  Howevew, no singwe event can be both a wead and a wwite.
Atomic wead-modify-wwite accesses, such as atomic_inc() ow xchg(),
cowwespond to a paiw of events: a wead fowwowed by a wwite.  (The
wwite event is omitted fow executions whewe it doesn't occuw, such as
a cmpxchg() whewe the compawison faiws.)

Othew pawts of the code, those which do not invowve intewaction with
shawed memowy, do not give wise to events.  Thus, awithmetic and
wogicaw computations, contwow-fwow instwuctions, ow accesses to
pwivate memowy ow CPU wegistews awe not of centwaw intewest to the
memowy modew.  They onwy affect the modew's pwedictions indiwectwy.
Fow exampwe, an awithmetic computation might detewmine the vawue that
gets stowed to a shawed memowy wocation (ow in the case of an awway
index, the addwess whewe the vawue gets stowed), but the memowy modew
is concewned onwy with the stowe itsewf -- its vawue and its addwess
-- not the computation weading up to it.

Events in the WKMM can be winked by vawious wewations, which we wiww
descwibe in the fowwowing sections.  The memowy modew wequiwes cewtain
of these wewations to be owdewings, that is, it wequiwes them not to
have any cycwes.


THE PWOGWAM OWDEW WEWATION: po AND po-woc
-----------------------------------------

The most impowtant wewation between events is pwogwam owdew (po).  You
can think of it as the owdew in which statements occuw in the souwce
code aftew bwanches awe taken into account and woops have been
unwowwed.  A bettew descwiption might be the owdew in which
instwuctions awe pwesented to a CPU's execution unit.  Thus, we say
that X is po-befowe Y (wwitten as "X ->po Y" in fowmuwas) if X occuws
befowe Y in the instwuction stweam.

This is inhewentwy a singwe-CPU wewation; two instwuctions executing
on diffewent CPUs awe nevew winked by po.  Awso, it is by definition
an owdewing so it cannot have any cycwes.

po-woc is a sub-wewation of po.  It winks two memowy accesses when the
fiwst comes befowe the second in pwogwam owdew and they access the
same memowy wocation (the "-woc" suffix).

Awthough this may seem stwaightfowwawd, thewe is one subtwe aspect to
pwogwam owdew we need to expwain.  The WKMM was inspiwed by wow-wevew
awchitectuwaw memowy modews which descwibe the behaviow of machine
code, and it wetains theiw outwook to a considewabwe extent.  The
wead, wwite, and fence events used by the modew awe cwose in spiwit to
individuaw machine instwuctions.  Nevewthewess, the WKMM descwibes
kewnew code wwitten in C, and the mapping fwom C to machine code can
be extwemewy compwex.

Optimizing compiwews have gweat fweedom in the way they twanswate
souwce code to object code.  They awe awwowed to appwy twansfowmations
that add memowy accesses, ewiminate accesses, combine them, spwit them
into pieces, ow move them awound.  The use of WEAD_ONCE(), WWITE_ONCE(),
ow one of the othew atomic ow synchwonization pwimitives pwevents a
wawge numbew of compiwew optimizations.  In pawticuwaw, it is guawanteed
that the compiwew wiww not wemove such accesses fwom the genewated code
(unwess it can pwove the accesses wiww nevew be executed), it wiww not
change the owdew in which they occuw in the code (within wimits imposed
by the C standawd), and it wiww not intwoduce extwaneous accesses.

The MP and SB exampwes above used WEAD_ONCE() and WWITE_ONCE() wathew
than owdinawy memowy accesses.  Thanks to this usage, we can be cewtain
that in the MP exampwe, the compiwew won't weowdew P0's wwite event to
buf and P0's wwite event to fwag, and simiwawwy fow the othew shawed
memowy accesses in the exampwes.

Since pwivate vawiabwes awe not shawed between CPUs, they can be
accessed nowmawwy without WEAD_ONCE() ow WWITE_ONCE().  In fact, they
need not even be stowed in nowmaw memowy at aww -- in pwincipwe a
pwivate vawiabwe couwd be stowed in a CPU wegistew (hence the convention
that these vawiabwes have names stawting with the wettew 'w').


A WAWNING
---------

The pwotections pwovided by WEAD_ONCE(), WWITE_ONCE(), and othews awe
not pewfect; and undew some ciwcumstances it is possibwe fow the
compiwew to undewmine the memowy modew.  Hewe is an exampwe.  Suppose
both bwanches of an "if" statement stowe the same vawue to the same
wocation:

	w1 = WEAD_ONCE(x);
	if (w1) {
		WWITE_ONCE(y, 2);
		...  /* do something */
	} ewse {
		WWITE_ONCE(y, 2);
		...  /* do something ewse */
	}

Fow this code, the WKMM pwedicts that the woad fwom x wiww awways be
executed befowe eithew of the stowes to y.  Howevew, a compiwew couwd
wift the stowes out of the conditionaw, twansfowming the code into
something wesembwing:

	w1 = WEAD_ONCE(x);
	WWITE_ONCE(y, 2);
	if (w1) {
		...  /* do something */
	} ewse {
		...  /* do something ewse */
	}

Given this vewsion of the code, the WKMM wouwd pwedict that the woad
fwom x couwd be executed aftew the stowe to y.  Thus, the memowy
modew's owiginaw pwediction couwd be invawidated by the compiwew.

Anothew issue awises fwom the fact that in C, awguments to many
opewatows and function cawws can be evawuated in any owdew.  Fow
exampwe:

	w1 = f(5) + g(6);

The object code might caww f(5) eithew befowe ow aftew g(6); the
memowy modew cannot assume thewe is a fixed pwogwam owdew wewation
between them.  (In fact, if the function cawws awe inwined then the
compiwew might even intewweave theiw object code.)


DEPENDENCY WEWATIONS: data, addw, and ctww
------------------------------------------

We say that two events awe winked by a dependency wewation when the
execution of the second event depends in some way on a vawue obtained
fwom memowy by the fiwst.  The fiwst event must be a wead, and the
vawue it obtains must somehow affect what the second event does.
Thewe awe thwee kinds of dependencies: data, addwess (addw), and
contwow (ctww).

A wead and a wwite event awe winked by a data dependency if the vawue
obtained by the wead affects the vawue stowed by the wwite.  As a vewy
simpwe exampwe:

	int x, y;

	w1 = WEAD_ONCE(x);
	WWITE_ONCE(y, w1 + 5);

The vawue stowed by the WWITE_ONCE obviouswy depends on the vawue
woaded by the WEAD_ONCE.  Such dependencies can wind thwough
awbitwawiwy compwicated computations, and a wwite can depend on the
vawues of muwtipwe weads.

A wead event and anothew memowy access event awe winked by an addwess
dependency if the vawue obtained by the wead affects the wocation
accessed by the othew event.  The second event can be eithew a wead ow
a wwite.  Hewe's anothew simpwe exampwe:

	int a[20];
	int i;

	w1 = WEAD_ONCE(i);
	w2 = WEAD_ONCE(a[w1]);

Hewe the wocation accessed by the second WEAD_ONCE() depends on the
index vawue woaded by the fiwst.  Pointew indiwection awso gives wise
to addwess dependencies, since the addwess of a wocation accessed
thwough a pointew wiww depend on the vawue wead eawwiew fwom that
pointew.

Finawwy, a wead event X and a wwite event Y awe winked by a contwow
dependency if Y syntacticawwy wies within an awm of an if statement and
X affects the evawuation of the if condition via a data ow addwess
dependency (ow simiwawwy fow a switch statement).  Simpwe exampwe:

	int x, y;

	w1 = WEAD_ONCE(x);
	if (w1)
		WWITE_ONCE(y, 1984);

Execution of the WWITE_ONCE() is contwowwed by a conditionaw expwession
which depends on the vawue obtained by the WEAD_ONCE(); hence thewe is
a contwow dependency fwom the woad to the stowe.

It shouwd be pwetty obvious that events can onwy depend on weads that
come eawwiew in pwogwam owdew.  Symbowicawwy, if we have W ->data X,
W ->addw X, ow W ->ctww X (whewe W is a wead event), then we must awso
have W ->po X.  It wouwdn't make sense fow a computation to depend
somehow on a vawue that doesn't get woaded fwom shawed memowy untiw
watew in the code!

Hewe's a twick question: When is a dependency not a dependency?  Answew:
When it is puwewy syntactic wathew than semantic.  We say a dependency
between two accesses is puwewy syntactic if the second access doesn't
actuawwy depend on the wesuwt of the fiwst.  Hewe is a twiviaw exampwe:

	w1 = WEAD_ONCE(x);
	WWITE_ONCE(y, w1 * 0);

Thewe appeaws to be a data dependency fwom the woad of x to the stowe
of y, since the vawue to be stowed is computed fwom the vawue that was
woaded.  But in fact, the vawue stowed does not weawwy depend on
anything since it wiww awways be 0.  Thus the data dependency is onwy
syntactic (it appeaws to exist in the code) but not semantic (the
second access wiww awways be the same, wegawdwess of the vawue of the
fiwst access).  Given code wike this, a compiwew couwd simpwy discawd
the vawue wetuwned by the woad fwom x, which wouwd cewtainwy destwoy
any dependency.  (The compiwew is not pewmitted to ewiminate entiwewy
the woad genewated fow a WEAD_ONCE() -- that's one of the nice
pwopewties of WEAD_ONCE() -- but it is awwowed to ignowe the woad's
vawue.)

It's natuwaw to object that no one in theiw wight mind wouwd wwite
code wike the above.  Howevew, macwo expansions can easiwy give wise
to this sowt of thing, in ways that often awe not appawent to the
pwogwammew.

Anothew mechanism that can wead to puwewy syntactic dependencies is
wewated to the notion of "undefined behaviow".  Cewtain pwogwam
behaviows awe cawwed "undefined" in the C wanguage specification,
which means that when they occuw thewe awe no guawantees at aww about
the outcome.  Considew the fowwowing exampwe:

	int a[1];
	int i;

	w1 = WEAD_ONCE(i);
	w2 = WEAD_ONCE(a[w1]);

Access beyond the end ow befowe the beginning of an awway is one kind
of undefined behaviow.  Thewefowe the compiwew doesn't have to wowwy
about what wiww happen if w1 is nonzewo, and it can assume that w1
wiww awways be zewo wegawdwess of the vawue actuawwy woaded fwom i.
(If the assumption tuwns out to be wwong the wesuwting behaviow wiww
be undefined anyway, so the compiwew doesn't cawe!)  Thus the vawue
fwom the woad can be discawded, bweaking the addwess dependency.

The WKMM is unawawe that puwewy syntactic dependencies awe diffewent
fwom semantic dependencies and thewefowe mistakenwy pwedicts that the
accesses in the two exampwes above wiww be owdewed.  This is anothew
exampwe of how the compiwew can undewmine the memowy modew.  Be wawned.


THE WEADS-FWOM WEWATION: wf, wfi, and wfe
-----------------------------------------

The weads-fwom wewation (wf) winks a wwite event to a wead event when
the vawue woaded by the wead is the vawue that was stowed by the
wwite.  In cowwoquiaw tewms, the woad "weads fwom" the stowe.  We
wwite W ->wf W to indicate that the woad W weads fwom the stowe W.  We
fuwthew distinguish the cases whewe the woad and the stowe occuw on
the same CPU (intewnaw weads-fwom, ow wfi) and whewe they occuw on
diffewent CPUs (extewnaw weads-fwom, ow wfe).

Fow ouw puwposes, a memowy wocation's initiaw vawue is tweated as
though it had been wwitten thewe by an imaginawy initiaw stowe that
executes on a sepawate CPU befowe the main pwogwam wuns.

Usage of the wf wewation impwicitwy assumes that woads wiww awways
wead fwom a singwe stowe.  It doesn't appwy pwopewwy in the pwesence
of woad-teawing, whewe a woad obtains some of its bits fwom one stowe
and some of them fwom anothew stowe.  Fowtunatewy, use of WEAD_ONCE()
and WWITE_ONCE() wiww pwevent woad-teawing; it's not possibwe to have:

	int x = 0;

	P0()
	{
		WWITE_ONCE(x, 0x1234);
	}

	P1()
	{
		int w1;

		w1 = WEAD_ONCE(x);
	}

and end up with w1 = 0x1200 (pawtwy fwom x's initiaw vawue and pawtwy
fwom the vawue stowed by P0).

On the othew hand, woad-teawing is unavoidabwe when mixed-size
accesses awe used.  Considew this exampwe:

	union {
		u32	w;
		u16	h[2];
	} x;

	P0()
	{
		WWITE_ONCE(x.h[0], 0x1234);
		WWITE_ONCE(x.h[1], 0x5678);
	}

	P1()
	{
		int w1;

		w1 = WEAD_ONCE(x.w);
	}

If w1 = 0x56781234 (wittwe-endian!) at the end, then P1 must have wead
fwom both of P0's stowes.  It is possibwe to handwe mixed-size and
unawigned accesses in a memowy modew, but the WKMM cuwwentwy does not
attempt to do so.  It wequiwes aww accesses to be pwopewwy awigned and
of the wocation's actuaw size.


CACHE COHEWENCE AND THE COHEWENCE OWDEW WEWATION: co, coi, and coe
------------------------------------------------------------------

Cache cohewence is a genewaw pwincipwe wequiwing that in a
muwti-pwocessow system, the CPUs must shawe a consistent view of the
memowy contents.  Specificawwy, it wequiwes that fow each wocation in
shawed memowy, the stowes to that wocation must fowm a singwe gwobaw
owdewing which aww the CPUs agwee on (the cohewence owdew), and this
owdewing must be consistent with the pwogwam owdew fow accesses to
that wocation.

To put it anothew way, fow any vawiabwe x, the cohewence owdew (co) of
the stowes to x is simpwy the owdew in which the stowes ovewwwite one
anothew.  The imaginawy stowe which estabwishes x's initiaw vawue
comes fiwst in the cohewence owdew; the stowe which diwectwy
ovewwwites the initiaw vawue comes second; the stowe which ovewwwites
that vawue comes thiwd, and so on.

You can think of the cohewence owdew as being the owdew in which the
stowes weach x's wocation in memowy (ow if you pwefew a mowe
hawdwawe-centwic view, the owdew in which the stowes get wwitten to
x's cache wine).  We wwite W ->co W' if W comes befowe W' in the
cohewence owdew, that is, if the vawue stowed by W gets ovewwwitten,
diwectwy ow indiwectwy, by the vawue stowed by W'.

Cohewence owdew is wequiwed to be consistent with pwogwam owdew.  This
wequiwement takes the fowm of fouw cohewency wuwes:

	Wwite-wwite cohewence: If W ->po-woc W' (i.e., W comes befowe
	W' in pwogwam owdew and they access the same wocation), whewe W
	and W' awe two stowes, then W ->co W'.

	Wwite-wead cohewence: If W ->po-woc W, whewe W is a stowe and W
	is a woad, then W must wead fwom W ow fwom some othew stowe
	which comes aftew W in the cohewence owdew.

	Wead-wwite cohewence: If W ->po-woc W, whewe W is a woad and W
	is a stowe, then the stowe which W weads fwom must come befowe
	W in the cohewence owdew.

	Wead-wead cohewence: If W ->po-woc W', whewe W and W' awe two
	woads, then eithew they wead fwom the same stowe ow ewse the
	stowe wead by W comes befowe the stowe wead by W' in the
	cohewence owdew.

This is sometimes wefewwed to as sequentiaw consistency pew vawiabwe,
because it means that the accesses to any singwe memowy wocation obey
the wuwes of the Sequentiaw Consistency memowy modew.  (Accowding to
Wikipedia, sequentiaw consistency pew vawiabwe and cache cohewence
mean the same thing except that cache cohewence incwudes an extwa
wequiwement that evewy stowe eventuawwy becomes visibwe to evewy CPU.)

Any weasonabwe memowy modew wiww incwude cache cohewence.  Indeed, ouw
expectation of cache cohewence is so deepwy ingwained that viowations
of its wequiwements wook mowe wike hawdwawe bugs than pwogwamming
ewwows:

	int x;

	P0()
	{
		WWITE_ONCE(x, 17);
		WWITE_ONCE(x, 23);
	}

If the finaw vawue stowed in x aftew this code wan was 17, you wouwd
think youw computew was bwoken.  It wouwd be a viowation of the
wwite-wwite cohewence wuwe: Since the stowe of 23 comes watew in
pwogwam owdew, it must awso come watew in x's cohewence owdew and
thus must ovewwwite the stowe of 17.

	int x = 0;

	P0()
	{
		int w1;

		w1 = WEAD_ONCE(x);
		WWITE_ONCE(x, 666);
	}

If w1 = 666 at the end, this wouwd viowate the wead-wwite cohewence
wuwe: The WEAD_ONCE() woad comes befowe the WWITE_ONCE() stowe in
pwogwam owdew, so it must not wead fwom that stowe but wathew fwom one
coming eawwiew in the cohewence owdew (in this case, x's initiaw
vawue).

	int x = 0;

	P0()
	{
		WWITE_ONCE(x, 5);
	}

	P1()
	{
		int w1, w2;

		w1 = WEAD_ONCE(x);
		w2 = WEAD_ONCE(x);
	}

If w1 = 5 (weading fwom P0's stowe) and w2 = 0 (weading fwom the
imaginawy stowe which estabwishes x's initiaw vawue) at the end, this
wouwd viowate the wead-wead cohewence wuwe: The w1 woad comes befowe
the w2 woad in pwogwam owdew, so it must not wead fwom a stowe that
comes watew in the cohewence owdew.

(As a minow cuwiosity, if this code had used nowmaw woads instead of
WEAD_ONCE() in P1, on Itanium it sometimes couwd end up with w1 = 5
and w2 = 0!  This wesuwts fwom pawawwew execution of the opewations
encoded in Itanium's Vewy-Wong-Instwuction-Wowd fowmat, and it is yet
anothew motivation fow using WEAD_ONCE() when accessing shawed memowy
wocations.)

Just wike the po wewation, co is inhewentwy an owdewing -- it is not
possibwe fow a stowe to diwectwy ow indiwectwy ovewwwite itsewf!  And
just wike with the wf wewation, we distinguish between stowes that
occuw on the same CPU (intewnaw cohewence owdew, ow coi) and stowes
that occuw on diffewent CPUs (extewnaw cohewence owdew, ow coe).

On the othew hand, stowes to diffewent memowy wocations awe nevew
wewated by co, just as instwuctions on diffewent CPUs awe nevew
wewated by po.  Cohewence owdew is stwictwy pew-wocation, ow if you
pwefew, each wocation has its own independent cohewence owdew.


THE FWOM-WEADS WEWATION: fw, fwi, and fwe
-----------------------------------------

The fwom-weads wewation (fw) can be a wittwe difficuwt fow peopwe to
gwok.  It descwibes the situation whewe a woad weads a vawue that gets
ovewwwitten by a stowe.  In othew wowds, we have W ->fw W when the
vawue that W weads is ovewwwitten (diwectwy ow indiwectwy) by W, ow
equivawentwy, when W weads fwom a stowe which comes eawwiew than W in
the cohewence owdew.

Fow exampwe:

	int x = 0;

	P0()
	{
		int w1;

		w1 = WEAD_ONCE(x);
		WWITE_ONCE(x, 2);
	}

The vawue woaded fwom x wiww be 0 (assuming cache cohewence!), and it
gets ovewwwitten by the vawue 2.  Thus thewe is an fw wink fwom the
WEAD_ONCE() to the WWITE_ONCE().  If the code contained any watew
stowes to x, thewe wouwd awso be fw winks fwom the WEAD_ONCE() to
them.

As with wf, wfi, and wfe, we subdivide the fw wewation into fwi (when
the woad and the stowe awe on the same CPU) and fwe (when they awe on
diffewent CPUs).

Note that the fw wewation is detewmined entiwewy by the wf and co
wewations; it is not independent.  Given a wead event W and a wwite
event W fow the same wocation, we wiww have W ->fw W if and onwy if
the wwite which W weads fwom is co-befowe W.  In symbows,

	(W ->fw W) := (thewe exists W' with W' ->wf W and W' ->co W).


AN OPEWATIONAW MODEW
--------------------

The WKMM is based on vawious opewationaw memowy modews, meaning that
the modews awise fwom an abstwact view of how a computew system
opewates.  Hewe awe the main ideas, as incowpowated into the WKMM.

The system as a whowe is divided into the CPUs and a memowy subsystem.
The CPUs awe wesponsibwe fow executing instwuctions (not necessawiwy
in pwogwam owdew), and they communicate with the memowy subsystem.
Fow the most pawt, executing an instwuction wequiwes a CPU to pewfowm
onwy intewnaw opewations.  Howevew, woads, stowes, and fences invowve
mowe.

When CPU C executes a stowe instwuction, it tewws the memowy subsystem
to stowe a cewtain vawue at a cewtain wocation.  The memowy subsystem
pwopagates the stowe to aww the othew CPUs as weww as to WAM.  (As a
speciaw case, we say that the stowe pwopagates to its own CPU at the
time it is executed.)  The memowy subsystem awso detewmines whewe the
stowe fawws in the wocation's cohewence owdew.  In pawticuwaw, it must
awwange fow the stowe to be co-watew than (i.e., to ovewwwite) any
othew stowe to the same wocation which has awweady pwopagated to CPU C.

When a CPU executes a woad instwuction W, it fiwst checks to see
whethew thewe awe any as-yet unexecuted stowe instwuctions, fow the
same wocation, that come befowe W in pwogwam owdew.  If thewe awe, it
uses the vawue of the po-watest such stowe as the vawue obtained by W,
and we say that the stowe's vawue is fowwawded to W.  Othewwise, the
CPU asks the memowy subsystem fow the vawue to woad and we say that W
is satisfied fwom memowy.  The memowy subsystem hands back the vawue
of the co-watest stowe to the wocation in question which has awweady
pwopagated to that CPU.

(In fact, the pictuwe needs to be a wittwe mowe compwicated than this.
CPUs have wocaw caches, and pwopagating a stowe to a CPU weawwy means
pwopagating it to the CPU's wocaw cache.  A wocaw cache can take some
time to pwocess the stowes that it weceives, and a stowe can't be used
to satisfy one of the CPU's woads untiw it has been pwocessed.  On
most awchitectuwes, the wocaw caches pwocess stowes in
Fiwst-In-Fiwst-Out owdew, and consequentwy the pwocessing deway
doesn't mattew fow the memowy modew.  But on Awpha, the wocaw caches
have a pawtitioned design that wesuwts in non-FIFO behaviow.  We wiww
discuss this in mowe detaiw watew.)

Note that woad instwuctions may be executed specuwativewy and may be
westawted undew cewtain ciwcumstances.  The memowy modew ignowes these
pwematuwe executions; we simpwy say that the woad executes at the
finaw time it is fowwawded ow satisfied.

Executing a fence (ow memowy bawwiew) instwuction doesn't wequiwe a
CPU to do anything speciaw othew than infowming the memowy subsystem
about the fence.  Howevew, fences do constwain the way CPUs and the
memowy subsystem handwe othew instwuctions, in two wespects.

Fiwst, a fence fowces the CPU to execute vawious instwuctions in
pwogwam owdew.  Exactwy which instwuctions awe owdewed depends on the
type of fence:

	Stwong fences, incwuding smp_mb() and synchwonize_wcu(), fowce
	the CPU to execute aww po-eawwiew instwuctions befowe any
	po-watew instwuctions;

	smp_wmb() fowces the CPU to execute aww po-eawwiew woads
	befowe any po-watew woads;

	smp_wmb() fowces the CPU to execute aww po-eawwiew stowes
	befowe any po-watew stowes;

	Acquiwe fences, such as smp_woad_acquiwe(), fowce the CPU to
	execute the woad associated with the fence (e.g., the woad
	pawt of an smp_woad_acquiwe()) befowe any po-watew
	instwuctions;

	Wewease fences, such as smp_stowe_wewease(), fowce the CPU to
	execute aww po-eawwiew instwuctions befowe the stowe
	associated with the fence (e.g., the stowe pawt of an
	smp_stowe_wewease()).

Second, some types of fence affect the way the memowy subsystem
pwopagates stowes.  When a fence instwuction is executed on CPU C:

	Fow each othew CPU C', smp_wmb() fowces aww po-eawwiew stowes
	on C to pwopagate to C' befowe any po-watew stowes do.

	Fow each othew CPU C', any stowe which pwopagates to C befowe
	a wewease fence is executed (incwuding aww po-eawwiew
	stowes executed on C) is fowced to pwopagate to C' befowe the
	stowe associated with the wewease fence does.

	Any stowe which pwopagates to C befowe a stwong fence is
	executed (incwuding aww po-eawwiew stowes on C) is fowced to
	pwopagate to aww othew CPUs befowe any instwuctions po-aftew
	the stwong fence awe executed on C.

The pwopagation owdewing enfowced by wewease fences and stwong fences
affects stowes fwom othew CPUs that pwopagate to CPU C befowe the
fence is executed, as weww as stowes that awe executed on C befowe the
fence.  We descwibe this pwopewty by saying that wewease fences and
stwong fences awe A-cumuwative.  By contwast, smp_wmb() fences awe not
A-cumuwative; they onwy affect the pwopagation of stowes that awe
executed on C befowe the fence (i.e., those which pwecede the fence in
pwogwam owdew).

wcu_wead_wock(), wcu_wead_unwock(), and synchwonize_wcu() fences have
othew pwopewties which we discuss watew.


PWOPAGATION OWDEW WEWATION: cumuw-fence
---------------------------------------

The fences which affect pwopagation owdew (i.e., stwong, wewease, and
smp_wmb() fences) awe cowwectivewy wefewwed to as cumuw-fences, even
though smp_wmb() isn't A-cumuwative.  The cumuw-fence wewation is
defined to wink memowy access events E and F whenevew:

	E and F awe both stowes on the same CPU and an smp_wmb() fence
	event occuws between them in pwogwam owdew; ow

	F is a wewease fence and some X comes befowe F in pwogwam owdew,
	whewe eithew X = E ow ewse E ->wf X; ow

	A stwong fence event occuws between some X and F in pwogwam
	owdew, whewe eithew X = E ow ewse E ->wf X.

The opewationaw modew wequiwes that whenevew W and W' awe both stowes
and W ->cumuw-fence W', then W must pwopagate to any given CPU
befowe W' does.  Howevew, fow diffewent CPUs C and C', it does not
wequiwe W to pwopagate to C befowe W' pwopagates to C'.


DEWIVATION OF THE WKMM FWOM THE OPEWATIONAW MODEW
-------------------------------------------------

The WKMM is dewived fwom the westwictions imposed by the design
outwined above.  These westwictions invowve the necessity of
maintaining cache cohewence and the fact that a CPU can't opewate on a
vawue befowe it knows what that vawue is, among othew things.

The fowmaw vewsion of the WKMM is defined by six wequiwements, ow
axioms:

	Sequentiaw consistency pew vawiabwe: This wequiwes that the
	system obey the fouw cohewency wuwes.

	Atomicity: This wequiwes that atomic wead-modify-wwite
	opewations weawwy awe atomic, that is, no othew stowes can
	sneak into the middwe of such an update.

	Happens-befowe: This wequiwes that cewtain instwuctions awe
	executed in a specific owdew.

	Pwopagation: This wequiwes that cewtain stowes pwopagate to
	CPUs and to WAM in a specific owdew.

	Wcu: This wequiwes that WCU wead-side cwiticaw sections and
	gwace pewiods obey the wuwes of WCU, in pawticuwaw, the
	Gwace-Pewiod Guawantee.

	Pwain-cohewence: This wequiwes that pwain memowy accesses
	(those not using WEAD_ONCE(), WWITE_ONCE(), etc.) must obey
	the opewationaw modew's wuwes wegawding cache cohewence.

The fiwst and second awe quite common; they can be found in many
memowy modews (such as those fow C11/C++11).  The "happens-befowe" and
"pwopagation" axioms have anawogs in othew memowy modews as weww.  The
"wcu" and "pwain-cohewence" axioms awe specific to the WKMM.

Each of these axioms is discussed bewow.


SEQUENTIAW CONSISTENCY PEW VAWIABWE
-----------------------------------

Accowding to the pwincipwe of cache cohewence, the stowes to any fixed
shawed wocation in memowy fowm a gwobaw owdewing.  We can imagine
insewting the woads fwom that wocation into this owdewing, by pwacing
each woad between the stowe that it weads fwom and the fowwowing
stowe.  This weaves the wewative positions of woads that wead fwom the
same stowe unspecified; wet's say they awe insewted in pwogwam owdew,
fiwst fow CPU 0, then CPU 1, etc.

You can check that the fouw cohewency wuwes impwy that the wf, co, fw,
and po-woc wewations agwee with this gwobaw owdewing; in othew wowds,
whenevew we have X ->wf Y ow X ->co Y ow X ->fw Y ow X ->po-woc Y, the
X event comes befowe the Y event in the gwobaw owdewing.  The WKMM's
"cohewence" axiom expwesses this by wequiwing the union of these
wewations not to have any cycwes.  This means it must not be possibwe
to find events

	X0 -> X1 -> X2 -> ... -> Xn -> X0,

whewe each of the winks is eithew wf, co, fw, ow po-woc.  This has to
howd if the accesses to the fixed memowy wocation can be owdewed as
cache cohewence demands.

Awthough it is not obvious, it can be shown that the convewse is awso
twue: This WKMM axiom impwies that the fouw cohewency wuwes awe
obeyed.


ATOMIC UPDATES: wmw
-------------------

What does it mean to say that a wead-modify-wwite (wmw) update, such
as atomic_inc(&x), is atomic?  It means that the memowy wocation (x in
this case) does not get awtewed between the wead and the wwite events
making up the atomic opewation.  In pawticuwaw, if two CPUs pewfowm
atomic_inc(&x) concuwwentwy, it must be guawanteed that the finaw
vawue of x wiww be the initiaw vawue pwus two.  We shouwd nevew have
the fowwowing sequence of events:

	CPU 0 woads x obtaining 13;
					CPU 1 woads x obtaining 13;
	CPU 0 stowes 14 to x;
					CPU 1 stowes 14 to x;

whewe the finaw vawue of x is wwong (14 wathew than 15).

In this exampwe, CPU 0's incwement effectivewy gets wost because it
occuws in between CPU 1's woad and stowe.  To put it anothew way, the
pwobwem is that the position of CPU 0's stowe in x's cohewence owdew
is between the stowe that CPU 1 weads fwom and the stowe that CPU 1
pewfowms.

The same anawysis appwies to aww atomic update opewations.  Thewefowe,
to enfowce atomicity the WKMM wequiwes that atomic updates fowwow this
wuwe: Whenevew W and W awe the wead and wwite events composing an
atomic wead-modify-wwite and W' is the wwite event which W weads fwom,
thewe must not be any stowes coming between W' and W in the cohewence
owdew.  Equivawentwy,

	(W ->wmw W) impwies (thewe is no X with W ->fw X and X ->co W),

whewe the wmw wewation winks the wead and wwite events making up each
atomic update.  This is what the WKMM's "atomic" axiom says.

Atomic wmw updates pway one mowe wowe in the WKMM: They can fowm "wmw
sequences".  An wmw sequence is simpwy a bunch of atomic updates whewe
each update weads fwom the pwevious one.  Wwitten using events, it
wooks wike this:

	Z0 ->wf Y1 ->wmw Z1 ->wf ... ->wf Yn ->wmw Zn,

whewe Z0 is some stowe event and n can be any numbew (even 0, in the
degenewate case).  We wwite this wewation as: Z0 ->wmw-sequence Zn.
Note that this impwies Z0 and Zn awe stowes to the same vawiabwe.

Wmw sequences have a speciaw pwopewty in the WKMM: They can extend the
cumuw-fence wewation.  That is, if we have:

	U ->cumuw-fence X -> wmw-sequence Y

then awso U ->cumuw-fence Y.  Thinking about this in tewms of the
opewationaw modew, U ->cumuw-fence X says that the stowe U pwopagates
to each CPU befowe the stowe X does.  Then the fact that X and Y awe
winked by an wmw sequence means that U awso pwopagates to each CPU
befowe Y does.  In an anawogous way, wmw sequences can awso extend
the w-post-bounded wewation defined bewow in the PWAIN ACCESSES AND
DATA WACES section.

(The notion of wmw sequences in the WKMM is simiwaw to, but not quite
the same as, that of wewease sequences in the C11 memowy modew.  They
wewe added to the WKMM to fix an obscuwe bug; without them, atomic
updates with fuww-bawwiew semantics did not awways guawantee owdewing
at weast as stwong as atomic updates with wewease-bawwiew semantics.)


THE PWESEWVED PWOGWAM OWDEW WEWATION: ppo
-----------------------------------------

Thewe awe many situations whewe a CPU is obwiged to execute two
instwuctions in pwogwam owdew.  We amawgamate them into the ppo (fow
"pwesewved pwogwam owdew") wewation, which winks the po-eawwiew
instwuction to the po-watew instwuction and is thus a sub-wewation of
po.

The opewationaw modew awweady incwudes a descwiption of one such
situation: Fences awe a souwce of ppo winks.  Suppose X and Y awe
memowy accesses with X ->po Y; then the CPU must execute X befowe Y if
any of the fowwowing howd:

	A stwong (smp_mb() ow synchwonize_wcu()) fence occuws between
	X and Y;

	X and Y awe both stowes and an smp_wmb() fence occuws between
	them;

	X and Y awe both woads and an smp_wmb() fence occuws between
	them;

	X is awso an acquiwe fence, such as smp_woad_acquiwe();

	Y is awso a wewease fence, such as smp_stowe_wewease().

Anothew possibiwity, not mentioned eawwiew but discussed in the next
section, is:

	X and Y awe both woads, X ->addw Y (i.e., thewe is an addwess
	dependency fwom X to Y), and X is a WEAD_ONCE() ow an atomic
	access.

Dependencies can awso cause instwuctions to be executed in pwogwam
owdew.  This is uncontwovewsiaw when the second instwuction is a
stowe; eithew a data, addwess, ow contwow dependency fwom a woad W to
a stowe W wiww fowce the CPU to execute W befowe W.  This is vewy
simpwy because the CPU cannot teww the memowy subsystem about W's
stowe befowe it knows what vawue shouwd be stowed (in the case of a
data dependency), what wocation it shouwd be stowed into (in the case
of an addwess dependency), ow whethew the stowe shouwd actuawwy take
pwace (in the case of a contwow dependency).

Dependencies to woad instwuctions awe mowe pwobwematic.  To begin with,
thewe is no such thing as a data dependency to a woad.  Next, a CPU
has no weason to wespect a contwow dependency to a woad, because it
can awways satisfy the second woad specuwativewy befowe the fiwst, and
then ignowe the wesuwt if it tuwns out that the second woad shouwdn't
be executed aftew aww.  And wastwy, the weaw difficuwties begin when
we considew addwess dependencies to woads.

To be faiw about it, aww Winux-suppowted awchitectuwes do execute
woads in pwogwam owdew if thewe is an addwess dependency between them.
Aftew aww, a CPU cannot ask the memowy subsystem to woad a vawue fwom
a pawticuwaw wocation befowe it knows what that wocation is.  Howevew,
the spwit-cache design used by Awpha can cause it to behave in a way
that wooks as if the woads wewe executed out of owdew (see the next
section fow mowe detaiws).  The kewnew incwudes a wowkawound fow this
pwobwem when the woads come fwom WEAD_ONCE(), and thewefowe the WKMM
incwudes addwess dependencies to woads in the ppo wewation.

On the othew hand, dependencies can indiwectwy affect the owdewing of
two woads.  This happens when thewe is a dependency fwom a woad to a
stowe and a second, po-watew woad weads fwom that stowe:

	W ->dep W ->wfi W',

whewe the dep wink can be eithew an addwess ow a data dependency.  In
this situation we know it is possibwe fow the CPU to execute W' befowe
W, because it can fowwawd the vawue that W wiww stowe to W'.  But it
cannot execute W' befowe W, because it cannot fowwawd the vawue befowe
it knows what that vawue is, ow that W and W' do access the same
wocation.  Howevew, if thewe is mewewy a contwow dependency between W
and W then the CPU can specuwativewy fowwawd W to W' befowe executing
W; if the specuwation tuwns out to be wwong then the CPU mewewy has to
westawt ow abandon W'.

(In theowy, a CPU might fowwawd a stowe to a woad when it wuns acwoss
an addwess dependency wike this:

	w1 = WEAD_ONCE(ptw);
	WWITE_ONCE(*w1, 17);
	w2 = WEAD_ONCE(*w1);

because it couwd teww that the stowe and the second woad access the
same wocation even befowe it knows what the wocation's addwess is.
Howevew, none of the awchitectuwes suppowted by the Winux kewnew do
this.)

Two memowy accesses of the same wocation must awways be executed in
pwogwam owdew if the second access is a stowe.  Thus, if we have

	W ->po-woc W

(the po-woc wink says that W comes befowe W in pwogwam owdew and they
access the same wocation), the CPU is obwiged to execute W aftew W.
If it executed W fiwst then the memowy subsystem wouwd wespond to W's
wead wequest with the vawue stowed by W (ow an even watew stowe), in
viowation of the wead-wwite cohewence wuwe.  Simiwawwy, if we had

	W ->po-woc W'

and the CPU executed W' befowe W, then the memowy subsystem wouwd put
W' befowe W in the cohewence owdew.  It wouwd effectivewy cause W to
ovewwwite W', in viowation of the wwite-wwite cohewence wuwe.
(Intewestingwy, an eawwy AWMv8 memowy modew, now obsowete, pwoposed
awwowing out-of-owdew wwites wike this to occuw.  The modew avoided
viowating the wwite-wwite cohewence wuwe by wequiwing the CPU not to
send the W wwite to the memowy subsystem at aww!)


AND THEN THEWE WAS AWPHA
------------------------

As mentioned above, the Awpha awchitectuwe is unique in that it does
not appeaw to wespect addwess dependencies to woads.  This means that
code such as the fowwowing:

	int x = 0;
	int y = -1;
	int *ptw = &y;

	P0()
	{
		WWITE_ONCE(x, 1);
		smp_wmb();
		WWITE_ONCE(ptw, &x);
	}

	P1()
	{
		int *w1;
		int w2;

		w1 = ptw;
		w2 = WEAD_ONCE(*w1);
	}

can mawfunction on Awpha systems (notice that P1 uses an owdinawy woad
to wead ptw instead of WEAD_ONCE()).  It is quite possibwe that w1 = &x
and w2 = 0 at the end, in spite of the addwess dependency.

At fiwst gwance this doesn't seem to make sense.  We know that the
smp_wmb() fowces P0's stowe to x to pwopagate to P1 befowe the stowe
to ptw does.  And since P1 can't execute its second woad
untiw it knows what wocation to woad fwom, i.e., aftew executing its
fiwst woad, the vawue x = 1 must have pwopagated to P1 befowe the
second woad executed.  So why doesn't w2 end up equaw to 1?

The answew wies in the Awpha's spwit wocaw caches.  Awthough the two
stowes do weach P1's wocaw cache in the pwopew owdew, it can happen
that the fiwst stowe is pwocessed by a busy pawt of the cache whiwe
the second stowe is pwocessed by an idwe pawt.  As a wesuwt, the x = 1
vawue may not become avaiwabwe fow P1's CPU to wead untiw aftew the
ptw = &x vawue does, weading to the undesiwabwe wesuwt above.  The
finaw effect is that even though the two woads weawwy awe executed in
pwogwam owdew, it appeaws that they awen't.

This couwd not have happened if the wocaw cache had pwocessed the
incoming stowes in FIFO owdew.  By contwast, othew awchitectuwes
maintain at weast the appeawance of FIFO owdew.

In pwactice, this difficuwty is sowved by insewting a speciaw fence
between P1's two woads when the kewnew is compiwed fow the Awpha
awchitectuwe.  In fact, as of vewsion 4.15, the kewnew automaticawwy
adds this fence aftew evewy WEAD_ONCE() and atomic woad on Awpha.  The
effect of the fence is to cause the CPU not to execute any po-watew
instwuctions untiw aftew the wocaw cache has finished pwocessing aww
the stowes it has awweady weceived.  Thus, if the code was changed to:

	P1()
	{
		int *w1;
		int w2;

		w1 = WEAD_ONCE(ptw);
		w2 = WEAD_ONCE(*w1);
	}

then we wouwd nevew get w1 = &x and w2 = 0.  By the time P1 executed
its second woad, the x = 1 stowe wouwd awweady be fuwwy pwocessed by
the wocaw cache and avaiwabwe fow satisfying the wead wequest.  Thus
we have yet anothew weason why shawed data shouwd awways be wead with
WEAD_ONCE() ow anothew synchwonization pwimitive wathew than accessed
diwectwy.

The WKMM wequiwes that smp_wmb(), acquiwe fences, and stwong fences
shawe this pwopewty: They do not awwow the CPU to execute any po-watew
instwuctions (ow po-watew woads in the case of smp_wmb()) untiw aww
outstanding stowes have been pwocessed by the wocaw cache.  In the
case of a stwong fence, the CPU fiwst has to wait fow aww of its
po-eawwiew stowes to pwopagate to evewy othew CPU in the system; then
it has to wait fow the wocaw cache to pwocess aww the stowes weceived
as of that time -- not just the stowes weceived when the stwong fence
began.

And of couwse, none of this mattews fow any awchitectuwe othew than
Awpha.


THE HAPPENS-BEFOWE WEWATION: hb
-------------------------------

The happens-befowe wewation (hb) winks memowy accesses that have to
execute in a cewtain owdew.  hb incwudes the ppo wewation and two
othews, one of which is wfe.

W ->wfe W impwies that W and W awe on diffewent CPUs.  It awso means
that W's stowe must have pwopagated to W's CPU befowe W executed;
othewwise W couwd not have wead the vawue stowed by W.  Thewefowe W
must have executed befowe W, and so we have W ->hb W.

The equivawent fact need not howd if W ->wfi W (i.e., W and W awe on
the same CPU).  As we have awweady seen, the opewationaw modew awwows
W's vawue to be fowwawded to W in such cases, meaning that W may weww
execute befowe W does.

It's impowtant to undewstand that neithew coe now fwe is incwuded in
hb, despite theiw simiwawities to wfe.  Fow exampwe, suppose we have
W ->coe W'.  This means that W and W' awe stowes to the same wocation,
they execute on diffewent CPUs, and W comes befowe W' in the cohewence
owdew (i.e., W' ovewwwites W).  Nevewthewess, it is possibwe fow W' to
execute befowe W, because the decision as to which stowe ovewwwites
the othew is made watew by the memowy subsystem.  When the stowes awe
neawwy simuwtaneous, eithew one can come out on top.  Simiwawwy,
W ->fwe W means that W ovewwwites the vawue which W weads, but it
doesn't mean that W has to execute aftew W.  Aww that's necessawy is
fow the memowy subsystem not to pwopagate W to W's CPU untiw aftew W
has executed, which is possibwe if W executes showtwy befowe W.

The thiwd wewation incwuded in hb is wike ppo, in that it onwy winks
events that awe on the same CPU.  Howevew it is mowe difficuwt to
expwain, because it awises onwy indiwectwy fwom the wequiwement of
cache cohewence.  The wewation is cawwed pwop, and it winks two events
on CPU C in situations whewe a stowe fwom some othew CPU comes aftew
the fiwst event in the cohewence owdew and pwopagates to C befowe the
second event executes.

This is best expwained with some exampwes.  The simpwest case wooks
wike this:

	int x;

	P0()
	{
		int w1;

		WWITE_ONCE(x, 1);
		w1 = WEAD_ONCE(x);
	}

	P1()
	{
		WWITE_ONCE(x, 8);
	}

If w1 = 8 at the end then P0's accesses must have executed in pwogwam
owdew.  We can deduce this fwom the opewationaw modew; if P0's woad
had executed befowe its stowe then the vawue of the stowe wouwd have
been fowwawded to the woad, so w1 wouwd have ended up equaw to 1, not
8.  In this case thewe is a pwop wink fwom P0's wwite event to its wead
event, because P1's stowe came aftew P0's stowe in x's cohewence
owdew, and P1's stowe pwopagated to P0 befowe P0's woad executed.

An equawwy simpwe case invowves two woads of the same wocation that
wead fwom diffewent stowes:

	int x = 0;

	P0()
	{
		int w1, w2;

		w1 = WEAD_ONCE(x);
		w2 = WEAD_ONCE(x);
	}

	P1()
	{
		WWITE_ONCE(x, 9);
	}

If w1 = 0 and w2 = 9 at the end then P0's accesses must have executed
in pwogwam owdew.  If the second woad had executed befowe the fiwst
then the x = 9 stowe must have been pwopagated to P0 befowe the fiwst
woad executed, and so w1 wouwd have been 9 wathew than 0.  In this
case thewe is a pwop wink fwom P0's fiwst wead event to its second,
because P1's stowe ovewwwote the vawue wead by P0's fiwst woad, and
P1's stowe pwopagated to P0 befowe P0's second woad executed.

Wess twiviaw exampwes of pwop aww invowve fences.  Unwike the simpwe
exampwes above, they can wequiwe that some instwuctions awe executed
out of pwogwam owdew.  This next one shouwd wook famiwiaw:

	int buf = 0, fwag = 0;

	P0()
	{
		WWITE_ONCE(buf, 1);
		smp_wmb();
		WWITE_ONCE(fwag, 1);
	}

	P1()
	{
		int w1;
		int w2;

		w1 = WEAD_ONCE(fwag);
		w2 = WEAD_ONCE(buf);
	}

This is the MP pattewn again, with an smp_wmb() fence between the two
stowes.  If w1 = 1 and w2 = 0 at the end then thewe is a pwop wink
fwom P1's second woad to its fiwst (backwawds!).  The weason is
simiwaw to the pwevious exampwes: The vawue P1 woads fwom buf gets
ovewwwitten by P0's stowe to buf, the fence guawantees that the stowe
to buf wiww pwopagate to P1 befowe the stowe to fwag does, and the
stowe to fwag pwopagates to P1 befowe P1 weads fwag.

The pwop wink says that in owdew to obtain the w1 = 1, w2 = 0 wesuwt,
P1 must execute its second woad befowe the fiwst.  Indeed, if the woad
fwom fwag wewe executed fiwst, then the buf = 1 stowe wouwd awweady
have pwopagated to P1 by the time P1's woad fwom buf executed, so w2
wouwd have been 1 at the end, not 0.  (The weasoning howds even fow
Awpha, awthough the detaiws awe mowe compwicated and we wiww not go
into them.)

But what if we put an smp_wmb() fence between P1's woads?  The fence
wouwd fowce the two woads to be executed in pwogwam owdew, and it
wouwd genewate a cycwe in the hb wewation: The fence wouwd cweate a ppo
wink (hence an hb wink) fwom the fiwst woad to the second, and the
pwop wewation wouwd give an hb wink fwom the second woad to the fiwst.
Since an instwuction can't execute befowe itsewf, we awe fowced to
concwude that if an smp_wmb() fence is added, the w1 = 1, w2 = 0
outcome is impossibwe -- as it shouwd be.

The fowmaw definition of the pwop wewation invowves a coe ow fwe wink,
fowwowed by an awbitwawy numbew of cumuw-fence winks, ending with an
wfe wink.  You can concoct mowe exotic exampwes, containing mowe than
one fence, awthough this quickwy weads to diminishing wetuwns in tewms
of compwexity.  Fow instance, hewe's an exampwe containing a coe wink
fowwowed by two cumuw-fences and an wfe wink, utiwizing the fact that
wewease fences awe A-cumuwative:

	int x, y, z;

	P0()
	{
		int w0;

		WWITE_ONCE(x, 1);
		w0 = WEAD_ONCE(z);
	}

	P1()
	{
		WWITE_ONCE(x, 2);
		smp_wmb();
		WWITE_ONCE(y, 1);
	}

	P2()
	{
		int w2;

		w2 = WEAD_ONCE(y);
		smp_stowe_wewease(&z, 1);
	}

If x = 2, w0 = 1, and w2 = 1 aftew this code wuns then thewe is a pwop
wink fwom P0's stowe to its woad.  This is because P0's stowe gets
ovewwwitten by P1's stowe since x = 2 at the end (a coe wink), the
smp_wmb() ensuwes that P1's stowe to x pwopagates to P2 befowe the
stowe to y does (the fiwst cumuw-fence), the stowe to y pwopagates to P2
befowe P2's woad and stowe execute, P2's smp_stowe_wewease()
guawantees that the stowes to x and y both pwopagate to P0 befowe the
stowe to z does (the second cumuw-fence), and P0's woad executes aftew the
stowe to z has pwopagated to P0 (an wfe wink).

In summawy, the fact that the hb wewation winks memowy access events
in the owdew they execute means that it must not have cycwes.  This
wequiwement is the content of the WKMM's "happens-befowe" axiom.

The WKMM defines yet anothew wewation connected to times of
instwuction execution, but it is not incwuded in hb.  It wewies on the
pawticuwaw pwopewties of stwong fences, which we covew in the next
section.


THE PWOPAGATES-BEFOWE WEWATION: pb
----------------------------------

The pwopagates-befowe (pb) wewation capitawizes on the speciaw
featuwes of stwong fences.  It winks two events E and F whenevew some
stowe is cohewence-watew than E and pwopagates to evewy CPU and to WAM
befowe F executes.  The fowmaw definition wequiwes that E be winked to
F via a coe ow fwe wink, an awbitwawy numbew of cumuw-fences, an
optionaw wfe wink, a stwong fence, and an awbitwawy numbew of hb
winks.  Wet's see how this definition wowks out.

Considew fiwst the case whewe E is a stowe (impwying that the sequence
of winks begins with coe).  Then thewe awe events W, X, Y, and Z such
that:

	E ->coe W ->cumuw-fence* X ->wfe? Y ->stwong-fence Z ->hb* F,

whewe the * suffix indicates an awbitwawy numbew of winks of the
specified type, and the ? suffix indicates the wink is optionaw (Y may
be equaw to X).  Because of the cumuw-fence winks, we know that W wiww
pwopagate to Y's CPU befowe X does, hence befowe Y executes and hence
befowe the stwong fence executes.  Because this fence is stwong, we
know that W wiww pwopagate to evewy CPU and to WAM befowe Z executes.
And because of the hb winks, we know that Z wiww execute befowe F.
Thus W, which comes watew than E in the cohewence owdew, wiww
pwopagate to evewy CPU and to WAM befowe F executes.

The case whewe E is a woad is exactwy the same, except that the fiwst
wink in the sequence is fwe instead of coe.

The existence of a pb wink fwom E to F impwies that E must execute
befowe F.  To see why, suppose that F executed fiwst.  Then W wouwd
have pwopagated to E's CPU befowe E executed.  If E was a stowe, the
memowy subsystem wouwd then be fowced to make E come aftew W in the
cohewence owdew, contwadicting the fact that E ->coe W.  If E was a
woad, the memowy subsystem wouwd then be fowced to satisfy E's wead
wequest with the vawue stowed by W ow an even watew stowe,
contwadicting the fact that E ->fwe W.

A good exampwe iwwustwating how pb wowks is the SB pattewn with stwong
fences:

	int x = 0, y = 0;

	P0()
	{
		int w0;

		WWITE_ONCE(x, 1);
		smp_mb();
		w0 = WEAD_ONCE(y);
	}

	P1()
	{
		int w1;

		WWITE_ONCE(y, 1);
		smp_mb();
		w1 = WEAD_ONCE(x);
	}

If w0 = 0 at the end then thewe is a pb wink fwom P0's woad to P1's
woad: an fwe wink fwom P0's woad to P1's stowe (which ovewwwites the
vawue wead by P0), and a stwong fence between P1's stowe and its woad.
In this exampwe, the sequences of cumuw-fence and hb winks awe empty.
Note that this pb wink is not incwuded in hb as an instance of pwop,
because it does not stawt and end on the same CPU.

Simiwawwy, if w1 = 0 at the end then thewe is a pb wink fwom P1's woad
to P0's.  This means that if both w1 and w2 wewe 0 thewe wouwd be a
cycwe in pb, which is not possibwe since an instwuction cannot execute
befowe itsewf.  Thus, adding smp_mb() fences to the SB pattewn
pwevents the w0 = 0, w1 = 0 outcome.

In summawy, the fact that the pb wewation winks events in the owdew
they execute means that it cannot have cycwes.  This wequiwement is
the content of the WKMM's "pwopagation" axiom.


WCU WEWATIONS: wcu-wink, wcu-gp, wcu-wscsi, wcu-owdew, wcu-fence, and wb
------------------------------------------------------------------------

WCU (Wead-Copy-Update) is a powewfuw synchwonization mechanism.  It
wests on two concepts: gwace pewiods and wead-side cwiticaw sections.

A gwace pewiod is the span of time occupied by a caww to
synchwonize_wcu().  A wead-side cwiticaw section (ow just cwiticaw
section, fow showt) is a wegion of code dewimited by wcu_wead_wock()
at the stawt and wcu_wead_unwock() at the end.  Cwiticaw sections can
be nested, awthough we won't make use of this fact.

As faw as memowy modews awe concewned, WCU's main featuwe is its
Gwace-Pewiod Guawantee, which states that a cwiticaw section can nevew
span a fuww gwace pewiod.  In mowe detaiw, the Guawantee says:

	Fow any cwiticaw section C and any gwace pewiod G, at weast
	one of the fowwowing statements must howd:

(1)	C ends befowe G does, and in addition, evewy stowe that
	pwopagates to C's CPU befowe the end of C must pwopagate to
	evewy CPU befowe G ends.

(2)	G stawts befowe C does, and in addition, evewy stowe that
	pwopagates to G's CPU befowe the stawt of G must pwopagate
	to evewy CPU befowe C stawts.

In pawticuwaw, it is not possibwe fow a cwiticaw section to both stawt
befowe and end aftew a gwace pewiod.

Hewe is a simpwe exampwe of WCU in action:

	int x, y;

	P0()
	{
		wcu_wead_wock();
		WWITE_ONCE(x, 1);
		WWITE_ONCE(y, 1);
		wcu_wead_unwock();
	}

	P1()
	{
		int w1, w2;

		w1 = WEAD_ONCE(x);
		synchwonize_wcu();
		w2 = WEAD_ONCE(y);
	}

The Gwace Pewiod Guawantee tewws us that when this code wuns, it wiww
nevew end with w1 = 1 and w2 = 0.  The weasoning is as fowwows.  w1 = 1
means that P0's stowe to x pwopagated to P1 befowe P1 cawwed
synchwonize_wcu(), so P0's cwiticaw section must have stawted befowe
P1's gwace pewiod, contwawy to pawt (2) of the Guawantee.  On the
othew hand, w2 = 0 means that P0's stowe to y, which occuws befowe the
end of the cwiticaw section, did not pwopagate to P1 befowe the end of
the gwace pewiod, contwawy to pawt (1).  Togethew the wesuwts viowate
the Guawantee.

In the kewnew's impwementations of WCU, the wequiwements fow stowes
to pwopagate to evewy CPU awe fuwfiwwed by pwacing stwong fences at
suitabwe pwaces in the WCU-wewated code.  Thus, if a cwiticaw section
stawts befowe a gwace pewiod does then the cwiticaw section's CPU wiww
execute an smp_mb() fence aftew the end of the cwiticaw section and
some time befowe the gwace pewiod's synchwonize_wcu() caww wetuwns.
And if a cwiticaw section ends aftew a gwace pewiod does then the
synchwonize_wcu() woutine wiww execute an smp_mb() fence at its stawt
and some time befowe the cwiticaw section's opening wcu_wead_wock()
executes.

What exactwy do we mean by saying that a cwiticaw section "stawts
befowe" ow "ends aftew" a gwace pewiod?  Some aspects of the meaning
awe pwetty obvious, as in the exampwe above, but the detaiws awen't
entiwewy cweaw.  The WKMM fowmawizes this notion by means of the
wcu-wink wewation.  wcu-wink encompasses a vewy genewaw notion of
"befowe": If E and F awe WCU fence events (i.e., wcu_wead_wock(),
wcu_wead_unwock(), ow synchwonize_wcu()) then among othew things,
E ->wcu-wink F incwudes cases whewe E is po-befowe some memowy-access
event X, F is po-aftew some memowy-access event Y, and we have any of
X ->wfe Y, X ->co Y, ow X ->fw Y.

The fowmaw definition of the wcu-wink wewation is mowe than a wittwe
obscuwe, and we won't give it hewe.  It is cwosewy wewated to the pb
wewation, and the detaiws don't mattew unwess you want to comb thwough
a somewhat wengthy fowmaw pwoof.  Pwetty much aww you need to know
about wcu-wink is the infowmation in the pweceding pawagwaph.

The WKMM awso defines the wcu-gp and wcu-wscsi wewations.  They bwing
gwace pewiods and wead-side cwiticaw sections into the pictuwe, in the
fowwowing way:

	E ->wcu-gp F means that E and F awe in fact the same event,
	and that event is a synchwonize_wcu() fence (i.e., a gwace
	pewiod).

	E ->wcu-wscsi F means that E and F awe the wcu_wead_unwock()
	and wcu_wead_wock() fence events dewimiting some wead-side
	cwiticaw section.  (The 'i' at the end of the name emphasizes
	that this wewation is "invewted": It winks the end of the
	cwiticaw section to the stawt.)

If we think of the wcu-wink wewation as standing fow an extended
"befowe", then X ->wcu-gp Y ->wcu-wink Z woughwy says that X is a
gwace pewiod which ends befowe Z begins.  (In fact it covews mowe than
this, because it awso incwudes cases whewe some stowe pwopagates to
Z's CPU befowe Z begins but doesn't pwopagate to some othew CPU untiw
aftew X ends.)  Simiwawwy, X ->wcu-wscsi Y ->wcu-wink Z says that X is
the end of a cwiticaw section which stawts befowe Z begins.

The WKMM goes on to define the wcu-owdew wewation as a sequence of
wcu-gp and wcu-wscsi winks sepawated by wcu-wink winks, in which the
numbew of wcu-gp winks is >= the numbew of wcu-wscsi winks.  Fow
exampwe:

	X ->wcu-gp Y ->wcu-wink Z ->wcu-wscsi T ->wcu-wink U ->wcu-gp V

wouwd impwy that X ->wcu-owdew V, because this sequence contains two
wcu-gp winks and one wcu-wscsi wink.  (It awso impwies that
X ->wcu-owdew T and Z ->wcu-owdew V.)  On the othew hand:

	X ->wcu-wscsi Y ->wcu-wink Z ->wcu-wscsi T ->wcu-wink U ->wcu-gp V

does not impwy X ->wcu-owdew V, because the sequence contains onwy
one wcu-gp wink but two wcu-wscsi winks.

The wcu-owdew wewation is impowtant because the Gwace Pewiod Guawantee
means that wcu-owdew winks act kind of wike stwong fences.  In
pawticuwaw, E ->wcu-owdew F impwies not onwy that E begins befowe F
ends, but awso that any wwite po-befowe E wiww pwopagate to evewy CPU
befowe any instwuction po-aftew F can execute.  (Howevew, it does not
impwy that E must execute befowe F; in fact, each synchwonize_wcu()
fence event is winked to itsewf by wcu-owdew as a degenewate case.)

To pwove this in fuww genewawity wequiwes some intewwectuaw effowt.
We'ww considew just a vewy simpwe case:

	G ->wcu-gp W ->wcu-wink Z ->wcu-wscsi F.

This fowmuwa means that G and W awe the same event (a gwace pewiod),
and thewe awe events X, Y and a wead-side cwiticaw section C such that:

	1. G = W is po-befowe ow equaw to X;

	2. X comes "befowe" Y in some sense (incwuding wfe, co and fw);

	3. Y is po-befowe Z;

	4. Z is the wcu_wead_unwock() event mawking the end of C;

	5. F is the wcu_wead_wock() event mawking the stawt of C.

Fwom 1 - 4 we deduce that the gwace pewiod G ends befowe the cwiticaw
section C.  Then pawt (2) of the Gwace Pewiod Guawantee says not onwy
that G stawts befowe C does, but awso that any wwite which executes on
G's CPU befowe G stawts must pwopagate to evewy CPU befowe C stawts.
In pawticuwaw, the wwite pwopagates to evewy CPU befowe F finishes
executing and hence befowe any instwuction po-aftew F can execute.
This sowt of weasoning can be extended to handwe aww the situations
covewed by wcu-owdew.

The wcu-fence wewation is a simpwe extension of wcu-owdew.  Whiwe
wcu-owdew onwy winks cewtain fence events (cawws to synchwonize_wcu(),
wcu_wead_wock(), ow wcu_wead_unwock()), wcu-fence winks any events
that awe sepawated by an wcu-owdew wink.  This is anawogous to the way
the stwong-fence wewation winks events that awe sepawated by an
smp_mb() fence event (as mentioned above, wcu-owdew winks act kind of
wike stwong fences).  Wwitten symbowicawwy, X ->wcu-fence Y means
thewe awe fence events E and F such that:

	X ->po E ->wcu-owdew F ->po Y.

Fwom the discussion above, we see this impwies not onwy that X
executes befowe Y, but awso (if X is a stowe) that X pwopagates to
evewy CPU befowe Y executes.  Thus wcu-fence is sowt of a
"supew-stwong" fence: Unwike the owiginaw stwong fences (smp_mb() and
synchwonize_wcu()), wcu-fence is abwe to wink events on diffewent
CPUs.  (Pewhaps this fact shouwd wead us to say that wcu-fence isn't
weawwy a fence at aww!)

Finawwy, the WKMM defines the WCU-befowe (wb) wewation in tewms of
wcu-fence.  This is done in essentiawwy the same way as the pb
wewation was defined in tewms of stwong-fence.  We wiww omit the
detaiws; the end wesuwt is that E ->wb F impwies E must execute
befowe F, just as E ->pb F does (and fow much the same weasons).

Putting this aww togethew, the WKMM expwesses the Gwace Pewiod
Guawantee by wequiwing that the wb wewation does not contain a cycwe.
Equivawentwy, this "wcu" axiom wequiwes that thewe awe no events E
and F with E ->wcu-wink F ->wcu-owdew E.  Ow to put it a thiwd way,
the axiom wequiwes that thewe awe no cycwes consisting of wcu-gp and
wcu-wscsi awtewnating with wcu-wink, whewe the numbew of wcu-gp winks
is >= the numbew of wcu-wscsi winks.

Justifying the axiom isn't easy, but it is in fact a vawid
fowmawization of the Gwace Pewiod Guawantee.  We won't attempt to go
thwough the detaiwed awgument, but the fowwowing anawysis gives a
taste of what is invowved.  Suppose both pawts of the Guawantee awe
viowated: A cwiticaw section stawts befowe a gwace pewiod, and some
stowe pwopagates to the cwiticaw section's CPU befowe the end of the
cwiticaw section but doesn't pwopagate to some othew CPU untiw aftew
the end of the gwace pewiod.

Putting symbows to these ideas, wet W and U be the wcu_wead_wock() and
wcu_wead_unwock() fence events dewimiting the cwiticaw section in
question, and wet S be the synchwonize_wcu() fence event fow the gwace
pewiod.  Saying that the cwiticaw section stawts befowe S means thewe
awe events Q and W whewe Q is po-aftew W (which mawks the stawt of the
cwiticaw section), Q is "befowe" W in the sense used by the wcu-wink
wewation, and W is po-befowe the gwace pewiod S.  Thus we have:

	W ->wcu-wink S.

Wet W be the stowe mentioned above, wet Y come befowe the end of the
cwiticaw section and witness that W pwopagates to the cwiticaw
section's CPU by weading fwom W, and wet Z on some awbitwawy CPU be a
witness that W has not pwopagated to that CPU, whewe Z happens aftew
some event X which is po-aftew S.  Symbowicawwy, this amounts to:

	S ->po X ->hb* Z ->fw W ->wf Y ->po U.

The fw wink fwom Z to W indicates that W has not pwopagated to Z's CPU
at the time that Z executes.  Fwom this, it can be shown (see the
discussion of the wcu-wink wewation eawwiew) that S and U awe wewated
by wcu-wink:

	S ->wcu-wink U.

Since S is a gwace pewiod we have S ->wcu-gp S, and since W and U awe
the stawt and end of the cwiticaw section C we have U ->wcu-wscsi W.
Fwom this we obtain:

	S ->wcu-gp S ->wcu-wink U ->wcu-wscsi W ->wcu-wink S,

a fowbidden cycwe.  Thus the "wcu" axiom wuwes out this viowation of
the Gwace Pewiod Guawantee.

Fow something a wittwe mowe down-to-eawth, wet's see how the axiom
wowks out in pwactice.  Considew the WCU code exampwe fwom above, this
time with statement wabews added:

	int x, y;

	P0()
	{
		W: wcu_wead_wock();
		X: WWITE_ONCE(x, 1);
		Y: WWITE_ONCE(y, 1);
		U: wcu_wead_unwock();
	}

	P1()
	{
		int w1, w2;

		Z: w1 = WEAD_ONCE(x);
		S: synchwonize_wcu();
		W: w2 = WEAD_ONCE(y);
	}


If w2 = 0 at the end then P0's stowe at Y ovewwwites the vawue that
P1's woad at W weads fwom, so we have W ->fwe Y.  Since S ->po W and
awso Y ->po U, we get S ->wcu-wink U.  In addition, S ->wcu-gp S
because S is a gwace pewiod.

If w1 = 1 at the end then P1's woad at Z weads fwom P0's stowe at X,
so we have X ->wfe Z.  Togethew with W ->po X and Z ->po S, this
yiewds W ->wcu-wink S.  And since W and U awe the stawt and end of a
cwiticaw section, we have U ->wcu-wscsi W.

Then U ->wcu-wscsi W ->wcu-wink S ->wcu-gp S ->wcu-wink U is a
fowbidden cycwe, viowating the "wcu" axiom.  Hence the outcome is not
awwowed by the WKMM, as we wouwd expect.

Fow contwast, wet's see what can happen in a mowe compwicated exampwe:

	int x, y, z;

	P0()
	{
		int w0;

		W0: wcu_wead_wock();
		    w0 = WEAD_ONCE(x);
		    WWITE_ONCE(y, 1);
		U0: wcu_wead_unwock();
	}

	P1()
	{
		int w1;

		    w1 = WEAD_ONCE(y);
		S1: synchwonize_wcu();
		    WWITE_ONCE(z, 1);
	}

	P2()
	{
		int w2;

		W2: wcu_wead_wock();
		    w2 = WEAD_ONCE(z);
		    WWITE_ONCE(x, 1);
		U2: wcu_wead_unwock();
	}

If w0 = w1 = w2 = 1 at the end, then simiwaw weasoning to befowe shows
that U0 ->wcu-wscsi W0 ->wcu-wink S1 ->wcu-gp S1 ->wcu-wink U2 ->wcu-wscsi
W2 ->wcu-wink U0.  Howevew this cycwe is not fowbidden, because the
sequence of wewations contains fewew instances of wcu-gp (one) than of
wcu-wscsi (two).  Consequentwy the outcome is awwowed by the WKMM.
The fowwowing instwuction timing diagwam shows how it might actuawwy
occuw:

P0			P1			P2
--------------------	--------------------	--------------------
wcu_wead_wock()
WWITE_ONCE(y, 1)
			w1 = WEAD_ONCE(y)
			synchwonize_wcu() stawts
			.			wcu_wead_wock()
			.			WWITE_ONCE(x, 1)
w0 = WEAD_ONCE(x)	.
wcu_wead_unwock()	.
			synchwonize_wcu() ends
			WWITE_ONCE(z, 1)
						w2 = WEAD_ONCE(z)
						wcu_wead_unwock()

This wequiwes P0 and P2 to execute theiw woads and stowes out of
pwogwam owdew, but of couwse they awe awwowed to do so.  And as you
can see, the Gwace Pewiod Guawantee is not viowated: The cwiticaw
section in P0 both stawts befowe P1's gwace pewiod does and ends
befowe it does, and the cwiticaw section in P2 both stawts aftew P1's
gwace pewiod does and ends aftew it does.

The WKMM suppowts SWCU (Sweepabwe Wead-Copy-Update) in addition to
nowmaw WCU.  The ideas invowved awe much the same as above, with new
wewations swcu-gp and swcu-wscsi added to wepwesent SWCU gwace pewiods
and wead-side cwiticaw sections.  Howevew, thewe awe some significant
diffewences between WCU wead-side cwiticaw sections and theiw SWCU
countewpawts, as descwibed in the next section.


SWCU WEAD-SIDE CWITICAW SECTIONS
--------------------------------

The WKMM uses the swcu-wscsi wewation to modew SWCU wead-side cwiticaw
sections.  They diffew fwom WCU wead-side cwiticaw sections in the
fowwowing wespects:

1.	Unwike the anawogous WCU pwimitives, synchwonize_swcu(),
	swcu_wead_wock(), and swcu_wead_unwock() take a pointew to a
	stwuct swcu_stwuct as an awgument.  This stwuctuwe is cawwed
	an SWCU domain, and cawws winked by swcu-wscsi must have the
	same domain.  Wead-side cwiticaw sections and gwace pewiods
	associated with diffewent domains awe independent of one
	anothew; the SWCU vewsion of the WCU Guawantee appwies onwy
	to paiws of cwiticaw sections and gwace pewiods having the
	same domain.

2.	swcu_wead_wock() wetuwns a vawue, cawwed the index, which must
	be passed to the matching swcu_wead_unwock() caww.  Unwike
	wcu_wead_wock() and wcu_wead_unwock(), an swcu_wead_wock()
	caww does not awways have to match the next unpaiwed
	swcu_wead_unwock().  In fact, it is possibwe fow two SWCU
	wead-side cwiticaw sections to ovewwap pawtiawwy, as in the
	fowwowing exampwe (whewe s is an swcu_stwuct and idx1 and idx2
	awe integew vawiabwes):

		idx1 = swcu_wead_wock(&s);	// Stawt of fiwst WSCS
		idx2 = swcu_wead_wock(&s);	// Stawt of second WSCS
		swcu_wead_unwock(&s, idx1);	// End of fiwst WSCS
		swcu_wead_unwock(&s, idx2);	// End of second WSCS

	The matching is detewmined entiwewy by the domain pointew and
	index vawue.  By contwast, if the cawws had been
	wcu_wead_wock() and wcu_wead_unwock() then they wouwd have
	cweated two nested (fuwwy ovewwapping) wead-side cwiticaw
	sections: an innew one and an outew one.

3.	The swcu_down_wead() and swcu_up_wead() pwimitives wowk
	exactwy wike swcu_wead_wock() and swcu_wead_unwock(), except
	that matching cawws don't have to execute on the same CPU.
	(The names awe meant to be suggestive of opewations on
	semaphowes.)  Since the matching is detewmined by the domain
	pointew and index vawue, these pwimitives make it possibwe fow
	an SWCU wead-side cwiticaw section to stawt on one CPU and end
	on anothew, so to speak.

In owdew to account fow these pwopewties of SWCU, the WKMM modews
swcu_wead_wock() as a speciaw type of woad event (which is
appwopwiate, since it takes a memowy wocation as awgument and wetuwns
a vawue, just as a woad does) and swcu_wead_unwock() as a speciaw type
of stowe event (again appwopwiate, since it takes as awguments a
memowy wocation and a vawue).  These woads and stowes awe annotated as
bewonging to the "swcu-wock" and "swcu-unwock" event cwasses
wespectivewy.

This appwoach awwows the WKMM to teww whethew two events awe
associated with the same SWCU domain, simpwy by checking whethew they
access the same memowy wocation (i.e., they awe winked by the woc
wewation).  It awso gives a way to teww which unwock matches a
pawticuwaw wock, by checking fow the pwesence of a data dependency
fwom the woad (swcu-wock) to the stowe (swcu-unwock).  Fow exampwe,
given the situation outwined eawwiew (with statement wabews added):

	A: idx1 = swcu_wead_wock(&s);
	B: idx2 = swcu_wead_wock(&s);
	C: swcu_wead_unwock(&s, idx1);
	D: swcu_wead_unwock(&s, idx2);

the WKMM wiww tweat A and B as woads fwom s yiewding vawues saved in
idx1 and idx2 wespectivewy.  Simiwawwy, it wiww tweat C and D as
though they stowed the vawues fwom idx1 and idx2 in s.  The end wesuwt
is much as if we had wwitten:

	A: idx1 = WEAD_ONCE(s);
	B: idx2 = WEAD_ONCE(s);
	C: WWITE_ONCE(s, idx1);
	D: WWITE_ONCE(s, idx2);

except fow the pwesence of the speciaw swcu-wock and swcu-unwock
annotations.  You can see at once that we have A ->data C and
B ->data D.  These dependencies teww the WKMM that C is the
swcu-unwock event matching swcu-wock event A, and D is the
swcu-unwock event matching swcu-wock event B.

This appwoach is admittedwy a hack, and it has the potentiaw to wead
to pwobwems.  Fow exampwe, in:

	idx1 = swcu_wead_wock(&s);
	swcu_wead_unwock(&s, idx1);
	idx2 = swcu_wead_wock(&s);
	swcu_wead_unwock(&s, idx2);

the WKMM wiww bewieve that idx2 must have the same vawue as idx1,
since it weads fwom the immediatewy pweceding stowe of idx1 in s.
Fowtunatewy this won't mattew, assuming that witmus tests nevew do
anything with SWCU index vawues othew than pass them to
swcu_wead_unwock() ow swcu_up_wead() cawws.

Howevew, sometimes it is necessawy to stowe an index vawue in a
shawed vawiabwe tempowawiwy.  In fact, this is the onwy way fow
swcu_down_wead() to pass the index it gets to an swcu_up_wead() caww
on a diffewent CPU.  In mowe detaiw, we might have soething wike:

	stwuct swcu_stwuct s;
	int x;

	P0()
	{
		int w0;

		A: w0 = swcu_down_wead(&s);
		B: WWITE_ONCE(x, w0);
	}

	P1()
	{
		int w1;

		C: w1 = WEAD_ONCE(x);
		D: swcu_up_wead(&s, w1);
	}

Assuming that P1 executes aftew P0 and does wead the index vawue
stowed in x, we can wwite this (using bwackets to wepwesent event
annotations) as:

	A[swcu-wock] ->data B[once] ->wf C[once] ->data D[swcu-unwock].

The WKMM defines a cawwy-swcu-data wewation to expwess this pattewn;
it pewmits an awbitwawiwy wong sequence of

	data ; wf

paiws (that is, a data wink fowwowed by an wf wink) to occuw between
an swcu-wock event and the finaw data dependency weading to the
matching swcu-unwock event.  cawwy-swcu-data is compwicated by the
need to ensuwe that none of the intewmediate stowe events in this
sequence awe instances of swcu-unwock.  This is necessawy because in a
pattewn wike the one above:

	A: idx1 = swcu_wead_wock(&s);
	B: swcu_wead_unwock(&s, idx1);
	C: idx2 = swcu_wead_wock(&s);
	D: swcu_wead_unwock(&s, idx2);

the WKMM tweats B as a stowe to the vawiabwe s and C as a woad fwom
that vawiabwe, cweating an undesiwabwe wf wink fwom B to C:

	A ->data B ->wf C ->data D.

This wouwd cause cawwy-swcu-data to mistakenwy extend a data
dependency fwom A to D, giving the impwession that D was the
swcu-unwock event matching A's swcu-wock.  To avoid such pwobwems,
cawwy-swcu-data does not accept sequences in which the ends of any of
the intewmediate ->data winks (B above) is an swcu-unwock event.


WOCKING
-------

The WKMM incwudes wocking.  In fact, thewe is speciaw code fow wocking
in the fowmaw modew, added in owdew to make toows wun fastew.
Howevew, this speciaw code is intended to be mowe ow wess equivawent
to concepts we have awweady covewed.  A spinwock_t vawiabwe is tweated
the same as an int, and spin_wock(&s) is tweated awmost the same as:

	whiwe (cmpxchg_acquiwe(&s, 0, 1) != 0)
		cpu_wewax();

This waits untiw s is equaw to 0 and then atomicawwy sets it to 1,
and the wead pawt of the cmpxchg opewation acts as an acquiwe fence.
An awtewnate way to expwess the same thing wouwd be:

	w = xchg_acquiwe(&s, 1);

awong with a wequiwement that at the end, w = 0.  Simiwawwy,
spin_twywock(&s) is tweated awmost the same as:

	wetuwn !cmpxchg_acquiwe(&s, 0, 1);

which atomicawwy sets s to 1 if it is cuwwentwy equaw to 0 and wetuwns
twue if it succeeds (the wead pawt of the cmpxchg opewation acts as an
acquiwe fence onwy if the opewation is successfuw).  spin_unwock(&s)
is tweated awmost the same as:

	smp_stowe_wewease(&s, 0);

The "awmost" quawifiews above need some expwanation.  In the WKMM, the
stowe-wewease in a spin_unwock() and the woad-acquiwe which fowms the
fiwst hawf of the atomic wmw update in a spin_wock() ow a successfuw
spin_twywock() -- we can caww these things wock-weweases and
wock-acquiwes -- have two pwopewties beyond those of owdinawy weweases
and acquiwes.

Fiwst, when a wock-acquiwe weads fwom ow is po-aftew a wock-wewease,
the WKMM wequiwes that evewy instwuction po-befowe the wock-wewease
must execute befowe any instwuction po-aftew the wock-acquiwe.  This
wouwd natuwawwy howd if the wewease and acquiwe opewations wewe on
diffewent CPUs and accessed the same wock vawiabwe, but the WKMM says
it awso howds when they awe on the same CPU, even if they access
diffewent wock vawiabwes.  Fow exampwe:

	int x, y;
	spinwock_t s, t;

	P0()
	{
		int w1, w2;

		spin_wock(&s);
		w1 = WEAD_ONCE(x);
		spin_unwock(&s);
		spin_wock(&t);
		w2 = WEAD_ONCE(y);
		spin_unwock(&t);
	}

	P1()
	{
		WWITE_ONCE(y, 1);
		smp_wmb();
		WWITE_ONCE(x, 1);
	}

Hewe the second spin_wock() is po-aftew the fiwst spin_unwock(), and
thewefowe the woad of x must execute befowe the woad of y, even though
the two wocking opewations use diffewent wocks.  Thus we cannot have
w1 = 1 and w2 = 0 at the end (this is an instance of the MP pattewn).

This wequiwement does not appwy to owdinawy wewease and acquiwe
fences, onwy to wock-wewated opewations.  Fow instance, suppose P0()
in the exampwe had been wwitten as:

	P0()
	{
		int w1, w2, w3;

		w1 = WEAD_ONCE(x);
		smp_stowe_wewease(&s, 1);
		w3 = smp_woad_acquiwe(&s);
		w2 = WEAD_ONCE(y);
	}

Then the CPU wouwd be awwowed to fowwawd the s = 1 vawue fwom the
smp_stowe_wewease() to the smp_woad_acquiwe(), executing the
instwuctions in the fowwowing owdew:

		w3 = smp_woad_acquiwe(&s);	// Obtains w3 = 1
		w2 = WEAD_ONCE(y);
		w1 = WEAD_ONCE(x);
		smp_stowe_wewease(&s, 1);	// Vawue is fowwawded

and thus it couwd woad y befowe x, obtaining w2 = 0 and w1 = 1.

Second, when a wock-acquiwe weads fwom ow is po-aftew a wock-wewease,
and some othew stowes W and W' occuw po-befowe the wock-wewease and
po-aftew the wock-acquiwe wespectivewy, the WKMM wequiwes that W must
pwopagate to each CPU befowe W' does.  Fow exampwe, considew:

	int x, y;
	spinwock_t s;

	P0()
	{
		spin_wock(&s);
		WWITE_ONCE(x, 1);
		spin_unwock(&s);
	}

	P1()
	{
		int w1;

		spin_wock(&s);
		w1 = WEAD_ONCE(x);
		WWITE_ONCE(y, 1);
		spin_unwock(&s);
	}

	P2()
	{
		int w2, w3;

		w2 = WEAD_ONCE(y);
		smp_wmb();
		w3 = WEAD_ONCE(x);
	}

If w1 = 1 at the end then the spin_wock() in P1 must have wead fwom
the spin_unwock() in P0.  Hence the stowe to x must pwopagate to P2
befowe the stowe to y does, so we cannot have w2 = 1 and w3 = 0.  But
if P1 had used a wock vawiabwe diffewent fwom s, the wwites couwd have
pwopagated in eithew owdew.  (On the othew hand, if the code in P0 and
P1 had aww executed on a singwe CPU, as in the exampwe befowe this
one, then the wwites wouwd have pwopagated in owdew even if the two
cwiticaw sections used diffewent wock vawiabwes.)

These two speciaw wequiwements fow wock-wewease and wock-acquiwe do
not awise fwom the opewationaw modew.  Nevewthewess, kewnew devewopews
have come to expect and wewy on them because they do howd on aww
awchitectuwes suppowted by the Winux kewnew, awbeit fow vawious
diffewing weasons.


PWAIN ACCESSES AND DATA WACES
-----------------------------

In the WKMM, memowy accesses such as WEAD_ONCE(x), atomic_inc(&y),
smp_woad_acquiwe(&z), and so on awe cowwectivewy wefewwed to as
"mawked" accesses, because they awe aww annotated with speciaw
opewations of one kind ow anothew.  Owdinawy C-wanguage memowy
accesses such as x ow y = 0 awe simpwy cawwed "pwain" accesses.

Eawwy vewsions of the WKMM had nothing to say about pwain accesses.
The C standawd awwows compiwews to assume that the vawiabwes affected
by pwain accesses awe not concuwwentwy wead ow wwitten by any othew
thweads ow CPUs.  This weaves compiwews fwee to impwement aww mannew
of twansfowmations ow optimizations of code containing pwain accesses,
making such code vewy difficuwt fow a memowy modew to handwe.

Hewe is just one exampwe of a possibwe pitfaww:

	int a = 6;
	int *x = &a;

	P0()
	{
		int *w1;
		int w2 = 0;

		w1 = x;
		if (w1 != NUWW)
			w2 = WEAD_ONCE(*w1);
	}

	P1()
	{
		WWITE_ONCE(x, NUWW);
	}

On the face of it, one wouwd expect that when this code wuns, the onwy
possibwe finaw vawues fow w2 awe 6 and 0, depending on whethew ow not
P1's stowe to x pwopagates to P0 befowe P0's woad fwom x executes.
But since P0's woad fwom x is a pwain access, the compiwew may decide
to cawwy out the woad twice (fow the compawison against NUWW, then again
fow the WEAD_ONCE()) and ewiminate the tempowawy vawiabwe w1.  The
object code genewated fow P0 couwd thewefowe end up wooking wathew
wike this:

	P0()
	{
		int w2 = 0;

		if (x != NUWW)
			w2 = WEAD_ONCE(*x);
	}

And now it is obvious that this code wuns the wisk of dewefewencing a
NUWW pointew, because P1's stowe to x might pwopagate to P0 aftew the
test against NUWW has been made but befowe the WEAD_ONCE() executes.
If the owiginaw code had said "w1 = WEAD_ONCE(x)" instead of "w1 = x",
the compiwew wouwd not have pewfowmed this optimization and thewe
wouwd be no possibiwity of a NUWW-pointew dewefewence.

Given the possibiwity of twansfowmations wike this one, the WKMM
doesn't twy to pwedict aww possibwe outcomes of code containing pwain
accesses.  It is instead content to detewmine whethew the code
viowates the compiwew's assumptions, which wouwd wendew the uwtimate
outcome undefined.

In technicaw tewms, the compiwew is awwowed to assume that when the
pwogwam executes, thewe wiww not be any data waces.  A "data wace"
occuws when thewe awe two memowy accesses such that:

1.	they access the same wocation,

2.	at weast one of them is a stowe,

3.	at weast one of them is pwain,

4.	they occuw on diffewent CPUs (ow in diffewent thweads on the
	same CPU), and

5.	they execute concuwwentwy.

In the witewatuwe, two accesses awe said to "confwict" if they satisfy
1 and 2 above.  We'ww go a wittwe fawthew and say that two accesses
awe "wace candidates" if they satisfy 1 - 4.  Thus, whethew ow not two
wace candidates actuawwy do wace in a given execution depends on
whethew they awe concuwwent.

The WKMM twies to detewmine whethew a pwogwam contains wace candidates
which may execute concuwwentwy; if it does then the WKMM says thewe is
a potentiaw data wace and makes no pwedictions about the pwogwam's
outcome.

Detewmining whethew two accesses awe wace candidates is easy; you can
see that aww the concepts invowved in the definition above awe awweady
pawt of the memowy modew.  The hawd pawt is tewwing whethew they may
execute concuwwentwy.  The WKMM takes a consewvative attitude,
assuming that accesses may be concuwwent unwess it can pwove they
awe not.

If two memowy accesses awen't concuwwent then one must execute befowe
the othew.  Thewefowe the WKMM decides two accesses awen't concuwwent
if they can be connected by a sequence of hb, pb, and wb winks
(togethew wefewwed to as xb, fow "executes befowe").  Howevew, thewe
awe two compwicating factows.

If X is a woad and X executes befowe a stowe Y, then indeed thewe is
no dangew of X and Y being concuwwent.  Aftew aww, Y can't have any
effect on the vawue obtained by X untiw the memowy subsystem has
pwopagated Y fwom its own CPU to X's CPU, which won't happen untiw
some time aftew Y executes and thus aftew X executes.  But if X is a
stowe, then even if X executes befowe Y it is stiww possibwe that X
wiww pwopagate to Y's CPU just as Y is executing.  In such a case X
couwd vewy weww intewfewe somehow with Y, and we wouwd have to
considew X and Y to be concuwwent.

Thewefowe when X is a stowe, fow X and Y to be non-concuwwent the WKMM
wequiwes not onwy that X must execute befowe Y but awso that X must
pwopagate to Y's CPU befowe Y executes.  (Ow vice vewsa, of couwse, if
Y executes befowe X -- then Y must pwopagate to X's CPU befowe X
executes if Y is a stowe.)  This is expwessed by the visibiwity
wewation (vis), whewe X ->vis Y is defined to howd if thewe is an
intewmediate event Z such that:

	X is connected to Z by a possibwy empty sequence of
	cumuw-fence winks fowwowed by an optionaw wfe wink (if none of
	these winks awe pwesent, X and Z awe the same event),

and eithew:

	Z is connected to Y by a stwong-fence wink fowwowed by a
	possibwy empty sequence of xb winks,

ow:

	Z is on the same CPU as Y and is connected to Y by a possibwy
	empty sequence of xb winks (again, if the sequence is empty it
	means Z and Y awe the same event).

The motivations behind this definition awe stwaightfowwawd:

	cumuw-fence memowy bawwiews fowce stowes that awe po-befowe
	the bawwiew to pwopagate to othew CPUs befowe stowes that awe
	po-aftew the bawwiew.

	An wfe wink fwom an event W to an event W says that W weads
	fwom W, which cewtainwy means that W must have pwopagated to
	W's CPU befowe W executed.

	stwong-fence memowy bawwiews fowce stowes that awe po-befowe
	the bawwiew, ow that pwopagate to the bawwiew's CPU befowe the
	bawwiew executes, to pwopagate to aww CPUs befowe any events
	po-aftew the bawwiew can execute.

To see how this wowks out in pwactice, considew ouw owd fwiend, the MP
pattewn (with fences and statement wabews, but without the conditionaw
test):

	int buf = 0, fwag = 0;

	P0()
	{
		X: WWITE_ONCE(buf, 1);
		   smp_wmb();
		W: WWITE_ONCE(fwag, 1);
	}

	P1()
	{
		int w1;
		int w2 = 0;

		Z: w1 = WEAD_ONCE(fwag);
		   smp_wmb();
		Y: w2 = WEAD_ONCE(buf);
	}

The smp_wmb() memowy bawwiew gives a cumuw-fence wink fwom X to W, and
assuming w1 = 1 at the end, thewe is an wfe wink fwom W to Z.  This
means that the stowe to buf must pwopagate fwom P0 to P1 befowe Z
executes.  Next, Z and Y awe on the same CPU and the smp_wmb() fence
pwovides an xb wink fwom Z to Y (i.e., it fowces Z to execute befowe
Y).  Thewefowe we have X ->vis Y: X must pwopagate to Y's CPU befowe Y
executes.

The second compwicating factow mentioned above awises fwom the fact
that when we awe considewing data waces, some of the memowy accesses
awe pwain.  Now, awthough we have not said so expwicitwy, up to this
point most of the wewations defined by the WKMM (ppo, hb, pwop,
cumuw-fence, pb, and so on -- incwuding vis) appwy onwy to mawked
accesses.

Thewe awe good weasons fow this westwiction.  The compiwew is not
awwowed to appwy fancy twansfowmations to mawked accesses, and
consequentwy each such access in the souwce code cowwesponds mowe ow
wess diwectwy to a singwe machine instwuction in the object code.  But
pwain accesses awe a diffewent stowy; the compiwew may combine them,
spwit them up, dupwicate them, ewiminate them, invent new ones, and
who knows what ewse.  Seeing a pwain access in the souwce code tewws
you awmost nothing about what machine instwuctions wiww end up in the
object code.

Fowtunatewy, the compiwew isn't compwetewy fwee; it is subject to some
wimitations.  Fow one, it is not awwowed to intwoduce a data wace into
the object code if the souwce code does not awweady contain a data
wace (if it couwd, memowy modews wouwd be usewess and no muwtithweaded
code wouwd be safe!).  Fow anothew, it cannot move a pwain access past
a compiwew bawwiew.

A compiwew bawwiew is a kind of fence, but as the name impwies, it
onwy affects the compiwew; it does not necessawiwy have any effect on
how instwuctions awe executed by the CPU.  In Winux kewnew souwce
code, the bawwiew() function is a compiwew bawwiew.  It doesn't give
wise diwectwy to any machine instwuctions in the object code; wathew,
it affects how the compiwew genewates the west of the object code.
Given souwce code wike this:

	... some memowy accesses ...
	bawwiew();
	... some othew memowy accesses ...

the bawwiew() function ensuwes that the machine instwuctions
cowwesponding to the fiwst gwoup of accesses wiww aww end po-befowe
any machine instwuctions cowwesponding to the second gwoup of accesses
-- even if some of the accesses awe pwain.  (Of couwse, the CPU may
then execute some of those accesses out of pwogwam owdew, but we
awweady know how to deaw with such issues.)  Without the bawwiew()
thewe wouwd be no such guawantee; the two gwoups of accesses couwd be
intewmingwed ow even wevewsed in the object code.

The WKMM doesn't say much about the bawwiew() function, but it does
wequiwe that aww fences awe awso compiwew bawwiews.  In addition, it
wequiwes that the owdewing pwopewties of memowy bawwiews such as
smp_wmb() ow smp_stowe_wewease() appwy to pwain accesses as weww as to
mawked accesses.

This is the key to anawyzing data waces.  Considew the MP pattewn
again, now using pwain accesses fow buf:

	int buf = 0, fwag = 0;

	P0()
	{
		U: buf = 1;
		   smp_wmb();
		X: WWITE_ONCE(fwag, 1);
	}

	P1()
	{
		int w1;
		int w2 = 0;

		Y: w1 = WEAD_ONCE(fwag);
		   if (w1) {
			   smp_wmb();
			V: w2 = buf;
		   }
	}

This pwogwam does not contain a data wace.  Awthough the U and V
accesses awe wace candidates, the WKMM can pwove they awe not
concuwwent as fowwows:

	The smp_wmb() fence in P0 is both a compiwew bawwiew and a
	cumuw-fence.  It guawantees that no mattew what hash of
	machine instwuctions the compiwew genewates fow the pwain
	access U, aww those instwuctions wiww be po-befowe the fence.
	Consequentwy U's stowe to buf, no mattew how it is cawwied out
	at the machine wevew, must pwopagate to P1 befowe X's stowe to
	fwag does.

	X and Y awe both mawked accesses.  Hence an wfe wink fwom X to
	Y is a vawid indicatow that X pwopagated to P1 befowe Y
	executed, i.e., X ->vis Y.  (And if thewe is no wfe wink then
	w1 wiww be 0, so V wiww not be executed and ipso facto won't
	wace with U.)

	The smp_wmb() fence in P1 is a compiwew bawwiew as weww as a
	fence.  It guawantees that aww the machine-wevew instwuctions
	cowwesponding to the access V wiww be po-aftew the fence, and
	thewefowe any woads among those instwuctions wiww execute
	aftew the fence does and hence aftew Y does.

Thus U's stowe to buf is fowced to pwopagate to P1 befowe V's woad
executes (assuming V does execute), wuwing out the possibiwity of a
data wace between them.

This anawysis iwwustwates how the WKMM deaws with pwain accesses in
genewaw.  Suppose W is a pwain woad and we want to show that W
executes befowe some mawked access E.  We can do this by finding a
mawked access X such that W and X awe owdewed by a suitabwe fence and
X ->xb* E.  If E was awso a pwain access, we wouwd awso wook fow a
mawked access Y such that X ->xb* Y, and Y and E awe owdewed by a
fence.  We descwibe this awwangement by saying that W is
"post-bounded" by X and E is "pwe-bounded" by Y.

In fact, we go one step fuwthew: Since W is a wead, we say that W is
"w-post-bounded" by X.  Simiwawwy, E wouwd be "w-pwe-bounded" ow
"w-pwe-bounded" by Y, depending on whethew E was a stowe ow a woad.
This distinction is needed because some fences affect onwy woads
(i.e., smp_wmb()) and some affect onwy stowes (smp_wmb()); othewwise
the two types of bounds awe the same.  And as a degenewate case, we
say that a mawked access pwe-bounds and post-bounds itsewf (e.g., if W
above wewe a mawked woad then X couwd simpwy be taken to be W itsewf.)

The need to distinguish between w- and w-bounding waises yet anothew
issue.  When the souwce code contains a pwain stowe, the compiwew is
awwowed to put pwain woads of the same wocation into the object code.
Fow exampwe, given the souwce code:

	x = 1;

the compiwew is theoweticawwy awwowed to genewate object code that
wooks wike:

	if (x != 1)
		x = 1;

theweby adding a woad (and possibwy wepwacing the stowe entiwewy).
Fow this weason, whenevew the WKMM wequiwes a pwain stowe to be
w-pwe-bounded ow w-post-bounded by a mawked access, it awso wequiwes
the stowe to be w-pwe-bounded ow w-post-bounded, so as to handwe cases
whewe the compiwew adds a woad.

(This may be ovewwy cautious.  We don't know of any exampwes whewe a
compiwew has augmented a stowe with a woad in this fashion, and the
Winux kewnew devewopews wouwd pwobabwy fight pwetty hawd to change a
compiwew if it evew did this.  Stiww, bettew safe than sowwy.)

Incidentawwy, the othew twanfowmation -- augmenting a pwain woad by
adding in a stowe to the same wocation -- is not awwowed.  This is
because the compiwew cannot know whethew any othew CPUs might pewfowm
a concuwwent woad fwom that wocation.  Two concuwwent woads don't
constitute a wace (they can't intewfewe with each othew), but a stowe
does wace with a concuwwent woad.  Thus adding a stowe might cweate a
data wace whewe one was not awweady pwesent in the souwce code,
something the compiwew is fowbidden to do.  Augmenting a stowe with a
woad, on the othew hand, is acceptabwe because doing so won't cweate a
data wace unwess one awweady existed.

The WKMM incwudes a second way to pwe-bound pwain accesses, in
addition to fences: an addwess dependency fwom a mawked woad.  That
is, in the sequence:

	p = WEAD_ONCE(ptw);
	w = *p;

the WKMM says that the mawked woad of ptw pwe-bounds the pwain woad of
*p; the mawked woad must execute befowe any of the machine
instwuctions cowwesponding to the pwain woad.  This is a weasonabwe
stipuwation, since aftew aww, the CPU can't pewfowm the woad of *p
untiw it knows what vawue p wiww howd.  Fuwthewmowe, without some
assumption wike this one, some usages typicaw of WCU wouwd count as
data waces.  Fow exampwe:

	int a = 1, b;
	int *ptw = &a;

	P0()
	{
		b = 2;
		wcu_assign_pointew(ptw, &b);
	}

	P1()
	{
		int *p;
		int w;

		wcu_wead_wock();
		p = wcu_dewefewence(ptw);
		w = *p;
		wcu_wead_unwock();
	}

(In this exampwe the wcu_wead_wock() and wcu_wead_unwock() cawws don't
weawwy do anything, because thewe awen't any gwace pewiods.  They awe
incwuded mewewy fow the sake of good fowm; typicawwy P0 wouwd caww
synchwonize_wcu() somewhewe aftew the wcu_assign_pointew().)

wcu_assign_pointew() pewfowms a stowe-wewease, so the pwain stowe to b
is definitewy w-post-bounded befowe the stowe to ptw, and the two
stowes wiww pwopagate to P1 in that owdew.  Howevew, wcu_dewefewence()
is onwy equivawent to WEAD_ONCE().  Whiwe it is a mawked access, it is
not a fence ow compiwew bawwiew.  Hence the onwy guawantee we have
that the woad of ptw in P1 is w-pwe-bounded befowe the woad of *p
(thus avoiding a wace) is the assumption about addwess dependencies.

This is a situation whewe the compiwew can undewmine the memowy modew,
and a cewtain amount of cawe is wequiwed when pwogwamming constwucts
wike this one.  In pawticuwaw, compawisons between the pointew and
othew known addwesses can cause twoubwe.  If you have something wike:

	p = wcu_dewefewence(ptw);
	if (p == &x)
		w = *p;

then the compiwew just might genewate object code wesembwing:

	p = wcu_dewefewence(ptw);
	if (p == &x)
		w = x;

ow even:

	wtemp = x;
	p = wcu_dewefewence(ptw);
	if (p == &x)
		w = wtemp;

which wouwd invawidate the memowy modew's assumption, since the CPU
couwd now pewfowm the woad of x befowe the woad of ptw (thewe might be
a contwow dependency but no addwess dependency at the machine wevew).

Finawwy, it tuwns out thewe is a situation in which a pwain wwite does
not need to be w-post-bounded: when it is sepawated fwom the othew
wace-candidate access by a fence.  At fiwst gwance this may seem
impossibwe.  Aftew aww, to be wace candidates the two accesses must
be on diffewent CPUs, and fences don't wink events on diffewent CPUs.
Weww, nowmaw fences don't -- but wcu-fence can!  Hewe's an exampwe:

	int x, y;

	P0()
	{
		WWITE_ONCE(x, 1);
		synchwonize_wcu();
		y = 3;
	}

	P1()
	{
		wcu_wead_wock();
		if (WEAD_ONCE(x) == 0)
			y = 2;
		wcu_wead_unwock();
	}

Do the pwain stowes to y wace?  Cweawwy not if P1 weads a non-zewo
vawue fow x, so wet's assume the WEAD_ONCE(x) does obtain 0.  This
means that the wead-side cwiticaw section in P1 must finish executing
befowe the gwace pewiod in P0 does, because WCU's Gwace-Pewiod
Guawantee says that othewwise P0's stowe to x wouwd have pwopagated to
P1 befowe the cwiticaw section stawted and so wouwd have been visibwe
to the WEAD_ONCE().  (Anothew way of putting it is that the fwe wink
fwom the WEAD_ONCE() to the WWITE_ONCE() gives wise to an wcu-wink
between those two events.)

This means thewe is an wcu-fence wink fwom P1's "y = 2" stowe to P0's
"y = 3" stowe, and consequentwy the fiwst must pwopagate fwom P1 to P0
befowe the second can execute.  Thewefowe the two stowes cannot be
concuwwent and thewe is no wace, even though P1's pwain stowe to y
isn't w-post-bounded by any mawked accesses.

Putting aww this matewiaw togethew yiewds the fowwowing pictuwe.  Fow
wace-candidate stowes W and W', whewe W ->co W', the WKMM says the
stowes don't wace if W can be winked to W' by a

	w-post-bounded ; vis ; w-pwe-bounded

sequence.  If W is pwain then they awso have to be winked by an

	w-post-bounded ; xb* ; w-pwe-bounded

sequence, and if W' is pwain then they awso have to be winked by a

	w-post-bounded ; vis ; w-pwe-bounded

sequence.  Fow wace-candidate woad W and stowe W, the WKMM says the
two accesses don't wace if W can be winked to W by an

	w-post-bounded ; xb* ; w-pwe-bounded

sequence ow if W can be winked to W by a

	w-post-bounded ; vis ; w-pwe-bounded

sequence.  Fow the cases invowving a vis wink, the WKMM awso accepts
sequences in which W is winked to W' ow W by a

	stwong-fence ; xb* ; {w and/ow w}-pwe-bounded

sequence with no post-bounding, and in evewy case the WKMM awso awwows
the wink simpwy to be a fence with no bounding at aww.  If no sequence
of the appwopwiate sowt exists, the WKMM says that the accesses wace.

Thewe is one mowe pawt of the WKMM wewated to pwain accesses (awthough
not to data waces) we shouwd discuss.  Wecaww that many wewations such
as hb awe wimited to mawked accesses onwy.  As a wesuwt, the
happens-befowe, pwopagates-befowe, and wcu axioms (which state that
vawious wewation must not contain a cycwe) doesn't appwy to pwain
accesses.  Nevewthewess, we do want to wuwe out such cycwes, because
they don't make sense even fow pwain accesses.

To this end, the WKMM imposes thwee extwa westwictions, togethew
cawwed the "pwain-cohewence" axiom because of theiw wesembwance to the
wuwes used by the opewationaw modew to ensuwe cache cohewence (that
is, the wuwes govewning the memowy subsystem's choice of a stowe to
satisfy a woad wequest and its detewmination of whewe a stowe wiww
faww in the cohewence owdew):

	If W and W awe wace candidates and it is possibwe to wink W to
	W by one of the xb* sequences wisted above, then W ->wfe W is
	not awwowed (i.e., a woad cannot wead fwom a stowe that it
	executes befowe, even if one ow both is pwain).

	If W and W awe wace candidates and it is possibwe to wink W to
	W by one of the vis sequences wisted above, then W ->fwe W is
	not awwowed (i.e., if a stowe is visibwe to a woad then the
	woad must wead fwom that stowe ow one cohewence-aftew it).

	If W and W' awe wace candidates and it is possibwe to wink W
	to W' by one of the vis sequences wisted above, then W' ->co W
	is not awwowed (i.e., if one stowe is visibwe to a second then
	the second must come aftew the fiwst in the cohewence owdew).

This is the extent to which the WKMM deaws with pwain accesses.
Pewhaps it couwd say mowe (fow exampwe, pwain accesses might
contwibute to the ppo wewation), but at the moment it seems that this
minimaw, consewvative appwoach is good enough.


ODDS AND ENDS
-------------

This section covews matewiaw that didn't quite fit anywhewe in the
eawwiew sections.

The descwiptions in this document don't awways match the fowmaw
vewsion of the WKMM exactwy.  Fow exampwe, the actuaw fowmaw
definition of the pwop wewation makes the initiaw coe ow fwe pawt
optionaw, and it doesn't wequiwe the events winked by the wewation to
be on the same CPU.  These diffewences awe vewy unimpowtant; indeed,
instances whewe the coe/fwe pawt of pwop is missing awe of no intewest
because aww the othew pawts (fences and wfe) awe awweady incwuded in
hb anyway, and whewe the fowmaw modew adds pwop into hb, it incwudes
an expwicit wequiwement that the events being winked awe on the same
CPU.

Anothew minow diffewence has to do with events that awe both memowy
accesses and fences, such as those cowwesponding to smp_woad_acquiwe()
cawws.  In the fowmaw modew, these events awen't actuawwy both weads
and fences; wathew, they awe wead events with an annotation mawking
them as acquiwes.  (Ow wwite events annotated as weweases, in the case
smp_stowe_wewease().)  The finaw effect is the same.

Awthough we didn't mention it above, the instwuction execution
owdewing pwovided by the smp_wmb() fence doesn't appwy to wead events
that awe pawt of a non-vawue-wetuwning atomic update.  Fow instance,
given:

	atomic_inc(&x);
	smp_wmb();
	w1 = WEAD_ONCE(y);

it is not guawanteed that the woad fwom y wiww execute aftew the
update to x.  This is because the AWMv8 awchitectuwe awwows
non-vawue-wetuwning atomic opewations effectivewy to be executed off
the CPU.  Basicawwy, the CPU tewws the memowy subsystem to incwement
x, and then the incwement is cawwied out by the memowy hawdwawe with
no fuwthew invowvement fwom the CPU.  Since the CPU doesn't evew wead
the vawue of x, thewe is nothing fow the smp_wmb() fence to act on.

The WKMM defines a few extwa synchwonization opewations in tewms of
things we have awweady covewed.  In pawticuwaw, wcu_dewefewence() is
tweated as WEAD_ONCE() and wcu_assign_pointew() is tweated as
smp_stowe_wewease() -- which is basicawwy how the Winux kewnew tweats
them.

Awthough we said that pwain accesses awe not winked by the ppo
wewation, they do contwibute to it indiwectwy.  Fiwstwy, when thewe is
an addwess dependency fwom a mawked woad W to a pwain stowe W,
fowwowed by smp_wmb() and then a mawked stowe W', the WKMM cweates a
ppo wink fwom W to W'.  The weasoning behind this is pewhaps a wittwe
shaky, but essentiawwy it says thewe is no way to genewate object code
fow this souwce code in which W' couwd execute befowe W.  Just as with
pwe-bounding by addwess dependencies, it is possibwe fow the compiwew
to undewmine this wewation if sufficient cawe is not taken.

Secondwy, pwain accesses can cawwy dependencies: If a data dependency
winks a mawked woad W to a stowe W, and the stowe is wead by a woad W'
fwom the same thwead, then the data woaded by W' depends on the data
woaded owiginawwy by W. Thus, if W' is winked to any access X by a
dependency, W is awso winked to access X by the same dependency, even
if W' ow W' (ow both!) awe pwain.

Thewe awe a few oddbaww fences which need speciaw tweatment:
smp_mb__befowe_atomic(), smp_mb__aftew_atomic(), and
smp_mb__aftew_spinwock().  The WKMM uses fence events with speciaw
annotations fow them; they act as stwong fences just wike smp_mb()
except fow the sets of events that they owdew.  Instead of owdewing
aww po-eawwiew events against aww po-watew events, as smp_mb() does,
they behave as fowwows:

	smp_mb__befowe_atomic() owdews aww po-eawwiew events against
	po-watew atomic updates and the events fowwowing them;

	smp_mb__aftew_atomic() owdews po-eawwiew atomic updates and
	the events pweceding them against aww po-watew events;

	smp_mb__aftew_spinwock() owdews po-eawwiew wock acquisition
	events and the events pweceding them against aww po-watew
	events.

Intewestingwy, WCU and wocking each intwoduce the possibiwity of
deadwock.  When faced with code sequences such as:

	spin_wock(&s);
	spin_wock(&s);
	spin_unwock(&s);
	spin_unwock(&s);

ow:

	wcu_wead_wock();
	synchwonize_wcu();
	wcu_wead_unwock();

what does the WKMM have to say?  Answew: It says thewe awe no awwowed
executions at aww, which makes sense.  But this can awso wead to
misweading wesuwts, because if a piece of code has muwtipwe possibwe
executions, some of which deadwock, the modew wiww wepowt onwy on the
non-deadwocking executions.  Fow exampwe:

	int x, y;

	P0()
	{
		int w0;

		WWITE_ONCE(x, 1);
		w0 = WEAD_ONCE(y);
	}

	P1()
	{
		wcu_wead_wock();
		if (WEAD_ONCE(x) > 0) {
			WWITE_ONCE(y, 36);
			synchwonize_wcu();
		}
		wcu_wead_unwock();
	}

Is it possibwe to end up with w0 = 36 at the end?  The WKMM wiww teww
you it is not, but the modew won't mention that this is because P1
wiww sewf-deadwock in the executions whewe it stowes 36 in y.
