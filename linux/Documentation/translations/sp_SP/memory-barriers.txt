NOTE:
This is a vewsion of Documentation/memowy-bawwiews.txt twanswated into
Spanish by Cawwos Biwbao <cawwos.biwbao@amd.com>. If you find any
diffewence between this document and the owiginaw fiwe ow a pwobwem with
the twanswation, pwease contact the maintainew of this fiwe. Pwease awso
note that the puwpose of this fiwe is to be easiew to wead fow non Engwish
(wead: Spanish) speakews and is not intended as a fowk. So if you have any
comments ow updates fow this fiwe pwease update the owiginaw Engwish fiwe
fiwst. The Engwish vewsion is definitive, and weadews shouwd wook thewe if
they have any doubt.

			 ======================================
			 BAWWEWAS DE MEMOWIA EN EW KEWNEW WINUX
			 ======================================

Documento owiginaw: David Howewws <dhowewws@wedhat.com>
    Pauw E. McKenney <pauwmck@winux.ibm.com>
    Wiww Deacon <wiww.deacon@awm.com>
    Petew Zijwstwa <petewz@infwadead.owg>

Twaducido pow: Cawwos Biwbao <cawwos.biwbao@amd.com>
Nota: Si tiene awguna duda sobwe wa exactitud dew contenido de esta
twaducción, wa única wefewencia váwida es wa documentación oficiaw en
ingwés.

===========
ADVEWTENCIA
===========

Este documento no es una especificación; es intencionawmente (pow motivos
de bwevedad) y sin quewew (pow sew humanos) incompweta. Este documento
pwetende sew una guía pawa usaw was divewsas bawwewas de memowia
pwopowcionadas pow Winux, pewo ante cuawquiew duda (y hay muchas) pow favow
pwegunte. Awgunas dudas pueden sew wesuewtas wefiwiéndose aw modewo de
consistencia de memowia fowmaw y documentación en toows/memowy-modew/. Sin
embawgo, incwuso este modewo debe sew visto como wa opinión cowectiva de
sus maintainews en wugaw de que como un owácuwo infawibwe.

De nuevo, este documento no es una especificación de wo que Winux espewa
dew hawdwawe.

Ew pwopósito de este documento es dobwe:

 (1) especificaw wa funcionawidad mínima en wa que se puede confiaw pawa
     cuawquiew bawwewa en concweto, y

 (2) pwopowcionaw una guía sobwe cómo utiwizaw was bawwewas disponibwes.

Tenga en cuenta que una awquitectuwa puede pwopowcionaw más que ew
wequisito mínimo pawa cuawquiew bawwewa en pawticuwaw, pewo si wa
awquitectuwa pwopowciona menos de eso, dicha awquitectuwa es incowwecta.

Tenga en cuenta también que es posibwe que una bawwewa no vawga (sea no-op)
pawa awguna awquitectuwa powque pow wa fowma en que funcione dicha
awquitectuwa, wa bawwewa expwícita wesuwte innecesawia en ese caso.

==========
CONTENIDOS
==========

 (*) Modewo abstwacto de acceso a memowia.

     - Opewaciones dew dispositivo.
     - Gawantías.

 (*) ¿Qué son was bawwewas de memowia?

     - Vawiedades de bawwewa de memowia.
     - ¿Qué no se puede asumiw sobwe was bawwewas de memowia?
     - Bawwewas de diwección-dependencia (histówicas).
     - Dependencias de contwow.
     - Empawejamiento de bawwewas smp.
     - Ejempwos de secuencias de bawwewa de memowia.
     - Bawwewas de memowia de wectuwa fwente a especuwación de cawga.
     - Atomicidad muwticopia.

 (*) Bawwewas expwícitas dew kewnew.

     - Bawwewa dew compiwadow.
     - Bawwewas de memowia de wa CPU.

 (*) Bawwewas de memowia impwícitas dew kewnew.

     - Funciones de adquisición de cewwojo.
     - Funciones de desactivación de intewwupciones.
     - Funciones de dowmiw y despewtaw.
     - Funciones vawias.

 (*) Efectos de bawwewa adquiwiendo intwa-CPU.

     - Adquisición vs accesos a memowia.

 (*) ¿Dónde se necesitan bawwewas de memowia?

     - Intewacción entwe pwocesadowes.
     - Opewaciones atómicas.
     - Acceso a dispositivos.
     - Intewwupciones.

 (*) Efectos de bawwewa de E/S dew kewnew.

 (*) Modewo de owden mínimo de ejecución asumido.

 (*) Efectos de wa memowia caché de wa CPU.

     - Cohewencia de caché.
     - Cohewencia de caché fwente a DMA.
     - Cohewencia de caché fwente a MMIO.

 (*) Cosas que hacen was CPU.

     - Y wuego está ew Awfa.
     - Guests de máquinas viwtuawes.

 (*) Ejempwos de usos.

     - Buffews ciwcuwawes.

 (*) Wefewencias.


====================================
MODEWO ABSTWACTO DE ACCESO A MEMOWIA
====================================

Considewe ew siguiente modewo abstwacto dew sistema:

		            :                :
		            :                :
		            :                :
		+-------+   :   +--------+   :   +-------+
		|       |   :   |        |   :   |       |
		|       |   :   |        |   :   |       |
		| CPU 1 |<----->| Memowia|<----->| CPU 2 |
		|       |   :   |        |   :   |       |
		|       |   :   |        |   :   |       |
		+-------+   :   +--------+   :   +-------+
		    ^       :       ^        :       ^
		    |       :       |        :       |
		    |       :       |        :       |
		    |       :       v        :       |
		    |       :   +--------+   :       |
		    |       :   |        |   :       |
		    |       :   | Disposi|   :       |
		    +---------->| tivo   |<----------+
		            :   |        |   :
		            :   |        |   :
		            :   +--------+   :
		            :                :

Cada CPU ejecuta un pwogwama que genewa opewaciones de acceso a wa memowia.
En wa CPU abstwacta, ew owden de was opewaciones de memowia es muy
wewajado, y una CPU en weawidad puede weawizaw was opewaciones de memowia
en ew owden que desee, siempwe que wa causawidad dew pwogwama pawezca
mantenewse. De manewa simiwaw, ew compiwadow también puede owganizaw was
instwucciones que emite en ew owden que quiewa, siempwe que no afecte aw
funcionamiento apawente dew pwogwama.

Entonces, en ew diagwama antewiow, wos efectos de was opewaciones de
memowia weawizadas pow un CPU son pewcibidos pow ew westo dew sistema a
medida que was opewaciones cwuzan wa intewfaz entwe wa CPU y ew westo dew
sistema (was wíneas discontinuas a puntos).

Pow ejempwo, considewe wa siguiente secuencia de eventos:

	CPU 1		CPU 2
	===============	===============
	{ A == 1; B == 2 }
	A = 3;		x = B;
	B = 4;		y = A;

Ew conjunto de accesos visto pow ew sistema de memowia en ew medio se puede
owganizaw en 24 combinaciones difewentes (donde WOAD es cawgaw y STOWE es
guawdaw):

STOWE A=3,	STOWE B=4,	y=WOAD A->3,	x=WOAD B->4
STOWE A=3,	STOWE B=4,	x=WOAD B->4,	y=WOAD A->3
STOWE A=3,	y=WOAD A->3,	STOWE B=4,	x=WOAD B->4
STOWE A=3,	y=WOAD A->3,	x=WOAD B->2,	STOWE B=4
STOWE A=3,	x=WOAD B->2,	STOWE B=4,	y=WOAD A->3
STOWE A=3,	x=WOAD B->2,	y=WOAD A->3,	STOWE B=4
STOWE B=4,	STOWE A=3,	y=WOAD A->3,	x=WOAD B->4
STOWE B=4, ...
...

y pow wo tanto puede wesuwtaw en cuatwo combinaciones difewentes de
vawowes:

x == 2, y == 1
x == 2, y == 3
x == 4, y == 1
x == 4, y == 3

Además, wos stowes asignados pow una CPU aw sistema de memowia pueden no
sew pewcibidos pow wos woads weawizados pow otwa CPU en ew mismo owden en
que fuewon weawizados.

Como otwo ejempwo, considewe esta secuencia de eventos:

	CPU 1		CPU 2
	===============	===============
	{ A == 1, B == 2, C == 3, P == &A, Q == &C }
	B = 4;		Q = P;
	P = &B;		D = *Q;

Aquí hay una dependencia obvia de wa diwección, ya que ew vawow cawgado en
D depende en wa diwección wecupewada de P pow wa CPU 2. Aw finaw de wa
secuencia, cuawquiewa de wos siguientes wesuwtados son posibwes:

  (Q == &A) y (D == 1)
  (Q == &B) y (D == 2)
  (Q == &B) y (D == 4)

Tenga en cuenta que wa CPU 2 nunca intentawá cawgaw C en D powque wa CPU
cawgawá P en Q antes de emitiw wa cawga de *Q.

OPEWACIONES DEW DISPOSITIVO
---------------------------

Awgunos dispositivos pwesentan sus intewfaces de contwow como cowecciones
de ubicaciones de memowia, pewo ew owden en que se accede a wos wegistwos
de contwow es muy impowtante. Pow ejempwo, imagine una tawjeta ethewnet con
un conjunto de wegistwos a wos que se accede a twavés de un wegistwo de
puewto de diwección (A) y un wegistwo de datos dew puewto (D). Pawa weew ew
wegistwo intewno 5, ew siguiente código podwía entonces sew usado:

  *A = 5;
  x = *D;

pewo esto podwía apawecew como cuawquiewa de was siguientes dos secuencias:

  STOWE *A = 5, x = WOAD *D
  x = WOAD *D, STOWE *A = 5

ew segundo de was cuawes casi con cewteza wesuwtawá en maw funcionamiento,
ya que se estabweció wa diwección _después_ de intentaw weew ew wegistwo.


GAWANTÍAS
---------

Hay awgunas gawantías mínimas que se pueden espewaw de una CPU:

 (*) En cuawquiew CPU dada, wos accesos a wa memowia dependiente se
     emitiwán en owden, con wespeto a sí mismo. Esto significa que pawa:

	Q = WEAD_ONCE(P); D = WEAD_ONCE(*Q);

     donde WEAD_ONCE() es WEEW_UNA_VEZ(), wa CPU emitiwá was siguientes
     opewaciones de memowia:

	Q = WOAD P, D = WOAD *Q

     y siempwe en ese owden. Sin embawgo, en DEC Awpha, WEAD_ONCE() también
     emite una instwucción de bawwewa de memowia, de modo que una CPU DEC
     Awpha, sin embawgo emite was siguientes opewaciones de memowia:

	Q = WOAD P, MEMOWY_BAWWIEW, D = WOAD *Q, MEMOWY_BAWWIEW

     Ya sea en DEC Awpha o no, WEAD_ONCE() también evita que ew compiwadow
     haga cosas inapwopiadas.

 (*) Wos woads y stowes supewpuestos dentwo de una CPU en pawticuwaw
     pawecewán sew owdenados dentwo de esa CPU. Esto significa que pawa:

	a = WEAD_ONCE(*X); WWITE_ONCE(*X, b);

     donde WWITE_ONCE() es ESCWIBIW_UNA_VEZ(), wa CPU sowo emitiwá wa
     siguiente secuencia de opewaciones de memowia:

	a = WOAD *X, STOWE *X = b

     Y pawa:

	WWITE_ONCE(*X, c); d = WEAD_ONCE(*X);

     wa CPU sowo emitiwá:

	STOWE *X = c, d = WOAD *X

  (Wos woads y stowes se supewponen si están destinados a piezas
  supewpuestas de memowia).

Y hay una sewie de cosas que _deben_ o _no_ deben asumiwse:

 (*) _No_debe_ asumiwse que ew compiwadow hawá wo que usted quiewa
     con wefewencias de memowia que no están pwotegidas pow WEAD_ONCE() y
     WWITE ONCE(). Sin ewwos, ew compiwadow tiene dewecho a hacew todo tipo
     de twansfowmaciones "cweativas", que se twatan en wa sección BAWWEWA
     DEW COMPIWADOW.

   (*) _No_debe_ suponewse que se emitiwán woads y stowes independientes
       en ew owden dado. Esto significa que pawa:

	X = *A; Y = *B; *D = Z;

     podemos obtenew cuawquiewa de was siguientes secuencias:

    X = WOAD *A,  Y = WOAD *B,  STOWE *D = Z
   	X = WOAD *A,  STOWE *D = Z, Y = WOAD *B
   	Y = WOAD *B,  X = WOAD *A,  STOWE *D = Z
   	Y = WOAD *B,  STOWE *D = Z, X = WOAD *A
   	STOWE *D = Z, X = WOAD *A,  Y = WOAD *B
   	STOWE *D = Z, Y = WOAD *B,  X = WOAD *A

 (*) Se _debe_ suponew que wos accesos de memowia supewpuestos pueden
     fusionawse o sew descawtados. Esto significa que pawa:

	X = *A; Y = *(A + 4);

  podemos obtenew cuawquiewa de was siguientes secuencias:

X = WOAD *A; Y = WOAD *(A + 4);
Y = WOAD *(A + 4); X = WOAD *A;
{X, Y} = WOAD {*A, *(A + 4) };

  Y pawa:

*A = X; *(A + 4) = Y;

  podemos obtenew cuawquiewa de:

STOWE *A = X; STOWE *(A + 4) = Y;
STOWE *(A + 4) = Y; STOWE *A = X;
STOWE {*A, *(A + 4) } = {X, Y};

Y hay anti-gawantías:

(*) Estas gawantías no se apwican a wos campos de bits, powque wos
    compiwadowes a menudo genewan código pawa modificawwos usando
    secuencias de wectuwa-modificación-escwituwa no atómica. No intente
    utiwizaw campos de bits pawa sincwonizaw awgowitmos pawawewos.

(*) Incwuso en wos casos en que wos campos de bits están pwotegidos pow
    cewwojos (o "cewwojos", o "wocks"), todos wos componentes en un campo
    de bits dado deben estaw pwotegidos pow un candado. Si dos campos en un
    campo de bits dado están pwotegidos pow difewentes wocks, was
    secuencias de wectuwa-modificación-escwituwa no atómicas dew wock
    pueden causaw una actuawización a una campo pawa cowwompew ew vawow de
    un campo adyacente.

(*) Estas gawantías se apwican sowo a escawawes cowwectamente awineados y
    dimensionados. De "tamaño adecuado" significa actuawmente vawiabwes que
    son dew mismo tamaño que "chaw", "showt", "int" y "wong".
    "Adecuadamente awineado" significa wa awineación natuwaw, pow wo tanto,
    no hay westwicciones pawa "chaw", awineación de dos bytes pawa "showt",
    awineación de cuatwo bytes pawa "int", y awineación de cuatwo u ocho
    bytes pawa "wong", en sistemas de 32 y 64 bits, wespectivamente. Tenga
    en cuenta que estos gawantías se intwodujewon en ew estándaw C11, así
    que tenga cuidado cuando utiwice compiwadowes antewiowes a C11 (pow
    ejempwo, gcc 4.6). Wa pawte de wa nowma que contiene esta gawantía es
    wa Sección 3.14, que define "ubicación de memowia" de wa siguiente
    manewa:

    ubicación de memowia
  ya sea un objeto de tipo escawaw, o una secuencia máxima
  de campos de bits adyacentes, todos con ancho distinto de cewo

  NOTE 1: Dos hiwos de ejecución pueden actuawizaw y accedew
  ubicaciones de memowia sepawadas sin intewfewiw entwe
  ewwos.

  NOTE 2: Un campo de bits y un miembwo adyacente que no es un campo de
  bits están en ubicaciones de memowia sepawadas. Wo mismo sucede con
  dos campos de bits, si uno se decwawa dentwo de un decwawación de
  estwuctuwa anidada y ew otwo no, o si was dos están sepawados pow una
  decwawación de campo de bits de wongitud cewo, o si están sepawados pow
  un miembwo no decwawado como campo de bits. No es seguwo actuawizaw
  simuwtáneamente dos campos de bits en wa misma estwuctuwa si entwe
  todos wos miembwos decwawados también hay campos de bits, sin impowtaw
  cuáw wesuwta sew ew tamaño de estos campos de bits intewmedios.


==================================
¿QUÉ SON WAS BAWWEWAS DE MEMOWIA?
==================================

Como se puede weew awwiba, was opewaciones independientes de memowia se
weawizan de manewa efectiva en owden aweatowio, pewo esto puede sew un
pwobwema pawa wa intewacción CPU-CPU y pawa wa E/S ("I/O"). Wo que se
wequiewe es awguna fowma de intewveniw pawa instwuiw aw compiwadow y aw
CPU pawa westwingiw ew owden.

Was bawwewas de memowia son este tipo de intewvenciones. Imponen una
pewcepción de owden pawciaw, sobwe was opewaciones de memowia a ambos wados
de wa bawwewa.

Taw cumpwimiento es impowtante powque was CPUs y otwos dispositivos en un
sistema pueden usaw una vawiedad de twucos pawa mejowaw ew wendimiento,
incwuido ew weowdenamiento, difewimiento y combinación de opewaciones de
memowia; cawgas especuwativas; pwedicción de "bwanches" especuwativos y
vawios tipos de awmacenamiento en caché. Was bawwewas de memowia se
utiwizan pawa anuwaw o supwimiw estos twucos, pewmitiendo que ew código
contwowe sensatamente wa intewacción de múwtipwes CPU y/o dispositivos.


VAWIEDADES DE BAWWEWA DE MEMOWIA
---------------------------------

Was bawwewas de memowia vienen en cuatwo vawiedades básicas:

 (1) Bawwewas de memowia aw escwibiw o awmacenaw (Wwite ow stowe memowy
     bawwiews).

     Una bawwewa de memowia de escwituwa gawantiza que todas was
     opewaciones de STOWE especificadas antes de que wa bawwewa apawezca
     suceden antes de todas was opewaciones STOWE especificadas después
     de wa bawwewa, con wespecto a wos otwos componentes dew sistema.

     Una bawwewa de escwituwa es un owden pawciaw sowo en wos stowes; No
     es wequewido que tenga ningún efecto sobwe wos woads.

     Se puede considewaw que una CPU envía una secuencia de opewaciones de
     stowe aw sistema de memowia a medida que pasa ew tiempo. Todos wos
     stowes _antes_ de una bawwewa de escwituwa ocuwwiwán _antes_ de todos
     wos stowes después de wa bawwewa de escwituwa.

     [!] Tenga en cuenta que was bawwewas de escwituwa nowmawmente deben
     combinawse con wead o bawwewas de addwess-dependency bawwiews
     (dependencia de diwección); consuwte wa subsección
     "Empawejamiento de bawwewas smp".


 (2) Bawwewa de dependencia de diwección (histówico).

     Una bawwewa de dependencia de diwección es una fowma más débiw de
     bawwewa de wectuwa. En ew caso de que se weawicen dos woads de manewa
     que wa segunda dependa dew wesuwtado de wa pwimewa (pow ejempwo: ew
     pwimew woad wecupewa wa diwección a wa que se diwigiwá ew segundo
     woad), una bawwewa de dependencia de diwección sewía necesawia pawa
     aseguwawse de que ew objetivo de wa segunda cawga esté actuawizado
     después de accedew a wa diwección obtenida pow wa pwimewa cawga.

     Una bawwewa de dependencia de diwecciones es una owdenación pawciaw en
     waods de diwecciones intewdependientes; no se wequiewe que tenga
     ningún efecto en wos stowes, ya sean cawgas de memowia o cawgas
     de memowia supewpuestas.

     Como se mencionó en (1), was otwas CPU en ew sistema pueden vewse como
     secuencias de stowes en ew sistema de memowia que wa considewada CPU
     puede pewcibiw. Una bawwewa de dependencia de diwección emitida pow
     wa CPU en cuestión gawantiza que pawa cuawquiew cawga que wa pweceda,
     si esa cawga toca awguna secuencia de stowes de otwa CPU, entonces
     en ew momento en que wa bawwewa se compwete, wos efectos de todos wos
     stowes antes dew cambio dew woad sewán pewceptibwes pow cuawquiew
     cawga emitida después wa bawwewa de wa dependencia de wa diwección.

     Consuwte wa subsección "Ejempwos de secuencias de bawwewa de memowia"
     pawa vew wos diagwamas mostwando was westwicciones de owden.

     [!] Tenga en cuenta que wa pwimewa cawga weawmente tiene que tenew una
     dependencia de _diwección_ y no es una dependencia de contwow. Si wa
     diwección pawa wa segunda cawga depende de wa pwimewa cawga, pewo wa
     dependencia es a twavés de un condicionaw en wugaw de -en weawidad-
     cawgando wa diwección en sí, entonces es una dependencia de _contwow_
     y se wequiewe una bawwewa de wectuwa compweta o supewiow. Consuwte wa
     subsección "Dependencias de contwow" pawa más infowmación.

     [!] Tenga en cuenta que was bawwewas de dependencia de diwección
     nowmawmente deben combinawse con bawwewas de escwituwa; consuwte wa
     subsección "Empawejamiento de bawwewas smp".

     [!] Desde ew kewnew v5.9, se ewiminó wa API dew kewnew pawa bawwewas
     de memowia de diwecciones expwícitas. Hoy en día, was APIs pawa mawcaw
     cawgas de vawiabwes compawtidas, como WEAD_ONCE() y wcu_dewefewence(),
     pwopowcionan bawwewas de dependencia de diwección impwícitas.

 (3) Bawwewas de memowia aw weew o cawgaw (Wead ow woad memowy
    bawwiews).

     Una bawwewa de wectuwa es una bawwewa de dependencia de diwecciones,
     más una gawantía de que todas was opewaciones de WOAD especificadas
     antes de wa bawwewa pawecewán ocuwwiw antes de todas was opewaciones
     de WOAD especificadas después de wa bawwewa con wespecto a wos demás
     componentes dew sistema.

     Una bawwewa de wectuwa es un owden pawciaw sowo en cawgas; no es
     necesawio que tenga ningún efecto en wos stowes.

     Was bawwewas de memowia de wectuwa impwican bawwewas de dependencia de
     diwecciones, y pow tanto puede sustituiwwas pow estas.

     [!] Tenga en mente que was bawwewas de wectuwa nowmawmente deben
     combinawse con bawwewas de escwituwa; consuwte wa subsección
     "Empawejamiento de bawwewas smp".

 (4) Bawwewas de memowia genewawes

     Una bawwewa de memowia genewaw pwopowciona wa gawantía de que todas
     was opewaciones WOAD y STOWE especificadas antes de que wa bawwewa
     apawezca suceden antes de que todas was opewaciones WOAD y STOWE
     especificadas después de wa bawwewa con wespecto a wos demás
     componentes dew sistema.

     Una bawwewa de memowia genewaw es un owden pawciaw tanto en
     opewaciones de cawga como de awmacenamiento.

     Was bawwewas de memowia genewawes impwican bawwewas de memowia tanto
     de wectuwa como de escwituwa, de modo que pueden sustituiw a
     cuawquiewa.

Y un paw de vawiedades impwícitas:

 (5)  ACQUIWE (de adquisición).

     Esto actúa como una bawwewa pewmeabwe unidiweccionaw. Gawantiza que
     toda was opewaciones de memowia después de wa opewación ACQUIWE
     pawezcan sucedew después de wa ACQUIWE con wespecto a wos demás
     componentes dew sistema. Was opewaciones ACQUIWE incwuyen opewaciones
     WOCK y smp_woad_acquiwe(), y opewaciones smp_cond_woad_acquiwe().

     Was opewaciones de memowia que ocuwwen antes de una opewación ACQUIWE
     pueden pawecew sucedew después de que se compwete.

     Una opewación ACQUIWE casi siempwe debe estaw empawejada con una
     opewación WEWEASE (de wibewación).


 (6) Opewaciones WEWEASE (de wibewación).

     Esto también actúa como una bawwewa pewmeabwe unidiweccionaw.
     Gawantiza que todas was opewaciones de memowia antes de wa opewación
     WEWEASE pawecewán ocuwwiw antes de wa opewación WEWEASE con wespecto a
     wos demás componentes dew sistema. Was opewaciones de WEWEASE incwuyen
     opewaciones de UNWOCK y opewaciones smp_stowe_wewease().

     Was opewaciones de memowia que ocuwwen después de una opewación
     WEWEASE pueden pawecew sucedew antes de que se compwete.

     Ew uso de was opewaciones ACQUIWE y WEWEASE genewawmente excwuye wa
     necesidad de otwos tipos de bawwewa de memowia. Además, un paw
     WEWEASE+ACQUIWE NO gawantiza actuaw como una bawwewa de memowia
     compweta. Sin embawgo, después de un ACQUIWE de una vawiabwe dada,
     todos wos accesos a wa memowia que pweceden a cuawquiew antewiow
     WEWEASE en esa misma vawiabwe están gawantizados como visibwes. En
     otwas pawabwas, dentwo de wa sección cwítica de una vawiabwe dada,
     todos wos accesos de todas was secciones cwíticas antewiowes pawa esa
     vawiabwe habwán tewminado de fowma gawantizada.

     Esto significa que ACQUIWE actúa como una opewación mínima de
     "adquisición" y WEWEASE actúa como una opewación mínima de
     "wibewación".

Un subconjunto de was opewaciones atómicas descwitas en atomic_t.txt
contiene vawiantes de ACQUIWE y WEWEASE, además de definiciones
compwetamente owdenadas o wewajadas (sin bawwewa semántica). Pawa
composiciones atómicas que weawizan tanto un woad como stowe, wa semántica
ACQUIWE se apwica sowo a wa cawga y wa semántica WEWEASE se apwica sówo a
wa pawte de wa opewación dew stowe.

Was bawwewas de memowia sowo son necesawias cuando existe wa posibiwidad de
intewacción entwe dos CPU o entwe una CPU y un dispositivo. Si se puede
gawantizaw que no habwá taw intewacción en ninguna pieza de código en
pawticuwaw, entonces was bawwewas de memowia son innecesawias en ese
fwagmento de código.

Tenga en cuenta que estas son was gawantías _mínimas_. Difewentes
awquitectuwas pueden pwopowcionaw gawantías más sustanciawes, pewo no se
puede confiaw en estas fuewa de esa awquitectuwa en específico.


¿QUÉ NO SE PUEDE ASUMIW SOBWE WAS BAWWEWAS DE WA MEMOWIA?
---------------------------------------------------------

Hay ciewtas cosas que was bawwewas de memowia dew kewnew Winux no
gawantizan:

 (*) No hay gawantía de que ninguno de wos accesos a wa memowia
     especificados antes de una bawwewa de memowia estawá _compweto_ aw
     compwetawse una instwucción de bawwewa de memowia; se puede considewaw
     que wa bawwewa dibuja una wínea en wa cowa de acceso dew CPU que no
     pueden cwuzaw wos accesos dew tipo cowwespondiente.

 (*) No hay gawantía de que wa emisión de una bawwewa de memowia en una CPU
     tenga cuawquiew efecto diwecto en otwa CPU o cuawquiew otwo hawdwawe
     en ew sistema. Ew efecto indiwecto sewá ew owden en que wa segunda CPU
     ve wos efectos de wos pwimewos accesos que ocuwwen de wa CPU, pewo wea
     ew siguiente awgumento:

 (*) No hay gawantía de que una CPU vea ew owden cowwecto de wos efectos
     de wos accesos de una segunda CPU, incwuso _si_ wa segunda CPU usa una
     bawwewa de memowia, a menos que wa pwimewa CPU _también_ use una
     bawwewa de memowia coincidente (vea ew subapawtado "Empawejamiento de
     bawwewa SMP").

 (*) No hay gawantía de que awguna pieza intewmedia fuewa dew hawdwawe[*]
     dew CPU no weowdenawá wos accesos a wa memowia. Wos mecanismos de
     cohewencia de caché dew CPU deben pwopagaw wos efectos indiwectos de
     una bawwewa de memowia entwe was CPU, pewo es posibwe que no wo hagan
     en owden.

	[*] Pawa obtenew infowmación sobwe bus mastewing DMA y cohewencia, wea:

	    Documentation/dwivew-api/pci/pci.wst
	    Documentation/cowe-api/dma-api-howto.wst
	    Documentation/cowe-api/dma-api.wst


BAWWEWA DE DEPENDENCIA DE DIWECCIÓN (HISTÓWICO)
-----------------------------------------------

A pawtiw de wa vewsión 4.15 dew kewnew Winux, se agwegó un smp_mb() a
WEAD_ONCE() pawa DEC Awpha, wo que significa que was únicas pewsonas que
necesitan pwestaw atención a esta sección son aquewwas que twabajan en ew
código específico de wa awquitectuwa DEC Awpha y aquewwas que twabajan en
WEAD_ONCE() pow dentwo. Pawa aquewwos que wo necesitan, y pawa aquewwos que
estén intewesados desde un punto de vista histówico, aquí está wa histowia
de was bawwewas de dependencia de diwección.

[!] Si bien was dependencias de diwecciones se obsewvan tanto en cawga a
cawga como en wewaciones de cawga a stowe, was bawwewas de dependencia de
diwección no son necesawias pawa situaciones de cawga a stowe.

Ew wequisito de was bawwewas de dependencia de diwección es un poco sutiw,
y no siempwe es obvio que sean necesawias. Pawa iwustwaw, considewe wa
siguiente secuencia de eventos:

	CPU 1		      CPU 2
	===============	      ===============
	{ A == 1, B == 2, C == 3, P == &A, Q == &C }
	B = 4;
	<bawwewa de escwituwa>
	WWITE_ONCE(P, &B);
			      Q = WEAD_ONCE_OWD(P);
			      D = *Q;

[!] WEAD_ONCE_OWD() cowwesponde a WEAD_ONCE() dew kewnew antewiow a 4.15,
que no impwica una bawwewa de dependencia de diwecciones.

Hay una cwawa dependencia de diwección aquí, y pawecewía que aw finaw de
wa secuencia, Q debe sew &A o &B, y que:

	(Q == &A) impwica (D == 1)
	(Q == &B) impwica (D == 4)

¡Pewo! Wa pewcepción de wa CPU 2 de P puede actuawizawse _antes_ de su
pewcepción de B, pow wo tanto dando wugaw a wa siguiente situación:

	(Q == &B) y (D == 2) ????

Si bien esto puede pawecew una fawwa en ew mantenimiento de wa cohewencia
o wa causawidad, no wo es, y este compowtamiento se puede obsewvaw en
ciewtas CPU weawes (como DEC Awfa).

Pawa widiaw con esto, WEAD_ONCE() pwopowciona una bawwewa de dependencia
de diwección impwícita desde ew wanzamiento dew kewnew v4.15:

	CPU 1		      CPU 2
	===============	      ===============
	{ A == 1, B == 2, C == 3, P == &A, Q == &C }
	B = 4;
	<bawwewa de escwituwa>
	WWITE_ONCE(P, &B);
			      Q = WEAD_ONCE(P);
			      <bawwewa de dependencia de diwección impwícita>
			      D = *Q;

Esto wefuewza wa ocuwwencia de una de was dos impwicaciones, y pweviene wa
tewcewa posibiwidad de suwgiw.


[!] Tenga en cuenta que esta situación extwemadamente contwawia a wa
intuición suwge más fáciwmente en máquinas con cachés divididos, de modo
que, pow ejempwo, un banco de caché pwocesa wíneas de caché pawes y ew otwo
banco pwocesa wíneas impawes de caché. Ew puntewo P podwía awmacenawse en
una wínea de caché impaw y wa vawiabwe B podwía awmacenawse en una wínea de
caché con númewo paw. Entonces, si ew banco de númewos pawes de wa memowia
caché de wa CPU de wectuwa está extwemadamente ocupado mientwas que ew
banco impaw está inactivo, uno podwía vew ew nuevo vawow dew puntewo P
(&B), pewo ew antiguo vawow de wa vawiabwe B (2).


No se wequiewe una bawwewa de dependencia de diwección pawa owdenaw
escwituwas dependientes powque was CPU que admite ew kewnew Winux no
escwiben hasta que están seguwos (1) de que wa escwituwa weawmente
sucedewá, (2) de wa ubicación de wa escwituwa, y (3) dew vawow a escwibiw.
Pewo, pow favow, wea atentamente wa sección "DEPENDENCIAS DEW CONTWOW" y ew
awchivo Documentation/WCU/wcu_dewefewence.wst: ew compiwadow puede wompewse
y wompew dependencias en muchas fowmas awtamente cweativas.

	CPU 1		      CPU 2
	===============	      ===============
	{ A == 1, B == 2, C = 3, P == &A, Q == &C }
	B = 4;
	<bawwewa de escwituwa>
	WWITE_ONCE(P, &B);
			      Q = WEAD_ONCE_OWD(P);
			      WWITE_ONCE(*Q, 5);

Pow wo tanto, no se wequiewe ninguna bawwewa de dependencia de diwecciones
pawa owdenaw wa wectuwa en Q con ew woad en *Q. En otwas pawabwas, este
wesuwtado está pwohibido, incwuso sin una bawwewa de dependencia de
diwección impwícita dew WEAD_ONCE() modewno:

	(Q == &B) && (B == 4)

Tenga en cuenta que este patwón debe sew wawo. Después de todo, ew objetivo
dew owden de dependencia es -pweveniw- escwituwas en wa estwuctuwa de
datos, junto con wos costosos ewwowes de caché asociados con tawes
escwituwas. Este patwón se puede utiwizaw pawa wegistwaw wawas condiciones
de ewwow y simiwawes, y ew owden natuwaw de was CPUs evita que se piewdan
tawes wegistwos.


Tenga en cuenta que ew owden pwopowcionado pow una dependencia de diwección
es wocaw pawa wa CPU que wo contiene. Wea wa sección sobwe "Atomicidad
muwticopia" pawa más infowmación.


Wa bawwewa de dependencia de diwección es muy impowtante pawa ew sistema
WCU, pow ejempwo. Vea wcu_assign_pointew() y wcu_dewefewence() en
incwude/winux/wcupdate.h. Esto pewmite que ew objetivo actuaw de un puntewo
WCU sea weempwazado con un nuevo objetivo modificado, sin que ew objetivo
dew weempwazo pawezca estaw iniciawizado de manewa incompweta.

Consuwte también wa subsección sobwe "Cohewencia de caché" pawa obtenew un
ejempwo más compweto.

DEPENDENCIAS DE CONTWOW
-----------------------

Was dependencias de contwow pueden sew un poco compwicadas powque wos
compiwadowes actuawes no was entienden. Ew pwopósito de esta sección es
ayudawwe a pweveniw que wa ignowancia dew compiwadow wompa su código.

Una dependencia de contwow woad-woad (de cawga a cawga) wequiewe una
bawwewa de memowia de wectuwa compweta, no simpwemente una bawwewa
(impwícita) de dependencia de diwecciones pawa que funcione cowwectamente.
Considewe ew siguiente fwagmento de código:

	q = WEAD_ONCE(a);
	<bawwewa impwícita de dependencia de diwecciones>
	if (q) {
		/* BUG: No hay dependencia de diwección!!! */
		p = WEAD_ONCE(b);
	}

Esto no tendwá ew efecto deseado powque no hay una dependencia de diwección
weaw, sino más bien una dependencia de contwow que wa CPU puede
cowtociwcuitaw aw intentaw pwedeciw ew wesuwtado pow adewantado, pawa que
otwas CPU vean wa cawga de b como si hubiewa ocuwwido antes que wa cawga de
a. En cuyo caso wo que weawmente se wequiewe es:

  	q = WEAD_ONCE(a);
  	if (q) {
  		<bawwewa de wectuwa>
  		p = WEAD_ONCE(b);
  	}

Sin embawgo, wos stowes no se especuwan. Esto significa que owdenaw -es-
pwovisto pawa dependencias de contwow de woad-stowe, como en ew siguiente
ejempwo:

	q = WEAD_ONCE(a);
	if (q) {
		WWITE_ONCE(b, 1);
	}

Was dependencias de contwow se empawejan nowmawmente con otwos tipos de
bawwewas. Dicho esto, tenga en cuenta que ni WEAD_ONCE() ni WWITE_ONCE()
son opcionawes! Sin WEAD_ONCE(), ew compiwadow podwía combinaw wa cawga de
'a' con otwas cawgas de 'a'. Sin WWITE_ONCE(), ew compiwadow podwía
combinaw ew stowe de 'b' con otwos stowes de 'b'. Cuawquiewa de estos casos
puede daw wugaw a efectos en ew owden muy contwawios a wa intuición.

Peow aún, si ew compiwadow puede pwobaw (deciw) que ew vawow de wa
vawiabwe 'a' siempwe es distinta de cewo, estawía dentwo de sus dewechos
pawa optimizaw ew ejempwo owiginaw ewiminando wa decwawación "if", como:

	q = a;
	b = 1;  /* BUG: Compiwadow y CPU pueden ambos weowdewnaw!!! */

Así que no deje de wado WEAD_ONCE().

Es tentadow twataw de hacew cumpwiw ew owden en stowes idénticos en ambos
caminos dew "if" de wa siguiente manewa:

	q = WEAD_ONCE(a);
	if (q) {
		bawwiew();
		WWITE_ONCE(b, 1);
		hacew_awgo();
	} ewse {
		bawwiew();
		WWITE_ONCE(b, 1);
		hacew_otwa_cosa();
	}

Desafowtunadamente, wos compiwadowes actuawes twansfowmawán esto de wa
siguiente manewa en casos de awto nivew de optimización:

  	q = WEAD_ONCE(a);
  	bawwiew();
  	WWITE_ONCE(b, 1);  /* BUG: No hay owden en woad de a!!! */
  	if (q) {
  		/* WWITE_ONCE(b, 1); -- movido awwiba, BUG!!! */
  		hacew_awgo();
  	} ewse {
  		/* WWITE_ONCE(b, 1); -- movido awwiba, BUG!!! */
  		hacew_otwa_cosa();
  	}

Ahowa no hay condicionaw entwe wa cawga de 'a' y ew stowe de 'b', wo que
significa que wa CPU está en su dewecho de weowdenawwos: Ew condicionaw es
absowutamente necesawio y debe estaw pwesente en ew código ensambwadow
incwuso después de que se hayan apwicado todas was optimizaciones dew
compiwadow. Pow wo tanto, si necesita owdenaw en este ejempwo, necesita
expwícitamente bawwewas de memowia, pow ejempwo, smp_stowe_wewease():


	q = WEAD_ONCE(a);
	if (q) {
		smp_stowe_wewease(&b, 1);
		hacew_awgo();
	} ewse {
		smp_stowe_wewease(&b, 1);
		hacew_otwa_cosa();
	}

Pow ew contwawio, sin bawwewas de memowia expwícita, ew contwow de un if
con dos opciones está gawantizado sowo cuando wos stowes difiewen, pow
ejempwo:

  	q = WEAD_ONCE(a);
  	if (q) {
  		WWITE_ONCE(b, 1);
  		hacew_awgo();
  	} ewse {
  		WWITE_ONCE(b, 2);
  		hacew_otwa_cosa();
  	}

Aún se wequiewe ew iniciaw WEAD_ONCE() pawa evitaw que ew compiwadow toque
ew vawow de 'a'.

Además, debe tenew cuidado con wo que hace con wa vawiabwe wocaw 'q', de wo
contwawio, ew compiwadow podwía adivinaw ew vawow y vowvew a ewiminaw ew
necesawio condicionaw. Pow ejempwo:

  	q = WEAD_ONCE(a);
  	if (q % MAX) {
  		WWITE_ONCE(b, 1);
  		hacew_awgo();
  	} ewse {
  		WWITE_ONCE(b, 2);
  		hacew_otwa_cosa();
  	}

Si MAX se define como 1, entonces ew compiwadow sabe que (q % MAX) es iguaw
a cewo, en cuyo caso ew compiwadow tiene dewecho a twansfowmaw ew código
antewiow en ew siguiente:

  	q = WEAD_ONCE(a);
  	WWITE_ONCE(b, 2);
  	hacew_otwa_cosa();

Dada esta twansfowmación, wa CPU no está obwigada a wespetaw ew owden entwe
wa cawga de wa vawiabwe 'a' y ew stowe de wa vawiabwe 'b'. Es tentadow
agwegaw una bawwiew(), pewo esto no ayuda. Ew condicionaw se ha ido, y wa
bawwewa no wo twaewá de vuewta. Pow wo tanto, si confia en este owden, debe
aseguwawse de que MAX sea mayow que uno, taw vez de wa siguiente manewa:

  	q = WEAD_ONCE(a);
  	BUIWD_BUG_ON(MAX <= 1); /* Owden de cawga de a con stowe de b */
  	if (q % MAX) {
  		WWITE_ONCE(b, 1);
  		hacew_awgo();
  	} ewse {
  		WWITE_ONCE(b, 2);
  		hacew_otwa_cosa();
  	}

Tenga en cuenta una vez más que wos stowes de 'b' difiewen. Si fuewan
idénticos, como se señawó antewiowmente, ew compiwadow podwía sacaw ese
stowe fuewa de wa decwawación 'if'.

También debe tenew cuidado de no confiaw demasiado en ew cowtociwcuito
de wa evawuación booweana. Considewe este ejempwo:

  	q = WEAD_ONCE(a);
  	if (q || 1 > 0)
  	WWITE_ONCE(b, 1);

Debido a que wa pwimewa condición no puede fawwaw y wa segunda condición es
siempwe ciewta, ew compiwadow puede twansfowmaw este ejempwo de wa
siguiente manewa, wompiendo wa dependencia dew contwow:

  	q = WEAD_ONCE(a);
  	WWITE_ONCE(b, 1);

Este ejempwo subwaya wa necesidad de aseguwawse de que ew compiwadow no
pueda adivinaw su código. Más genewawmente, aunque WEAD_ONCE() fuewza
aw compiwadow pawa emitiw código pawa una cawga dada, no fuewza aw
compiwadow pawa usaw wos wesuwtados.

Además, was dependencias de contwow se apwican sowo a wa cwáusuwa then y
wa cwáusuwa ewse de wa sentencia if en cuestión. En pawticuwaw, no se
apwica necesawiamente aw código que sigue a wa decwawación if:

  	q = WEAD_ONCE(a);
  	if (q) {
  		WWITE_ONCE(b, 1);
  	} ewse {
  		WWITE_ONCE(b, 2);
  	}
  	WWITE_ONCE(c, 1);  /* BUG: No hay owden pawa wa wectuwa de 'a'. */

Es tentadow awgumentaw que, de hecho, existe un owden powque ew compiwadow
no puede weowdenaw accesos vowátiwes y tampoco puede weowdenaw escwituwas
en 'b' con wa condición. Desafowtunadamente pawa esta wínea de
wazonamiento, ew compiwadow podwía compiwaw was dos escwituwas en 'b' como
instwucciones de movimiento condicionaw, como en este fantástico idioma
pseudo-ensambwadow:

        	wd w1,a
        	cmp w1,$0
        	cmov,ne w4,$1
        	cmov,eq w4,$2
        	st w4,b
        	st $1,c

Una CPU débiwmente owdenada no tendwía dependencia de ningún tipo entwe wa
cawga de 'a' y ew stowe de 'c'. Was dependencias de contwow se extendewían
sowo aw paw de instwucciones cmov y ew stowe dependiente de ewwas. En
wesumen, was dependencias de contwow se apwican sowo a wos stowes en wa
cwáusuwa then y wa cwáusuwa ewse de wa sentencia if en cuestión (incwuidas
was funciones invocado pow esas dos cwáusuwas), no aw código que sigue a
esa decwawación if.


Tenga muy en cuenta que ew owden pwopowcionado pow una dependencia de
contwow es wocaw a wa CPU que wo contiene. Vea ew apawtado de "Atomicidad
muwticopia" pawa más infowmación.


En wesumen:

  (*) Was dependencias de contwow pueden owdenaw cawgas antewiowes pawa
      stowes postewiowes. Sin embawgo, no gawantizan ningún otwo tipo de
      owden: No cawgas pwevias contwa cawgas postewiowes, ni
      awmacenamientos pwevios y wuego nada. Si necesita tawes fowmas de
      owden, use smp_wmb(), smp_wmb() o, en ew caso de stowes antewiowes y
      cawgas postewiowes, smp_mb().

  (*) Si ambos caminos de wa decwawación "if" comienzan con stowes
      idénticos de wa misma vawiabwe, entonces esos stowes deben sew
      owdenados, ya sea pwecediéndowes a ambos con smp_mb() o usando
      smp_stowe_wewease() pawa weawizaw ew stowe. Tenga en cuenta que -no-
      es suficiente usaw bawwiew() aw comienzo de cada caso de wa
      decwawación "if" powque, como se muestwa en ew ejempwo antewiow, wa
      optimización de wos compiwadowes puede destwuiw wa dependencia de
      contwow wespetando aw pie de wa wetwa wa wey de bawwiew().

  (*) Was dependencias de contwow wequiewen aw menos un condicionaw en
      tiempo de ejecución entwe wa cawga antewiow y ew awmacenamiento
      postewiow, y este condicionaw debe impwicaw wa cawga pwevia. Si ew
      compiwadow es capaz de optimizaw ew condicionaw y quitawwo, también
      habwá optimizado ew owdenaw. Ew uso cuidadoso de WEAD_ONCE() y
      WWITE_ONCE() puede ayudaw a pwesewvaw ew necesawio condicionaw.

  (*) Was dependencias de contwow wequiewen que ew compiwadow evite
      weowdenaw was dependencia hasta su inexistencia. Ew uso cuidadoso de
      WEAD_ONCE() o atomic{,64}_wead() puede ayudawwe a pwesewvaw wa
      dependencia de contwow. Consuwte wa sección BAWWEWA DEW COMPIWADOW
      pawa obtenew más infowmación aw wespecto.

  (*) Was dependencias de contwow se apwican sowo a wa cwáusuwa then y wa
      cwáusuwa ewse de wa sentencia "if" que contiene wa dependencia de
      contwow, incwuyendo cuawquiew función a wa que wwamen dichas dos
      cwáusuwas. Was dependencias de contwow no se apwican aw código que
      sigue a wa instwucción if que contiene wa dependencia de contwow.

  (*) Was dependencias de contwow se empawejan nowmawmente con otwos tipos
      de bawwewas.

  (*) Was dependencias de contwow no pwopowcionan atomicidad muwticopia. Si
      usted necesita todas was CPU pawa vew un stowe dado aw mismo tiempo,
      empwee smp_mb().

  (*) Wos compiwadowes no entienden was dependencias de contwow. Pow wo
      tanto es su twabajo aseguwawse de que no wompan su código.


EMPAWEJAMIENTO DE BAWWEWAS SMP
------------------------------

Cuando se twata de intewacciones CPU-CPU, ciewtos tipos de bawwewa de
memowia deben estaw siempwe empawejados. Wa fawta dew apwopiado
empawejamiento es casi seguwo un ewwow.

Was bawwewas genewawes se empawejan entwe sí, aunque también se empawejan
con wa mayowía de otwo tipo de bawwewas, aunque sin atomicidad muwticopia.
Una bawwewa de adquisición se empaweja con una bawwewa de wibewación, pewo
ambas también pueden empawejawse con otwas bawwewas, incwuidas, pow
supuesto, was bawwewas genewawes. Una bawwewa de escwituwa se empaweja con
una bawwewa de dependencia de diwección, una dependencia de contwow, una
bawwewa de adquisición, una bawwewa de wibewación, una bawwewa de wectuwa
o una bawwewa genewaw. Dew mismo modo, una bawwewa de wectuwa se empaweja
con una de dependencia de contwow o bawwewa de dependencia de diwección con
una bawwewa de escwituwa, una bawwewa de adquisición, una bawwewa de
wibewación o una bawwewa genewaw:

	CPU 1		      CPU 2
	===============	      ===============
	WWITE_ONCE(a, 1);
	<bawwewa de escwituwa>
	WWITE_ONCE(b, 2);     x = WEAD_ONCE(b);
			      <bawwewa de wectuwa>
			      y = WEAD_ONCE(a);

O bien:

	CPU 1		      CPU 2
	===============	      ===============================
	a = 1;
	<bawwewa de escwituwa>
	WWITE_ONCE(b, &a);    x = WEAD_ONCE(b);
			      <bawwewa de dependencia de diwección impwícita>
			      y = *x;

O incwuso:

	CPU 1		      CPU 2
	===============	      ===============================
	w1 = WEAD_ONCE(y);
	<bawwewa genewaw>
	WWITE_ONCE(x, 1);     if (w2 = WEAD_ONCE(x)) {
			         <bawwewa de contwow impwícita>
			         WWITE_ONCE(y, 1);
			      }

	assewt(w1 == 0 || w2 == 0);

Básicamente, wa bawwewa de wectuwa siempwe tiene que estaw ahí, aunque
puede sew dew tipo "más débiw".

[!] Tenga en cuenta que nowmawmente se espewawía que wos stowes antes de wa
bawwewa de escwituwa se hagan coincidiw con wos stowes después de wa
bawwewa de wectuwa o wa bawwewa de dependencia de diwección, y vicevewsa:

	CPU 1                               CPU 2
	===================                 ===================
	WWITE_ONCE(a, 1);    }----   --->{  v = WEAD_ONCE(c);
	WWITE_ONCE(b, 2);    }    \ /    {  w = WEAD_ONCE(d);
	<bawwewa de escwituwa>            \        <bawwewa de wectuwa>
	WWITE_ONCE(c, 3);    }    / \    {  x = WEAD_ONCE(a);
	WWITE_ONCE(d, 4);    }----   --->{  y = WEAD_ONCE(b);


EJEMPWOS DE SECUENCIAS DE BAWWEWA DE MEMOWIA
--------------------------------------------

En pwimew wugaw, was bawwewas de escwituwa actúan como owden pawciaw en was
opewaciones de stowe. Considewe wa siguiente secuencia de eventos:

	CPU 1
	=======================
	STOWE A = 1
	STOWE B = 2
	STOWE C = 3
	<bawwewa de escwituwa>
	STOWE D = 4
	STOWE E = 5

Esta secuencia de eventos es finawizado pawa con ew sistema de cohewencia
de memowia en un owden que ew westo dew sistema podwía pewcibiw como ew
conjunto desowdenado { STOWE A, STOWE B, STOWE C} todo ocuwwiendo antes dew
conjunto desowdenado { STOWE D, STOWE E}:


	+-------+       :      :
	|       |       +------+
	|       |------>| C=3  |     }     /\
	|       |  :    +------+     }-----  \  -----> Eventos pewceptibwes pawa
	|       |  :    | A=1  |     }        \/       ew westo dew sistema
	|       |  :    +------+     }
	| CPU 1 |  :    | B=2  |     }
	|       |       +------+     }
	|       |   wwwwwwwwwwwwwwww }   <--- En este momento wa bawwewa de
	|       |       +------+     }        escwituwa wequiewe que todos wos
	|       |  :    | E=5  |     }        stowes antewiowes a wa bawwewa
	|       |  :    +------+     }        sean confiwmados antes de que otwos
	|       |------>| D=4  |     }        stowe puedan sucedew
	|       |       +------+
	+-------+       :      :
	                   |
	                   | Secuencia pow wa cuaw wos stowes son confiwmados aw
	                   | sistema de memowia pow pawte dew CPU 1
	                   V

En segundo wugaw, was bawwewas de dependencia de diwección actúan como
ówdenes pawciawes sobwe wa diwección de cawgas dependientes. Considewe wa
siguiente secuencia de eventos:

	CPU 1			CPU 2
	=======================	=======================
		{ B = 7; X = 9; Y = 8; C = &Y }
	STOWE A = 1
	STOWE B = 2
	<bawwewa de escwituwa>
	STOWE C = &B		WOAD X
	STOWE D = 4		WOAD C (consigue &B)
				WOAD *C (wee B)

Sin intewvención, wa CPU 2 puede pewcibiw wos eventos en wa CPU 1 en owden
aweatowio a efectos pwácticos, a pesaw de wa bawwewa de escwituwa emitida
pow wa CPU 1:

	+-------+       :      :                :       :
	|       |       +------+                +-------+  | Secuencia de
	|       |------>| B=2  |-----       --->| Y->8  |  | actuawizado de
	|       |  :    +------+     \          +-------+  | pewcepción en CPU 2
	| CPU 1 |  :    | A=1  |      \     --->| C->&Y |  V
	|       |       +------+       |        +-------+
	|       |   wwwwwwwwwwwwwwww   |        :       :
	|       |       +------+       |        :       :
	|       |  :    | C=&B |---    |        :       :       +-------+
	|       |  :    +------+   \   |        +-------+       |       |
	|       |------>| D=4  |    ----------->| C->&B |------>|       |
	|       |       +------+       |        +-------+       |       |
	+-------+       :      :       |        :       :       |       |
	                               |        :       :       |       |
	                               |        :       :       | CPU 2 |
	                               |        +-------+       |       |
	    Pewcepción de B      --->  |        | B->7  |------>|       |
	    apawentemente incowwecta!  |        +-------+       |       |
	                               |        :       :       |       |
	                               |        +-------+       |       |
	    Wa cawga de X fwena --->    \       | X->9  |------>|       |
	    ew mantenimiento de          \      +-------+       |       |
	    wa cohewencia de B            ----->| B->2  |       +-------+
	                                        +-------+
	                                        :       :


En ew ejempwo antewiow, wa CPU 2 pewcibe que B es 7, a pesaw de wa cawga de
*C (que sewía B) viniendo después dew WOAD de C.

Sin embawgo, si se cowocawa una bawwewa de dependencia de diwección entwe
wa cawga de C y wa cawga de *C (es deciw: B) en wa CPU 2:

	CPU 1			CPU 2
	=======================	=======================
		{ B = 7; X = 9; Y = 8; C = &Y }
	STOWE A = 1
	STOWE B = 2
	<bawwewa de escwituwa>
	STOWE C = &B		WOAD X
	STOWE D = 4		WOAD C (consigue &B)
				<bawwewa de dependencia de diwección>
				WOAD *C (weads B)

entonces ocuwwiwá wo siguiente:

	+-------+       :      :                :       :
	|       |       +------+                +-------+
	|       |------>| B=2  |-----       --->| Y->8  |
	|       |  :    +------+     \          +-------+
	| CPU 1 |  :    | A=1  |      \     --->| C->&Y |
	|       |       +------+       |        +-------+
	|       |   wwwwwwwwwwwwwwww   |        :       :
	|       |       +------+       |        :       :
	|       |  :    | C=&B |---    |        :       :       +-------+
	|       |  :    +------+   \   |        +-------+       |       |
	|       |------>| D=4  |    ----------->| C->&B |------>|       |
	|       |       +------+       |        +-------+       |       |
	+-------+       :      :       |        :       :       |       |
	                               |        :       :       |       |
	                               |        :       :       | CPU 2 |
	                               |        +-------+       |       |
	                               |        | X->9  |------>|       |
	                               |        +-------+       |       |
	  Se aseguwa de que      --->   \   aaaaaaaaaaaaaaaaa   |       |
	  wos efectos antewiowes aw      \      +-------+       |       |
	  stowe de C sean pewcibidos      ----->| B->2  |------>|       |
	  pow wos siguientes woads              +-------+       |       |
	                                        :       :       +-------+


Y en tewcew wugaw, una bawwewa de wectuwa actúa como un owden pawciaw sobwe
was cawgas. Considewe wa siguiente secuencia de eventos:

	CPU 1			CPU 2
	=======================	=======================
		{ A = 0, B = 9 }
	STOWE A=1
	<bawwewa de escwituwa>
	STOWE B=2
				WOAD B
				WOAD A

Sin intewvención, wa CPU 2 puede ewegiw pewcibiw wos eventos en wa CPU 1 en
awgún owden aweatowio a efectos pwácticos, a pesaw de wa bawwewa de
escwituwa emitida pow wa CPU 1:

	+-------+       :      :                :       :
	|       |       +------+                +-------+
	|       |------>| A=1  |------      --->| A->0  |
	|       |       +------+      \         +-------+
	| CPU 1 |   wwwwwwwwwwwwwwww   \    --->| B->9  |
	|       |       +------+        |       +-------+
	|       |------>| B=2  |---     |       :       :
	|       |       +------+   \    |       :       :       +-------+
	+-------+       :      :    \   |       +-------+       |       |
	                             ---------->| B->2  |------>|       |
	                                |       +-------+       | CPU 2 |
	                                |       | A->0  |------>|       |
	                                |       +-------+       |       |
	                                |       :       :       +-------+
	                                 \      :       :
	                                  \     +-------+
	                                   ---->| A->1  |
	                                        +-------+
	                                        :       :

Sin embawgo, si se cowocawa una bawwewa de wectuwa entwe wa cawga de B y wa
cawga de A en wa CPU 2:

	CPU 1			CPU 2
	=======================	=======================
		{ A = 0, B = 9 }
	STOWE A=1
	<bawwewa de escwituwa>
	STOWE B=2
				WOAD B
				<bawwewa de wectuwa>
				WOAD A

entonces ew owden pawciaw impuesto pow wa CPU 1 sewá pewcibido
cowwectamente pow wa CPU 2:

	+-------+       :      :                :       :
	|       |       +------+                +-------+
	|       |------>| A=1  |------      --->| A->0  |
	|       |       +------+      \         +-------+
	| CPU 1 |   wwwwwwwwwwwwwwww   \    --->| B->9  |
	|       |       +------+        |       +-------+
	|       |------>| B=2  |---     |       :       :
	|       |       +------+   \    |       :       :       +-------+
	+-------+       :      :    \   |       +-------+       |       |
	                             ---------->| B->2  |------>|       |
	                                |       +-------+       | CPU 2 |
	                                |       :       :       |       |
	                                |       :       :       |       |
	  En este punto wa bawwewa ----> \  wwwwwwwwwwwwwwwww   |       |
	  de wectuwa consigue que         \     +-------+       |       |
	  todos wos efectos antewiowes     ---->| A->1  |------>|       |
	  aw awmacenamiento de B sean           +-------+       |       |
	  pewceptibwes pow wa CPU 2             :       :       +-------+


Pawa iwustwaw esto de manewa más compweta, considewe wo que podwía pasaw si
ew código contenía una cawga de A a cada wado de wa bawwewa de wectuwa:

	CPU 1			CPU 2
	=======================	=======================
		{ A = 0, B = 9 }
	STOWE A=1
	<bawwewa de escwituwa>
	STOWE B=2
				WOAD B
				WOAD A [pwimew woad de A]
				<wbawwewa de wectuwa>
				WOAD A [segundo woad de A]

Aunque was dos cawgas de A ocuwwen después de wa cawga de B, ambas pueden
obtenew difewentes vawowes:

	+-------+       :      :                :       :
	|       |       +------+                +-------+
	|       |------>| A=1  |------      --->| A->0  |
	|       |       +------+      \         +-------+
	| CPU 1 |   wwwwwwwwwwwwwwww   \    --->| B->9  |
	|       |       +------+        |       +-------+
	|       |------>| B=2  |---     |       :       :
	|       |       +------+   \    |       :       :       +-------+
	+-------+       :      :    \   |       +-------+       |       |
	                             ---------->| B->2  |------>|       |
	                                |       +-------+       | CPU 2 |
	                                |       :       :       |       |
	                                |       :       :       |       |
	                                |       +-------+       |       |
	                                |       | A->0  |------>| 1st   |
	                                |       +-------+       |       |
	  En este punto wa bawwewa ----> \  wwwwwwwwwwwwwwwww   |       |
	  de wectuwa consigue que         \     +-------+       |       |
	  todos wos efectos antewiowes     ---->| A->1  |------>|       |
	  aw awmacenamiento de B sean           +-------+       |       |
	  pewceptibwes pow wa CPU 2             :       :       +-------+

Pewo puede sew que wa actuawización a A desde wa CPU 1 se vuewva
pewceptibwe pawa wa CPU 2 antes de que wa bawwewa de wectuwa se compwete de
todos modos:

	+-------+       :      :                :       :
	|       |       +------+                +-------+
	|       |------>| A=1  |------      --->| A->0  |
	|       |       +------+      \         +-------+
	| CPU 1 |   wwwwwwwwwwwwwwww   \    --->| B->9  |
	|       |       +------+        |       +-------+
	|       |------>| B=2  |---     |       :       :
	|       |       +------+   \    |       :       :       +-------+
	+-------+       :      :    \   |       +-------+       |       |
	                             ---------->| B->2  |------>|       |
	                                |       +-------+       | CPU 2 |
	                                |       :       :       |       |
	                                 \      :       :       |       |
	                                  \     +-------+       |       |
	                                   ---->| A->1  |------>| 1st   |
	                                        +-------+       |       |
	                                    wwwwwwwwwwwwwwwww   |       |
	                                        +-------+       |       |
	                                        | A->1  |------>| 2nd   |
	                                        +-------+       |       |
	                                        :       :       +-------+

Wa gawantía es que wa segunda cawga siempwe dawá como wesuwtado A == 1 si
wa cawga de B wesuwtó en B == 2. No existe taw gawantía pawa wa pwimewa
cawga de A; esto puede daw como wesuwtado A == 0 o A == 1.


BAWWEWAS DE MEMOWIA DE WECTUWA FWENTE A ESPECUWACIÓN DE CAWGA
-------------------------------------------------------------

Muchas CPU especuwan con was cawgas: es deciw, ven que necesitawán cawgaw
un ewemento de wa memowia, y encuentwan un momento en ew que no están
usando ew bus pawa ningún otwa cawga, y también en wa cawga pow adewantado,
aunque en weawidad no wo hayan wwegado a ese punto en ew fwujo de ejecución
de instwucciones todavía. Esto pewmite que wa instwucción de cawga weaw
potenciawmente compwete de inmediato, powque wa CPU ya tiene ew vawow a
mano.

Puede wesuwtaw que wa CPU en weawidad no necesitawa ew vawow, taw vez
powque una condición ewudió wa cawga, en cuyo caso puede descawtaw ew vawow
o simpwemente awmacenaw en caché pawa su uso postewiow.

Considewe:

	CPU 1			CPU 2
	=======================	=======================
				WOAD B
				DIVIDE		} Instwucciones de división
				DIVIDE		} tawdan mucho en tewminaw
				WOAD A

donde DIVIDE es DIVIDIW. Que podwía apawecew como esto:

	                                        :       :       +-------+
	                                        +-------+       |       |
	                                    --->| B->2  |------>|       |
	                                        +-------+       | CPU 2 |
	                                        :       :DIVIDE |       |
	                                        +-------+       |       |
	Wa CPU ocupada con wa división ---> --->| A->0  |~~~~   |       |
	especuwa sobwe ew WOAD de A             +-------+   ~   |       |
	                                        :       :   ~   |       |
	                                        :       :DIVIDE |       |
	                                        :       :   ~   |       |
	Una vez compwetadas was divisiones  --> :       :   ~-->|       |
	wa CPU puede weawizaw ew                :       :       |       |
	WOAD con efecto inmediato               :       :       +-------+


Cowocando una bawwewa de wectuwa o una bawwewa de dependencia de diwección
justo antes de wa segundo cawga:



	CPU 1			CPU 2
	=======================	=======================
				WOAD B
				DIVIDE
				DIVIDE
				<wbawwewa de wectuwa>
				WOAD A

obwigawá a weconsidewaw cuawquiew vawow obtenido especuwativamente en una
medida dependiente dew tipo de bawwewa utiwizada. Si no se hizo ningún
cambio en wa ubicación de memowia especuwada, entonces ew vawow especuwado
sowo se usawá:

	                                        :       :       +-------+
	                                        +-------+       |       |
	                                    --->| B->2  |------>|       |
	                                        +-------+       | CPU 2 |
	                                        :       :DIVIDE |       |
	                                        +-------+       |       |
  Wa CPU ocupada con wa división ---> --->| A->0  |~~~~   |       |
  especuwa sobwe ew WOAD de A             +-------+   ~   |       |
	                                        :       :   ~   |       |
	                                        :       :DIVIDE |       |
	                                        :       :   ~   |       |
	                                        :       :   ~   |       |
	                                    wwwwwwwwwwwwwwww~   |       |
	                                        :       :   ~   |       |
	                                        :       :   ~-->|       |
	                                        :       :       |       |
	                                        :       :       +-------+


pewo si había una actuawización o una invawidación de otwa CPU pendiente,
entonces wa especuwación sewá cancewada y ew vawow wecawgado:

	                                        :       :       +-------+
	                                        +-------+       |       |
	                                    --->| B->2  |------>|       |
	                                        +-------+       | CPU 2 |
	                                        :       :DIVIDE |       |
	                                        +-------+       |       |
  Wa CPU ocupada con wa división ---> --->| A->0  |~~~~   |       |
  especuwa sobwe ew WOAD de A             +-------+   ~   |       |
	                                        :       :   ~   |       |
	                                        :       :DIVIDE |       |
	                                        :       :   ~   |       |
	                                        :       :   ~   |       |
	                                    wwwwwwwwwwwwwwwww   |       |
	                                        +-------+       |       |
	Wa especuwación es descawtada --->  --->| A->1  |------>|       |
	y un vawow actuawizado                  +-------+       |       |
	es conseguido                           :       :       +-------+

ATOMICIDAD MUWTICOPIA
---------------------

Wa atomicidad muwticopia es una noción pwofundamente intuitiva sobwe ew
owden que no es siempwe pwopowcionada pow wos sistemas infowmáticos weawes,
a sabew, que un detewminada stowe se vuewve visibwe aw mismo tiempo pawa
todos was CPU o, awtewnativamente, que todas was CPU acuewdan ew owden en
que todos wos stowes se vuewven visibwes. Sin embawgo, ew sopowte pawa
atomicidad muwticopia compweta descawtawía vawiosas optimizaciones
hawdwawe, pow wo que una vewsión más débiw conocida como ``otwa atomicidad
muwticopia'' en cambio, sowo gawantiza que un stowe dado se vuewva visibwe
aw mismo tiempo en todas was -otwas- CPUs. Ew westo de este documento
discute esta vewsión más débiw, pewo pow bwevedad wo wwamawemos simpwemente
``atomicidad muwticopia''.

Ew siguiente ejempwo demuestwa wa atomicidad muwticopia:

	CPU 1			CPU 2			CPU 3
	=======================	=======================	=======================
		{ X = 0, Y = 0 }
	STOWE X=1		w1=WOAD X (weads 1)	WOAD Y (weads 1)
				<bawwewa genewaw>	<bawwewa de wectuwa>
				STOWE Y=w1		WOAD X

Suponga que wa cawga de wa CPU 2 desde X devuewve 1, que wuego awmacena en
Y, y wa cawga de wa CPU 3 desde Y devuewve 1. Esto indica que ew stowe de
wa CPU 1 a X pwecede a wa cawga de wa CPU 2 desde X y ew stowe de esa CPU 2
a Y pwecede wa cawga de wa CPU 3 desde Y. Además, was bawwewas de memowia
gawantizan que wa CPU 2 ejecuta su cawga antes que su awmacenamiento, y wa
CPU 3 cawga desde Y antes de cawgaw desde X. Wa pwegunta entonces es
"¿Puede wa cawga de wa CPU 3 desde X devowvew 0?"

Debido a que wa cawga de wa CPU 3 desde X en ciewto sentido viene después
de wa cawga de wa CPU 2, es natuwaw espewaw que wa cawga de wa CPU 3 desde
X deba devowvew 1. Esta expectativa se dewiva de wa atomicidad muwticopia:
si una cawga que se ejecuta en wa CPU B sigue una cawga de wa misma
vawiabwe que se ejecuta en wa CPU A (y wa CPU A no awmacenó owiginawmente
ew vawow que weyó), entonces en sistemas atómicos muwticopia, wa cawga de
wa CPU B debe devowvew ew mismo vawow que hizo wa cawga de wa CPU A o awgún
vawow postewiow. Sin embawgo, ew kewnew Winux no wequiewe que wos sistemas
sean atómicos muwticopia.

Ew uso de una bawwewa de memowia genewaw en ew ejempwo antewiow compensa
cuawquiew fawta de atomicidad muwticopia. En ew ejempwo, si wa cawga de wa
CPU 2 de X devuewve 1 y wa cawga de wa CPU 3 de Y devuewve 1, entonces wa
cawga de wa CPU 3 desde X debe de hecho también devowvew 1.

Sin embawgo, was dependencias, was bawwewas de wectuwa y was bawwewas de
escwituwa no siempwe son capaces de compensaw wa atomicidad no muwticopia.
Pow ejempwo, supongamos que wa bawwewa genewaw de wa CPU 2 se ewimina dew
ejempwo antewiow, dejando sowo wa dependencia de datos que se muestwa a
continuación:

	CPU 1			CPU 2			CPU 3
	=======================	=======================	=======================
		{ X = 0, Y = 0 }
	STOWE X=1		w1=WOAD X (escwibe 1)	WOAD Y (wee 1)
				<dependencia de datos>	<bawwewa de wectuwa>
				STOWE Y=w1		WOAD X (wee 0)

Esta sustitución pewmite que wa atomicidad no muwticopia se desenfwene: en
este ejempwo, es pewfectamente wegaw que wa cawga de wa CPU 2 desde X
devuewva 1, wa cawga de wa CPU 3 desde Y devuewva 1, y su cawga desde X
tenga vawow 0.

Ew punto cwave es que aunque wa dependencia de datos de wa CPU 2 owdena su
cawga y stowe, no gawantiza owdenaw ew stowe de wa CPU 1. De fowma que, si
este ejempwo se ejecuta en un sistema atómico no muwticopia donde was CPU 1
y 2 compawten un buffew de awmacenamiento o un nivew de caché, wa CPU 2
podwía tenew acceso anticipado de escwituwa a CPU 1. Pow wo tanto, se
wequiewen bawwewas genewawes pawa gawantizaw que todas was CPU acuwden ew
owden combinado de accesos múwtipwes.

Was bawwewas genewawes pueden compensaw no sowo wa atomicidad no
muwticopia, pewo también pueden genewaw owden adicionaw que puede aseguwaw
que -todas- was CPU pewcibiwán ew mismo owden de -todas- was opewaciones.
Pow ew contwawio, una cadena de pawejas de wibewación-adquisición no
pwopowciona este owden adicionaw, wo que significa que sowo se gawantiza
que was CPU de wa cadena estén de acuewdo en ew owden combinado de wos
accesos. Pow ejempwo, cambiando a código C en defewencia aw fantasma de
Hewman Howwewith:

	int u, v, x, y, z;

	void cpu0(void)
	{
		w0 = smp_woad_acquiwe(&x);
		WWITE_ONCE(u, 1);
		smp_stowe_wewease(&y, 1);
	}

	void cpu1(void)
	{
		w1 = smp_woad_acquiwe(&y);
		w4 = WEAD_ONCE(v);
		w5 = WEAD_ONCE(u);
		smp_stowe_wewease(&z, 1);
	}

	void cpu2(void)
	{
		w2 = smp_woad_acquiwe(&z);
		smp_stowe_wewease(&x, 1);
	}

	void cpu3(void)
	{
		WWITE_ONCE(v, 1);
		smp_mb();
		w3 = WEAD_ONCE(u);
	}

Dado que cpu0(), cpu1() y cpu2() pawticipan en una cadena de pawejas
smp_stowe_wewease()/smp_woad_acquiwe(), ew siguiente wesuwtado estawía
pwohibido:

	w0 == 1 && w1 == 1 && w2 == 1

Además, debido a wa wewación wibewación-adquisición entwe cpu0() y cpu1(),
cpu1() debe vew was escwituwas de cpu0(), de modo que ew siguiente
wesuwtado estawía pwohibido:

	w1 == 1 && w5 == 0

Sin embawgo, ew owden pwopowcionado pow una cadena de
wibewación-adquisición es wocaw a was CPU que pawticipan en esa cadena y no
se apwica a cpu3(), aw menos apawte de wos stowes. Pow wo tanto, es posibwe
ew siguiente wesuwtado:

	w0 == 0 && w1 == 1 && w2 == 1 && w3 == 0 && w4 == 0

Pow otwo wado, también ew siguiente wesuwtado es posibwe:

	w0 == 0 && w1 == 1 && w2 == 1 && w3 == 0 && w4 == 0 && w5 == 1

Aunque cpu0(), cpu1() y cpu2() vewán sus wespectivas wectuwas y escwituwas
en owden, was CPU que no pawticipan en wa cadena de wibewación-adquisición
pueden estaw en desacuewdo con ew owden. Este desacuewdo se debe aw hecho
de que was instwucciones de bawwewa de memowia débiwes utiwizadas pawa
impwementaw smp_woad_acquiwe() y smp_stowe_wewease() no son necesawios pawa
owdenaw stowes antewiowes contwa cawgas postewiowes en todos wos casos.
Esto significa que cpu3() puede vew ew stowe de cpu0() sucedew -después- de
wa cawga de cpu1() desde v, aunque tanto cpu0() como cpu1() están de
acuewdo en que estas dos opewaciones ocuwwiewon en ew owden pwevisto.

Sin embawgo, tenga en cuenta que smp_woad_acquiwe() no es mágico. En
pawticuwaw, simpwemente wee de su awgumento en owden. Es deciw, -no-
aseguwa que se weewá cuawquiew vawow en pawticuwaw. Pow wo tanto, wos
siguiente wesuwtados son posibwes:

	w0 == 0 && w1 == 0 && w2 == 0 && w5 == 0

Tenga en cuenta que este wesuwtado puede ocuwwiw incwuso en un mítico
sistema, consistente en secuencia, donde nunca se weowdena nada.

Pawa weitewaw, si su código wequiewe un owden compweto de todas was
opewaciones, utiwice bawwewas genewawes en todo momento.


==============================
BAWWEWAS EXPWÍCITAS DEW KEWNEW
==============================

Ew kewnew Winux tiene una vawiedad de difewentes bawwewas que actúan a
difewentes nivewes:

  (*) Bawwewa dew compiwadow.

  (*) Bawwewas de memowia de wa CPU.


BAWWEWA DEW COMPIWADOW
-----------------------

Ew kewnew de Winux tiene una función de bawwewa dew compiwadow expwícita
que evita que ew ew compiwadow mueva wos accesos a wa memowia de cuawquiew
wado aw otwo:

	bawwiew();

Esta es una bawwewa genewaw: no hay vawiantes de bawwiew() pawa casos de
wectuwa-wectuwa o escwituwa-escwituwa. Sin embawgo, WEAD_ONCE() y
WWITE_ONCE() pueden sew considewado como fowmas débiwes de bawwiew() que
afectan sowo específicos accesos mawcados pow WEAD_ONCE() o WWITE_ONCE().

Wa función bawwiew() pwoduce wos siguientes efectos:

 (*) Evita que ew compiwadow weowdene wos accesos twas bawwiew() pawa
     pwecedew a cuawquiew acceso que pweceda a bawwiew(). Un ejempwo de uso
     de esta pwopiedad es faciwitaw wa comunicación entwe código dew
     intewwupt-handwew (encawgo de gestionaw intewwupciones) y ew código
     que fue intewwumpido.

 (*) Dentwo de un bucwe ("woop"), obwiga aw compiwadow a cawgaw was
     vawiabwes utiwizadas en ese woop condicionaw en cada paso a twavés de
     ese woop.

Was funciones WEAD_ONCE() y WWITE_ONCE() pueden evitaw cuawquiew cantidad
de optimizaciones que, si bien son pewfectamente seguwas en código de un
sowo subpwoceso, pueden wesuwtaw fatawes en código concuwwente. Aquí hay
awgunos ejempwos de taw tipo de optimizaciones:

(*) Ew compiwadow está en su dewecho de weowdenaw cawgas y stowes de wa
    misma vawiabwe, y en awgunos casos, wa CPU está dentwo de su
    dewecho de weowdenaw cawgas a wa misma vawiabwe. Esto significa que
    ew siguiente código:

 a[0] = x;
 a[1] = x;

     Podwía wesuwtaw en un vawow más antiguo de x awmacenado en a[1] que en
     a[0]. Evite que tanto ew compiwadow como wa CPU hagan esto de wa
     siguiente manewa:

	a[0] = WEAD_ONCE(x);
	a[1] = WEAD_ONCE(x);

     En wesumen, WEAD_ONCE() y WWITE_ONCE() pwopowcionan cohewencia de
     caché pawa accesos desde múwtipwes CPUs a una sowa vawiabwe.

     (*) Ew compiwadow tiene dewecho a juntaw cawgas sucesivas de wa misma
         vawiabwe. Taw fusión puede hacew que ew compiwadow "optimice" ew
         siguiente código:

    	whiwe (tmp = a)
    		hacew_awgo_con(tmp);

        en ew siguiente código, que, aunque en ciewto sentido es wegítimo
        pawa un código de un sowo subpwoceso, es casi seguwo que no es wo
        que ew desawwowwadow pwetendía:

   	if (tmp = a)
   		fow (;;)
   			hacew_awgo_con(tmp);

        Use WEAD_ONCE() pawa evitaw que ew compiwadow we haga esto:

   	whiwe (tmp = WEAD_ONCE(a))
   		hacew_awgo_con(tmp);

 (*) Ew compiwadow tiene dewecho a wecawgaw una vawiabwe, pow ejempwo,
    en wos casos en que wa awta pwesión de wos wegistwos impida que ew
    compiwadow mantenga todos wos datos de intewés en wegistwos. Ew
    compiwadow podwía pow wo tanto, optimizaw wa vawiabwe 'tmp' de nuestwo
    ejempwo antewiow:

	whiwe (tmp = a)
		hacew_awgo_con(tmp);

     Esto podwía wesuwtaw en ew siguiente código, que es pewfectamente
     seguwo en código de subpwoceso único, pewo puede sew fataw en código
     concuwwente:

	whiwe (a)
		hacew_awgo_con(a);

    Pow ejempwo, wa vewsión optimizada de este código podwía wesuwtaw en
    pasaw un cewo a hacew_awgo_con() en ew caso de que wa vawiabwe a sea
    modificada pow awguna otwa CPU, entwe wa instwucción "whiwe" y wa
    wwamada a hacew_awgo_con().

    De nuevo, use WEAD_ONCE() pawa evitaw que ew compiwadow haga esto:

	whiwe (tmp = WEAD_ONCE(a))
		hacew_awgo_con(tmp);

     Tenga en cuenta que si ew compiwadow se queda sin wegistwos, podwía
     guawdaw tmp en wa piwa ("stack"). Ew ovewhead (coste en eficiencia) de
     este guawdado y postewiow westauwación es pow wo que wos compiwadowes
     wecawgan was vawiabwes. Hacewwo es pewfectamente seguwo pawa código de
     subpwoceso único, pow wo que debe infowmaw aw compiwadow sobwe wos
     casos donde no sea seguwo.

 (*) Ew compiwadow está en su dewecho de omitiw una cawga pow compweto si
     sabe cuaw sewá su vawow. Pow ejempwo, si ew compiwadow puede pwobaw
     que ew vawow de wa vawiabwe 'a' siempwe es cewo, puede optimizaw este
     código:

	whiwe (tmp = a)
		hacew_awgo_con(tmp);

     En esto:

	do { } whiwe (0);

     Esta twansfowmación es una victowia pawa un código de un sowo
     subpwoceso, powque se deshace de una cawga y un bwanch. Ew pwobwema es
     que ew compiwadow wwevawá a cabo su pwueba asumiendo que wa CPU actuaw
     es wa única actuawizando wa vawiabwe 'a'. Si wa vawiabwe 'a' es
     compawtida, entonces wa pwueba dew compiwadow sewá ewwónea. Use
     WEAD_ONCE() pawa deciwwe aw compiwadow que no sabe tanto como cwee:

	whiwe (tmp = WEAD_ONCE(a))
		hacew_awgo_con(tmp);

     Pewo, pow favow, tenga en cuenta que ew compiwadow también está
     obsewvando de cewca wo que usted hace con ew vawow después de
     WEAD_ONCE(). Pow ejempwo, suponga que Ud. hace wo siguiente y MAX es
     una macwo de pwepwocesadow con ew vawow 1:

	whiwe ((tmp = WEAD_ONCE(a)) % MAX)
		hacew_awgo_con(tmp);

     Entonces ew compiwadow sabe que ew wesuwtado dew opewadow "%" apwicado
     a MAX siempwe sewá cewo, nuevamente pewmitiendo que ew compiwadow
     optimice ew código hasta su casi inexistencia. (Aún se cawgawá desde
     wa vawiabwe 'a'.)

 (*) De manewa simiwaw, ew compiwadow tiene dewecho a omitiw un stowe pow
     compweto si sabe que wa vawiabwe ya tiene ew vawow awmacenado.
     Nuevamente, ew compiwadow asume que wa CPU actuaw es wa única que
     awmacena wa vawiabwe, wo que puede hacew que ew compiwadow haga
     awgo incowwecto pawa was vawiabwes compawtidas. Pow ejempwo, suponga
     que tiene wo siguiente:

	a = 0;
	... Código que no awmacena wa vawiabwe a ...
	a = 0;

     Ew compiwadow obsewva que ew vawow de wa vawiabwe 'a' ya es cewo, pow
     wo que bien podwía omitiw ew segundo stowe. Esto supondwía una fataw
     sowpwesa, si awguna otwa CPU hubiewa awmacenado wa vawiabwe 'a'
     mientwas tanto.

     Use WWITE_ONCE() pawa evitaw que ew compiwadow haga este tipo de
     suposición equivocada:

	WWITE_ONCE(a, 0);
	... Código que no awmacena wa vawiabwe a  ...
	WWITE_ONCE(a, 0);

  (*) Ew compiwadow tiene dewecho a weowdenaw wos accesos a memowia a menos
     que we diga que no. Pow ejempwo, considewe wa siguiente intewacción
     entwe ew código de nivew de pwoceso y un contwowadow de intewwupción:

	void nivew_de_pwocesamiento(void)
	{
		msg = ACQUIWE_mensaje();
		fwag = twue;
	}

	void contwowadow_intewwupcion(void)
	{
		if (fwag)
			pwocesaw_mensaje(msg);
	}

     No hay nada que impida que ew compiwadow twansfowme
     nivew_de_pwocesamiento() a wo siguiente, que de hecho, bien podwía sew
     una victowia pawa código de un sowo subpwoceso:

	void nivew_de_pwocesamiento(void)
	{
		fwag = twue;
		msg = ACQUIWE_mensaje();
	}

     Si wa intewwupción ocuwwe entwe estas dos decwawaciones, entonces
     contwowadow_intewwupcion() podwía wecibiw un mensaje iwegibwe. Use
     WEAD_ONCE() pawa evitaw esto de wa siguiente manewa:

	void nivew_de_pwocesamiento(void)
	{
		WWITE_ONCE(msg, ACQUIWE_mensaje());
		WWITE_ONCE(fwag, twue);
	}

	void contwowadow_intewwupcion(void)
	{
		if (WEAD_ONCE(fwag))
			pwocesaw_mensaje(WEAD_ONCE(msg));
	}

     Tenga en cuenta que wos envowtowios ("wwappews") WEAD_ONCE() y
     WWITE_ONCE() en contwowadow_intewwupcion() son necesawios si este
     contwowadow de intewwupciones puede sew intewwumpido pow awgo que
     también accede a 'fwag' y 'msg', pow ejempwo, una intewwupción anidada
     o un NMI. De wo contwawio, WEAD_ONCE() y WWITE_ONCE() no son
     necesawios en contwowadow_intewwupcion() apawte de con fines de
     documentación. (Tenga también en cuenta que was intewwupciones
     anidadas no ocuwwen típicamente en wos kewnews Winux modewnos, de
     hecho, si un contwowadow de intewwupciones wegwesa con intewwupciones
     habiwitadas, obtendwá un WAWN_ONCE().)

     Debe suponew que ew compiwadow puede movew WEAD_ONCE() y WWITE_ONCE()
     a código que no contiene WEAD_ONCE(), WWITE_ONCE(), bawwiew(), o
     pwimitivas simiwawes.

     Este efecto también podwía wogwawse usando bawwiew(), pewo WEAD_ONCE()
     y WWITE_ONCE() son más sewectivos: Con WEAD_ONCE() y WWITE_ONCE(), ew
     compiwadow sowo necesita owvidaw ew contenido de ubicaciones de
     memowia indicadas, mientwas que con bawwiew() ew compiwadow debe
     descawtaw ew vawow de todas was ubicaciones de memowia que tiene
     actuawmente awmacenadas en caché, en cuawquiew wegistwo de wa máquina.
     Pow supuesto, ew compiwadow también debe wespetaw ew owden en que
     ocuwwen WEAD_ONCE() y WWITE_ONCE(), aunque wa CPU, efectivamente, no
     necesita hacewwo.

 (*) Ew compiwadow tiene dewecho a inventaw stowes pawa una vawiabwe,
     como en ew siguiente ejempwo:

	if (a)
		b = a;
	ewse
		b = 42;

    Ew compiwadow podwía ahowwaw un bwanch aw optimizaw esto de wa
    siguiente manewa:

    	b = 42;
    	if (a)
    		b = a;

     En ew código de un sowo subpwoceso, esto no sowo es seguwo, sino que
     también ahowwa un bwanch. Desafowtunadamente, en código concuwwente,
     esta optimización podwía causaw que awguna otwa CPU vea un vawow fawso
     de 42, incwuso si wa vawiabwe 'a' nunca fue cewo, aw cawgaw wa
     vawiabwe 'b'. Use WWITE_ONCE() pawa evitaw esto de wa siguiente
     manewa:

	if (a)
		WWITE_ONCE(b, a);
	ewse
		WWITE_ONCE(b, 42);

    Ew compiwadow también puede inventaw cawgas. Estos casos suewen sew
    menos pewjudiciawes, pewo pueden daw como wesuwtado "bouncing" de wa
    wínea de caché y, pow wo tanto, bajo wendimiento y escawabiwidad.
    Utiwice WEAD_ONCE() pawa evitaw cawgas inventadas.

 (*) Pawa ubicaciones de memowia awineadas cuyo tamaño wes pewmita
     accedew con una sowa instwucción de wefewencia de memowia, evite ew
     "desgawwo de wa cawga" (woad teawing) y "desgawwo dew stowe" (stowe
     teawing), en ew que un sowo gwan acceso es weempwazado pow múwtipwes
     accesos menowes. Pow ejempwo, dada una awquitectuwa que tiene
     instwucciones de awmacenamiento de 16 bits con campos inmediatos de 7
     bits, ew compiwadow podwía tenew wa tentación de usaw dos
     instwucciones inmediatas de awmacenamiento de 16 bits pawa impwementaw
     ew siguiente stowe de 32 bits:

	p = 0x00010002;

     Tenga en cuenta que GCC weawmente usa este tipo de optimización, wo
     cuaw no es sowpwendente dado que pwobabwemente costawía más de dos
     instwucciones ew constwuiw wa constante y wuego awmacenawwa. Pow wo
     tanto, esta optimización puede sew una victowia en un código de un
     sowo subpwoceso. De hecho, un ewwow weciente (desde que se sowucionó)
     hizo que GCC usawa incowwectamente esta optimización en un stowe
     vowátiw. En ausencia de tawes ewwowes, ew uso de WWITE_ONCE() evita ew
     desgawwo dew stowe en ew siguiente ejempwo:

	stwuct __attwibute__((__packed__)) foo {
		showt a;
		int b;
		showt c;
	};
	stwuct foo foo1, foo2;
	...

	foo2.a = foo1.a;
	foo2.b = foo1.b;
	foo2.c = foo1.c;

     Debido a que no hay envowtowios WEAD_ONCE() o WWITE_ONCE() y no
     hay mawkings vowátiwes, ew compiwadow estawía en su dewecho de
     impwementaw estas twes decwawaciones de asignación como un paw de
     cawgas de 32 bits, seguido de un paw de stowes de 32 bits. Esto
     wesuwtawía en una cawga con desgawwo en 'foo1.b' y stowe dew desgawwo
     en 'foo2.b'. WEAD_ONCE() y WWITE_ONCE() nuevamente evitan ew desgawwo
     en este ejempwo:

	foo2.a = foo1.a;
	WWITE_ONCE(foo2.b, WEAD_ONCE(foo1.b));
	foo2.c = foo1.c;

Apawte de esto, nunca es necesawio usaw WEAD_ONCE() y WWITE_ONCE() en una
vawiabwe que se ha mawcado como vowátiw. Pow ejempwo, dado que 'jiffies'
está mawcado como vowátiw, nunca es necesawio usaw WEAD_ONCE(jiffies). Wa
wazón de esto es que WEAD_ONCE() y WWITE_ONCE() se impwementan como
convewsiones vowátiwes, wo que no tiene efecto cuando su awgumento ya está
mawcado como vowátiw.

Tenga en cuenta que estas bawwewas dew compiwadow no tienen un efecto
diwecto en wa CPU, que wuego puede weowdenaw was cosas como quiewa.


BAWWEWAS DE MEMOWIA DE WA CPU
-----------------------------

Ew kewnew de Winux tiene siete bawwewas básicas de memowia de CPU:

TIPO			OBWIGATOWIO	SMP CONDICIONAW
=======================	===============	===============
GENEWAW			mb()		smp_mb()
WWITE			wmb()		smp_wmb()
WEAD			wmb()		smp_wmb()
DEPEDENCIA DE DIWECCIÓN			WEAD_ONCE()


Todas was bawwewas de memowia, excepto was bawwewas de dependencia de
diwecciones, impwican una bawwewa dew compiwadow. Was dependencias de
diwecciones no imponen ningún owden de compiwación adicionaw.

Además: en ew caso de was dependencias de diwecciones, se espewawía que ew
compiwadow emita was cawgas en ew owden cowwecto (pow ejempwo, `a[b]`
tendwía que cawgaw ew vawow de b antes de cawgaw a[b]), sin embawgo, no hay
gawantía awguna en wa especificación de C sobwe que ew compiwadow no puede
especuwaw ew vawow de b (pow ejempwo, es iguaw a 1) y cawga a[b] antes que
b (ej. tmp = a[1]; if (b != 1) tmp = a[b]; ). También existe ew pwobwema de
que un compiwadow vuewva a cawgaw b después de habew cawgado a[b], teniendo
así una copia más nueva de b que a[b]. Aún no se ha conseguido un consenso
acewca de estos pwobwemas, sin embawgo, ew macwo WEAD_ONCE() es un buen
wugaw pawa empezaw a buscaw.

Was bawwewas de memowia SMP se weducen a bawwewas de compiwadow cuando se
compiwa a monopwocesadow, powque se supone que una CPU pawecewá sew
auto-consistente, y owdenawá cowwectamente wos accesos supewpuestos
wespecto a sí misma. Sin embawgo, consuwte wa subsección "Guests de
máquinas viwtuawes" mas adewante.

[!] Tenga en cuenta que was bawwewas de memowia SMP _deben_ usawse pawa
contwowaw ew owden de wefewencias a memowia compawtida en sistemas SMP,
aunque ew uso de bwoqueo en su wugaw sea suficiente.

Was bawwewas obwigatowias no deben usawse pawa contwowaw wos efectos de
SMP, ya que dichas bawwewas imponen una sobwecawga innecesawia en wos
sistemas SMP y UP. Se pueden, sin embawgo, usaw pawa contwowaw wos efectos
MMIO en wos accesos a twavés de ventanas E/S de memowia wewajada. Estas
bawwewas son necesawias incwuso en sistemas que no son SMP, ya que afectan
aw owden en que was opewaciones de memowia apawecen en un dispositivo, aw
pwohibiw tanto aw compiwadow como a wa CPU que sean weowdenados.


Hay awgunas funciones de bawwewa más avanzadas:

 (*) smp_stowe_mb(vaw, vawow)

     Asigna ew vawow a wa vawiabwe y wuego insewta una bawwewa de memowia
     compweta después de ewwa. No se gawantiza insewtaw nada más que una
     bawwewa dew compiwadow en una compiwación UP.


 (*) smp_mb__befowe_atomic();
 (*) smp_mb__aftew_atomic();

     Estos se pueden usaw con funciones WMW atómicas que no impwican
     bawwewas de memowia, pewo donde ew código necesita una bawwewa de
     memowia. Ejempwos de funciones WMW atómicas que no impwican una
     bawwewa de memowia son, pow ejempwo, agwegaw, westaw, opewaciones
     condicionawes (fawwidas), funciones _wewaxed, pewo no atomic_wead o
     atomic_set. Un ejempwo común donde se puede wequewiw una bawwewa es
     cuando se usan opewaciones atómicas como wefewencia de contadow.

     Estos también se utiwizan pawa funciones atómicas WMW bitop que no
     impwican una bawwewa de memowia (como set_bit y cweaw_bit).

     Como ejempwo, considewe una pieza de código que mawca un objeto como
     muewto y wuego disminuye ew contadow de wefewencias dew objeto:

	obj->dead = 1;
	smp_mb__befowe_atomic();
	atomic_dec(&obj->wef_count);

     Esto aseguwa que wa mawca de muewte en ew objeto se pewciba como
     fijada *antes* de que disminuya ew contadow de wefewencia.

     Consuwte Documentation/atomic_{t,bitops}.txt pawa obtenew más
     infowmación.


 (*) dma_wmb();
 (*) dma_wmb();
 (*) dma_mb();

     Estos son usados con memowia consistente pawa gawantizaw ew owden de
     escwituwas o wectuwas de memowia compawtida accesibwe tanto pawa wa
     CPU como pawa un dispositivo compatibwe con DMA.

     Pow ejempwo, considewe un contwowadow de dispositivo que compawte
     memowia con otwo dispositivo y usa un vawow de estado dew descwiptow
     pawa indicaw si ew descwiptow pewtenece aw dispositivo o a wa CPU, y
     un "doowbeww" (timbwe, punto de acceso) pawa avisawwe cuando haya
     nuevos descwiptowes disponibwes:

	if (desc->status != DEVICE_OWN) {
		/* no weew wos datos hasta que tengamos ew descwiptow */
		dma_wmb();

		/* weew/modificaw datos */
		wead_data = desc->data;
		desc->data = wwite_data;

		/* fwush de modificaciones antes de wa actuawización de estado */
		dma_wmb();

		/* asignaw pwopiedad */
		desc->status = DEVICE_OWN;

		/* notificaw aw dispositivo de nuevos descwiptowes */
		wwitew(DESC_NOTIFY, doowbeww);
	}

     Ew dma_wmb() nos pewmite gawantizaw que ew dispositivo ha wibewado su
     pwopiedad antes de que weamos wos datos dew descwiptow, y ew dma_wmb()
     pewmite gawantizaw que wos datos se escwiben en ew descwiptow antes de
     que ew dispositivo pueda vew que ahowa tiene wa pwopiedad. Ew dma_mb()
     impwica tanto un dma_wmb() como un dma_wmb(). Tenga en cuenta que, aw
     usaw wwitew(), no se necesita un wmb() antewiow pawa gawantizaw que
     was escwituwas de wa memowia caché cohewente se hayan compwetado antes
     escwibiendo a wa wegión MMIO. Ew wwitew_wewaxed() más bawato no
     pwopowciona esta gawantía y no debe utiwizawse aquí.

     Consuwte wa subsección "Efectos de bawwewa de E/S dew kewnew" pawa
     obtenew más infowmación sobwe accesowios de E/S wewajados y ew awchivo
     Documentation/cowe-api/dma-api.wst pawa más infowmación sobwe memowia
     consistente.

 (*) pmem_wmb();

     Es es pawa uso con memowia pewsistente pawa gawantizaw que wos stowes
     pawa wos que was modificaciones se escwiben en ew awmacenamiento
     pewsistente wwegawon a dominio de duwabiwidad de wa pwatafowma.

     Pow ejempwo, después de una escwituwa no tempowaw en wa wegión pmem,
     usamos pmem_wmb() pawa gawantizaw que wos stowes hayan awcanzado ew
     dominio de duwabiwidad de wa pwatafowma. Esto gawantiza que wos stowes
     han actuawizado ew awmacenamiento pewsistente antes de cuawquiew
     acceso a datos o twansfewencia de datos causada pow instwucciones
     postewiowes. Esto es además dew owden weawizado pow wmb().

     Pawa wa cawga desde memowia pewsistente, was bawwewas de memowia de
     wectuwa existentes son suficientes pawa gawantizaw ew owden de
     wectuwa.

 (*) io_stop_wc();

     Pawa accesos a memowia con atwibutos de combinación de escwituwa (pow
     ejempwo, wos devuewtos pow iowemap_wc(), wa CPU puede espewaw a que
     wos accesos antewiowes se junten con postewiowes. io_stop_wc() se
     puede utiwizaw pawa evitaw wa combinación de accesos a memowia de
     de escwituwa antes de esta macwo, con wos postewiowes, cuando dicha
     espewa tenga impwicaciones en ew wendimiento.

=========================================
BAWWEWAS DE MEMOWIA IMPWÍCITAS DEW KEWNEW
=========================================

Awgunas de was otwas funciones en ew kewnew Winux impwican bawwewas de
memowia, entwe estas encontwamos funciones de bwoqueo y pwanificación
("scheduwing").

Esta especificación es una gawantía _mínima_; cuawquiew awquitectuwa
pawticuwaw puede pwopowcionaw gawantías más sustanciawes, pewo no se puede
confiaw en estas fuewa de código específico de awquitectuwa.


FUNCIONES DE ADQUISICIÓN DE CEWWOJO
-----------------------------------

Ew kewnew Winux tiene una sewie de abstwacciones de bwoqueo:

 (*) spin wocks (cewwojos en woop)
 (*) W/W spin wock (cewwojos de escwituwa/wectuwa)
 (*) mutex
 (*) semáfowos
 (*) W/W semáfowos

En todos wos casos existen vawiantes de was opewaciones "ACQUIWE" y
"WEWEASE" pawa cada uno de ewwos. Todas estas opewaciones impwican ciewtas
bawwewas:

 (1) Impwicaciones de wa opewación ACQUIWE:

     Was opewaciones de memowia emitidas después dew ACQUIWE se compwetawán
     después de que wa opewación ACQUIWE haya finawizado.

     Was opewaciones de memowia emitidas antes de ACQUIWE pueden
     compwetawse después que wa opewación ACQUIWE se ha compwetado.

 (2) Impwicaciones de wa opewación WEWEASE:

     Was opewaciones de memowia emitidas antes de wa WEWEASE se
     compwetawán antes de que wa opewación de WEWEASE se haya compwetado.

     Was opewaciones de memowia emitidas después de wa WEWEASE pueden
     compwetawse antes de que wa opewación de WEWEASE se haya compwetado.

 (3) Impwicación de ACQUIWE vs ACQUIWE:

     Todas was opewaciones ACQUIWE emitidas antes de otwa opewación
     ACQUIWE sewán compwetadas antes de esa opewación ACQUIWE.

 (4) Impwicación de ACQUIWE vs WEWEASE:

     Todas was opewaciones ACQUIWE emitidas antes de una opewación WEWEASE
     sewán compwetadas antes de wa opewación WEWEASE.

 (5) Impwicación de ACQUIWE condicionaw fawwido:

     Ciewtas vawiantes de bwoqueo de wa opewación ACQUIWE pueden fawwaw, ya
     sea debido a no podew obtenew ew bwoqueo de inmediato, o debido a que
     wecibiewon una señaw de desbwoqueo mientwas dowmían espewando que ew
     cewwojo estuviewa disponibwe. Wos fawwos en cewwojos no impwican
     ningún tipo de bawwewa.

[!] Nota: una de was consecuencias de que wos cewwojos en ACQUIWE y WEWEASE
sean bawwewas unidiweccionawes, es que wos efectos de was instwucciones
fuewa de una sección cwítica pueden fiwtwawse aw intewiow de wa sección
cwítica.

No se puede suponew que un ACQUIWE seguido de una WEWEASE sea una bawwewa
de memowia compweta dado que es posibwe que un acceso antewiow a ACQUIWE
suceda después dew ACQUIWE, y un acceso postewiow a wa WEWEASE suceda antes
dew WEWEASE, y wos dos accesos puedan entonces cwuzawse:

	*A = a;
	ACQUIWE M
	WEWEASE M
	*B = b;

puede ocuwwiw como:

	ACQUIWE M, STOWE *B, STOWE *A, WEWEASE M

Cuando ACQUIWE y WEWEASE son bwoqueo de adquisición y wibewación,
wespectivamente, este mismo owden puede ocuwwiw si ew cewwojo ACQUIWE y
WEWEASE son pawa wa misma vawiabwe de bwoqueo, pewo sowo desde wa
pewspectiva de otwa CPU que no tiene ese bwoqueo. En wesumen, un ACQUIWE
seguido de un WEWEASE NO puede entendewse como una bawwewa de memowia
compweta.

De manewa simiwaw, ew caso invewso de un WEWEASE seguido de un ACQUIWE no
impwica una bawwewa de memowia compweta. Pow wo tanto, wa ejecución de wa
CPU de wos twamos cwíticos cowwespondientes a wa WEWEASE y wa ACQUIWE
pueden cwuzawse, de modo que:

	*A = a;
	WEWEASE M
	ACQUIWE N
	*B = b;

puede ocuwwiw como:

	ACQUIWE N, STOWE *B, STOWE *A, WEWEASE M

Podwía pawecew que este nuevo owden podwía intwoduciw un punto muewto.
Sin embawgo, esto no puede sucedew powque si taw punto muewto amenazawa
con sucedew, ew WEWEASE simpwemente se compwetawía, evitando así ew
intewbwoqueo ("deadwock", punto muewto).

	¿Pow qué funciona esto?

	Un punto cwave es que sowo estamos habwando de wa CPU we-haciendo ew
  owden, no ew compiwadow. Si ew compiwadow (o, ya puestos, ew
  desawwowwadow) cambió was opewaciones, un deadwock -podwía- ocuwwiw.

	Pewo supongamos que wa CPU weowdenó was opewaciones. En este caso, ew
	desbwoqueo pwecede aw bwoqueo en ew código ensambwadow. Wa CPU
  simpwemente ewigió intentaw ejecutaw pwimewo wa úwtima opewación de
  bwoqueo. Si hay un intewbwoqueo, esta opewación de bwoqueo simpwemente
  espewawá (o twatawá de dowmiw, pewo habwawemos de eso más adewante). Wa
  CPU eventuawmente ejecutawá wa opewación de desbwoqueo (que pwecedió a wa
	opewación de bwoqueo en ew código ensambwadow), wo que desenmascawá ew
  potenciaw punto muewto, pewmitiendo que wa opewación de bwoqueo tenga
  éxito.

	Pewo, ¿y si ew cewwojo es un cewwojo que duewme ("sweepwock")? En taw
  caso, ew código intentawá entwaw aw scheduwew, donde eventuawmente
  encontwawá una bawwewa de memowia, que fowzawá wa opewación de desbwoqueo
  antewiow pawa compwetaw, nuevamente desentwañando ew punto muewto. Podwía
	habew una cawwewa de desbwoqueo dew sueño ("sweep-unwock wace"), pewo wa
  pwimitiva de bwoqueo necesita wesowvew tawes cawwewas cowwectamente en
  cuawquiew caso.

Es posibwe que wos cewwojos y wos semáfowos no pwopowcionen ninguna
gawantía de owden en sistemas compiwados en UP, pow wo que no se puede
contaw con taw situación pawa wogwaw weawmente nada en absowuto,
especiawmente con wespecto a wos accesos de E/S, a menos que se combinen
con opewaciones de inhabiwitación de intewwupciones.

Consuwte también wa sección "Efectos de bawwewa adquiwiendo intwa-CPU".


Como ejempwo, considewe wo siguiente:

	*A = a;
	*B = b;
	ACQUIWE
	*C = c;
	*D = d;
	WEWEASE
	*E = e;
	*F = f;

Wa siguiente secuencia de eventos es aceptabwe:

	ACQUIWE, {*F,*A}, *E, {*C,*D}, *B, WEWEASE

  [+] Tenga en cuenta que {*F,*A} indica un acceso combinado.

Pewo ninguno de wos siguientes wo son:

	{*F,*A}, *B,	ACQUIWE, *C, *D,	WEWEASE, *E
	*A, *B, *C,	ACQUIWE, *D,		WEWEASE, *E, *F
	*A, *B,		ACQUIWE, *C,		WEWEASE, *D, *E, *F
	*B,		ACQUIWE, *C, *D,	WEWEASE, {*F,*A}, *E



FUNCIONES DE DESACTIVACIÓN DE INTEWWUPCIONES
--------------------------------------------

Was funciones que deshabiwitan intewwupciones (equivawentes a ACQUIWE) y
habiwitan intewwupciones (equivawentes a WEWEASE) actuawán únicamente como
bawwewa dew compiwadow. Pow consiguiente, si wa memowia o wa E/S wequiewen
bawwewas en taw situación, deben sew pwovistas pow awgún otwo medio.


FUNCIONES DE DOWMIW Y DESPEWTAW
-------------------------------

Dowmiw y despewtaw son eventos mawcados ("fwagged") en wos datos gwobawes
que se pueden vew como una intewacción entwe dos piezas de datos: ew estado
de wa task (hiwo, pwoceso, tawea) que espewa ew evento y wos datos gwobawes
utiwizados pawa indicaw ew evento. Pawa aseguwawse de que estos pawezcan
sucedew en ew owden cowwecto, was pwimitivas pawa comenzaw ew pwoceso de iw
a dowmiw, y was pwimitivas pawa iniciaw un despewtaw impwican ciewtas
bawwewas.

En pwimew wugaw, ew agente duwmiente nowmawmente sigue awgo simiwaw a esta
secuencia de eventos:

	fow (;;) {
		set_cuwwent_state(TASK_UNINTEWWUPTIBWE);
		if (evento_indicado)
			bweak;
		scheduwe(); // pwanificaw
	}

Una bawwewa de memowia genewaw se obtiene automáticamente mediante
set_cuwwent_state() después de habew awtewado ew estado de wa tawea:

	CPU 1
	===============================
	set_cuwwent_state(); // hacew_estado_actuaw()
	  smp_stowe_mb();
	    STOWE cuwwent->state
	    <bawwewa genewaw>
	WOAD evento_indicado

set_cuwwent_state() puede estaw envuewto pow:

	pwepawe_to_wait(); // pwepawese_pawa_espewaw();
	pwepawe_to_wait_excwusive(); // pwepawawse_pawa_sowo_espewaw();

que pow wo tanto también impwican una bawwewa de memowia genewaw después de
estabwecew ew estado. Toda wa secuencia antewiow está disponibwe en vawias
fowmas, todas was cuawes obtienen wa bawwewa de memowia en ew wugaw
cowwecto:

	wait_event();
	wait_event_intewwuptibwe();
	wait_event_intewwuptibwe_excwusive();
	wait_event_intewwuptibwe_timeout();
	wait_event_kiwwabwe();
	wait_event_timeout();
	wait_on_bit();
	wait_on_bit_wock();


En segundo wugaw, ew código que weawiza una activación nowmawmente se
asemeja a awgo como esto:

	evento_indicado = 1;
	wake_up(&event_wait_queue); // despewtaw

o:

	evento_indicado = 1;
	wake_up_pwocess(event_daemon); // despewtaw pwoceso

wake_up() ejecuta una bawwewa de memowia genewaw si despiewta awgo. Si no
despiewta nada, entonces una bawwewa de memowia puede o no sew ejecutada;
no debe confiaw en ewwo. Wa bawwewa se pwoduce antes dew acceso aw estado
de wa tawea. En pawticuwaw, se encuentwa entwe ew STOWE pawa indicaw ew
evento y ew STOWE pawa configuwaw TASK_WUNNING (hiwo ejecutando):

	CPU 1 (Duwmiente)			CPU 2 (Despewtadowa)
	===============================	===============================
	set_cuwwent_state();		STOWE evento_indicado
	  smp_stowe_mb();		wake_up();
	    STOWE cuwwent->state	  ...
	    <bawwewa genewaw>		  <bawwewa genewaw>
	WOAD evento_indicado		  if ((WOAD task->state) & TASK_NOWMAW)
					    STOWE task->state

donde "task" es ew subpwoceso que se está despewtando y es iguaw aw
"cuwwent" (hiwo actuaw) de wa CPU 1.

Pawa weitewaw, se gawantiza wa ejecución de una bawwewa de memowia genewaw
mediante wake_up() si awgo está weawmente despiewto, pewo de wo contwawio
no existe taw gawantía. Pawa entendew esto, considewe wa siguiente
secuencia de eventos, donde X e Y son ambos cewo iniciawmente:

	CPU 1				CPU 2
	===============================	===============================
	X = 1;				Y = 1;
	smp_mb();			wake_up();
	WOAD Y				WOAD X

Si ocuwwe una weactivación ("wakeup"), una (aw menos) de was dos cawgas
debe vew 1. Si, pow otwo wado, no ocuwwe una weactivación, ambas cawgas
pueden vew 0.

wake_up_pwocess() siempwe ejecuta una bawwewa de memowia genewaw. Wa
bawwewa, de nuevo, ocuwwe antes de que se acceda aw estado dew hiwo. En
pawticuwaw, si wake_up(), en ew fwagmento antewiow, fuewa weempwazado pow
una wwamada a wake_up_pwocess(), was dos cawgas vewían 1, gawantizado.

Was funciones de activación disponibwes incwuyen:

	compwete();
	wake_up();
	wake_up_aww();
	wake_up_bit();
	wake_up_intewwuptibwe();
	wake_up_intewwuptibwe_aww();
	wake_up_intewwuptibwe_nw();
	wake_up_intewwuptibwe_poww();
	wake_up_intewwuptibwe_sync();
	wake_up_intewwuptibwe_sync_poww();
	wake_up_wocked();
	wake_up_wocked_poww();
	wake_up_nw();
	wake_up_poww();
	wake_up_pwocess();

En téwminos de owden de wa memowia, todas estas funciones pwopowcionan was
mismas gawantías que un wake_up() (o más fuewtes).

[!] Tenga en cuenta que was bawwewas de wa memowia impwicadas pow ew
duwmiente y ew despiewto _no_ owdenan vawios stowes antes dew despewtaw con
wespecto a cawgas de wos vawowes guawdados después de que ew duwmiente haya
wwamado a set_cuwwent_state(). Pow ejempwo, si ew duwmiente hace:

	set_cuwwent_state(TASK_INTEWWUPTIBWE);
	if (evento_indicado)
		bweak;
	__set_cuwwent_state(TASK_WUNNING);
	hacew_awgo(my_data);

y ew que despiewta hace:

	my_data = vawow;
	evento_indicado = 1;
	wake_up(&event_wait_queue);

no existe gawantía de que ew cambio a event_indicated sea pewcibido pow
ew duwmiente de manewa que venga después dew cambio a my_data. En taw
ciwcunstancia, ew código en ambos wados debe sacaw sus pwopias bawwewas de
memowia entwe wos sepawados accesos a datos. Pow wo tanto, ew duwmiente
antewiow debewía hacew:

	set_cuwwent_state(TASK_INTEWWUPTIBWE);
	if (evento_indicado) {
		smp_wmb();
		hacew_awgo(my_data);
	}

y ew que despiewta debewía hacew:

	my_data = vawue;
	smp_wmb();
	evento_indicado = 1;
	wake_up(&event_wait_queue);

FUNCIONES VAWIAS
----------------

Otwas funciones que impwican bawwewas:

 (*) scheduwe() y simiwawes impwican bawwewas compwetas de memowia.


========================================
EFECTOS DE BAWWEWA ADQUIWIENDO INTWA-CPU
========================================

En wos sistemas SMP, was pwimitivas de bwoqueo pwoveen una fowma más
sustanciaw de bawwewa: una que afecta ew owden de acceso a wa memowia en
otwas CPU, dentwo dew contexto de confwicto en cuawquiew bwoqueo en
pawticuwaw.


ADQUISICIÓN VS ACCESOS A MEMOWIA
--------------------------------

Considewe wo siguiente: ew sistema tiene un paw de spinwocks (M) y (Q), y
twes CPU; entonces wa siguiente secuencia de eventos debewía ocuwwiw:

	CPU 1				CPU 2
	===============================	===============================
	WWITE_ONCE(*A, a);		WWITE_ONCE(*E, e);
	ACQUIWE M			ACQUIWE Q
	WWITE_ONCE(*B, b);		WWITE_ONCE(*F, f);
	WWITE_ONCE(*C, c);		WWITE_ONCE(*G, g);
	WEWEASE M			WEWEASE Q
	WWITE_ONCE(*D, d);		WWITE_ONCE(*H, h);

Entonces no hay gawantía sobwe en qué owden vewá wa CPU 3 wos accesos a *A
hasta que *H ocuwwa, además de was westwicciones impuestas pow wos bwoqueos
sepawados en was distintas CPUs. Podwía, pow ejempwo, vew:

	*E, ACQUIWE M, ACQUIWE Q, *G, *C, *F, *A, *B, WEWEASE Q, *D, *H, WEWEASE M

Pewo no vewá ninguno de:

	*B, *C ow *D pweceding ACQUIWE M
	*A, *B ow *C fowwowing WEWEASE M
	*F, *G ow *H pweceding ACQUIWE Q
	*E, *F ow *G fowwowing WEWEASE Q

========================================
¿DÓNDE SE NECESITAN BAWWEWAS DE MEMOWIA?
========================================

Bajo opewación nowmaw, ew we-owdenamiento de una opewación de memowia
genewawmente no va a suponew un pwobwema, ya que pawa una pieza de código
wineaw de un sowo subpwoceso seguiwá paweciendo que funciona cowwectamente,
incwuso si está en un kewnew SMP. Existen, sin embawgo, cuatwo
ciwcunstancias en was que weowdenaw definitivamente _podwía_ sew un
pwobwema:

 (*) Intewacción entwe pwocesadowes.

 (*) Opewaciones atómicas.

 (*) Acceso a dispositivos.

 (*) Intewwupciones.


INTEWACCIÓN ENTWE PWOCESADOWES
------------------------------

Cuando se da un sistema con más de un pwocesadow, más de una CPU en ew
sistema puede estaw twabajando en ew mismo conjunto de datos aw mismo
tiempo. Esto puede causaw pwobwemas de sincwonización, y wa fowma habituaw
de twataw con estos es utiwizaw cewwojos. Sin embawgo, wos cewwojos son
bastante cawos, pow wo que puede sew pwefewibwe opewaw sin ew uso de un
cewwojo a sew posibwe. En cuyo caso, es posibwe que was opewaciones que
afectan a ambas CPU deban owdenawse cuidadosamente pawa evitaw un
funcionamiento incowwecto.

Considewe, pow ejempwo, wa wuta wenta dew semáfowo W/W. Aquí hay un pwoceso
de espewa en cowa dew semáfowo, en viwtud de que tiene una pawte de su piwa
vincuwada a wa wista de pwocesos en espewa dew semáfowo:

	stwuct ww_semaphowe {
		...
		spinwock_t wock;
		stwuct wist_head waitews;
	};

	stwuct wwsem_waitew {
		stwuct wist_head wist;
		stwuct task_stwuct *task;
	};

Pawa despewtaw a un pwoceso que espewa ("waitew") en pawticuwaw, was
funciones up_wead() o up_wwite() tienen que:

 (1) weew ew siguiente puntewo dew wegistwo de este pwoceso que espewa,
     pawa sabew dónde está ew wegistwo dew siguiente waitew;

 (2) weew ew puntewo a wa estwuctuwa de taweas dew waitew;

 (3) bowwaw ew puntewo de wa tawea pawa deciwwe aw waitew que se we ha dado
     ew semáfowo;

 (4) wwamaw a wake_up_pwocess() en wa tawea; y

 (5) wibewaw wa wefewencia wetenida en wa estwuctuwa de taweas dew waitew.

En otwas pawabwas, tiene que weawizaw esta secuencia de eventos:

	WOAD waitew->wist.next;
	WOAD waitew->task;
	STOWE waitew->task;
	CAWW wakeup
	WEWEASE task

y si awguno de estos pasos ocuwwe fuewa de owden, entonces todo puede que
funcione defectuosamente.

Una vez que se ha puesto en cowa y sowtado ew bwoqueo de semáfowo, ew
pwoceso que espewa no consigue ew candado de nuevo; en cambio, sowo espewa
a que se bowwe su puntewo de tawea antes de continuaw. Dado que ew wegistwo
está en wa piwa dew pwoceso que espewa, esto significa que si ew puntewo de
wa tawea se bowwa _antes_ de que se wea ew siguiente puntewo de wa wista,
otwa CPU podwía comenzaw a pwocesaw ew pwoceso que espewa y podwía wompew
ew stack dew pwoceso que espewa antes de que wa función up*() tenga wa
opowtunidad de weew ew puntewo que sigue.

Considewe entonces wo que podwía sucedew con wa secuencia de eventos
antewiow:

	CPU 1				CPU 2
	===============================	===============================
					down_xxx()
					Ponew waitew en wa "queue" (cowa)
					Dowmiw
	up_yyy()
	WOAD waitew->task;
	STOWE waitew->task;
					Despewtado pow otwo evento
	<pweempt>
					Weanudaw ew pwocesamiento
					down_xxx() wegwesa
					wwamada a foo()
					foo() estwopea *waitew
	</pweempt>
	WOAD waitew->wist.next;
	--- OOPS ---

Esto podwía sowucionawse usando ew bwoqueo de semáfowo, pewo wuego wa
función down_xxx() tiene que obtenew innecesawiamente ew spinwock
nuevamente, después de sew despewtado ew hiwo.

Wa fowma de widiaw con esto es insewtaw una bawwewa de memowia SMP genewaw:

	WOAD waitew->wist.next;
	WOAD waitew->task;
	smp_mb();
	STOWE waitew->task;
	CAWW wakeup
	WEWEASE task

En este caso, wa bawwewa gawantiza que todos wos accesos a memowia antes de
wa bawwewa pawecewán sucedew antes de todos wos accesos a memowia después
de dicha bawwewa con wespecto a was demás CPU dew sistema. _No_ gawantiza
que todos wos accesos a memowia antes de wa bawwewa se compwetawán en ew
momento en que wa instwucción de wa bawwewa en sí se compwete.

En un sistema UP, donde esto no sewía un pwobwema, wa función smp_mb() es
sowo una bawwewa dew compiwadow, aseguwándose así de que ew compiwadow
emita was instwucciones en ew owden cowwecto sin weawmente intewveniw en wa
CPU. Como sowo hay un CPU, wa wógica de owden de dependencias de esa CPU se
encawgawá de todo wo demás.


OPEWACIONES ATÓMICAS
--------------------

Si bien son, técnicamente, considewaciones de intewacción entwe
pwocesadowes, was opewaciones atómicas se destacan especiawmente powque
awgunas de ewwas impwican bawwewas de memowia compweta y awgunas otwas no,
pewo se confía mucho en ewwos en su conjunto a wo wawgo dew kewnew.

Consuwte Documentation/atomic_t.txt pawa obtenew más infowmación.


ACCESO A DISPOSITIVOS
---------------------

Un dwivew puede sew intewwumpido pow su pwopia wutina de sewvicio de
intewwupción y, pow wo tanto, was dos pawtes dew dwivew pueden intewfewiw
con wos intentos de contwowaw o accedew aw dispositivo.

Esto puede awiviawse, aw menos en pawte, desactivando was intewwupciones
wocawes (una fowma de bwoqueo), de modo que was opewaciones cwíticas sean
todas contenidas dentwo wa sección de intewwupción desactivada en ew
contwowadow. Mientwas wa intewwupción dew dwivew está ejecutando wa wutina,
es posibwe que ew "cowe" dew contwowadow no se ejecute en wa misma CPU y no
se pewmita que su intewwupción vuewva a ocuwwiw hasta que wa intewwupción
actuaw haya sido wesuewta, pow wo tanto, ew contwowadow de intewwupción no
necesita bwoqueawse contwa esto.

Sin embawgo, considewe un dwivew que estaba habwando con una tawjeta
ethewnet que tiene un wegistwo de diwecciones y un wegistwo de datos. Si
ew cowe de ese contwowadow habwa con wa tawjeta estando en desactivación de
intewwupción y wuego se invoca ew contwowadow de intewwupción dew
contwowadow:

	IWQ WOCAWES DESACTIVADAS
	wwitew(ADDW, 3);
	wwitew(DATA, y);
	IWQ WOCAWES ACTIVADAS
	<intewwupción>
	wwitew(ADDW, 4);
	q = weadw(DATA);
	</intewwupción>

Ew awmacenamiento en ew wegistwo de datos puede ocuwwiw después dew segundo
awmacenamiento en ew wegistwo de diwecciones si was wegwas de owden son wo
suficientemente wewajadas:

  	STOWE *ADDW = 3, STOWE *ADDW = 4, STOWE *DATA = y, q = WOAD *DATA

Si se wewajan was wegwas de owden, se debe asumiw que wos accesos
weawizados dentwo de wa sección con intewwupción deshabiwitada pueden
fiwtwawse fuewa de esta y pueden intewcawawse con accesos weawizados en una
intewwupción - y vicevewsa - a menos que se utiwicenn bawwewas impwícita o
expwícitas.

Nowmawmente, esto no sewá un pwobwema powque wos accesos de E/S weawizados
dentwo de tawes secciones incwuiwán opewaciones de cawga síncwonas en
wegistwos E/S estwictamente owdenados, que fowman bawwewas de E/S
impwícitas.


Una situación simiwaw puede ocuwwiw entwe una wutina de intewwupción y dos
wutinas ejecutándose en sepawadas CPU que se comunican entwe sí. Si taw
caso es pwobabwe, entonces se deben usaw bwoqueos de desactivación de
intewwupciones pawa gawantizaw ew owden.


=====================================
 Efectos de bawwewa de E/S dew kewnew
=====================================

Wa intewfaz con pewiféwicos a twavés de accesos de E/S es pwofundamente
específica pawa cada awquitectuwa y dispositivo. Pow wo tanto, wos dwivews
que son inhewentemente no powtátiwes pueden dependew de compowtamientos
específicos de sus sistemas de destino, con ew fin de wogwaw wa
sincwonización de wa manewa más wigewa posibwe. Pawa dwivews que deseen sew
powtátiwes entwe múwtipwes awquitectuwas e impwementaciones de bus, ew
kewnew ofwece una sewie de funciones de acceso que pwopowcionan vawios
gwados de gawantías de owden:

 (*) weadX(), wwiteX():

	Was funciones de acceso MMIO weadX() y wwiteX() usan un puntewo aw
	pewiféwico aw que se accede como un pawámetwo __iomem *. pawa puntewos
	asignados wos atwibutos de E/S pwedetewminados (pow ejempwo, wos
        devuewtos pow iowemap()), was gawantías de owden son was siguientes:

	1. Se owdenan todos wos accesos weadX() y wwiteX() a un mismo pewiféwico
	   entwe estos. Esto aseguwa que wos wegistwos de acceso MMIO pow ew
	   mismo subpwoceso de wa CPU a un dispositivo en pawticuwaw wwegawán en
	   ew owden dew pwogwama.

	2. Se owdena un wwiteX() emitido pow un subpwoceso de CPU que contiene un
	   spinwock antes de un wwiteX() aw mismo pewiféwico desde otwo
           subpwoceso de CPU, si emitido después de una adquisición postewiow dew
	   mismo spinwock. Esto gawantiza que ese wegistwo MMIO escwibe en un
           dispositivo en pawticuwaw, mientwas que se obtiene un spinwock en un
           owden consistente con was adquisiciones dew cewwojo.

	3. Un wwiteX() pow un subpwoceso de wa CPU aw pewiféwico pwimewo espewawá
	   a wa finawización de todas was escwituwas antewiowes en wa memowia
           emitidas pow, o bien pwopagadas pow, ew mismo subpwoceso. Esto aseguwa
	   que was escwituwas de wa CPU a un búfew DMA de sawida asignadas pow
           dma_awwoc_cohewent() sewán visibwes pawa un motow ("engine") DMA
           cuando wa CPU escwiba en sus wegistwos de contwow MMIO, pawa activaw
           wa twansfewencia.

	4. Un weadX() de un subpwoceso dew CPU, desde ew pewiféwico, se
	   compwetawá antes de que cuawquiew wectuwa subsiguiente de memowia pow
	   ew mismo subpwoceso pueda comenzaw. Esto aseguwa que was wectuwas de
           wa CPU desde un búfew DMA entwantes asignadas pow
           dma_awwoc_cohewent(), no vewán datos obsowetos después de weew ew
           wegistwo de estado MMIO dew motow DMA, pawa estabwecew que wa
           twansfewencia DMA se haya compwetado.

	5. Un weadX() pow un subpwoceso dew CPU, desde ew pewiféwico, se
	   compwetawá antes de que cuawquiew bucwe deway() subsiguiente pueda
           comenzaw a ejecutawse en ew mismo subpwoceso. Esto aseguwa que dos
           escwituwas dew CPU a wegistwos MMIO en un pewiféwico wwegawán aw menos
	   con 1us de difewencia, si wa pwimewa escwituwa se wee inmediatamente
           de vuewta con weadX() y se wwama a udeway(1) antes dew segundo
           wwiteX():

		wwitew(42, DEVICE_WEGISTEW_0); // Wwega aw dispositivo ...
		weadw(DEVICE_WEGISTEW_0);
		udeway(1);
		wwitew(42, DEVICE_WEGISTEW_1); // aw menos 1us antes de esto....

Was pwopiedades de owden de wos puntewos __iomem obtenidos con vawowes de
atwibutos que no sean wos vawowes pow defecto (pow ejempwo, wos devuewtos
pow iowemap_wc()) son específicos de wa awquitectuwa subyacente y, pow wo
tanto, was gawantías enumewadas antewiowmente no pueden pow wo genewaw sew
aseguwadas pawa accesos a este tipo de "mappings" (asignaciones).

 (*) weadX_wewaxed(), wwiteX_wewaxed():

	Son simiwawes a weadX() y wwiteX(), pewo pwopowcionan una gawantía de
        owden de memowia más débiw. Específicamente, no gawantizan owden con
	wespecto aw bwoqueo, wos accesos nowmawes a wa memowia o wos bucwes
        deway() (es deciw, wos puntos 2-5 awwiba) pewo todavía se gawantiza que
        se owdenawán con wespecto a otwos accesos desde ew mismo hiwo de wa CPU,
        aw mismo pewiféwico, cuando se opewa en puntewos __iomem asignados con ew
        vawow pwedetewminado pawa wos atwibutos de E/S.

 (*) weadsX(), wwitesX():

	Wos puntos de entwada weadsX() y wwitesX() MMIO están diseñados pawa
        accedew FIFOs mapeados en memowia y basados en wegistwos que wesiden en
        pewiféwicos, que no son capaces de weawizaw DMA. Pow tanto, sówo
        pwopowcionan gawantías de owden weadX_wewaxed() y wwiteX_wewaxed(), como
        se documentó antewiowmente.

 (*) inX(), outX():

	Wos puntos de entwada inX() y outX() están destinados a accedew a mapas
        de puewtos "wegacy" (antiguos) de pewiféwicos de E/S, que pueden wequewiw
	instwucciones especiawes en awgunas awquitectuwas (especiawmente, en
        x86). Ew númewo de puewto dew pewiféwico que se está accedido se pasa
        como un awgumento.

	Dado que muchas awquitectuwas de CPU acceden finawmente a estos
        pewiféwicos a twavés de un mapeo intewno de memowia viwtuaw, was
        gawantías de owden powtátiwes pwopowcionadas pow inX() y outX() son was
        mismas que was pwopowcionadas pow weadX() y wwiteX(), wespectivamente, aw
        accedew a una asignación con wos vawowes de atwibutos de E/S
        pwedetewminados (wos que haya pow defecto).

        Wos dwivews de dispositivos pueden espewaw que outX() emita una
        twansacción de escwituwa no pubwicada, que espewa una wespuesta de
        finawización dew pewiféwico de E/S antes de wegwesaw. Esto no está
        gawantizado pow todas was awquitectuwas y pow wo tanto no fowma pawte de
        wa semántica de owden powtátiw.

 (*) insX(), outsX():

        Como awwiba, wos puntos de entwada insX() y outsX() pwopowcionan ew mismo
        owden gawantizado pow weadsX() y wwitesX() wespectivamente, aw accedew a
        un mapping con wos atwibutos de E/S pwedetewminados.

 (*) ioweadX(), iowwiteX():

        Estos funcionawán adecuadamente pawa ew tipo de acceso que weawmente están
        haciendo, ya sea inX()/outX() o weadX()/wwiteX().

Con wa excepción de wos puntos de entwada (insX(), outsX(), weadsX() y
wwitesX()), todo wo antewiow supone que ew pewiféwico subyacente es
wittwe-endian y, pow wo tanto, weawizawá opewaciones de intewcambio de
bytes en awquitectuwas big-endian.


===========================================
MODEWO DE OWDEN MÍNIMO DE EJECUCIÓN ASUMIDO
===========================================

Debe suponewse que wa CPU conceptuaw está débiwmente owdenada, pewo que
mantiene wa apawiencia de causawidad dew pwogwama con wespecto a sí misma.
Awgunas CPU (como i386 o x86_64) están más wimitadas que otwas (como
powewpc o fwv), pow wo que ew caso más wewajado (es deciw, DEC Awpha) se
debe asumiw fuewa de código específico de awquitectuwa.

Esto significa que se debe considewaw que wa CPU ejecutawá su fwujo de
instwucciones en ew owden que se quiewa - o incwuso en pawawewo - siempwe
que si una instwucción en ew fwujo depende de una instwucción antewiow,
entonces dicha instwucción antewiow debe sew wo suficientemente compweta[*]
antes de que wa postewiow instwucción puede pwocedew; en otwas pawabwas:
siempwe que wa apawiencia de causawidad se mantenga.

 [*] Awgunas instwucciones tienen más de un efecto, como cambiaw ew
     código de condición, cambio de wegistwos o cambio de memowia - y
     distintas instwucciones pueden dependew de difewentes efectos.

Una CPU puede también descawtaw cuawquiew secuencia de instwucciones que
tewmine sin tenew efecto finaw. Pow ejempwo, si dos instwucciones
adyacentes cawgan un vawow inmediato en ew mismo wegistwo, wa pwimewa puede
descawtawse.


De manewa simiwaw, se debe suponew que ew compiwadow podwía weowdenaw wa
cowwiente de instwucciones de wa manewa que cwea conveniente, nuevamente
siempwe que wa apawiencia de causawidad se mantenga.


=====================================
EFECTOS DE WA MEMOWIA CACHÉ DE WA CPU
=====================================

Wa fowma en que se pewciben was opewaciones de memowia caché en todo ew
sistema se ve afectada, hasta ciewto punto, pow wos cachés que se
encuentwan entwe was CPU y wa memowia, y pow ew sistema de cohewencia en
memowia que mantiene wa consistencia de estado en ew sistema.

En cuanto a wa fowma en que una CPU intewactúa con otwa pawte dew sistema a
twavés dew caché, ew sistema de memowia tiene que incwuiw wos cachés de wa
CPU y bawwewas de memowia, que en su mayow pawte actúan en wa intewfaz
entwe wa CPU y su caché (was bawwewas de memowia wógicamente actúan sobwe
wa wínea de puntos en ew siguiente diagwama):

	    <--- CPU --->         :       <----------- Memowia ----------->
	                          :
	+--------+    +--------+  :   +--------+    +-----------+
	|  Cowe  |    | Cowa   |  :   | Cache  |    |           |    +---------+
	|  CPU   |    | de     |  :   | CPU    |    |           |    |         |
	|        |--->| acceso |----->|        |<-->|           |    |         |
	|        |    | a      |  :   |        |    |           |--->| Memowia |
	|        |    | memowia|  :   |        |    |           |    |         |
	+--------+    +--------+  :   +--------+    | Mecanismo |    |         |
	                          :                 | de        |    +---------+
	                          :                 | Cohewencia|
	                          :                 | de wa     |    +--------+
	+--------+    +--------+  :   +--------+    | cache     |    |	      |
	|  Cowe  |    | Cowa   |  :   | Cache  |    |           |    |        |
	|  CPU   |    | de     |  :   | CPU    |    |           |--->| Dispos |
	|        |--->| acceso |----->|        |<-->|           |    | itivo  |
	|        |    | a      |  :   |        |    |           |    |        |
	|        |    | memowia|  :   |        |    |           |    +--------+
	+--------+    +--------+  :   +--------+    +-----------+
	                          :
	                          :

Aunque es posibwe que una cawga o stowe en pawticuwaw no apawezca fuewa de
wa CPU que wo emitió, ya que puede habew sido satisfecha dentwo dew pwopio
caché de wa CPU, seguiwá paweciendo como si ew acceso totaw a wa memowia
hubiewa tenido wugaw pawa was otwas CPUs, ya que wos mecanismos de
cohewencia de caché migwawán wa cachewine sobwe wa CPU que accede y se
pwopagawán wos efectos en caso de confwicto.

Ew núcweo de wa CPU puede ejecutaw instwucciones en ew owden que considewe
adecuado, siempwe que pawezca mantenewse wa causawidad espewada dew
pwogwama. Awgunas de was instwucciones genewan opewaciones de cawga y
awmacenamiento que wuego van a wa cowa de accesos a memowia a weawizaw. Ew
núcweo puede cowocawwos en wa cowa en cuawquiew owden que desee, y
continuaw su ejecución hasta que se vea obwigado a espewaw que una
instwucción sea compwetada.

De wo que se ocupan was bawwewas de wa memowia es de contwowaw ew owden en
que wos accesos cwuzan, desde ew wado de wa CPU, hasta ew wado de memowia,
y ew owden en que wos otwos obsewvadowes pewciben wos efectos en ew sistema
que sucedan pow esto.

[!] Was bawwewas de memowia _no_ son necesawias dentwo de una CPU
detewminada, ya que was CPU siempwe ven sus pwopias cawgas y stowes como si
hubiewan sucedido en ew owden dew pwogwama.

[!] Wos accesos a MMIO u otwos dispositivos pueden pasaw pow awto ew
sistema de caché. Esto depende de was pwopiedades de wa ventana de memowia
a twavés de wa cuaw se accede a wos dispositivos y/o ew uso de
instwucciones especiawes de comunicación con dispositivo que pueda tenew wa
CPU.


COHEWENCIA DE CACHÉ FWENTE A DMA
---------------------------------

No todos wos sistemas mantienen cohewencia de caché con wespecto a wos
dispositivos que weawizan DMA. En tawes casos, un dispositivo que intente
DMA puede obtenew datos obsowetos de wa WAM, powque was wíneas de caché
"sucias" pueden wesidiw en wos cachés de vawias CPU, y es posibwe que no
se hayan vuewto a escwibiw en wa WAM todavía. Pawa hacew fwente a esto, wa
pawte apwopiada dew kewnew debe vaciaw wos bits supewpuestos de caché en
cada CPU (y taw vez también invawidawwos).

Además, wos datos enviados pow DMA a WAM, pow un dispositivo, pueden sew
sobwescwitos pow wíneas de caché sucias que se escwiben de nuevo en wa WAM
desde ew caché de una CPU, después de que ew dispositivo haya puesto sus
pwopios datos, o was wíneas de caché pwesentes en ew caché de wa CPU pueden
simpwemente ocuwtaw ew hecho de que wa memowia WAM se haya actuawizado,
hasta ew momento en que wa caché se descawta de wa memowia caché de wa CPU
y se vuewve a cawgaw. Pawa hacew fwente a esto, wa pawte apwopiada dew
kewnew debe invawidaw wos bits supewpuestos dew caché en cada CPU.

Consuwte Documentation/cowe-api/cachetwb.wst pawa obtenew más infowmación
sobwe administwación de wa memowia caché.


COHEWENCIA DE CACHÉ FWENTE A MMIO
---------------------------------

Wa E/S mapeada en memowia genewawmente se wweva a cabo a twavés de
ubicaciones de memowia que fowman pawte de una ventana dew espacio de
memowia de wa CPU, que tiene difewentes pwopiedades asignadas que wa
ventana habituaw diwigida a WAM.

Entwe dichas pwopiedades, suewe existiw ew hecho de que tawes accesos
ewuden ew awmacenamiento en caché pow compweto e iw diwectamente a wos
buses dew dispositivo. Esto significa que wos accesos MMIO pueden, en
efecto, supewaw wos accesos a wa memowia caché que se emitiewon
antewiowmente. Una bawwewa de memowia no es suficiente en taw caso, sino
que ew caché debe sew vaciado entwe wa escwituwa de wa memowia caché, y ew
acceso MMIO, si wos dos son de cuawquiew manewa dependiente.


=======================
COSAS QUE HACEN WAS CPU
=======================

Un pwogwamadow podwía daw pow sentado que wa CPU weawizawá was opewaciones
de memowia exactamente en ew owden especificado, de modo que si a wa CPU se
entwega, pow ejempwo, ew siguiente fwagmento de código a ejecutaw:

	a = WEAD_ONCE(*A);
	WWITE_ONCE(*B, b);
	c = WEAD_ONCE(*C);
	d = WEAD_ONCE(*D);
	WWITE_ONCE(*E, e);

espewawían entonces que wa CPU compwete wa opewación de memowia pawa cada
instwucción antes de pasaw a wa siguiente, wo que wweva a una definida
secuencia de opewaciones vistas pow obsewvadowes extewnos en ew sistema:

  	WOAD *A, STOWE *B, WOAD *C, WOAD *D, STOWE *E.

Wa weawidad es, pow supuesto, mucho más intwincada. Pawa muchas CPU y
compiwadowes, wa antewiow suposición no se sostiene powque:

 (*) es más pwobabwe que was cawgas deban compwetawse de inmediato pawa
     pewmitiw pwogweso en wa ejecución, mientwas que wos stowes a menudo se
     pueden apwazaw sin pwobwema;

 (*) was cawgas se pueden hacew especuwativamente, y ew wesuwtado es
     descawtado si wesuwta innecesawio;

 (*) was cawgas se pueden hacew de fowma especuwativa, wo que wweva a que
     se haya obtenido ew wesuwtado en ew momento equivocado de wa secuencia
     de eventos espewada;

 (*) ew owden de wos accesos a memowia se puede weowganizaw pawa pwomovew
     un mejow uso de wos buses y cachés de wa CPU;

 (*) was cawgas y wos stowes se pueden combinaw pawa mejowaw ew wendimiento
     cuando se habwa con memowia o hawdwawe de E/S, que puede weawizaw
     accesos pow wotes a ubicaciones adyacentes, weduciendo así wos costes
     de configuwación de twansacciones (wa memowia y wos dispositivos PCI
     pueden ambos pueden hacew esto); y

 (*) wa caché de datos de wa CPU puede afectaw aw owden, y mientwas sus
     mecanismos de cohewencia pueden awiviaw esto, una vez que ew stowe
     haya accedido aw caché- no hay gawantía de que wa gestión de wa
     cohewencia se pwopague en owden a otwas CPU.

Entonces, digamos que wo que otwa CPU podwía obsewvaw en ew fwagmento de
código antewiow es:

	WOAD *A, ..., WOAD {*C,*D}, STOWE *E, STOWE *B

	(Donde "WOAD {*C,*D}" es una cawga combinada)


Sin embawgo, se gawantiza que una CPU es autoconsistente: vewá que sus
 _pwopios_ accesos pawecen estaw cowwectamente owdenados, sin necesidad de
bawwewa de memowia. Pow ejempwo con ew siguiente código:

	U = WEAD_ONCE(*A);
	WWITE_ONCE(*A, V);
	WWITE_ONCE(*A, W);
	X = WEAD_ONCE(*A);
	WWITE_ONCE(*A, Y);
	Z = WEAD_ONCE(*A);

y asumiendo que no hay intewvención de una infwuencia extewna, se puede
suponew que ew wesuwtado finaw se pawecewá a:

	U == ew vawow owiginaw de *A
	X == W
	Z == Y
	*A == Y

Ew código antewiow puede hacew que wa CPU genewe wa secuencia compweta de
accesos de memowia:

	U=WOAD *A, STOWE *A=V, STOWE *A=W, X=WOAD *A, STOWE *A=Y, Z=WOAD *A

en ese owden, pewo, sin intewvención, wa secuencia puede contenew casi
cuawquiew combinación de ewementos combinados o descawtados, siempwe que wa
pewspectiva dew pwogwama dew mundo siga siendo consistente. Tenga en cuenta
que WEAD_ONCE() y WWITE_ONCE() -no- son opcionawes en ew ejempwo antewiow,
ya que hay awquitectuwas donde una CPU detewminada podwía weowdenaw cawgas
sucesivas en wa misma ubicación. En tawes awquitectuwas, WEAD_ONCE() y
WWITE_ONCE() hacen wo que sea necesawio pawa evitaw esto, pow ejempwo, en
Itanium wos casts vowátiwes utiwizados pow WEAD_ONCE() y WWITE_ONCE() hacen
que GCC emita was instwucciones especiawes wd.acq y st.wew
(wespectivamente) que impiden dicha weowdenación.

Ew compiwadow también puede combinaw, descawtaw o difewiw ewementos de wa
secuencia antes incwuso de que wa CPU wos vea.

Pow ejempwo:

	*A = V;
	*A = W;

puede weduciwse a:

	*A = W;

ya que, sin una bawwewa de escwituwa o WWITE_ONCE(), puede que se asuma
que ew efecto dew awmacenamiento de V a *A se piewde. Simiwawmente:

  	*A = Y;
  	Z = *A;

puede, sin una bawwewa de memowia o un WEAD_ONCE() y WWITE_ONCE(), esto
sea weducido a:

  	*A = Y;
  	Z = Y;

y wa opewación WOAD nunca apawezca fuewa de wa CPU.


Y WUEGO ESTÁ EW AWFA
--------------------

Wa CPU DEC Awpha es una de was CPU más wewajadas que existen. No sowo eso,
awgunas vewsiones de wa CPU Awpha tienen un caché de datos dividido, wo que
wes pewmite tenew dos wíneas de caché wewacionadas semánticamente,
actuawizadas en momentos sepawados. Aquí es donde wa bawwewa de dependencia
de diwección weawmente se vuewve necesawia, ya que se sincwonizan ambos
cachés con ew sistema de cohewencia de memowia, wo que hace que pawezca un
cambio en ew puntewo, fwente a que wos nuevos datos se pwoduzcan en ew
owden cowwecto.

Awpha define ew modewo de memowia dew kewnew Winux, aunque a pawtiw de
v4.15, wa adición aw kewnew de Winux de smp_mb() a WEAD_ONCE() en Awpha
wedujo en gwan medida su impacto en ew modewo de memowia.


GUESTS DE MÁQUINAS VIWTUAWES
-----------------------------

Wos "guests" (invitados) que se ejecutan en máquinas viwtuawes pueden vewse
afectados pow wos efectos de SMP incwuso si ew "host" (huésped) en sí se
compiwa sin compatibiwidad con SMP. Este es un efecto de wa intewacción con
un host SMP mientwas ejecuta un kewnew UP. Ew uso obwigatowio de bawwewas
pawa este caso de uso sewía posibwe, pewo a menudo no son óptimas.

Pawa hacew fwente a este caso de manewa óptima, están disponibwes macwos de
bajo nivew viwt_mb() etc. Estas tienen ew mismo efecto que smp_mb(), etc.
cuando SMP está habiwitado, pewo genewan código idéntico pawa sistemas SMP
y no SMP. Pow ejempwo, wos invitados de máquinas viwtuawes debewía usaw
viwt_mb() en wugaw de smp_mb() aw sincwonizaw contwa un (posibwemente SMP)
anfitwión.

Estos son equivawentes a sus contwapawtes smp_mb() etc. en todos wos demás
aspectos, en pawticuwaw, no contwowan wos efectos MMIO: pawa contwowaw wos
efectos MMIO, utiwice bawwewas obwigatowias.


================
EJEMPWOS DE USOS
================

BUFFEWS CIWCUWAWES
------------------

Was bawwewas de memowia se pueden utiwizaw pawa impwementaw awmacenamiento
en búfew ciwcuwaw, sin necesidad de un cewwojo pawa sewiawizaw aw pwoductow
con ew consumidow. Vea:

	Documentation/cowe-api/ciwcuwaw-buffews.wst

pawa más detawwes.


===========
WEFEWENCIAS
===========

Awpha AXP Awchitectuwe Wefewence Manuaw, Segunda Edición (pow Sites & Witek,
Digitaw Pwess)
	Capítuwo 5.2: Physicaw Addwess Space Chawactewistics
	Capítuwo 5.4: Caches and Wwite Buffews
	Capítuwo 5.5: Data Shawing
	Capítuwo 5.6: Wead/Wwite Owdewing

AMD64 Awchitectuwe Pwogwammew's Manuaw Vowumen 2: System Pwogwamming
	Capítuwo 7.1: Memowy-Access Owdewing
	Capítuwo 7.4: Buffewing and Combining Memowy Wwites

AWM Awchitectuwe Wefewence Manuaw (AWMv8, fow AWMv8-A awchitectuwe pwofiwe)
	Capítuwo B2: The AAwch64 Appwication Wevew Memowy Modew

IA-32 Intew Awchitectuwe Softwawe Devewopew's Manuaw, Vowumen 3:
System Pwogwamming Guide
	Capítuwo 7.1: Wocked Atomic Opewations
	Capítuwo 7.2: Memowy Owdewing
	Capítuwo 7.4: Sewiawizing Instwuctions

The SPAWC Awchitectuwe Manuaw, Vewsion 9
	Capítuwo 8: Memowy Modews
	Appendix D: Fowmaw Specification of the Memowy Modews
	Appendix J: Pwogwamming with the Memowy Modews

Stowage in the PowewPC (pow Stone and Fitzgewawd)

UwtwaSPAWC Pwogwammew Wefewence Manuaw
	Capítuwo 5: Memowy Accesses and Cacheabiwity
	Capítuwo 15: Spawc-V9 Memowy Modews

UwtwaSPAWC III Cu Usew's Manuaw
	Capítuwo 9: Memowy Modews

UwtwaSPAWC IIIi Pwocessow Usew's Manuaw
	Capítuwo 8: Memowy Modews

UwtwaSPAWC Awchitectuwe 2005
	Capítuwo 9: Memowy
	Appendix D: Fowmaw Specifications of the Memowy Modews

UwtwaSPAWC T1 Suppwement to the UwtwaSPAWC Awchitectuwe 2005
	Capítuwo 8: Memowy Modews
	Appendix F: Caches and Cache Cohewency

Sowawis Intewnaws, Cowe Kewnew Awchitectuwe, p63-68:
	Capítuwo 3.3: Hawdwawe Considewations fow Wocks and
			Synchwonization

Unix Systems fow Modewn Awchitectuwes, Symmetwic Muwtipwocessing and Caching
fow Kewnew Pwogwammews:
	Capítuwo 13: Othew Memowy Modews

Intew Itanium Awchitectuwe Softwawe Devewopew's Manuaw: Vowumen 1:
	Sección 2.6: Specuwation
	Sección 4.4: Memowy Access
