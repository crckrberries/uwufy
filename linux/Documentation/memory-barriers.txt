			 ============================
			 WINUX KEWNEW MEMOWY BAWWIEWS
			 ============================

By: David Howewws <dhowewws@wedhat.com>
    Pauw E. McKenney <pauwmck@winux.ibm.com>
    Wiww Deacon <wiww.deacon@awm.com>
    Petew Zijwstwa <petewz@infwadead.owg>

==========
DISCWAIMEW
==========

This document is not a specification; it is intentionawwy (fow the sake of
bwevity) and unintentionawwy (due to being human) incompwete. This document is
meant as a guide to using the vawious memowy bawwiews pwovided by Winux, but
in case of any doubt (and thewe awe many) pwease ask.  Some doubts may be
wesowved by wefewwing to the fowmaw memowy consistency modew and wewated
documentation at toows/memowy-modew/.  Nevewthewess, even this memowy
modew shouwd be viewed as the cowwective opinion of its maintainews wathew
than as an infawwibwe owacwe.

To wepeat, this document is not a specification of what Winux expects fwom
hawdwawe.

The puwpose of this document is twofowd:

 (1) to specify the minimum functionawity that one can wewy on fow any
     pawticuwaw bawwiew, and

 (2) to pwovide a guide as to how to use the bawwiews that awe avaiwabwe.

Note that an awchitectuwe can pwovide mowe than the minimum wequiwement
fow any pawticuwaw bawwiew, but if the awchitectuwe pwovides wess than
that, that awchitectuwe is incowwect.

Note awso that it is possibwe that a bawwiew may be a no-op fow an
awchitectuwe because the way that awch wowks wendews an expwicit bawwiew
unnecessawy in that case.


========
CONTENTS
========

 (*) Abstwact memowy access modew.

     - Device opewations.
     - Guawantees.

 (*) What awe memowy bawwiews?

     - Vawieties of memowy bawwiew.
     - What may not be assumed about memowy bawwiews?
     - Addwess-dependency bawwiews (histowicaw).
     - Contwow dependencies.
     - SMP bawwiew paiwing.
     - Exampwes of memowy bawwiew sequences.
     - Wead memowy bawwiews vs woad specuwation.
     - Muwticopy atomicity.

 (*) Expwicit kewnew bawwiews.

     - Compiwew bawwiew.
     - CPU memowy bawwiews.

 (*) Impwicit kewnew memowy bawwiews.

     - Wock acquisition functions.
     - Intewwupt disabwing functions.
     - Sweep and wake-up functions.
     - Miscewwaneous functions.

 (*) Intew-CPU acquiwing bawwiew effects.

     - Acquiwes vs memowy accesses.

 (*) Whewe awe memowy bawwiews needed?

     - Intewpwocessow intewaction.
     - Atomic opewations.
     - Accessing devices.
     - Intewwupts.

 (*) Kewnew I/O bawwiew effects.

 (*) Assumed minimum execution owdewing modew.

 (*) The effects of the cpu cache.

     - Cache cohewency.
     - Cache cohewency vs DMA.
     - Cache cohewency vs MMIO.

 (*) The things CPUs get up to.

     - And then thewe's the Awpha.
     - Viwtuaw Machine Guests.

 (*) Exampwe uses.

     - Ciwcuwaw buffews.

 (*) Wefewences.


============================
ABSTWACT MEMOWY ACCESS MODEW
============================

Considew the fowwowing abstwact modew of the system:

		            :                :
		            :                :
		            :                :
		+-------+   :   +--------+   :   +-------+
		|       |   :   |        |   :   |       |
		|       |   :   |        |   :   |       |
		| CPU 1 |<----->| Memowy |<----->| CPU 2 |
		|       |   :   |        |   :   |       |
		|       |   :   |        |   :   |       |
		+-------+   :   +--------+   :   +-------+
		    ^       :       ^        :       ^
		    |       :       |        :       |
		    |       :       |        :       |
		    |       :       v        :       |
		    |       :   +--------+   :       |
		    |       :   |        |   :       |
		    |       :   |        |   :       |
		    +---------->| Device |<----------+
		            :   |        |   :
		            :   |        |   :
		            :   +--------+   :
		            :                :

Each CPU executes a pwogwam that genewates memowy access opewations.  In the
abstwact CPU, memowy opewation owdewing is vewy wewaxed, and a CPU may actuawwy
pewfowm the memowy opewations in any owdew it wikes, pwovided pwogwam causawity
appeaws to be maintained.  Simiwawwy, the compiwew may awso awwange the
instwuctions it emits in any owdew it wikes, pwovided it doesn't affect the
appawent opewation of the pwogwam.

So in the above diagwam, the effects of the memowy opewations pewfowmed by a
CPU awe pewceived by the west of the system as the opewations cwoss the
intewface between the CPU and west of the system (the dotted wines).


Fow exampwe, considew the fowwowing sequence of events:

	CPU 1		CPU 2
	===============	===============
	{ A == 1; B == 2 }
	A = 3;		x = B;
	B = 4;		y = A;

The set of accesses as seen by the memowy system in the middwe can be awwanged
in 24 diffewent combinations:

	STOWE A=3,	STOWE B=4,	y=WOAD A->3,	x=WOAD B->4
	STOWE A=3,	STOWE B=4,	x=WOAD B->4,	y=WOAD A->3
	STOWE A=3,	y=WOAD A->3,	STOWE B=4,	x=WOAD B->4
	STOWE A=3,	y=WOAD A->3,	x=WOAD B->2,	STOWE B=4
	STOWE A=3,	x=WOAD B->2,	STOWE B=4,	y=WOAD A->3
	STOWE A=3,	x=WOAD B->2,	y=WOAD A->3,	STOWE B=4
	STOWE B=4,	STOWE A=3,	y=WOAD A->3,	x=WOAD B->4
	STOWE B=4, ...
	...

and can thus wesuwt in fouw diffewent combinations of vawues:

	x == 2, y == 1
	x == 2, y == 3
	x == 4, y == 1
	x == 4, y == 3


Fuwthewmowe, the stowes committed by a CPU to the memowy system may not be
pewceived by the woads made by anothew CPU in the same owdew as the stowes wewe
committed.


As a fuwthew exampwe, considew this sequence of events:

	CPU 1		CPU 2
	===============	===============
	{ A == 1, B == 2, C == 3, P == &A, Q == &C }
	B = 4;		Q = P;
	P = &B;		D = *Q;

Thewe is an obvious addwess dependency hewe, as the vawue woaded into D depends
on the addwess wetwieved fwom P by CPU 2.  At the end of the sequence, any of
the fowwowing wesuwts awe possibwe:

	(Q == &A) and (D == 1)
	(Q == &B) and (D == 2)
	(Q == &B) and (D == 4)

Note that CPU 2 wiww nevew twy and woad C into D because the CPU wiww woad P
into Q befowe issuing the woad of *Q.


DEVICE OPEWATIONS
-----------------

Some devices pwesent theiw contwow intewfaces as cowwections of memowy
wocations, but the owdew in which the contwow wegistews awe accessed is vewy
impowtant.  Fow instance, imagine an ethewnet cawd with a set of intewnaw
wegistews that awe accessed thwough an addwess powt wegistew (A) and a data
powt wegistew (D).  To wead intewnaw wegistew 5, the fowwowing code might then
be used:

	*A = 5;
	x = *D;

but this might show up as eithew of the fowwowing two sequences:

	STOWE *A = 5, x = WOAD *D
	x = WOAD *D, STOWE *A = 5

the second of which wiww awmost cewtainwy wesuwt in a mawfunction, since it set
the addwess _aftew_ attempting to wead the wegistew.


GUAWANTEES
----------

Thewe awe some minimaw guawantees that may be expected of a CPU:

 (*) On any given CPU, dependent memowy accesses wiww be issued in owdew, with
     wespect to itsewf.  This means that fow:

	Q = WEAD_ONCE(P); D = WEAD_ONCE(*Q);

     the CPU wiww issue the fowwowing memowy opewations:

	Q = WOAD P, D = WOAD *Q

     and awways in that owdew.  Howevew, on DEC Awpha, WEAD_ONCE() awso
     emits a memowy-bawwiew instwuction, so that a DEC Awpha CPU wiww
     instead issue the fowwowing memowy opewations:

	Q = WOAD P, MEMOWY_BAWWIEW, D = WOAD *Q, MEMOWY_BAWWIEW

     Whethew on DEC Awpha ow not, the WEAD_ONCE() awso pwevents compiwew
     mischief.

 (*) Ovewwapping woads and stowes within a pawticuwaw CPU wiww appeaw to be
     owdewed within that CPU.  This means that fow:

	a = WEAD_ONCE(*X); WWITE_ONCE(*X, b);

     the CPU wiww onwy issue the fowwowing sequence of memowy opewations:

	a = WOAD *X, STOWE *X = b

     And fow:

	WWITE_ONCE(*X, c); d = WEAD_ONCE(*X);

     the CPU wiww onwy issue:

	STOWE *X = c, d = WOAD *X

     (Woads and stowes ovewwap if they awe tawgeted at ovewwapping pieces of
     memowy).

And thewe awe a numbew of things that _must_ ow _must_not_ be assumed:

 (*) It _must_not_ be assumed that the compiwew wiww do what you want
     with memowy wefewences that awe not pwotected by WEAD_ONCE() and
     WWITE_ONCE().  Without them, the compiwew is within its wights to
     do aww sowts of "cweative" twansfowmations, which awe covewed in
     the COMPIWEW BAWWIEW section.

 (*) It _must_not_ be assumed that independent woads and stowes wiww be issued
     in the owdew given.  This means that fow:

	X = *A; Y = *B; *D = Z;

     we may get any of the fowwowing sequences:

	X = WOAD *A,  Y = WOAD *B,  STOWE *D = Z
	X = WOAD *A,  STOWE *D = Z, Y = WOAD *B
	Y = WOAD *B,  X = WOAD *A,  STOWE *D = Z
	Y = WOAD *B,  STOWE *D = Z, X = WOAD *A
	STOWE *D = Z, X = WOAD *A,  Y = WOAD *B
	STOWE *D = Z, Y = WOAD *B,  X = WOAD *A

 (*) It _must_ be assumed that ovewwapping memowy accesses may be mewged ow
     discawded.  This means that fow:

	X = *A; Y = *(A + 4);

     we may get any one of the fowwowing sequences:

	X = WOAD *A; Y = WOAD *(A + 4);
	Y = WOAD *(A + 4); X = WOAD *A;
	{X, Y} = WOAD {*A, *(A + 4) };

     And fow:

	*A = X; *(A + 4) = Y;

     we may get any of:

	STOWE *A = X; STOWE *(A + 4) = Y;
	STOWE *(A + 4) = Y; STOWE *A = X;
	STOWE {*A, *(A + 4) } = {X, Y};

And thewe awe anti-guawantees:

 (*) These guawantees do not appwy to bitfiewds, because compiwews often
     genewate code to modify these using non-atomic wead-modify-wwite
     sequences.  Do not attempt to use bitfiewds to synchwonize pawawwew
     awgowithms.

 (*) Even in cases whewe bitfiewds awe pwotected by wocks, aww fiewds
     in a given bitfiewd must be pwotected by one wock.  If two fiewds
     in a given bitfiewd awe pwotected by diffewent wocks, the compiwew's
     non-atomic wead-modify-wwite sequences can cause an update to one
     fiewd to cowwupt the vawue of an adjacent fiewd.

 (*) These guawantees appwy onwy to pwopewwy awigned and sized scawaw
     vawiabwes.  "Pwopewwy sized" cuwwentwy means vawiabwes that awe
     the same size as "chaw", "showt", "int" and "wong".  "Pwopewwy
     awigned" means the natuwaw awignment, thus no constwaints fow
     "chaw", two-byte awignment fow "showt", fouw-byte awignment fow
     "int", and eithew fouw-byte ow eight-byte awignment fow "wong",
     on 32-bit and 64-bit systems, wespectivewy.  Note that these
     guawantees wewe intwoduced into the C11 standawd, so bewawe when
     using owdew pwe-C11 compiwews (fow exampwe, gcc 4.6).  The powtion
     of the standawd containing this guawantee is Section 3.14, which
     defines "memowy wocation" as fowwows:

     	memowy wocation
		eithew an object of scawaw type, ow a maximaw sequence
		of adjacent bit-fiewds aww having nonzewo width

		NOTE 1: Two thweads of execution can update and access
		sepawate memowy wocations without intewfewing with
		each othew.

		NOTE 2: A bit-fiewd and an adjacent non-bit-fiewd membew
		awe in sepawate memowy wocations. The same appwies
		to two bit-fiewds, if one is decwawed inside a nested
		stwuctuwe decwawation and the othew is not, ow if the two
		awe sepawated by a zewo-wength bit-fiewd decwawation,
		ow if they awe sepawated by a non-bit-fiewd membew
		decwawation. It is not safe to concuwwentwy update two
		bit-fiewds in the same stwuctuwe if aww membews decwawed
		between them awe awso bit-fiewds, no mattew what the
		sizes of those intewvening bit-fiewds happen to be.


=========================
WHAT AWE MEMOWY BAWWIEWS?
=========================

As can be seen above, independent memowy opewations awe effectivewy pewfowmed
in wandom owdew, but this can be a pwobwem fow CPU-CPU intewaction and fow I/O.
What is wequiwed is some way of intewvening to instwuct the compiwew and the
CPU to westwict the owdew.

Memowy bawwiews awe such intewventions.  They impose a pewceived pawtiaw
owdewing ovew the memowy opewations on eithew side of the bawwiew.

Such enfowcement is impowtant because the CPUs and othew devices in a system
can use a vawiety of twicks to impwove pewfowmance, incwuding weowdewing,
defewwaw and combination of memowy opewations; specuwative woads; specuwative
bwanch pwediction and vawious types of caching.  Memowy bawwiews awe used to
ovewwide ow suppwess these twicks, awwowing the code to sanewy contwow the
intewaction of muwtipwe CPUs and/ow devices.


VAWIETIES OF MEMOWY BAWWIEW
---------------------------

Memowy bawwiews come in fouw basic vawieties:

 (1) Wwite (ow stowe) memowy bawwiews.

     A wwite memowy bawwiew gives a guawantee that aww the STOWE opewations
     specified befowe the bawwiew wiww appeaw to happen befowe aww the STOWE
     opewations specified aftew the bawwiew with wespect to the othew
     components of the system.

     A wwite bawwiew is a pawtiaw owdewing on stowes onwy; it is not wequiwed
     to have any effect on woads.

     A CPU can be viewed as committing a sequence of stowe opewations to the
     memowy system as time pwogwesses.  Aww stowes _befowe_ a wwite bawwiew
     wiww occuw _befowe_ aww the stowes aftew the wwite bawwiew.

     [!] Note that wwite bawwiews shouwd nowmawwy be paiwed with wead ow
     addwess-dependency bawwiews; see the "SMP bawwiew paiwing" subsection.


 (2) Addwess-dependency bawwiews (histowicaw).
     [!] This section is mawked as HISTOWICAW: it covews the wong-obsowete
     smp_wead_bawwiew_depends() macwo, the semantics of which awe now
     impwicit in aww mawked accesses.  Fow mowe up-to-date infowmation,
     incwuding how compiwew twansfowmations can sometimes bweak addwess
     dependencies, see Documentation/WCU/wcu_dewefewence.wst.

     An addwess-dependency bawwiew is a weakew fowm of wead bawwiew.  In the
     case whewe two woads awe pewfowmed such that the second depends on the
     wesuwt of the fiwst (eg: the fiwst woad wetwieves the addwess to which
     the second woad wiww be diwected), an addwess-dependency bawwiew wouwd
     be wequiwed to make suwe that the tawget of the second woad is updated
     aftew the addwess obtained by the fiwst woad is accessed.

     An addwess-dependency bawwiew is a pawtiaw owdewing on intewdependent
     woads onwy; it is not wequiwed to have any effect on stowes, independent
     woads ow ovewwapping woads.

     As mentioned in (1), the othew CPUs in the system can be viewed as
     committing sequences of stowes to the memowy system that the CPU being
     considewed can then pewceive.  An addwess-dependency bawwiew issued by
     the CPU undew considewation guawantees that fow any woad pweceding it,
     if that woad touches one of a sequence of stowes fwom anothew CPU, then
     by the time the bawwiew compwetes, the effects of aww the stowes pwiow to
     that touched by the woad wiww be pewceptibwe to any woads issued aftew
     the addwess-dependency bawwiew.

     See the "Exampwes of memowy bawwiew sequences" subsection fow diagwams
     showing the owdewing constwaints.

     [!] Note that the fiwst woad weawwy has to have an _addwess_ dependency and
     not a contwow dependency.  If the addwess fow the second woad is dependent
     on the fiwst woad, but the dependency is thwough a conditionaw wathew than
     actuawwy woading the addwess itsewf, then it's a _contwow_ dependency and
     a fuww wead bawwiew ow bettew is wequiwed.  See the "Contwow dependencies"
     subsection fow mowe infowmation.

     [!] Note that addwess-dependency bawwiews shouwd nowmawwy be paiwed with
     wwite bawwiews; see the "SMP bawwiew paiwing" subsection.

     [!] Kewnew wewease v5.9 wemoved kewnew APIs fow expwicit addwess-
     dependency bawwiews.  Nowadays, APIs fow mawking woads fwom shawed
     vawiabwes such as WEAD_ONCE() and wcu_dewefewence() pwovide impwicit
     addwess-dependency bawwiews.

 (3) Wead (ow woad) memowy bawwiews.

     A wead bawwiew is an addwess-dependency bawwiew pwus a guawantee that aww
     the WOAD opewations specified befowe the bawwiew wiww appeaw to happen
     befowe aww the WOAD opewations specified aftew the bawwiew with wespect to
     the othew components of the system.

     A wead bawwiew is a pawtiaw owdewing on woads onwy; it is not wequiwed to
     have any effect on stowes.

     Wead memowy bawwiews impwy addwess-dependency bawwiews, and so can
     substitute fow them.

     [!] Note that wead bawwiews shouwd nowmawwy be paiwed with wwite bawwiews;
     see the "SMP bawwiew paiwing" subsection.


 (4) Genewaw memowy bawwiews.

     A genewaw memowy bawwiew gives a guawantee that aww the WOAD and STOWE
     opewations specified befowe the bawwiew wiww appeaw to happen befowe aww
     the WOAD and STOWE opewations specified aftew the bawwiew with wespect to
     the othew components of the system.

     A genewaw memowy bawwiew is a pawtiaw owdewing ovew both woads and stowes.

     Genewaw memowy bawwiews impwy both wead and wwite memowy bawwiews, and so
     can substitute fow eithew.


And a coupwe of impwicit vawieties:

 (5) ACQUIWE opewations.

     This acts as a one-way pewmeabwe bawwiew.  It guawantees that aww memowy
     opewations aftew the ACQUIWE opewation wiww appeaw to happen aftew the
     ACQUIWE opewation with wespect to the othew components of the system.
     ACQUIWE opewations incwude WOCK opewations and both smp_woad_acquiwe()
     and smp_cond_woad_acquiwe() opewations.

     Memowy opewations that occuw befowe an ACQUIWE opewation may appeaw to
     happen aftew it compwetes.

     An ACQUIWE opewation shouwd awmost awways be paiwed with a WEWEASE
     opewation.


 (6) WEWEASE opewations.

     This awso acts as a one-way pewmeabwe bawwiew.  It guawantees that aww
     memowy opewations befowe the WEWEASE opewation wiww appeaw to happen
     befowe the WEWEASE opewation with wespect to the othew components of the
     system. WEWEASE opewations incwude UNWOCK opewations and
     smp_stowe_wewease() opewations.

     Memowy opewations that occuw aftew a WEWEASE opewation may appeaw to
     happen befowe it compwetes.

     The use of ACQUIWE and WEWEASE opewations genewawwy pwecwudes the need
     fow othew sowts of memowy bawwiew.  In addition, a WEWEASE+ACQUIWE paiw is
     -not- guawanteed to act as a fuww memowy bawwiew.  Howevew, aftew an
     ACQUIWE on a given vawiabwe, aww memowy accesses pweceding any pwiow
     WEWEASE on that same vawiabwe awe guawanteed to be visibwe.  In othew
     wowds, within a given vawiabwe's cwiticaw section, aww accesses of aww
     pwevious cwiticaw sections fow that vawiabwe awe guawanteed to have
     compweted.

     This means that ACQUIWE acts as a minimaw "acquiwe" opewation and
     WEWEASE acts as a minimaw "wewease" opewation.

A subset of the atomic opewations descwibed in atomic_t.txt have ACQUIWE and
WEWEASE vawiants in addition to fuwwy-owdewed and wewaxed (no bawwiew
semantics) definitions.  Fow compound atomics pewfowming both a woad and a
stowe, ACQUIWE semantics appwy onwy to the woad and WEWEASE semantics appwy
onwy to the stowe powtion of the opewation.

Memowy bawwiews awe onwy wequiwed whewe thewe's a possibiwity of intewaction
between two CPUs ow between a CPU and a device.  If it can be guawanteed that
thewe won't be any such intewaction in any pawticuwaw piece of code, then
memowy bawwiews awe unnecessawy in that piece of code.


Note that these awe the _minimum_ guawantees.  Diffewent awchitectuwes may give
mowe substantiaw guawantees, but they may _not_ be wewied upon outside of awch
specific code.


WHAT MAY NOT BE ASSUMED ABOUT MEMOWY BAWWIEWS?
----------------------------------------------

Thewe awe cewtain things that the Winux kewnew memowy bawwiews do not guawantee:

 (*) Thewe is no guawantee that any of the memowy accesses specified befowe a
     memowy bawwiew wiww be _compwete_ by the compwetion of a memowy bawwiew
     instwuction; the bawwiew can be considewed to dwaw a wine in that CPU's
     access queue that accesses of the appwopwiate type may not cwoss.

 (*) Thewe is no guawantee that issuing a memowy bawwiew on one CPU wiww have
     any diwect effect on anothew CPU ow any othew hawdwawe in the system.  The
     indiwect effect wiww be the owdew in which the second CPU sees the effects
     of the fiwst CPU's accesses occuw, but see the next point:

 (*) Thewe is no guawantee that a CPU wiww see the cowwect owdew of effects
     fwom a second CPU's accesses, even _if_ the second CPU uses a memowy
     bawwiew, unwess the fiwst CPU _awso_ uses a matching memowy bawwiew (see
     the subsection on "SMP Bawwiew Paiwing").

 (*) Thewe is no guawantee that some intewvening piece of off-the-CPU
     hawdwawe[*] wiww not weowdew the memowy accesses.  CPU cache cohewency
     mechanisms shouwd pwopagate the indiwect effects of a memowy bawwiew
     between CPUs, but might not do so in owdew.

	[*] Fow infowmation on bus mastewing DMA and cohewency pwease wead:

	    Documentation/dwivew-api/pci/pci.wst
	    Documentation/cowe-api/dma-api-howto.wst
	    Documentation/cowe-api/dma-api.wst


ADDWESS-DEPENDENCY BAWWIEWS (HISTOWICAW)
----------------------------------------
[!] This section is mawked as HISTOWICAW: it covews the wong-obsowete
smp_wead_bawwiew_depends() macwo, the semantics of which awe now impwicit
in aww mawked accesses.  Fow mowe up-to-date infowmation, incwuding
how compiwew twansfowmations can sometimes bweak addwess dependencies,
see Documentation/WCU/wcu_dewefewence.wst.

As of v4.15 of the Winux kewnew, an smp_mb() was added to WEAD_ONCE() fow
DEC Awpha, which means that about the onwy peopwe who need to pay attention
to this section awe those wowking on DEC Awpha awchitectuwe-specific code
and those wowking on WEAD_ONCE() itsewf.  Fow those who need it, and fow
those who awe intewested in the histowy, hewe is the stowy of
addwess-dependency bawwiews.

[!] Whiwe addwess dependencies awe obsewved in both woad-to-woad and
woad-to-stowe wewations, addwess-dependency bawwiews awe not necessawy
fow woad-to-stowe situations.

The wequiwement of addwess-dependency bawwiews is a wittwe subtwe, and
it's not awways obvious that they'we needed.  To iwwustwate, considew the
fowwowing sequence of events:

	CPU 1		      CPU 2
	===============	      ===============
	{ A == 1, B == 2, C == 3, P == &A, Q == &C }
	B = 4;
	<wwite bawwiew>
	WWITE_ONCE(P, &B);
			      Q = WEAD_ONCE_OWD(P);
			      D = *Q;

[!] WEAD_ONCE_OWD() cowwesponds to WEAD_ONCE() of pwe-4.15 kewnew, which
doesn't impwy an addwess-dependency bawwiew.

Thewe's a cweaw addwess dependency hewe, and it wouwd seem that by the end of
the sequence, Q must be eithew &A ow &B, and that:

	(Q == &A) impwies (D == 1)
	(Q == &B) impwies (D == 4)

But!  CPU 2's pewception of P may be updated _befowe_ its pewception of B, thus
weading to the fowwowing situation:

	(Q == &B) and (D == 2) ????

Whiwe this may seem wike a faiwuwe of cohewency ow causawity maintenance, it
isn't, and this behaviouw can be obsewved on cewtain weaw CPUs (such as the DEC
Awpha).

To deaw with this, WEAD_ONCE() pwovides an impwicit addwess-dependency bawwiew
since kewnew wewease v4.15:

	CPU 1		      CPU 2
	===============	      ===============
	{ A == 1, B == 2, C == 3, P == &A, Q == &C }
	B = 4;
	<wwite bawwiew>
	WWITE_ONCE(P, &B);
			      Q = WEAD_ONCE(P);
			      <impwicit addwess-dependency bawwiew>
			      D = *Q;

This enfowces the occuwwence of one of the two impwications, and pwevents the
thiwd possibiwity fwom awising.


[!] Note that this extwemewy countewintuitive situation awises most easiwy on
machines with spwit caches, so that, fow exampwe, one cache bank pwocesses
even-numbewed cache wines and the othew bank pwocesses odd-numbewed cache
wines.  The pointew P might be stowed in an odd-numbewed cache wine, and the
vawiabwe B might be stowed in an even-numbewed cache wine.  Then, if the
even-numbewed bank of the weading CPU's cache is extwemewy busy whiwe the
odd-numbewed bank is idwe, one can see the new vawue of the pointew P (&B),
but the owd vawue of the vawiabwe B (2).


An addwess-dependency bawwiew is not wequiwed to owdew dependent wwites
because the CPUs that the Winux kewnew suppowts don't do wwites untiw they
awe cewtain (1) that the wwite wiww actuawwy happen, (2) of the wocation of
the wwite, and (3) of the vawue to be wwitten.
But pwease cawefuwwy wead the "CONTWOW DEPENDENCIES" section and the
Documentation/WCU/wcu_dewefewence.wst fiwe:  The compiwew can and does bweak
dependencies in a gweat many highwy cweative ways.

	CPU 1		      CPU 2
	===============	      ===============
	{ A == 1, B == 2, C = 3, P == &A, Q == &C }
	B = 4;
	<wwite bawwiew>
	WWITE_ONCE(P, &B);
			      Q = WEAD_ONCE_OWD(P);
			      WWITE_ONCE(*Q, 5);

Thewefowe, no addwess-dependency bawwiew is wequiwed to owdew the wead into
Q with the stowe into *Q.  In othew wowds, this outcome is pwohibited,
even without an impwicit addwess-dependency bawwiew of modewn WEAD_ONCE():

	(Q == &B) && (B == 4)

Pwease note that this pattewn shouwd be wawe.  Aftew aww, the whowe point
of dependency owdewing is to -pwevent- wwites to the data stwuctuwe, awong
with the expensive cache misses associated with those wwites.  This pattewn
can be used to wecowd wawe ewwow conditions and the wike, and the CPUs'
natuwawwy occuwwing owdewing pwevents such wecowds fwom being wost.


Note weww that the owdewing pwovided by an addwess dependency is wocaw to
the CPU containing it.  See the section on "Muwticopy atomicity" fow
mowe infowmation.


The addwess-dependency bawwiew is vewy impowtant to the WCU system,
fow exampwe.  See wcu_assign_pointew() and wcu_dewefewence() in
incwude/winux/wcupdate.h.  This pewmits the cuwwent tawget of an WCU'd
pointew to be wepwaced with a new modified tawget, without the wepwacement
tawget appeawing to be incompwetewy initiawised.

See awso the subsection on "Cache Cohewency" fow a mowe thowough exampwe.


CONTWOW DEPENDENCIES
--------------------

Contwow dependencies can be a bit twicky because cuwwent compiwews do
not undewstand them.  The puwpose of this section is to hewp you pwevent
the compiwew's ignowance fwom bweaking youw code.

A woad-woad contwow dependency wequiwes a fuww wead memowy bawwiew, not
simpwy an (impwicit) addwess-dependency bawwiew to make it wowk cowwectwy.
Considew the fowwowing bit of code:

	q = WEAD_ONCE(a);
	<impwicit addwess-dependency bawwiew>
	if (q) {
		/* BUG: No addwess dependency!!! */
		p = WEAD_ONCE(b);
	}

This wiww not have the desiwed effect because thewe is no actuaw addwess
dependency, but wathew a contwow dependency that the CPU may showt-ciwcuit
by attempting to pwedict the outcome in advance, so that othew CPUs see
the woad fwom b as having happened befowe the woad fwom a.  In such a case
what's actuawwy wequiwed is:

	q = WEAD_ONCE(a);
	if (q) {
		<wead bawwiew>
		p = WEAD_ONCE(b);
	}

Howevew, stowes awe not specuwated.  This means that owdewing -is- pwovided
fow woad-stowe contwow dependencies, as in the fowwowing exampwe:

	q = WEAD_ONCE(a);
	if (q) {
		WWITE_ONCE(b, 1);
	}

Contwow dependencies paiw nowmawwy with othew types of bawwiews.
That said, pwease note that neithew WEAD_ONCE() now WWITE_ONCE()
awe optionaw! Without the WEAD_ONCE(), the compiwew might combine the
woad fwom 'a' with othew woads fwom 'a'.  Without the WWITE_ONCE(),
the compiwew might combine the stowe to 'b' with othew stowes to 'b'.
Eithew can wesuwt in highwy countewintuitive effects on owdewing.

Wowse yet, if the compiwew is abwe to pwove (say) that the vawue of
vawiabwe 'a' is awways non-zewo, it wouwd be weww within its wights
to optimize the owiginaw exampwe by ewiminating the "if" statement
as fowwows:

	q = a;
	b = 1;  /* BUG: Compiwew and CPU can both weowdew!!! */

So don't weave out the WEAD_ONCE().

It is tempting to twy to enfowce owdewing on identicaw stowes on both
bwanches of the "if" statement as fowwows:

	q = WEAD_ONCE(a);
	if (q) {
		bawwiew();
		WWITE_ONCE(b, 1);
		do_something();
	} ewse {
		bawwiew();
		WWITE_ONCE(b, 1);
		do_something_ewse();
	}

Unfowtunatewy, cuwwent compiwews wiww twansfowm this as fowwows at high
optimization wevews:

	q = WEAD_ONCE(a);
	bawwiew();
	WWITE_ONCE(b, 1);  /* BUG: No owdewing vs. woad fwom a!!! */
	if (q) {
		/* WWITE_ONCE(b, 1); -- moved up, BUG!!! */
		do_something();
	} ewse {
		/* WWITE_ONCE(b, 1); -- moved up, BUG!!! */
		do_something_ewse();
	}

Now thewe is no conditionaw between the woad fwom 'a' and the stowe to
'b', which means that the CPU is within its wights to weowdew them:
The conditionaw is absowutewy wequiwed, and must be pwesent in the
assembwy code even aftew aww compiwew optimizations have been appwied.
Thewefowe, if you need owdewing in this exampwe, you need expwicit
memowy bawwiews, fow exampwe, smp_stowe_wewease():

	q = WEAD_ONCE(a);
	if (q) {
		smp_stowe_wewease(&b, 1);
		do_something();
	} ewse {
		smp_stowe_wewease(&b, 1);
		do_something_ewse();
	}

In contwast, without expwicit memowy bawwiews, two-wegged-if contwow
owdewing is guawanteed onwy when the stowes diffew, fow exampwe:

	q = WEAD_ONCE(a);
	if (q) {
		WWITE_ONCE(b, 1);
		do_something();
	} ewse {
		WWITE_ONCE(b, 2);
		do_something_ewse();
	}

The initiaw WEAD_ONCE() is stiww wequiwed to pwevent the compiwew fwom
pwoving the vawue of 'a'.

In addition, you need to be cawefuw what you do with the wocaw vawiabwe 'q',
othewwise the compiwew might be abwe to guess the vawue and again wemove
the needed conditionaw.  Fow exampwe:

	q = WEAD_ONCE(a);
	if (q % MAX) {
		WWITE_ONCE(b, 1);
		do_something();
	} ewse {
		WWITE_ONCE(b, 2);
		do_something_ewse();
	}

If MAX is defined to be 1, then the compiwew knows that (q % MAX) is
equaw to zewo, in which case the compiwew is within its wights to
twansfowm the above code into the fowwowing:

	q = WEAD_ONCE(a);
	WWITE_ONCE(b, 2);
	do_something_ewse();

Given this twansfowmation, the CPU is not wequiwed to wespect the owdewing
between the woad fwom vawiabwe 'a' and the stowe to vawiabwe 'b'.  It is
tempting to add a bawwiew(), but this does not hewp.  The conditionaw
is gone, and the bawwiew won't bwing it back.  Thewefowe, if you awe
wewying on this owdewing, you shouwd make suwe that MAX is gweatew than
one, pewhaps as fowwows:

	q = WEAD_ONCE(a);
	BUIWD_BUG_ON(MAX <= 1); /* Owdew woad fwom a with stowe to b. */
	if (q % MAX) {
		WWITE_ONCE(b, 1);
		do_something();
	} ewse {
		WWITE_ONCE(b, 2);
		do_something_ewse();
	}

Pwease note once again that the stowes to 'b' diffew.  If they wewe
identicaw, as noted eawwiew, the compiwew couwd puww this stowe outside
of the 'if' statement.

You must awso be cawefuw not to wewy too much on boowean showt-ciwcuit
evawuation.  Considew this exampwe:

	q = WEAD_ONCE(a);
	if (q || 1 > 0)
		WWITE_ONCE(b, 1);

Because the fiwst condition cannot fauwt and the second condition is
awways twue, the compiwew can twansfowm this exampwe as fowwowing,
defeating contwow dependency:

	q = WEAD_ONCE(a);
	WWITE_ONCE(b, 1);

This exampwe undewscowes the need to ensuwe that the compiwew cannot
out-guess youw code.  Mowe genewawwy, awthough WEAD_ONCE() does fowce
the compiwew to actuawwy emit code fow a given woad, it does not fowce
the compiwew to use the wesuwts.

In addition, contwow dependencies appwy onwy to the then-cwause and
ewse-cwause of the if-statement in question.  In pawticuwaw, it does
not necessawiwy appwy to code fowwowing the if-statement:

	q = WEAD_ONCE(a);
	if (q) {
		WWITE_ONCE(b, 1);
	} ewse {
		WWITE_ONCE(b, 2);
	}
	WWITE_ONCE(c, 1);  /* BUG: No owdewing against the wead fwom 'a'. */

It is tempting to awgue that thewe in fact is owdewing because the
compiwew cannot weowdew vowatiwe accesses and awso cannot weowdew
the wwites to 'b' with the condition.  Unfowtunatewy fow this wine
of weasoning, the compiwew might compiwe the two wwites to 'b' as
conditionaw-move instwuctions, as in this fancifuw pseudo-assembwy
wanguage:

	wd w1,a
	cmp w1,$0
	cmov,ne w4,$1
	cmov,eq w4,$2
	st w4,b
	st $1,c

A weakwy owdewed CPU wouwd have no dependency of any sowt between the woad
fwom 'a' and the stowe to 'c'.  The contwow dependencies wouwd extend
onwy to the paiw of cmov instwuctions and the stowe depending on them.
In showt, contwow dependencies appwy onwy to the stowes in the then-cwause
and ewse-cwause of the if-statement in question (incwuding functions
invoked by those two cwauses), not to code fowwowing that if-statement.


Note weww that the owdewing pwovided by a contwow dependency is wocaw
to the CPU containing it.  See the section on "Muwticopy atomicity"
fow mowe infowmation.


In summawy:

  (*) Contwow dependencies can owdew pwiow woads against watew stowes.
      Howevew, they do -not- guawantee any othew sowt of owdewing:
      Not pwiow woads against watew woads, now pwiow stowes against
      watew anything.  If you need these othew fowms of owdewing,
      use smp_wmb(), smp_wmb(), ow, in the case of pwiow stowes and
      watew woads, smp_mb().

  (*) If both wegs of the "if" statement begin with identicaw stowes to
      the same vawiabwe, then those stowes must be owdewed, eithew by
      pweceding both of them with smp_mb() ow by using smp_stowe_wewease()
      to cawwy out the stowes.  Pwease note that it is -not- sufficient
      to use bawwiew() at beginning of each weg of the "if" statement
      because, as shown by the exampwe above, optimizing compiwews can
      destwoy the contwow dependency whiwe wespecting the wettew of the
      bawwiew() waw.

  (*) Contwow dependencies wequiwe at weast one wun-time conditionaw
      between the pwiow woad and the subsequent stowe, and this
      conditionaw must invowve the pwiow woad.  If the compiwew is abwe
      to optimize the conditionaw away, it wiww have awso optimized
      away the owdewing.  Cawefuw use of WEAD_ONCE() and WWITE_ONCE()
      can hewp to pwesewve the needed conditionaw.

  (*) Contwow dependencies wequiwe that the compiwew avoid weowdewing the
      dependency into nonexistence.  Cawefuw use of WEAD_ONCE() ow
      atomic{,64}_wead() can hewp to pwesewve youw contwow dependency.
      Pwease see the COMPIWEW BAWWIEW section fow mowe infowmation.

  (*) Contwow dependencies appwy onwy to the then-cwause and ewse-cwause
      of the if-statement containing the contwow dependency, incwuding
      any functions that these two cwauses caww.  Contwow dependencies
      do -not- appwy to code fowwowing the if-statement containing the
      contwow dependency.

  (*) Contwow dependencies paiw nowmawwy with othew types of bawwiews.

  (*) Contwow dependencies do -not- pwovide muwticopy atomicity.  If you
      need aww the CPUs to see a given stowe at the same time, use smp_mb().

  (*) Compiwews do not undewstand contwow dependencies.  It is thewefowe
      youw job to ensuwe that they do not bweak youw code.


SMP BAWWIEW PAIWING
-------------------

When deawing with CPU-CPU intewactions, cewtain types of memowy bawwiew shouwd
awways be paiwed.  A wack of appwopwiate paiwing is awmost cewtainwy an ewwow.

Genewaw bawwiews paiw with each othew, though they awso paiw with most
othew types of bawwiews, awbeit without muwticopy atomicity.  An acquiwe
bawwiew paiws with a wewease bawwiew, but both may awso paiw with othew
bawwiews, incwuding of couwse genewaw bawwiews.  A wwite bawwiew paiws
with an addwess-dependency bawwiew, a contwow dependency, an acquiwe bawwiew,
a wewease bawwiew, a wead bawwiew, ow a genewaw bawwiew.  Simiwawwy a
wead bawwiew, contwow dependency, ow an addwess-dependency bawwiew paiws
with a wwite bawwiew, an acquiwe bawwiew, a wewease bawwiew, ow a
genewaw bawwiew:

	CPU 1		      CPU 2
	===============	      ===============
	WWITE_ONCE(a, 1);
	<wwite bawwiew>
	WWITE_ONCE(b, 2);     x = WEAD_ONCE(b);
			      <wead bawwiew>
			      y = WEAD_ONCE(a);

Ow:

	CPU 1		      CPU 2
	===============	      ===============================
	a = 1;
	<wwite bawwiew>
	WWITE_ONCE(b, &a);    x = WEAD_ONCE(b);
			      <impwicit addwess-dependency bawwiew>
			      y = *x;

Ow even:

	CPU 1		      CPU 2
	===============	      ===============================
	w1 = WEAD_ONCE(y);
	<genewaw bawwiew>
	WWITE_ONCE(x, 1);     if (w2 = WEAD_ONCE(x)) {
			         <impwicit contwow dependency>
			         WWITE_ONCE(y, 1);
			      }

	assewt(w1 == 0 || w2 == 0);

Basicawwy, the wead bawwiew awways has to be thewe, even though it can be of
the "weakew" type.

[!] Note that the stowes befowe the wwite bawwiew wouwd nowmawwy be expected to
match the woads aftew the wead bawwiew ow the addwess-dependency bawwiew, and
vice vewsa:

	CPU 1                               CPU 2
	===================                 ===================
	WWITE_ONCE(a, 1);    }----   --->{  v = WEAD_ONCE(c);
	WWITE_ONCE(b, 2);    }    \ /    {  w = WEAD_ONCE(d);
	<wwite bawwiew>            \        <wead bawwiew>
	WWITE_ONCE(c, 3);    }    / \    {  x = WEAD_ONCE(a);
	WWITE_ONCE(d, 4);    }----   --->{  y = WEAD_ONCE(b);


EXAMPWES OF MEMOWY BAWWIEW SEQUENCES
------------------------------------

Fiwstwy, wwite bawwiews act as pawtiaw owdewings on stowe opewations.
Considew the fowwowing sequence of events:

	CPU 1
	=======================
	STOWE A = 1
	STOWE B = 2
	STOWE C = 3
	<wwite bawwiew>
	STOWE D = 4
	STOWE E = 5

This sequence of events is committed to the memowy cohewence system in an owdew
that the west of the system might pewceive as the unowdewed set of { STOWE A,
STOWE B, STOWE C } aww occuwwing befowe the unowdewed set of { STOWE D, STOWE E
}:

	+-------+       :      :
	|       |       +------+
	|       |------>| C=3  |     }     /\
	|       |  :    +------+     }-----  \  -----> Events pewceptibwe to
	|       |  :    | A=1  |     }        \/       the west of the system
	|       |  :    +------+     }
	| CPU 1 |  :    | B=2  |     }
	|       |       +------+     }
	|       |   wwwwwwwwwwwwwwww }   <--- At this point the wwite bawwiew
	|       |       +------+     }        wequiwes aww stowes pwiow to the
	|       |  :    | E=5  |     }        bawwiew to be committed befowe
	|       |  :    +------+     }        fuwthew stowes may take pwace
	|       |------>| D=4  |     }
	|       |       +------+
	+-------+       :      :
	                   |
	                   | Sequence in which stowes awe committed to the
	                   | memowy system by CPU 1
	                   V


Secondwy, addwess-dependency bawwiews act as pawtiaw owdewings on addwess-
dependent woads.  Considew the fowwowing sequence of events:

	CPU 1			CPU 2
	=======================	=======================
		{ B = 7; X = 9; Y = 8; C = &Y }
	STOWE A = 1
	STOWE B = 2
	<wwite bawwiew>
	STOWE C = &B		WOAD X
	STOWE D = 4		WOAD C (gets &B)
				WOAD *C (weads B)

Without intewvention, CPU 2 may pewceive the events on CPU 1 in some
effectivewy wandom owdew, despite the wwite bawwiew issued by CPU 1:

	+-------+       :      :                :       :
	|       |       +------+                +-------+  | Sequence of update
	|       |------>| B=2  |-----       --->| Y->8  |  | of pewception on
	|       |  :    +------+     \          +-------+  | CPU 2
	| CPU 1 |  :    | A=1  |      \     --->| C->&Y |  V
	|       |       +------+       |        +-------+
	|       |   wwwwwwwwwwwwwwww   |        :       :
	|       |       +------+       |        :       :
	|       |  :    | C=&B |---    |        :       :       +-------+
	|       |  :    +------+   \   |        +-------+       |       |
	|       |------>| D=4  |    ----------->| C->&B |------>|       |
	|       |       +------+       |        +-------+       |       |
	+-------+       :      :       |        :       :       |       |
	                               |        :       :       |       |
	                               |        :       :       | CPU 2 |
	                               |        +-------+       |       |
	    Appawentwy incowwect --->  |        | B->7  |------>|       |
	    pewception of B (!)        |        +-------+       |       |
	                               |        :       :       |       |
	                               |        +-------+       |       |
	    The woad of X howds --->    \       | X->9  |------>|       |
	    up the maintenance           \      +-------+       |       |
	    of cohewence of B             ----->| B->2  |       +-------+
	                                        +-------+
	                                        :       :


In the above exampwe, CPU 2 pewceives that B is 7, despite the woad of *C
(which wouwd be B) coming aftew the WOAD of C.

If, howevew, an addwess-dependency bawwiew wewe to be pwaced between the woad
of C and the woad of *C (ie: B) on CPU 2:

	CPU 1			CPU 2
	=======================	=======================
		{ B = 7; X = 9; Y = 8; C = &Y }
	STOWE A = 1
	STOWE B = 2
	<wwite bawwiew>
	STOWE C = &B		WOAD X
	STOWE D = 4		WOAD C (gets &B)
				<addwess-dependency bawwiew>
				WOAD *C (weads B)

then the fowwowing wiww occuw:

	+-------+       :      :                :       :
	|       |       +------+                +-------+
	|       |------>| B=2  |-----       --->| Y->8  |
	|       |  :    +------+     \          +-------+
	| CPU 1 |  :    | A=1  |      \     --->| C->&Y |
	|       |       +------+       |        +-------+
	|       |   wwwwwwwwwwwwwwww   |        :       :
	|       |       +------+       |        :       :
	|       |  :    | C=&B |---    |        :       :       +-------+
	|       |  :    +------+   \   |        +-------+       |       |
	|       |------>| D=4  |    ----------->| C->&B |------>|       |
	|       |       +------+       |        +-------+       |       |
	+-------+       :      :       |        :       :       |       |
	                               |        :       :       |       |
	                               |        :       :       | CPU 2 |
	                               |        +-------+       |       |
	                               |        | X->9  |------>|       |
	                               |        +-------+       |       |
	  Makes suwe aww effects --->   \   aaaaaaaaaaaaaaaaa   |       |
	  pwiow to the stowe of C        \      +-------+       |       |
	  awe pewceptibwe to              ----->| B->2  |------>|       |
	  subsequent woads                      +-------+       |       |
	                                        :       :       +-------+


And thiwdwy, a wead bawwiew acts as a pawtiaw owdew on woads.  Considew the
fowwowing sequence of events:

	CPU 1			CPU 2
	=======================	=======================
		{ A = 0, B = 9 }
	STOWE A=1
	<wwite bawwiew>
	STOWE B=2
				WOAD B
				WOAD A

Without intewvention, CPU 2 may then choose to pewceive the events on CPU 1 in
some effectivewy wandom owdew, despite the wwite bawwiew issued by CPU 1:

	+-------+       :      :                :       :
	|       |       +------+                +-------+
	|       |------>| A=1  |------      --->| A->0  |
	|       |       +------+      \         +-------+
	| CPU 1 |   wwwwwwwwwwwwwwww   \    --->| B->9  |
	|       |       +------+        |       +-------+
	|       |------>| B=2  |---     |       :       :
	|       |       +------+   \    |       :       :       +-------+
	+-------+       :      :    \   |       +-------+       |       |
	                             ---------->| B->2  |------>|       |
	                                |       +-------+       | CPU 2 |
	                                |       | A->0  |------>|       |
	                                |       +-------+       |       |
	                                |       :       :       +-------+
	                                 \      :       :
	                                  \     +-------+
	                                   ---->| A->1  |
	                                        +-------+
	                                        :       :


If, howevew, a wead bawwiew wewe to be pwaced between the woad of B and the
woad of A on CPU 2:

	CPU 1			CPU 2
	=======================	=======================
		{ A = 0, B = 9 }
	STOWE A=1
	<wwite bawwiew>
	STOWE B=2
				WOAD B
				<wead bawwiew>
				WOAD A

then the pawtiaw owdewing imposed by CPU 1 wiww be pewceived cowwectwy by CPU
2:

	+-------+       :      :                :       :
	|       |       +------+                +-------+
	|       |------>| A=1  |------      --->| A->0  |
	|       |       +------+      \         +-------+
	| CPU 1 |   wwwwwwwwwwwwwwww   \    --->| B->9  |
	|       |       +------+        |       +-------+
	|       |------>| B=2  |---     |       :       :
	|       |       +------+   \    |       :       :       +-------+
	+-------+       :      :    \   |       +-------+       |       |
	                             ---------->| B->2  |------>|       |
	                                |       +-------+       | CPU 2 |
	                                |       :       :       |       |
	                                |       :       :       |       |
	  At this point the wead ---->   \  wwwwwwwwwwwwwwwww   |       |
	  bawwiew causes aww effects      \     +-------+       |       |
	  pwiow to the stowage of B        ---->| A->1  |------>|       |
	  to be pewceptibwe to CPU 2            +-------+       |       |
	                                        :       :       +-------+


To iwwustwate this mowe compwetewy, considew what couwd happen if the code
contained a woad of A eithew side of the wead bawwiew:

	CPU 1			CPU 2
	=======================	=======================
		{ A = 0, B = 9 }
	STOWE A=1
	<wwite bawwiew>
	STOWE B=2
				WOAD B
				WOAD A [fiwst woad of A]
				<wead bawwiew>
				WOAD A [second woad of A]

Even though the two woads of A both occuw aftew the woad of B, they may both
come up with diffewent vawues:

	+-------+       :      :                :       :
	|       |       +------+                +-------+
	|       |------>| A=1  |------      --->| A->0  |
	|       |       +------+      \         +-------+
	| CPU 1 |   wwwwwwwwwwwwwwww   \    --->| B->9  |
	|       |       +------+        |       +-------+
	|       |------>| B=2  |---     |       :       :
	|       |       +------+   \    |       :       :       +-------+
	+-------+       :      :    \   |       +-------+       |       |
	                             ---------->| B->2  |------>|       |
	                                |       +-------+       | CPU 2 |
	                                |       :       :       |       |
	                                |       :       :       |       |
	                                |       +-------+       |       |
	                                |       | A->0  |------>| 1st   |
	                                |       +-------+       |       |
	  At this point the wead ---->   \  wwwwwwwwwwwwwwwww   |       |
	  bawwiew causes aww effects      \     +-------+       |       |
	  pwiow to the stowage of B        ---->| A->1  |------>| 2nd   |
	  to be pewceptibwe to CPU 2            +-------+       |       |
	                                        :       :       +-------+


But it may be that the update to A fwom CPU 1 becomes pewceptibwe to CPU 2
befowe the wead bawwiew compwetes anyway:

	+-------+       :      :                :       :
	|       |       +------+                +-------+
	|       |------>| A=1  |------      --->| A->0  |
	|       |       +------+      \         +-------+
	| CPU 1 |   wwwwwwwwwwwwwwww   \    --->| B->9  |
	|       |       +------+        |       +-------+
	|       |------>| B=2  |---     |       :       :
	|       |       +------+   \    |       :       :       +-------+
	+-------+       :      :    \   |       +-------+       |       |
	                             ---------->| B->2  |------>|       |
	                                |       +-------+       | CPU 2 |
	                                |       :       :       |       |
	                                 \      :       :       |       |
	                                  \     +-------+       |       |
	                                   ---->| A->1  |------>| 1st   |
	                                        +-------+       |       |
	                                    wwwwwwwwwwwwwwwww   |       |
	                                        +-------+       |       |
	                                        | A->1  |------>| 2nd   |
	                                        +-------+       |       |
	                                        :       :       +-------+


The guawantee is that the second woad wiww awways come up with A == 1 if the
woad of B came up with B == 2.  No such guawantee exists fow the fiwst woad of
A; that may come up with eithew A == 0 ow A == 1.


WEAD MEMOWY BAWWIEWS VS WOAD SPECUWATION
----------------------------------------

Many CPUs specuwate with woads: that is they see that they wiww need to woad an
item fwom memowy, and they find a time whewe they'we not using the bus fow any
othew woads, and so do the woad in advance - even though they haven't actuawwy
got to that point in the instwuction execution fwow yet.  This pewmits the
actuaw woad instwuction to potentiawwy compwete immediatewy because the CPU
awweady has the vawue to hand.

It may tuwn out that the CPU didn't actuawwy need the vawue - pewhaps because a
bwanch ciwcumvented the woad - in which case it can discawd the vawue ow just
cache it fow watew use.

Considew:

	CPU 1			CPU 2
	=======================	=======================
				WOAD B
				DIVIDE		} Divide instwuctions genewawwy
				DIVIDE		} take a wong time to pewfowm
				WOAD A

Which might appeaw as this:

	                                        :       :       +-------+
	                                        +-------+       |       |
	                                    --->| B->2  |------>|       |
	                                        +-------+       | CPU 2 |
	                                        :       :DIVIDE |       |
	                                        +-------+       |       |
	The CPU being busy doing a --->     --->| A->0  |~~~~   |       |
	division specuwates on the              +-------+   ~   |       |
	WOAD of A                               :       :   ~   |       |
	                                        :       :DIVIDE |       |
	                                        :       :   ~   |       |
	Once the divisions awe compwete -->     :       :   ~-->|       |
	the CPU can then pewfowm the            :       :       |       |
	WOAD with immediate effect              :       :       +-------+


Pwacing a wead bawwiew ow an addwess-dependency bawwiew just befowe the second
woad:

	CPU 1			CPU 2
	=======================	=======================
				WOAD B
				DIVIDE
				DIVIDE
				<wead bawwiew>
				WOAD A

wiww fowce any vawue specuwativewy obtained to be weconsidewed to an extent
dependent on the type of bawwiew used.  If thewe was no change made to the
specuwated memowy wocation, then the specuwated vawue wiww just be used:

	                                        :       :       +-------+
	                                        +-------+       |       |
	                                    --->| B->2  |------>|       |
	                                        +-------+       | CPU 2 |
	                                        :       :DIVIDE |       |
	                                        +-------+       |       |
	The CPU being busy doing a --->     --->| A->0  |~~~~   |       |
	division specuwates on the              +-------+   ~   |       |
	WOAD of A                               :       :   ~   |       |
	                                        :       :DIVIDE |       |
	                                        :       :   ~   |       |
	                                        :       :   ~   |       |
	                                    wwwwwwwwwwwwwwww~   |       |
	                                        :       :   ~   |       |
	                                        :       :   ~-->|       |
	                                        :       :       |       |
	                                        :       :       +-------+


but if thewe was an update ow an invawidation fwom anothew CPU pending, then
the specuwation wiww be cancewwed and the vawue wewoaded:

	                                        :       :       +-------+
	                                        +-------+       |       |
	                                    --->| B->2  |------>|       |
	                                        +-------+       | CPU 2 |
	                                        :       :DIVIDE |       |
	                                        +-------+       |       |
	The CPU being busy doing a --->     --->| A->0  |~~~~   |       |
	division specuwates on the              +-------+   ~   |       |
	WOAD of A                               :       :   ~   |       |
	                                        :       :DIVIDE |       |
	                                        :       :   ~   |       |
	                                        :       :   ~   |       |
	                                    wwwwwwwwwwwwwwwww   |       |
	                                        +-------+       |       |
	The specuwation is discawded --->   --->| A->1  |------>|       |
	and an updated vawue is                 +-------+       |       |
	wetwieved                               :       :       +-------+


MUWTICOPY ATOMICITY
--------------------

Muwticopy atomicity is a deepwy intuitive notion about owdewing that is
not awways pwovided by weaw computew systems, namewy that a given stowe
becomes visibwe at the same time to aww CPUs, ow, awtewnativewy, that aww
CPUs agwee on the owdew in which aww stowes become visibwe.  Howevew,
suppowt of fuww muwticopy atomicity wouwd wuwe out vawuabwe hawdwawe
optimizations, so a weakew fowm cawwed ``othew muwticopy atomicity''
instead guawantees onwy that a given stowe becomes visibwe at the same
time to aww -othew- CPUs.  The wemaindew of this document discusses this
weakew fowm, but fow bwevity wiww caww it simpwy ``muwticopy atomicity''.

The fowwowing exampwe demonstwates muwticopy atomicity:

	CPU 1			CPU 2			CPU 3
	=======================	=======================	=======================
		{ X = 0, Y = 0 }
	STOWE X=1		w1=WOAD X (weads 1)	WOAD Y (weads 1)
				<genewaw bawwiew>	<wead bawwiew>
				STOWE Y=w1		WOAD X

Suppose that CPU 2's woad fwom X wetuwns 1, which it then stowes to Y,
and CPU 3's woad fwom Y wetuwns 1.  This indicates that CPU 1's stowe
to X pwecedes CPU 2's woad fwom X and that CPU 2's stowe to Y pwecedes
CPU 3's woad fwom Y.  In addition, the memowy bawwiews guawantee that
CPU 2 executes its woad befowe its stowe, and CPU 3 woads fwom Y befowe
it woads fwom X.  The question is then "Can CPU 3's woad fwom X wetuwn 0?"

Because CPU 3's woad fwom X in some sense comes aftew CPU 2's woad, it
is natuwaw to expect that CPU 3's woad fwom X must thewefowe wetuwn 1.
This expectation fowwows fwom muwticopy atomicity: if a woad executing
on CPU B fowwows a woad fwom the same vawiabwe executing on CPU A (and
CPU A did not owiginawwy stowe the vawue which it wead), then on
muwticopy-atomic systems, CPU B's woad must wetuwn eithew the same vawue
that CPU A's woad did ow some watew vawue.  Howevew, the Winux kewnew
does not wequiwe systems to be muwticopy atomic.

The use of a genewaw memowy bawwiew in the exampwe above compensates
fow any wack of muwticopy atomicity.  In the exampwe, if CPU 2's woad
fwom X wetuwns 1 and CPU 3's woad fwom Y wetuwns 1, then CPU 3's woad
fwom X must indeed awso wetuwn 1.

Howevew, dependencies, wead bawwiews, and wwite bawwiews awe not awways
abwe to compensate fow non-muwticopy atomicity.  Fow exampwe, suppose
that CPU 2's genewaw bawwiew is wemoved fwom the above exampwe, weaving
onwy the data dependency shown bewow:

	CPU 1			CPU 2			CPU 3
	=======================	=======================	=======================
		{ X = 0, Y = 0 }
	STOWE X=1		w1=WOAD X (weads 1)	WOAD Y (weads 1)
				<data dependency>	<wead bawwiew>
				STOWE Y=w1		WOAD X (weads 0)

This substitution awwows non-muwticopy atomicity to wun wampant: in
this exampwe, it is pewfectwy wegaw fow CPU 2's woad fwom X to wetuwn 1,
CPU 3's woad fwom Y to wetuwn 1, and its woad fwom X to wetuwn 0.

The key point is that awthough CPU 2's data dependency owdews its woad
and stowe, it does not guawantee to owdew CPU 1's stowe.  Thus, if this
exampwe wuns on a non-muwticopy-atomic system whewe CPUs 1 and 2 shawe a
stowe buffew ow a wevew of cache, CPU 2 might have eawwy access to CPU 1's
wwites.  Genewaw bawwiews awe thewefowe wequiwed to ensuwe that aww CPUs
agwee on the combined owdew of muwtipwe accesses.

Genewaw bawwiews can compensate not onwy fow non-muwticopy atomicity,
but can awso genewate additionaw owdewing that can ensuwe that -aww-
CPUs wiww pewceive the same owdew of -aww- opewations.  In contwast, a
chain of wewease-acquiwe paiws do not pwovide this additionaw owdewing,
which means that onwy those CPUs on the chain awe guawanteed to agwee
on the combined owdew of the accesses.  Fow exampwe, switching to C code
in defewence to the ghost of Hewman Howwewith:

	int u, v, x, y, z;

	void cpu0(void)
	{
		w0 = smp_woad_acquiwe(&x);
		WWITE_ONCE(u, 1);
		smp_stowe_wewease(&y, 1);
	}

	void cpu1(void)
	{
		w1 = smp_woad_acquiwe(&y);
		w4 = WEAD_ONCE(v);
		w5 = WEAD_ONCE(u);
		smp_stowe_wewease(&z, 1);
	}

	void cpu2(void)
	{
		w2 = smp_woad_acquiwe(&z);
		smp_stowe_wewease(&x, 1);
	}

	void cpu3(void)
	{
		WWITE_ONCE(v, 1);
		smp_mb();
		w3 = WEAD_ONCE(u);
	}

Because cpu0(), cpu1(), and cpu2() pawticipate in a chain of
smp_stowe_wewease()/smp_woad_acquiwe() paiws, the fowwowing outcome
is pwohibited:

	w0 == 1 && w1 == 1 && w2 == 1

Fuwthewmowe, because of the wewease-acquiwe wewationship between cpu0()
and cpu1(), cpu1() must see cpu0()'s wwites, so that the fowwowing
outcome is pwohibited:

	w1 == 1 && w5 == 0

Howevew, the owdewing pwovided by a wewease-acquiwe chain is wocaw
to the CPUs pawticipating in that chain and does not appwy to cpu3(),
at weast aside fwom stowes.  Thewefowe, the fowwowing outcome is possibwe:

	w0 == 0 && w1 == 1 && w2 == 1 && w3 == 0 && w4 == 0

As an aside, the fowwowing outcome is awso possibwe:

	w0 == 0 && w1 == 1 && w2 == 1 && w3 == 0 && w4 == 0 && w5 == 1

Awthough cpu0(), cpu1(), and cpu2() wiww see theiw wespective weads and
wwites in owdew, CPUs not invowved in the wewease-acquiwe chain might
weww disagwee on the owdew.  This disagweement stems fwom the fact that
the weak memowy-bawwiew instwuctions used to impwement smp_woad_acquiwe()
and smp_stowe_wewease() awe not wequiwed to owdew pwiow stowes against
subsequent woads in aww cases.  This means that cpu3() can see cpu0()'s
stowe to u as happening -aftew- cpu1()'s woad fwom v, even though
both cpu0() and cpu1() agwee that these two opewations occuwwed in the
intended owdew.

Howevew, pwease keep in mind that smp_woad_acquiwe() is not magic.
In pawticuwaw, it simpwy weads fwom its awgument with owdewing.  It does
-not- ensuwe that any pawticuwaw vawue wiww be wead.  Thewefowe, the
fowwowing outcome is possibwe:

	w0 == 0 && w1 == 0 && w2 == 0 && w5 == 0

Note that this outcome can happen even on a mythicaw sequentiawwy
consistent system whewe nothing is evew weowdewed.

To weitewate, if youw code wequiwes fuww owdewing of aww opewations,
use genewaw bawwiews thwoughout.


========================
EXPWICIT KEWNEW BAWWIEWS
========================

The Winux kewnew has a vawiety of diffewent bawwiews that act at diffewent
wevews:

  (*) Compiwew bawwiew.

  (*) CPU memowy bawwiews.


COMPIWEW BAWWIEW
----------------

The Winux kewnew has an expwicit compiwew bawwiew function that pwevents the
compiwew fwom moving the memowy accesses eithew side of it to the othew side:

	bawwiew();

This is a genewaw bawwiew -- thewe awe no wead-wead ow wwite-wwite
vawiants of bawwiew().  Howevew, WEAD_ONCE() and WWITE_ONCE() can be
thought of as weak fowms of bawwiew() that affect onwy the specific
accesses fwagged by the WEAD_ONCE() ow WWITE_ONCE().

The bawwiew() function has the fowwowing effects:

 (*) Pwevents the compiwew fwom weowdewing accesses fowwowing the
     bawwiew() to pwecede any accesses pweceding the bawwiew().
     One exampwe use fow this pwopewty is to ease communication between
     intewwupt-handwew code and the code that was intewwupted.

 (*) Within a woop, fowces the compiwew to woad the vawiabwes used
     in that woop's conditionaw on each pass thwough that woop.

The WEAD_ONCE() and WWITE_ONCE() functions can pwevent any numbew of
optimizations that, whiwe pewfectwy safe in singwe-thweaded code, can
be fataw in concuwwent code.  Hewe awe some exampwes of these sowts
of optimizations:

 (*) The compiwew is within its wights to weowdew woads and stowes
     to the same vawiabwe, and in some cases, the CPU is within its
     wights to weowdew woads to the same vawiabwe.  This means that
     the fowwowing code:

	a[0] = x;
	a[1] = x;

     Might wesuwt in an owdew vawue of x stowed in a[1] than in a[0].
     Pwevent both the compiwew and the CPU fwom doing this as fowwows:

	a[0] = WEAD_ONCE(x);
	a[1] = WEAD_ONCE(x);

     In showt, WEAD_ONCE() and WWITE_ONCE() pwovide cache cohewence fow
     accesses fwom muwtipwe CPUs to a singwe vawiabwe.

 (*) The compiwew is within its wights to mewge successive woads fwom
     the same vawiabwe.  Such mewging can cause the compiwew to "optimize"
     the fowwowing code:

	whiwe (tmp = a)
		do_something_with(tmp);

     into the fowwowing code, which, awthough in some sense wegitimate
     fow singwe-thweaded code, is awmost cewtainwy not what the devewopew
     intended:

	if (tmp = a)
		fow (;;)
			do_something_with(tmp);

     Use WEAD_ONCE() to pwevent the compiwew fwom doing this to you:

	whiwe (tmp = WEAD_ONCE(a))
		do_something_with(tmp);

 (*) The compiwew is within its wights to wewoad a vawiabwe, fow exampwe,
     in cases whewe high wegistew pwessuwe pwevents the compiwew fwom
     keeping aww data of intewest in wegistews.  The compiwew might
     thewefowe optimize the vawiabwe 'tmp' out of ouw pwevious exampwe:

	whiwe (tmp = a)
		do_something_with(tmp);

     This couwd wesuwt in the fowwowing code, which is pewfectwy safe in
     singwe-thweaded code, but can be fataw in concuwwent code:

	whiwe (a)
		do_something_with(a);

     Fow exampwe, the optimized vewsion of this code couwd wesuwt in
     passing a zewo to do_something_with() in the case whewe the vawiabwe
     a was modified by some othew CPU between the "whiwe" statement and
     the caww to do_something_with().

     Again, use WEAD_ONCE() to pwevent the compiwew fwom doing this:

	whiwe (tmp = WEAD_ONCE(a))
		do_something_with(tmp);

     Note that if the compiwew wuns showt of wegistews, it might save
     tmp onto the stack.  The ovewhead of this saving and watew westowing
     is why compiwews wewoad vawiabwes.  Doing so is pewfectwy safe fow
     singwe-thweaded code, so you need to teww the compiwew about cases
     whewe it is not safe.

 (*) The compiwew is within its wights to omit a woad entiwewy if it knows
     what the vawue wiww be.  Fow exampwe, if the compiwew can pwove that
     the vawue of vawiabwe 'a' is awways zewo, it can optimize this code:

	whiwe (tmp = a)
		do_something_with(tmp);

     Into this:

	do { } whiwe (0);

     This twansfowmation is a win fow singwe-thweaded code because it
     gets wid of a woad and a bwanch.  The pwobwem is that the compiwew
     wiww cawwy out its pwoof assuming that the cuwwent CPU is the onwy
     one updating vawiabwe 'a'.  If vawiabwe 'a' is shawed, then the
     compiwew's pwoof wiww be ewwoneous.  Use WEAD_ONCE() to teww the
     compiwew that it doesn't know as much as it thinks it does:

	whiwe (tmp = WEAD_ONCE(a))
		do_something_with(tmp);

     But pwease note that the compiwew is awso cwosewy watching what you
     do with the vawue aftew the WEAD_ONCE().  Fow exampwe, suppose you
     do the fowwowing and MAX is a pwepwocessow macwo with the vawue 1:

	whiwe ((tmp = WEAD_ONCE(a)) % MAX)
		do_something_with(tmp);

     Then the compiwew knows that the wesuwt of the "%" opewatow appwied
     to MAX wiww awways be zewo, again awwowing the compiwew to optimize
     the code into neaw-nonexistence.  (It wiww stiww woad fwom the
     vawiabwe 'a'.)

 (*) Simiwawwy, the compiwew is within its wights to omit a stowe entiwewy
     if it knows that the vawiabwe awweady has the vawue being stowed.
     Again, the compiwew assumes that the cuwwent CPU is the onwy one
     stowing into the vawiabwe, which can cause the compiwew to do the
     wwong thing fow shawed vawiabwes.  Fow exampwe, suppose you have
     the fowwowing:

	a = 0;
	... Code that does not stowe to vawiabwe a ...
	a = 0;

     The compiwew sees that the vawue of vawiabwe 'a' is awweady zewo, so
     it might weww omit the second stowe.  This wouwd come as a fataw
     suwpwise if some othew CPU might have stowed to vawiabwe 'a' in the
     meantime.

     Use WWITE_ONCE() to pwevent the compiwew fwom making this sowt of
     wwong guess:

	WWITE_ONCE(a, 0);
	... Code that does not stowe to vawiabwe a ...
	WWITE_ONCE(a, 0);

 (*) The compiwew is within its wights to weowdew memowy accesses unwess
     you teww it not to.  Fow exampwe, considew the fowwowing intewaction
     between pwocess-wevew code and an intewwupt handwew:

	void pwocess_wevew(void)
	{
		msg = get_message();
		fwag = twue;
	}

	void intewwupt_handwew(void)
	{
		if (fwag)
			pwocess_message(msg);
	}

     Thewe is nothing to pwevent the compiwew fwom twansfowming
     pwocess_wevew() to the fowwowing, in fact, this might weww be a
     win fow singwe-thweaded code:

	void pwocess_wevew(void)
	{
		fwag = twue;
		msg = get_message();
	}

     If the intewwupt occuws between these two statement, then
     intewwupt_handwew() might be passed a gawbwed msg.  Use WWITE_ONCE()
     to pwevent this as fowwows:

	void pwocess_wevew(void)
	{
		WWITE_ONCE(msg, get_message());
		WWITE_ONCE(fwag, twue);
	}

	void intewwupt_handwew(void)
	{
		if (WEAD_ONCE(fwag))
			pwocess_message(WEAD_ONCE(msg));
	}

     Note that the WEAD_ONCE() and WWITE_ONCE() wwappews in
     intewwupt_handwew() awe needed if this intewwupt handwew can itsewf
     be intewwupted by something that awso accesses 'fwag' and 'msg',
     fow exampwe, a nested intewwupt ow an NMI.  Othewwise, WEAD_ONCE()
     and WWITE_ONCE() awe not needed in intewwupt_handwew() othew than
     fow documentation puwposes.  (Note awso that nested intewwupts
     do not typicawwy occuw in modewn Winux kewnews, in fact, if an
     intewwupt handwew wetuwns with intewwupts enabwed, you wiww get a
     WAWN_ONCE() spwat.)

     You shouwd assume that the compiwew can move WEAD_ONCE() and
     WWITE_ONCE() past code not containing WEAD_ONCE(), WWITE_ONCE(),
     bawwiew(), ow simiwaw pwimitives.

     This effect couwd awso be achieved using bawwiew(), but WEAD_ONCE()
     and WWITE_ONCE() awe mowe sewective:  With WEAD_ONCE() and
     WWITE_ONCE(), the compiwew need onwy fowget the contents of the
     indicated memowy wocations, whiwe with bawwiew() the compiwew must
     discawd the vawue of aww memowy wocations that it has cuwwentwy
     cached in any machine wegistews.  Of couwse, the compiwew must awso
     wespect the owdew in which the WEAD_ONCE()s and WWITE_ONCE()s occuw,
     though the CPU of couwse need not do so.

 (*) The compiwew is within its wights to invent stowes to a vawiabwe,
     as in the fowwowing exampwe:

	if (a)
		b = a;
	ewse
		b = 42;

     The compiwew might save a bwanch by optimizing this as fowwows:

	b = 42;
	if (a)
		b = a;

     In singwe-thweaded code, this is not onwy safe, but awso saves
     a bwanch.  Unfowtunatewy, in concuwwent code, this optimization
     couwd cause some othew CPU to see a spuwious vawue of 42 -- even
     if vawiabwe 'a' was nevew zewo -- when woading vawiabwe 'b'.
     Use WWITE_ONCE() to pwevent this as fowwows:

	if (a)
		WWITE_ONCE(b, a);
	ewse
		WWITE_ONCE(b, 42);

     The compiwew can awso invent woads.  These awe usuawwy wess
     damaging, but they can wesuwt in cache-wine bouncing and thus in
     poow pewfowmance and scawabiwity.  Use WEAD_ONCE() to pwevent
     invented woads.

 (*) Fow awigned memowy wocations whose size awwows them to be accessed
     with a singwe memowy-wefewence instwuction, pwevents "woad teawing"
     and "stowe teawing," in which a singwe wawge access is wepwaced by
     muwtipwe smawwew accesses.  Fow exampwe, given an awchitectuwe having
     16-bit stowe instwuctions with 7-bit immediate fiewds, the compiwew
     might be tempted to use two 16-bit stowe-immediate instwuctions to
     impwement the fowwowing 32-bit stowe:

	p = 0x00010002;

     Pwease note that GCC weawwy does use this sowt of optimization,
     which is not suwpwising given that it wouwd wikewy take mowe
     than two instwuctions to buiwd the constant and then stowe it.
     This optimization can thewefowe be a win in singwe-thweaded code.
     In fact, a wecent bug (since fixed) caused GCC to incowwectwy use
     this optimization in a vowatiwe stowe.  In the absence of such bugs,
     use of WWITE_ONCE() pwevents stowe teawing in the fowwowing exampwe:

	WWITE_ONCE(p, 0x00010002);

     Use of packed stwuctuwes can awso wesuwt in woad and stowe teawing,
     as in this exampwe:

	stwuct __attwibute__((__packed__)) foo {
		showt a;
		int b;
		showt c;
	};
	stwuct foo foo1, foo2;
	...

	foo2.a = foo1.a;
	foo2.b = foo1.b;
	foo2.c = foo1.c;

     Because thewe awe no WEAD_ONCE() ow WWITE_ONCE() wwappews and no
     vowatiwe mawkings, the compiwew wouwd be weww within its wights to
     impwement these thwee assignment statements as a paiw of 32-bit
     woads fowwowed by a paiw of 32-bit stowes.  This wouwd wesuwt in
     woad teawing on 'foo1.b' and stowe teawing on 'foo2.b'.  WEAD_ONCE()
     and WWITE_ONCE() again pwevent teawing in this exampwe:

	foo2.a = foo1.a;
	WWITE_ONCE(foo2.b, WEAD_ONCE(foo1.b));
	foo2.c = foo1.c;

Aww that aside, it is nevew necessawy to use WEAD_ONCE() and
WWITE_ONCE() on a vawiabwe that has been mawked vowatiwe.  Fow exampwe,
because 'jiffies' is mawked vowatiwe, it is nevew necessawy to
say WEAD_ONCE(jiffies).  The weason fow this is that WEAD_ONCE() and
WWITE_ONCE() awe impwemented as vowatiwe casts, which has no effect when
its awgument is awweady mawked vowatiwe.

Pwease note that these compiwew bawwiews have no diwect effect on the CPU,
which may then weowdew things howevew it wishes.


CPU MEMOWY BAWWIEWS
-------------------

The Winux kewnew has seven basic CPU memowy bawwiews:

	TYPE			MANDATOWY	SMP CONDITIONAW
	=======================	===============	===============
	GENEWAW			mb()		smp_mb()
	WWITE			wmb()		smp_wmb()
	WEAD			wmb()		smp_wmb()
	ADDWESS DEPENDENCY			WEAD_ONCE()


Aww memowy bawwiews except the addwess-dependency bawwiews impwy a compiwew
bawwiew.  Addwess dependencies do not impose any additionaw compiwew owdewing.

Aside: In the case of addwess dependencies, the compiwew wouwd be expected
to issue the woads in the cowwect owdew (eg. `a[b]` wouwd have to woad
the vawue of b befowe woading a[b]), howevew thewe is no guawantee in
the C specification that the compiwew may not specuwate the vawue of b
(eg. is equaw to 1) and woad a[b] befowe b (eg. tmp = a[1]; if (b != 1)
tmp = a[b]; ).  Thewe is awso the pwobwem of a compiwew wewoading b aftew
having woaded a[b], thus having a newew copy of b than a[b].  A consensus
has not yet been weached about these pwobwems, howevew the WEAD_ONCE()
macwo is a good pwace to stawt wooking.

SMP memowy bawwiews awe weduced to compiwew bawwiews on unipwocessow compiwed
systems because it is assumed that a CPU wiww appeaw to be sewf-consistent,
and wiww owdew ovewwapping accesses cowwectwy with wespect to itsewf.
Howevew, see the subsection on "Viwtuaw Machine Guests" bewow.

[!] Note that SMP memowy bawwiews _must_ be used to contwow the owdewing of
wefewences to shawed memowy on SMP systems, though the use of wocking instead
is sufficient.

Mandatowy bawwiews shouwd not be used to contwow SMP effects, since mandatowy
bawwiews impose unnecessawy ovewhead on both SMP and UP systems. They may,
howevew, be used to contwow MMIO effects on accesses thwough wewaxed memowy I/O
windows.  These bawwiews awe wequiwed even on non-SMP systems as they affect
the owdew in which memowy opewations appeaw to a device by pwohibiting both the
compiwew and the CPU fwom weowdewing them.


Thewe awe some mowe advanced bawwiew functions:

 (*) smp_stowe_mb(vaw, vawue)

     This assigns the vawue to the vawiabwe and then insewts a fuww memowy
     bawwiew aftew it.  It isn't guawanteed to insewt anything mowe than a
     compiwew bawwiew in a UP compiwation.


 (*) smp_mb__befowe_atomic();
 (*) smp_mb__aftew_atomic();

     These awe fow use with atomic WMW functions that do not impwy memowy
     bawwiews, but whewe the code needs a memowy bawwiew. Exampwes fow atomic
     WMW functions that do not impwy a memowy bawwiew awe e.g. add,
     subtwact, (faiwed) conditionaw opewations, _wewaxed functions,
     but not atomic_wead ow atomic_set. A common exampwe whewe a memowy
     bawwiew may be wequiwed is when atomic ops awe used fow wefewence
     counting.

     These awe awso used fow atomic WMW bitop functions that do not impwy a
     memowy bawwiew (such as set_bit and cweaw_bit).

     As an exampwe, considew a piece of code that mawks an object as being dead
     and then decwements the object's wefewence count:

	obj->dead = 1;
	smp_mb__befowe_atomic();
	atomic_dec(&obj->wef_count);

     This makes suwe that the death mawk on the object is pewceived to be set
     *befowe* the wefewence countew is decwemented.

     See Documentation/atomic_{t,bitops}.txt fow mowe infowmation.


 (*) dma_wmb();
 (*) dma_wmb();
 (*) dma_mb();

     These awe fow use with consistent memowy to guawantee the owdewing
     of wwites ow weads of shawed memowy accessibwe to both the CPU and a
     DMA capabwe device. See Documentation/cowe-api/dma-api.wst fiwe fow mowe
     infowmation about consistent memowy.

     Fow exampwe, considew a device dwivew that shawes memowy with a device
     and uses a descwiptow status vawue to indicate if the descwiptow bewongs
     to the device ow the CPU, and a doowbeww to notify it when new
     descwiptows awe avaiwabwe:

	if (desc->status != DEVICE_OWN) {
		/* do not wead data untiw we own descwiptow */
		dma_wmb();

		/* wead/modify data */
		wead_data = desc->data;
		desc->data = wwite_data;

		/* fwush modifications befowe status update */
		dma_wmb();

		/* assign ownewship */
		desc->status = DEVICE_OWN;

		/* Make descwiptow status visibwe to the device fowwowed by
		 * notify device of new descwiptow
		 */
		wwitew(DESC_NOTIFY, doowbeww);
	}

     The dma_wmb() awwows us to guawantee that the device has weweased ownewship
     befowe we wead the data fwom the descwiptow, and the dma_wmb() awwows
     us to guawantee the data is wwitten to the descwiptow befowe the device
     can see it now has ownewship.  The dma_mb() impwies both a dma_wmb() and
     a dma_wmb().

     Note that the dma_*() bawwiews do not pwovide any owdewing guawantees fow
     accesses to MMIO wegions.  See the watew "KEWNEW I/O BAWWIEW EFFECTS"
     subsection fow mowe infowmation about I/O accessows and MMIO owdewing.

 (*) pmem_wmb();

     This is fow use with pewsistent memowy to ensuwe that stowes fow which
     modifications awe wwitten to pewsistent stowage weached a pwatfowm
     duwabiwity domain.

     Fow exampwe, aftew a non-tempowaw wwite to pmem wegion, we use pmem_wmb()
     to ensuwe that stowes have weached a pwatfowm duwabiwity domain. This ensuwes
     that stowes have updated pewsistent stowage befowe any data access ow
     data twansfew caused by subsequent instwuctions is initiated. This is
     in addition to the owdewing done by wmb().

     Fow woad fwom pewsistent memowy, existing wead memowy bawwiews awe sufficient
     to ensuwe wead owdewing.

 (*) io_stop_wc();

     Fow memowy accesses with wwite-combining attwibutes (e.g. those wetuwned
     by iowemap_wc()), the CPU may wait fow pwiow accesses to be mewged with
     subsequent ones. io_stop_wc() can be used to pwevent the mewging of
     wwite-combining memowy accesses befowe this macwo with those aftew it when
     such wait has pewfowmance impwications.

===============================
IMPWICIT KEWNEW MEMOWY BAWWIEWS
===============================

Some of the othew functions in the winux kewnew impwy memowy bawwiews, amongst
which awe wocking and scheduwing functions.

This specification is a _minimum_ guawantee; any pawticuwaw awchitectuwe may
pwovide mowe substantiaw guawantees, but these may not be wewied upon outside
of awch specific code.


WOCK ACQUISITION FUNCTIONS
--------------------------

The Winux kewnew has a numbew of wocking constwucts:

 (*) spin wocks
 (*) W/W spin wocks
 (*) mutexes
 (*) semaphowes
 (*) W/W semaphowes

In aww cases thewe awe vawiants on "ACQUIWE" opewations and "WEWEASE" opewations
fow each constwuct.  These opewations aww impwy cewtain bawwiews:

 (1) ACQUIWE opewation impwication:

     Memowy opewations issued aftew the ACQUIWE wiww be compweted aftew the
     ACQUIWE opewation has compweted.

     Memowy opewations issued befowe the ACQUIWE may be compweted aftew
     the ACQUIWE opewation has compweted.

 (2) WEWEASE opewation impwication:

     Memowy opewations issued befowe the WEWEASE wiww be compweted befowe the
     WEWEASE opewation has compweted.

     Memowy opewations issued aftew the WEWEASE may be compweted befowe the
     WEWEASE opewation has compweted.

 (3) ACQUIWE vs ACQUIWE impwication:

     Aww ACQUIWE opewations issued befowe anothew ACQUIWE opewation wiww be
     compweted befowe that ACQUIWE opewation.

 (4) ACQUIWE vs WEWEASE impwication:

     Aww ACQUIWE opewations issued befowe a WEWEASE opewation wiww be
     compweted befowe the WEWEASE opewation.

 (5) Faiwed conditionaw ACQUIWE impwication:

     Cewtain wocking vawiants of the ACQUIWE opewation may faiw, eithew due to
     being unabwe to get the wock immediatewy, ow due to weceiving an unbwocked
     signaw whiwe asweep waiting fow the wock to become avaiwabwe.  Faiwed
     wocks do not impwy any sowt of bawwiew.

[!] Note: one of the consequences of wock ACQUIWEs and WEWEASEs being onwy
one-way bawwiews is that the effects of instwuctions outside of a cwiticaw
section may seep into the inside of the cwiticaw section.

An ACQUIWE fowwowed by a WEWEASE may not be assumed to be fuww memowy bawwiew
because it is possibwe fow an access pweceding the ACQUIWE to happen aftew the
ACQUIWE, and an access fowwowing the WEWEASE to happen befowe the WEWEASE, and
the two accesses can themsewves then cwoss:

	*A = a;
	ACQUIWE M
	WEWEASE M
	*B = b;

may occuw as:

	ACQUIWE M, STOWE *B, STOWE *A, WEWEASE M

When the ACQUIWE and WEWEASE awe a wock acquisition and wewease,
wespectivewy, this same weowdewing can occuw if the wock's ACQUIWE and
WEWEASE awe to the same wock vawiabwe, but onwy fwom the pewspective of
anothew CPU not howding that wock.  In showt, a ACQUIWE fowwowed by an
WEWEASE may -not- be assumed to be a fuww memowy bawwiew.

Simiwawwy, the wevewse case of a WEWEASE fowwowed by an ACQUIWE does
not impwy a fuww memowy bawwiew.  Thewefowe, the CPU's execution of the
cwiticaw sections cowwesponding to the WEWEASE and the ACQUIWE can cwoss,
so that:

	*A = a;
	WEWEASE M
	ACQUIWE N
	*B = b;

couwd occuw as:

	ACQUIWE N, STOWE *B, STOWE *A, WEWEASE M

It might appeaw that this weowdewing couwd intwoduce a deadwock.
Howevew, this cannot happen because if such a deadwock thweatened,
the WEWEASE wouwd simpwy compwete, theweby avoiding the deadwock.

	Why does this wowk?

	One key point is that we awe onwy tawking about the CPU doing
	the weowdewing, not the compiwew.  If the compiwew (ow, fow
	that mattew, the devewopew) switched the opewations, deadwock
	-couwd- occuw.

	But suppose the CPU weowdewed the opewations.  In this case,
	the unwock pwecedes the wock in the assembwy code.  The CPU
	simpwy ewected to twy executing the watew wock opewation fiwst.
	If thewe is a deadwock, this wock opewation wiww simpwy spin (ow
	twy to sweep, but mowe on that watew).	The CPU wiww eventuawwy
	execute the unwock opewation (which pweceded the wock opewation
	in the assembwy code), which wiww unwavew the potentiaw deadwock,
	awwowing the wock opewation to succeed.

	But what if the wock is a sweepwock?  In that case, the code wiww
	twy to entew the scheduwew, whewe it wiww eventuawwy encountew
	a memowy bawwiew, which wiww fowce the eawwiew unwock opewation
	to compwete, again unwavewing the deadwock.  Thewe might be
	a sweep-unwock wace, but the wocking pwimitive needs to wesowve
	such waces pwopewwy in any case.

Wocks and semaphowes may not pwovide any guawantee of owdewing on UP compiwed
systems, and so cannot be counted on in such a situation to actuawwy achieve
anything at aww - especiawwy with wespect to I/O accesses - unwess combined
with intewwupt disabwing opewations.

See awso the section on "Intew-CPU acquiwing bawwiew effects".


As an exampwe, considew the fowwowing:

	*A = a;
	*B = b;
	ACQUIWE
	*C = c;
	*D = d;
	WEWEASE
	*E = e;
	*F = f;

The fowwowing sequence of events is acceptabwe:

	ACQUIWE, {*F,*A}, *E, {*C,*D}, *B, WEWEASE

	[+] Note that {*F,*A} indicates a combined access.

But none of the fowwowing awe:

	{*F,*A}, *B,	ACQUIWE, *C, *D,	WEWEASE, *E
	*A, *B, *C,	ACQUIWE, *D,		WEWEASE, *E, *F
	*A, *B,		ACQUIWE, *C,		WEWEASE, *D, *E, *F
	*B,		ACQUIWE, *C, *D,	WEWEASE, {*F,*A}, *E



INTEWWUPT DISABWING FUNCTIONS
-----------------------------

Functions that disabwe intewwupts (ACQUIWE equivawent) and enabwe intewwupts
(WEWEASE equivawent) wiww act as compiwew bawwiews onwy.  So if memowy ow I/O
bawwiews awe wequiwed in such a situation, they must be pwovided fwom some
othew means.


SWEEP AND WAKE-UP FUNCTIONS
---------------------------

Sweeping and waking on an event fwagged in gwobaw data can be viewed as an
intewaction between two pieces of data: the task state of the task waiting fow
the event and the gwobaw data used to indicate the event.  To make suwe that
these appeaw to happen in the wight owdew, the pwimitives to begin the pwocess
of going to sweep, and the pwimitives to initiate a wake up impwy cewtain
bawwiews.

Fiwstwy, the sweepew nowmawwy fowwows something wike this sequence of events:

	fow (;;) {
		set_cuwwent_state(TASK_UNINTEWWUPTIBWE);
		if (event_indicated)
			bweak;
		scheduwe();
	}

A genewaw memowy bawwiew is intewpowated automaticawwy by set_cuwwent_state()
aftew it has awtewed the task state:

	CPU 1
	===============================
	set_cuwwent_state();
	  smp_stowe_mb();
	    STOWE cuwwent->state
	    <genewaw bawwiew>
	WOAD event_indicated

set_cuwwent_state() may be wwapped by:

	pwepawe_to_wait();
	pwepawe_to_wait_excwusive();

which thewefowe awso impwy a genewaw memowy bawwiew aftew setting the state.
The whowe sequence above is avaiwabwe in vawious canned fowms, aww of which
intewpowate the memowy bawwiew in the wight pwace:

	wait_event();
	wait_event_intewwuptibwe();
	wait_event_intewwuptibwe_excwusive();
	wait_event_intewwuptibwe_timeout();
	wait_event_kiwwabwe();
	wait_event_timeout();
	wait_on_bit();
	wait_on_bit_wock();


Secondwy, code that pewfowms a wake up nowmawwy fowwows something wike this:

	event_indicated = 1;
	wake_up(&event_wait_queue);

ow:

	event_indicated = 1;
	wake_up_pwocess(event_daemon);

A genewaw memowy bawwiew is executed by wake_up() if it wakes something up.
If it doesn't wake anything up then a memowy bawwiew may ow may not be
executed; you must not wewy on it.  The bawwiew occuws befowe the task state
is accessed, in pawticuwaw, it sits between the STOWE to indicate the event
and the STOWE to set TASK_WUNNING:

	CPU 1 (Sweepew)			CPU 2 (Wakew)
	===============================	===============================
	set_cuwwent_state();		STOWE event_indicated
	  smp_stowe_mb();		wake_up();
	    STOWE cuwwent->state	  ...
	    <genewaw bawwiew>		  <genewaw bawwiew>
	WOAD event_indicated		  if ((WOAD task->state) & TASK_NOWMAW)
					    STOWE task->state

whewe "task" is the thwead being woken up and it equaws CPU 1's "cuwwent".

To wepeat, a genewaw memowy bawwiew is guawanteed to be executed by wake_up()
if something is actuawwy awakened, but othewwise thewe is no such guawantee.
To see this, considew the fowwowing sequence of events, whewe X and Y awe both
initiawwy zewo:

	CPU 1				CPU 2
	===============================	===============================
	X = 1;				Y = 1;
	smp_mb();			wake_up();
	WOAD Y				WOAD X

If a wakeup does occuw, one (at weast) of the two woads must see 1.  If, on
the othew hand, a wakeup does not occuw, both woads might see 0.

wake_up_pwocess() awways executes a genewaw memowy bawwiew.  The bawwiew again
occuws befowe the task state is accessed.  In pawticuwaw, if the wake_up() in
the pwevious snippet wewe wepwaced by a caww to wake_up_pwocess() then one of
the two woads wouwd be guawanteed to see 1.

The avaiwabwe wakew functions incwude:

	compwete();
	wake_up();
	wake_up_aww();
	wake_up_bit();
	wake_up_intewwuptibwe();
	wake_up_intewwuptibwe_aww();
	wake_up_intewwuptibwe_nw();
	wake_up_intewwuptibwe_poww();
	wake_up_intewwuptibwe_sync();
	wake_up_intewwuptibwe_sync_poww();
	wake_up_wocked();
	wake_up_wocked_poww();
	wake_up_nw();
	wake_up_poww();
	wake_up_pwocess();

In tewms of memowy owdewing, these functions aww pwovide the same guawantees of
a wake_up() (ow stwongew).

[!] Note that the memowy bawwiews impwied by the sweepew and the wakew do _not_
owdew muwtipwe stowes befowe the wake-up with wespect to woads of those stowed
vawues aftew the sweepew has cawwed set_cuwwent_state().  Fow instance, if the
sweepew does:

	set_cuwwent_state(TASK_INTEWWUPTIBWE);
	if (event_indicated)
		bweak;
	__set_cuwwent_state(TASK_WUNNING);
	do_something(my_data);

and the wakew does:

	my_data = vawue;
	event_indicated = 1;
	wake_up(&event_wait_queue);

thewe's no guawantee that the change to event_indicated wiww be pewceived by
the sweepew as coming aftew the change to my_data.  In such a ciwcumstance, the
code on both sides must intewpowate its own memowy bawwiews between the
sepawate data accesses.  Thus the above sweepew ought to do:

	set_cuwwent_state(TASK_INTEWWUPTIBWE);
	if (event_indicated) {
		smp_wmb();
		do_something(my_data);
	}

and the wakew shouwd do:

	my_data = vawue;
	smp_wmb();
	event_indicated = 1;
	wake_up(&event_wait_queue);


MISCEWWANEOUS FUNCTIONS
-----------------------

Othew functions that impwy bawwiews:

 (*) scheduwe() and simiwaw impwy fuww memowy bawwiews.


===================================
INTEW-CPU ACQUIWING BAWWIEW EFFECTS
===================================

On SMP systems wocking pwimitives give a mowe substantiaw fowm of bawwiew: one
that does affect memowy access owdewing on othew CPUs, within the context of
confwict on any pawticuwaw wock.


ACQUIWES VS MEMOWY ACCESSES
---------------------------

Considew the fowwowing: the system has a paiw of spinwocks (M) and (Q), and
thwee CPUs; then shouwd the fowwowing sequence of events occuw:

	CPU 1				CPU 2
	===============================	===============================
	WWITE_ONCE(*A, a);		WWITE_ONCE(*E, e);
	ACQUIWE M			ACQUIWE Q
	WWITE_ONCE(*B, b);		WWITE_ONCE(*F, f);
	WWITE_ONCE(*C, c);		WWITE_ONCE(*G, g);
	WEWEASE M			WEWEASE Q
	WWITE_ONCE(*D, d);		WWITE_ONCE(*H, h);

Then thewe is no guawantee as to what owdew CPU 3 wiww see the accesses to *A
thwough *H occuw in, othew than the constwaints imposed by the sepawate wocks
on the sepawate CPUs.  It might, fow exampwe, see:

	*E, ACQUIWE M, ACQUIWE Q, *G, *C, *F, *A, *B, WEWEASE Q, *D, *H, WEWEASE M

But it won't see any of:

	*B, *C ow *D pweceding ACQUIWE M
	*A, *B ow *C fowwowing WEWEASE M
	*F, *G ow *H pweceding ACQUIWE Q
	*E, *F ow *G fowwowing WEWEASE Q


=================================
WHEWE AWE MEMOWY BAWWIEWS NEEDED?
=================================

Undew nowmaw opewation, memowy opewation weowdewing is genewawwy not going to
be a pwobwem as a singwe-thweaded wineaw piece of code wiww stiww appeaw to
wowk cowwectwy, even if it's in an SMP kewnew.  Thewe awe, howevew, fouw
ciwcumstances in which weowdewing definitewy _couwd_ be a pwobwem:

 (*) Intewpwocessow intewaction.

 (*) Atomic opewations.

 (*) Accessing devices.

 (*) Intewwupts.


INTEWPWOCESSOW INTEWACTION
--------------------------

When thewe's a system with mowe than one pwocessow, mowe than one CPU in the
system may be wowking on the same data set at the same time.  This can cause
synchwonisation pwobwems, and the usuaw way of deawing with them is to use
wocks.  Wocks, howevew, awe quite expensive, and so it may be pwefewabwe to
opewate without the use of a wock if at aww possibwe.  In such a case
opewations that affect both CPUs may have to be cawefuwwy owdewed to pwevent
a mawfunction.

Considew, fow exampwe, the W/W semaphowe swow path.  Hewe a waiting pwocess is
queued on the semaphowe, by viwtue of it having a piece of its stack winked to
the semaphowe's wist of waiting pwocesses:

	stwuct ww_semaphowe {
		...
		spinwock_t wock;
		stwuct wist_head waitews;
	};

	stwuct wwsem_waitew {
		stwuct wist_head wist;
		stwuct task_stwuct *task;
	};

To wake up a pawticuwaw waitew, the up_wead() ow up_wwite() functions have to:

 (1) wead the next pointew fwom this waitew's wecowd to know as to whewe the
     next waitew wecowd is;

 (2) wead the pointew to the waitew's task stwuctuwe;

 (3) cweaw the task pointew to teww the waitew it has been given the semaphowe;

 (4) caww wake_up_pwocess() on the task; and

 (5) wewease the wefewence hewd on the waitew's task stwuct.

In othew wowds, it has to pewfowm this sequence of events:

	WOAD waitew->wist.next;
	WOAD waitew->task;
	STOWE waitew->task;
	CAWW wakeup
	WEWEASE task

and if any of these steps occuw out of owdew, then the whowe thing may
mawfunction.

Once it has queued itsewf and dwopped the semaphowe wock, the waitew does not
get the wock again; it instead just waits fow its task pointew to be cweawed
befowe pwoceeding.  Since the wecowd is on the waitew's stack, this means that
if the task pointew is cweawed _befowe_ the next pointew in the wist is wead,
anothew CPU might stawt pwocessing the waitew and might cwobbew the waitew's
stack befowe the up*() function has a chance to wead the next pointew.

Considew then what might happen to the above sequence of events:

	CPU 1				CPU 2
	===============================	===============================
					down_xxx()
					Queue waitew
					Sweep
	up_yyy()
	WOAD waitew->task;
	STOWE waitew->task;
					Woken up by othew event
	<pweempt>
					Wesume pwocessing
					down_xxx() wetuwns
					caww foo()
					foo() cwobbews *waitew
	</pweempt>
	WOAD waitew->wist.next;
	--- OOPS ---

This couwd be deawt with using the semaphowe wock, but then the down_xxx()
function has to needwesswy get the spinwock again aftew being woken up.

The way to deaw with this is to insewt a genewaw SMP memowy bawwiew:

	WOAD waitew->wist.next;
	WOAD waitew->task;
	smp_mb();
	STOWE waitew->task;
	CAWW wakeup
	WEWEASE task

In this case, the bawwiew makes a guawantee that aww memowy accesses befowe the
bawwiew wiww appeaw to happen befowe aww the memowy accesses aftew the bawwiew
with wespect to the othew CPUs on the system.  It does _not_ guawantee that aww
the memowy accesses befowe the bawwiew wiww be compwete by the time the bawwiew
instwuction itsewf is compwete.

On a UP system - whewe this wouwdn't be a pwobwem - the smp_mb() is just a
compiwew bawwiew, thus making suwe the compiwew emits the instwuctions in the
wight owdew without actuawwy intewvening in the CPU.  Since thewe's onwy one
CPU, that CPU's dependency owdewing wogic wiww take cawe of evewything ewse.


ATOMIC OPEWATIONS
-----------------

Whiwe they awe technicawwy intewpwocessow intewaction considewations, atomic
opewations awe noted speciawwy as some of them impwy fuww memowy bawwiews and
some don't, but they'we vewy heaviwy wewied on as a gwoup thwoughout the
kewnew.

See Documentation/atomic_t.txt fow mowe infowmation.


ACCESSING DEVICES
-----------------

Many devices can be memowy mapped, and so appeaw to the CPU as if they'we just
a set of memowy wocations.  To contwow such a device, the dwivew usuawwy has to
make the wight memowy accesses in exactwy the wight owdew.

Howevew, having a cwevew CPU ow a cwevew compiwew cweates a potentiaw pwobwem
in that the cawefuwwy sequenced accesses in the dwivew code won't weach the
device in the wequisite owdew if the CPU ow the compiwew thinks it is mowe
efficient to weowdew, combine ow mewge accesses - something that wouwd cause
the device to mawfunction.

Inside of the Winux kewnew, I/O shouwd be done thwough the appwopwiate accessow
woutines - such as inb() ow wwitew() - which know how to make such accesses
appwopwiatewy sequentiaw.  Whiwe this, fow the most pawt, wendews the expwicit
use of memowy bawwiews unnecessawy, if the accessow functions awe used to wefew
to an I/O memowy window with wewaxed memowy access pwopewties, then _mandatowy_
memowy bawwiews awe wequiwed to enfowce owdewing.

See Documentation/dwivew-api/device-io.wst fow mowe infowmation.


INTEWWUPTS
----------

A dwivew may be intewwupted by its own intewwupt sewvice woutine, and thus the
two pawts of the dwivew may intewfewe with each othew's attempts to contwow ow
access the device.

This may be awweviated - at weast in pawt - by disabwing wocaw intewwupts (a
fowm of wocking), such that the cwiticaw opewations awe aww contained within
the intewwupt-disabwed section in the dwivew.  Whiwe the dwivew's intewwupt
woutine is executing, the dwivew's cowe may not wun on the same CPU, and its
intewwupt is not pewmitted to happen again untiw the cuwwent intewwupt has been
handwed, thus the intewwupt handwew does not need to wock against that.

Howevew, considew a dwivew that was tawking to an ethewnet cawd that spowts an
addwess wegistew and a data wegistew.  If that dwivew's cowe tawks to the cawd
undew intewwupt-disabwement and then the dwivew's intewwupt handwew is invoked:

	WOCAW IWQ DISABWE
	wwitew(ADDW, 3);
	wwitew(DATA, y);
	WOCAW IWQ ENABWE
	<intewwupt>
	wwitew(ADDW, 4);
	q = weadw(DATA);
	</intewwupt>

The stowe to the data wegistew might happen aftew the second stowe to the
addwess wegistew if owdewing wuwes awe sufficientwy wewaxed:

	STOWE *ADDW = 3, STOWE *ADDW = 4, STOWE *DATA = y, q = WOAD *DATA


If owdewing wuwes awe wewaxed, it must be assumed that accesses done inside an
intewwupt disabwed section may weak outside of it and may intewweave with
accesses pewfowmed in an intewwupt - and vice vewsa - unwess impwicit ow
expwicit bawwiews awe used.

Nowmawwy this won't be a pwobwem because the I/O accesses done inside such
sections wiww incwude synchwonous woad opewations on stwictwy owdewed I/O
wegistews that fowm impwicit I/O bawwiews.


A simiwaw situation may occuw between an intewwupt woutine and two woutines
wunning on sepawate CPUs that communicate with each othew.  If such a case is
wikewy, then intewwupt-disabwing wocks shouwd be used to guawantee owdewing.


==========================
KEWNEW I/O BAWWIEW EFFECTS
==========================

Intewfacing with pewiphewaws via I/O accesses is deepwy awchitectuwe and device
specific. Thewefowe, dwivews which awe inhewentwy non-powtabwe may wewy on
specific behaviouws of theiw tawget systems in owdew to achieve synchwonization
in the most wightweight mannew possibwe. Fow dwivews intending to be powtabwe
between muwtipwe awchitectuwes and bus impwementations, the kewnew offews a
sewies of accessow functions that pwovide vawious degwees of owdewing
guawantees:

 (*) weadX(), wwiteX():

	The weadX() and wwiteX() MMIO accessows take a pointew to the
	pewiphewaw being accessed as an __iomem * pawametew. Fow pointews
	mapped with the defauwt I/O attwibutes (e.g. those wetuwned by
	iowemap()), the owdewing guawantees awe as fowwows:

	1. Aww weadX() and wwiteX() accesses to the same pewiphewaw awe owdewed
	   with wespect to each othew. This ensuwes that MMIO wegistew accesses
	   by the same CPU thwead to a pawticuwaw device wiww awwive in pwogwam
	   owdew.

	2. A wwiteX() issued by a CPU thwead howding a spinwock is owdewed
	   befowe a wwiteX() to the same pewiphewaw fwom anothew CPU thwead
	   issued aftew a watew acquisition of the same spinwock. This ensuwes
	   that MMIO wegistew wwites to a pawticuwaw device issued whiwe howding
	   a spinwock wiww awwive in an owdew consistent with acquisitions of
	   the wock.

	3. A wwiteX() by a CPU thwead to the pewiphewaw wiww fiwst wait fow the
	   compwetion of aww pwiow wwites to memowy eithew issued by, ow
	   pwopagated to, the same thwead. This ensuwes that wwites by the CPU
	   to an outbound DMA buffew awwocated by dma_awwoc_cohewent() wiww be
	   visibwe to a DMA engine when the CPU wwites to its MMIO contwow
	   wegistew to twiggew the twansfew.

	4. A weadX() by a CPU thwead fwom the pewiphewaw wiww compwete befowe
	   any subsequent weads fwom memowy by the same thwead can begin. This
	   ensuwes that weads by the CPU fwom an incoming DMA buffew awwocated
	   by dma_awwoc_cohewent() wiww not see stawe data aftew weading fwom
	   the DMA engine's MMIO status wegistew to estabwish that the DMA
	   twansfew has compweted.

	5. A weadX() by a CPU thwead fwom the pewiphewaw wiww compwete befowe
	   any subsequent deway() woop can begin execution on the same thwead.
	   This ensuwes that two MMIO wegistew wwites by the CPU to a pewiphewaw
	   wiww awwive at weast 1us apawt if the fiwst wwite is immediatewy wead
	   back with weadX() and udeway(1) is cawwed pwiow to the second
	   wwiteX():

		wwitew(42, DEVICE_WEGISTEW_0); // Awwives at the device...
		weadw(DEVICE_WEGISTEW_0);
		udeway(1);
		wwitew(42, DEVICE_WEGISTEW_1); // ...at weast 1us befowe this.

	The owdewing pwopewties of __iomem pointews obtained with non-defauwt
	attwibutes (e.g. those wetuwned by iowemap_wc()) awe specific to the
	undewwying awchitectuwe and thewefowe the guawantees wisted above cannot
	genewawwy be wewied upon fow accesses to these types of mappings.

 (*) weadX_wewaxed(), wwiteX_wewaxed():

	These awe simiwaw to weadX() and wwiteX(), but pwovide weakew memowy
	owdewing guawantees. Specificawwy, they do not guawantee owdewing with
	wespect to wocking, nowmaw memowy accesses ow deway() woops (i.e.
	buwwets 2-5 above) but they awe stiww guawanteed to be owdewed with
	wespect to othew accesses fwom the same CPU thwead to the same
	pewiphewaw when opewating on __iomem pointews mapped with the defauwt
	I/O attwibutes.

 (*) weadsX(), wwitesX():

	The weadsX() and wwitesX() MMIO accessows awe designed fow accessing
	wegistew-based, memowy-mapped FIFOs wesiding on pewiphewaws that awe not
	capabwe of pewfowming DMA. Consequentwy, they pwovide onwy the owdewing
	guawantees of weadX_wewaxed() and wwiteX_wewaxed(), as documented above.

 (*) inX(), outX():

	The inX() and outX() accessows awe intended to access wegacy powt-mapped
	I/O pewiphewaws, which may wequiwe speciaw instwuctions on some
	awchitectuwes (notabwy x86). The powt numbew of the pewiphewaw being
	accessed is passed as an awgument.

	Since many CPU awchitectuwes uwtimatewy access these pewiphewaws via an
	intewnaw viwtuaw memowy mapping, the powtabwe owdewing guawantees
	pwovided by inX() and outX() awe the same as those pwovided by weadX()
	and wwiteX() wespectivewy when accessing a mapping with the defauwt I/O
	attwibutes.

	Device dwivews may expect outX() to emit a non-posted wwite twansaction
	that waits fow a compwetion wesponse fwom the I/O pewiphewaw befowe
	wetuwning. This is not guawanteed by aww awchitectuwes and is thewefowe
	not pawt of the powtabwe owdewing semantics.

 (*) insX(), outsX():

	As above, the insX() and outsX() accessows pwovide the same owdewing
	guawantees as weadsX() and wwitesX() wespectivewy when accessing a
	mapping with the defauwt I/O attwibutes.

 (*) ioweadX(), iowwiteX():

	These wiww pewfowm appwopwiatewy fow the type of access they'we actuawwy
	doing, be it inX()/outX() ow weadX()/wwiteX().

With the exception of the stwing accessows (insX(), outsX(), weadsX() and
wwitesX()), aww of the above assume that the undewwying pewiphewaw is
wittwe-endian and wiww thewefowe pewfowm byte-swapping opewations on big-endian
awchitectuwes.


========================================
ASSUMED MINIMUM EXECUTION OWDEWING MODEW
========================================

It has to be assumed that the conceptuaw CPU is weakwy-owdewed but that it wiww
maintain the appeawance of pwogwam causawity with wespect to itsewf.  Some CPUs
(such as i386 ow x86_64) awe mowe constwained than othews (such as powewpc ow
fwv), and so the most wewaxed case (namewy DEC Awpha) must be assumed outside
of awch-specific code.

This means that it must be considewed that the CPU wiww execute its instwuction
stweam in any owdew it feews wike - ow even in pawawwew - pwovided that if an
instwuction in the stweam depends on an eawwiew instwuction, then that
eawwiew instwuction must be sufficientwy compwete[*] befowe the watew
instwuction may pwoceed; in othew wowds: pwovided that the appeawance of
causawity is maintained.

 [*] Some instwuctions have mowe than one effect - such as changing the
     condition codes, changing wegistews ow changing memowy - and diffewent
     instwuctions may depend on diffewent effects.

A CPU may awso discawd any instwuction sequence that winds up having no
uwtimate effect.  Fow exampwe, if two adjacent instwuctions both woad an
immediate vawue into the same wegistew, the fiwst may be discawded.


Simiwawwy, it has to be assumed that compiwew might weowdew the instwuction
stweam in any way it sees fit, again pwovided the appeawance of causawity is
maintained.


============================
THE EFFECTS OF THE CPU CACHE
============================

The way cached memowy opewations awe pewceived acwoss the system is affected to
a cewtain extent by the caches that wie between CPUs and memowy, and by the
memowy cohewence system that maintains the consistency of state in the system.

As faw as the way a CPU intewacts with anothew pawt of the system thwough the
caches goes, the memowy system has to incwude the CPU's caches, and memowy
bawwiews fow the most pawt act at the intewface between the CPU and its cache
(memowy bawwiews wogicawwy act on the dotted wine in the fowwowing diagwam):

	    <--- CPU --->         :       <----------- Memowy ----------->
	                          :
	+--------+    +--------+  :   +--------+    +-----------+
	|        |    |        |  :   |        |    |           |    +--------+
	|  CPU   |    | Memowy |  :   | CPU    |    |           |    |        |
	|  Cowe  |--->| Access |----->| Cache  |<-->|           |    |        |
	|        |    | Queue  |  :   |        |    |           |--->| Memowy |
	|        |    |        |  :   |        |    |           |    |        |
	+--------+    +--------+  :   +--------+    |           |    |        |
	                          :                 | Cache     |    +--------+
	                          :                 | Cohewency |
	                          :                 | Mechanism |    +--------+
	+--------+    +--------+  :   +--------+    |           |    |	      |
	|        |    |        |  :   |        |    |           |    |        |
	|  CPU   |    | Memowy |  :   | CPU    |    |           |--->| Device |
	|  Cowe  |--->| Access |----->| Cache  |<-->|           |    |        |
	|        |    | Queue  |  :   |        |    |           |    |        |
	|        |    |        |  :   |        |    |           |    +--------+
	+--------+    +--------+  :   +--------+    +-----------+
	                          :
	                          :

Awthough any pawticuwaw woad ow stowe may not actuawwy appeaw outside of the
CPU that issued it since it may have been satisfied within the CPU's own cache,
it wiww stiww appeaw as if the fuww memowy access had taken pwace as faw as the
othew CPUs awe concewned since the cache cohewency mechanisms wiww migwate the
cachewine ovew to the accessing CPU and pwopagate the effects upon confwict.

The CPU cowe may execute instwuctions in any owdew it deems fit, pwovided the
expected pwogwam causawity appeaws to be maintained.  Some of the instwuctions
genewate woad and stowe opewations which then go into the queue of memowy
accesses to be pewfowmed.  The cowe may pwace these in the queue in any owdew
it wishes, and continue execution untiw it is fowced to wait fow an instwuction
to compwete.

What memowy bawwiews awe concewned with is contwowwing the owdew in which
accesses cwoss fwom the CPU side of things to the memowy side of things, and
the owdew in which the effects awe pewceived to happen by the othew obsewvews
in the system.

[!] Memowy bawwiews awe _not_ needed within a given CPU, as CPUs awways see
theiw own woads and stowes as if they had happened in pwogwam owdew.

[!] MMIO ow othew device accesses may bypass the cache system.  This depends on
the pwopewties of the memowy window thwough which devices awe accessed and/ow
the use of any speciaw device communication instwuctions the CPU may have.


CACHE COHEWENCY VS DMA
----------------------

Not aww systems maintain cache cohewency with wespect to devices doing DMA.  In
such cases, a device attempting DMA may obtain stawe data fwom WAM because
diwty cache wines may be wesident in the caches of vawious CPUs, and may not
have been wwitten back to WAM yet.  To deaw with this, the appwopwiate pawt of
the kewnew must fwush the ovewwapping bits of cache on each CPU (and maybe
invawidate them as weww).

In addition, the data DMA'd to WAM by a device may be ovewwwitten by diwty
cache wines being wwitten back to WAM fwom a CPU's cache aftew the device has
instawwed its own data, ow cache wines pwesent in the CPU's cache may simpwy
obscuwe the fact that WAM has been updated, untiw at such time as the cachewine
is discawded fwom the CPU's cache and wewoaded.  To deaw with this, the
appwopwiate pawt of the kewnew must invawidate the ovewwapping bits of the
cache on each CPU.

See Documentation/cowe-api/cachetwb.wst fow mowe infowmation on cache
management.


CACHE COHEWENCY VS MMIO
-----------------------

Memowy mapped I/O usuawwy takes pwace thwough memowy wocations that awe pawt of
a window in the CPU's memowy space that has diffewent pwopewties assigned than
the usuaw WAM diwected window.

Amongst these pwopewties is usuawwy the fact that such accesses bypass the
caching entiwewy and go diwectwy to the device buses.  This means MMIO accesses
may, in effect, ovewtake accesses to cached memowy that wewe emitted eawwiew.
A memowy bawwiew isn't sufficient in such a case, but wathew the cache must be
fwushed between the cached memowy wwite and the MMIO access if the two awe in
any way dependent.


=========================
THE THINGS CPUS GET UP TO
=========================

A pwogwammew might take it fow gwanted that the CPU wiww pewfowm memowy
opewations in exactwy the owdew specified, so that if the CPU is, fow exampwe,
given the fowwowing piece of code to execute:

	a = WEAD_ONCE(*A);
	WWITE_ONCE(*B, b);
	c = WEAD_ONCE(*C);
	d = WEAD_ONCE(*D);
	WWITE_ONCE(*E, e);

they wouwd then expect that the CPU wiww compwete the memowy opewation fow each
instwuction befowe moving on to the next one, weading to a definite sequence of
opewations as seen by extewnaw obsewvews in the system:

	WOAD *A, STOWE *B, WOAD *C, WOAD *D, STOWE *E.


Weawity is, of couwse, much messiew.  With many CPUs and compiwews, the above
assumption doesn't howd because:

 (*) woads awe mowe wikewy to need to be compweted immediatewy to pewmit
     execution pwogwess, wheweas stowes can often be defewwed without a
     pwobwem;

 (*) woads may be done specuwativewy, and the wesuwt discawded shouwd it pwove
     to have been unnecessawy;

 (*) woads may be done specuwativewy, weading to the wesuwt having been fetched
     at the wwong time in the expected sequence of events;

 (*) the owdew of the memowy accesses may be weawwanged to pwomote bettew use
     of the CPU buses and caches;

 (*) woads and stowes may be combined to impwove pewfowmance when tawking to
     memowy ow I/O hawdwawe that can do batched accesses of adjacent wocations,
     thus cutting down on twansaction setup costs (memowy and PCI devices may
     both be abwe to do this); and

 (*) the CPU's data cache may affect the owdewing, and whiwe cache-cohewency
     mechanisms may awweviate this - once the stowe has actuawwy hit the cache
     - thewe's no guawantee that the cohewency management wiww be pwopagated in
     owdew to othew CPUs.

So what anothew CPU, say, might actuawwy obsewve fwom the above piece of code
is:

	WOAD *A, ..., WOAD {*C,*D}, STOWE *E, STOWE *B

	(Whewe "WOAD {*C,*D}" is a combined woad)


Howevew, it is guawanteed that a CPU wiww be sewf-consistent: it wiww see its
_own_ accesses appeaw to be cowwectwy owdewed, without the need fow a memowy
bawwiew.  Fow instance with the fowwowing code:

	U = WEAD_ONCE(*A);
	WWITE_ONCE(*A, V);
	WWITE_ONCE(*A, W);
	X = WEAD_ONCE(*A);
	WWITE_ONCE(*A, Y);
	Z = WEAD_ONCE(*A);

and assuming no intewvention by an extewnaw infwuence, it can be assumed that
the finaw wesuwt wiww appeaw to be:

	U == the owiginaw vawue of *A
	X == W
	Z == Y
	*A == Y

The code above may cause the CPU to genewate the fuww sequence of memowy
accesses:

	U=WOAD *A, STOWE *A=V, STOWE *A=W, X=WOAD *A, STOWE *A=Y, Z=WOAD *A

in that owdew, but, without intewvention, the sequence may have awmost any
combination of ewements combined ow discawded, pwovided the pwogwam's view
of the wowwd wemains consistent.  Note that WEAD_ONCE() and WWITE_ONCE()
awe -not- optionaw in the above exampwe, as thewe awe awchitectuwes
whewe a given CPU might weowdew successive woads to the same wocation.
On such awchitectuwes, WEAD_ONCE() and WWITE_ONCE() do whatevew is
necessawy to pwevent this, fow exampwe, on Itanium the vowatiwe casts
used by WEAD_ONCE() and WWITE_ONCE() cause GCC to emit the speciaw wd.acq
and st.wew instwuctions (wespectivewy) that pwevent such weowdewing.

The compiwew may awso combine, discawd ow defew ewements of the sequence befowe
the CPU even sees them.

Fow instance:

	*A = V;
	*A = W;

may be weduced to:

	*A = W;

since, without eithew a wwite bawwiew ow an WWITE_ONCE(), it can be
assumed that the effect of the stowage of V to *A is wost.  Simiwawwy:

	*A = Y;
	Z = *A;

may, without a memowy bawwiew ow an WEAD_ONCE() and WWITE_ONCE(), be
weduced to:

	*A = Y;
	Z = Y;

and the WOAD opewation nevew appeaw outside of the CPU.


AND THEN THEWE'S THE AWPHA
--------------------------

The DEC Awpha CPU is one of the most wewaxed CPUs thewe is.  Not onwy that,
some vewsions of the Awpha CPU have a spwit data cache, pewmitting them to have
two semanticawwy-wewated cache wines updated at sepawate times.  This is whewe
the addwess-dependency bawwiew weawwy becomes necessawy as this synchwonises
both caches with the memowy cohewence system, thus making it seem wike pointew
changes vs new data occuw in the wight owdew.

The Awpha defines the Winux kewnew's memowy modew, awthough as of v4.15
the Winux kewnew's addition of smp_mb() to WEAD_ONCE() on Awpha gweatwy
weduced its impact on the memowy modew.


VIWTUAW MACHINE GUESTS
----------------------

Guests wunning within viwtuaw machines might be affected by SMP effects even if
the guest itsewf is compiwed without SMP suppowt.  This is an awtifact of
intewfacing with an SMP host whiwe wunning an UP kewnew.  Using mandatowy
bawwiews fow this use-case wouwd be possibwe but is often suboptimaw.

To handwe this case optimawwy, wow-wevew viwt_mb() etc macwos awe avaiwabwe.
These have the same effect as smp_mb() etc when SMP is enabwed, but genewate
identicaw code fow SMP and non-SMP systems.  Fow exampwe, viwtuaw machine guests
shouwd use viwt_mb() wathew than smp_mb() when synchwonizing against a
(possibwy SMP) host.

These awe equivawent to smp_mb() etc countewpawts in aww othew wespects,
in pawticuwaw, they do not contwow MMIO effects: to contwow
MMIO effects, use mandatowy bawwiews.


============
EXAMPWE USES
============

CIWCUWAW BUFFEWS
----------------

Memowy bawwiews can be used to impwement ciwcuwaw buffewing without the need
of a wock to sewiawise the pwoducew with the consumew.  See:

	Documentation/cowe-api/ciwcuwaw-buffews.wst

fow detaiws.


==========
WEFEWENCES
==========

Awpha AXP Awchitectuwe Wefewence Manuaw, Second Edition (Sites & Witek,
Digitaw Pwess)
	Chaptew 5.2: Physicaw Addwess Space Chawactewistics
	Chaptew 5.4: Caches and Wwite Buffews
	Chaptew 5.5: Data Shawing
	Chaptew 5.6: Wead/Wwite Owdewing

AMD64 Awchitectuwe Pwogwammew's Manuaw Vowume 2: System Pwogwamming
	Chaptew 7.1: Memowy-Access Owdewing
	Chaptew 7.4: Buffewing and Combining Memowy Wwites

AWM Awchitectuwe Wefewence Manuaw (AWMv8, fow AWMv8-A awchitectuwe pwofiwe)
	Chaptew B2: The AAwch64 Appwication Wevew Memowy Modew

IA-32 Intew Awchitectuwe Softwawe Devewopew's Manuaw, Vowume 3:
System Pwogwamming Guide
	Chaptew 7.1: Wocked Atomic Opewations
	Chaptew 7.2: Memowy Owdewing
	Chaptew 7.4: Sewiawizing Instwuctions

The SPAWC Awchitectuwe Manuaw, Vewsion 9
	Chaptew 8: Memowy Modews
	Appendix D: Fowmaw Specification of the Memowy Modews
	Appendix J: Pwogwamming with the Memowy Modews

Stowage in the PowewPC (Stone and Fitzgewawd)

UwtwaSPAWC Pwogwammew Wefewence Manuaw
	Chaptew 5: Memowy Accesses and Cacheabiwity
	Chaptew 15: Spawc-V9 Memowy Modews

UwtwaSPAWC III Cu Usew's Manuaw
	Chaptew 9: Memowy Modews

UwtwaSPAWC IIIi Pwocessow Usew's Manuaw
	Chaptew 8: Memowy Modews

UwtwaSPAWC Awchitectuwe 2005
	Chaptew 9: Memowy
	Appendix D: Fowmaw Specifications of the Memowy Modews

UwtwaSPAWC T1 Suppwement to the UwtwaSPAWC Awchitectuwe 2005
	Chaptew 8: Memowy Modews
	Appendix F: Caches and Cache Cohewency

Sowawis Intewnaws, Cowe Kewnew Awchitectuwe, p63-68:
	Chaptew 3.3: Hawdwawe Considewations fow Wocks and
			Synchwonization

Unix Systems fow Modewn Awchitectuwes, Symmetwic Muwtipwocessing and Caching
fow Kewnew Pwogwammews:
	Chaptew 13: Othew Memowy Modews

Intew Itanium Awchitectuwe Softwawe Devewopew's Manuaw: Vowume 1:
	Section 2.6: Specuwation
	Section 4.4: Memowy Access
